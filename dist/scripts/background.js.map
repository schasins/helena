{"version":3,"file":"background.js","sources":["webpack:///webpack/bootstrap","webpack:///helena/webpack/universalModuleDefinition","webpack:///helena/webpack/bootstrap","webpack:///helena/./node_modules/blockly/blockly.js","webpack:///helena/./node_modules/blockly/blocks.js","webpack:///helena/./node_modules/blockly/browser.js","webpack:///helena/./node_modules/blockly/core-browser.js","webpack:///helena/./node_modules/blockly/index.js","webpack:///helena/./node_modules/blockly/javascript.js","webpack:///helena/./node_modules/blockly/msg/en.js","webpack:///helena/../node_modules/tslib/tslib.es6.js","webpack:///helena/../src/css/layout/bounds.ts","webpack:///helena/../node_modules/css-line-break/src/Util.ts","webpack:///helena/../node_modules/css-line-break/src/Trie.ts","webpack:///helena/../node_modules/css-line-break/src/linebreak-trie.ts","webpack:///helena/../node_modules/css-line-break/src/LineBreak.ts","webpack:///helena/../src/css/syntax/tokenizer.ts","webpack:///helena/../src/css/syntax/parser.ts","webpack:///helena/../src/css/types/length.ts","webpack:///helena/../src/css/types/length-percentage.ts","webpack:///helena/../src/css/types/angle.ts","webpack:///helena/../src/css/types/color.ts","webpack:///helena/../src/css/IPropertyDescriptor.ts","webpack:///helena/../src/css/property-descriptors/background-clip.ts","webpack:///helena/../src/css/property-descriptors/background-color.ts","webpack:///helena/../src/css/types/functions/gradient.ts","webpack:///helena/../src/css/types/functions/linear-gradient.ts","webpack:///helena/../src/css/types/functions/-prefix-linear-gradient.ts","webpack:///helena/../src/core/features.ts","webpack:///helena/../src/core/logger.ts","webpack:///helena/../src/core/cache-storage.ts","webpack:///helena/../src/css/types/functions/-webkit-gradient.ts","webpack:///helena/../src/css/types/functions/radial-gradient.ts","webpack:///helena/../src/css/types/functions/-prefix-radial-gradient.ts","webpack:///helena/../src/css/types/image.ts","webpack:///helena/../src/css/property-descriptors/background-image.ts","webpack:///helena/../src/css/property-descriptors/background-origin.ts","webpack:///helena/../src/css/property-descriptors/background-position.ts","webpack:///helena/../src/css/property-descriptors/background-repeat.ts","webpack:///helena/../src/css/property-descriptors/background-size.ts","webpack:///helena/../src/css/property-descriptors/border-color.ts","webpack:///helena/../src/css/property-descriptors/border-radius.ts","webpack:///helena/../src/css/property-descriptors/border-style.ts","webpack:///helena/../src/css/property-descriptors/border-width.ts","webpack:///helena/../src/css/property-descriptors/color.ts","webpack:///helena/../src/css/property-descriptors/display.ts","webpack:///helena/../src/css/property-descriptors/float.ts","webpack:///helena/../src/css/property-descriptors/letter-spacing.ts","webpack:///helena/../src/css/property-descriptors/line-break.ts","webpack:///helena/../src/css/property-descriptors/line-height.ts","webpack:///helena/../src/css/property-descriptors/list-style-image.ts","webpack:///helena/../src/css/property-descriptors/list-style-position.ts","webpack:///helena/../src/css/property-descriptors/list-style-type.ts","webpack:///helena/../src/css/property-descriptors/margin.ts","webpack:///helena/../src/css/property-descriptors/overflow.ts","webpack:///helena/../src/css/property-descriptors/overflow-wrap.ts","webpack:///helena/../src/css/property-descriptors/padding.ts","webpack:///helena/../src/css/property-descriptors/text-align.ts","webpack:///helena/../src/css/property-descriptors/position.ts","webpack:///helena/../src/css/property-descriptors/text-shadow.ts","webpack:///helena/../src/css/property-descriptors/text-transform.ts","webpack:///helena/../src/css/property-descriptors/transform.ts","webpack:///helena/../src/css/property-descriptors/transform-origin.ts","webpack:///helena/../src/css/property-descriptors/visibility.ts","webpack:///helena/../src/css/property-descriptors/word-break.ts","webpack:///helena/../src/css/property-descriptors/z-index.ts","webpack:///helena/../src/css/property-descriptors/opacity.ts","webpack:///helena/../src/css/property-descriptors/text-decoration-color.ts","webpack:///helena/../src/css/property-descriptors/text-decoration-line.ts","webpack:///helena/../src/css/property-descriptors/font-family.ts","webpack:///helena/../src/css/property-descriptors/font-size.ts","webpack:///helena/../src/css/property-descriptors/font-weight.ts","webpack:///helena/../src/css/property-descriptors/font-variant.ts","webpack:///helena/../src/css/property-descriptors/font-style.ts","webpack:///helena/../src/core/bitwise.ts","webpack:///helena/../src/css/property-descriptors/content.ts","webpack:///helena/../src/css/property-descriptors/counter-increment.ts","webpack:///helena/../src/css/property-descriptors/counter-reset.ts","webpack:///helena/../src/css/property-descriptors/quotes.ts","webpack:///helena/../src/css/property-descriptors/box-shadow.ts","webpack:///helena/../src/css/index.ts","webpack:///helena/../src/dom/element-container.ts","webpack:///helena/../src/css/layout/text.ts","webpack:///helena/../src/dom/text-container.ts","webpack:///helena/../src/dom/replaced-elements/image-element-container.ts","webpack:///helena/../src/dom/replaced-elements/canvas-element-container.ts","webpack:///helena/../src/dom/replaced-elements/svg-element-container.ts","webpack:///helena/../src/dom/elements/li-element-container.ts","webpack:///helena/../src/dom/elements/ol-element-container.ts","webpack:///helena/../src/dom/replaced-elements/input-element-container.ts","webpack:///helena/../src/dom/elements/select-element-container.ts","webpack:///helena/../src/dom/elements/textarea-element-container.ts","webpack:///helena/../src/dom/replaced-elements/iframe-element-container.ts","webpack:///helena/../src/dom/node-parser.ts","webpack:///helena/../src/css/types/functions/counter.ts","webpack:///helena/../src/dom/document-cloner.ts","webpack:///helena/../src/render/path.ts","webpack:///helena/../src/render/vector.ts","webpack:///helena/../src/render/bezier-curve.ts","webpack:///helena/../src/render/bound-curves.ts","webpack:///helena/../src/render/effects.ts","webpack:///helena/../src/render/stacking-context.ts","webpack:///helena/../src/render/border.ts","webpack:///helena/../src/render/box-sizing.ts","webpack:///helena/../src/render/background.ts","webpack:///helena/../src/core/util.ts","webpack:///helena/../src/render/font-metrics.ts","webpack:///helena/../src/render/canvas/canvas-renderer.ts","webpack:///helena/../src/render/canvas/foreignobject-renderer.ts","webpack:///helena/../src/index.ts","webpack:///helena/./node_modules/json-stable-stringify/index.js","webpack:///helena/./node_modules/jsonify/index.js","webpack:///helena/./node_modules/jsonify/lib/parse.js","webpack:///helena/./node_modules/jsonify/lib/stringify.js","webpack:///helena/./node_modules/later/index.js","webpack:///helena/./node_modules/later/later.js","webpack:///helena/./src/lib/JSOG.js","webpack:///helena/./src/lib/jquery-dateFormat.min.js","webpack:///helena/./src/lib/jquery-ui.js","webpack:///helena/./src/lib/jquery.js","webpack:///helena/./src/lib/jquery_csv.js","webpack:///helena/./node_modules/underscore/underscore.js","webpack:///helena/(webpack)/buildin/global.js","webpack:///helena/(webpack)/buildin/module.js","webpack:///helena/src/background/helena_background.ts","webpack:///helena/src/common/config/config.ts","webpack:///helena/src/common/mainpanel_node.ts","webpack:///helena/src/common/messages.ts","webpack:///helena/src/common/misc_utilities.ts","webpack:///helena/src/common/utils/dom_creation.ts","webpack:///helena/src/common/utils/helena_console.ts","webpack:///helena/src/common/utils/trace.ts","webpack:///helena/src/content/filters/recording_mode_filters.ts","webpack:///helena/src/content/filters/scrape_mode_filters.ts","webpack:///helena/src/content/handlers/recording_mode_handlers.ts","webpack:///helena/src/content/handlers/scrape_mode_handlers.ts","webpack:///helena/src/content/helena_content.ts","webpack:///helena/src/content/selector/column_selector.ts","webpack:///helena/src/content/selector/interfaces.ts","webpack:///helena/src/content/selector/next_button_selector.ts","webpack:///helena/src/content/selector/relation_finding.ts","webpack:///helena/src/content/selector/relation_selector.ts","webpack:///helena/src/content/ui/highlight.ts","webpack:///helena/src/content/ui/relation_highlighter.ts","webpack:///helena/src/content/ui/scraping_tooltip.ts","webpack:///helena/src/content/utils/features.ts","webpack:///helena/src/content/utils/screenshot.ts","webpack:///helena/src/content/utils/xpath.ts","webpack:///helena/src/index.ts","webpack:///helena/src/mainpanel/dataset.ts","webpack:///helena/src/mainpanel/environment.ts","webpack:///helena/src/mainpanel/helena_mainpanel.ts","webpack:///helena/src/mainpanel/lang/helena_lang.ts","webpack:///helena/src/mainpanel/lang/program.ts","webpack:///helena/src/mainpanel/lang/statements/browser/back.ts","webpack:///helena/src/mainpanel/lang/statements/browser/close_page.ts","webpack:///helena/src/mainpanel/lang/statements/browser/load.ts","webpack:///helena/src/mainpanel/lang/statements/container.ts","webpack:///helena/src/mainpanel/lang/statements/control_flow/loop.ts","webpack:///helena/src/mainpanel/lang/statements/control_flow/skip_block.ts","webpack:///helena/src/mainpanel/lang/statements/control_flow/wait.ts","webpack:///helena/src/mainpanel/lang/statements/output_row.ts","webpack:///helena/src/mainpanel/lang/statements/page_action/click.ts","webpack:///helena/src/mainpanel/lang/statements/page_action/page_action.ts","webpack:///helena/src/mainpanel/lang/statements/page_action/pulldown_interaction.ts","webpack:///helena/src/mainpanel/lang/statements/page_action/scrape.ts","webpack:///helena/src/mainpanel/lang/statements/page_action/type.ts","webpack:///helena/src/mainpanel/lang/statements/statement_types.ts","webpack:///helena/src/mainpanel/lang/values/concatenate.ts","webpack:///helena/src/mainpanel/lang/values/node_variable_use.ts","webpack:///helena/src/mainpanel/lang/values/number.ts","webpack:///helena/src/mainpanel/lang/values/string.ts","webpack:///helena/src/mainpanel/lang/values/value.ts","webpack:///helena/src/mainpanel/parameterized_trace.ts","webpack:///helena/src/mainpanel/relation/generic.ts","webpack:///helena/src/mainpanel/relation/relation.ts","webpack:///helena/src/mainpanel/relation/text_relation.ts","webpack:///helena/src/mainpanel/revival.ts","webpack:///helena/src/mainpanel/ui/blocks.ts","webpack:///helena/src/mainpanel/ui/helena_ui_base.ts","webpack:///helena/src/mainpanel/ui/recorder_ui.ts","webpack:///helena/src/mainpanel/utils/server.ts","webpack:///helena/src/mainpanel/variables/node_variable.ts","webpack:///helena/src/mainpanel/variables/page_variable.ts","webpack:///helena/src/ringer-record-replay/common/event.ts","webpack:///helena/src/ringer-record-replay/common/logs.ts","webpack:///helena/src/ringer-record-replay/common/messages.ts","webpack:///helena/src/ringer-record-replay/common/params.ts","webpack:///helena/src/ringer-record-replay/common/utils.ts","webpack:///helena/src/ringer-record-replay/content/dom_utils.ts","webpack:///helena/src/ringer-record-replay/content/highlight.ts","webpack:///helena/src/ringer-record-replay/content/ringer_content.ts","webpack:///helena/src/ringer-record-replay/content/snapshot.ts","webpack:///helena/src/ringer-record-replay/content/target.ts","webpack:///helena/src/ringer-record-replay/mainpanel/port_manager.ts","webpack:///helena/src/ringer-record-replay/mainpanel/record.ts","webpack:///helena/src/ringer-record-replay/mainpanel/replay.ts","webpack:///helena/src/ringer-record-replay/mainpanel/ringer_mainpanel.ts","webpack:///helena/src/ringer-record-replay/mainpanel/user.ts","webpack:///src/background.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/background.ts\");\n","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"helena\"] = factory();\n\telse\n\t\troot[\"helena\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory();\n  } else { // Browser\n    root.Blockly = factory();\n  }\n}(this, function() {\n// Do not edit this file; automatically generated by gulp.\n'use strict';var Blockly={constants:{},LINE_MODE_MULTIPLIER:40,PAGE_MODE_MULTIPLIER:125,DRAG_RADIUS:5,FLYOUT_DRAG_RADIUS:10,SNAP_RADIUS:28};Blockly.CONNECTING_SNAP_RADIUS=Blockly.SNAP_RADIUS;Blockly.CURRENT_CONNECTION_PREFERENCE=8;Blockly.BUMP_DELAY=250;Blockly.BUMP_RANDOMNESS=10;Blockly.COLLAPSE_CHARS=30;Blockly.LONGPRESS=750;Blockly.SOUND_LIMIT=100;Blockly.DRAG_STACK=!0;Blockly.HSV_SATURATION=.45;Blockly.HSV_VALUE=.65;Blockly.SPRITE={width:96,height:124,url:\"sprites.png\"};Blockly.INPUT_VALUE=1;\nBlockly.OUTPUT_VALUE=2;Blockly.NEXT_STATEMENT=3;Blockly.PREVIOUS_STATEMENT=4;Blockly.DUMMY_INPUT=5;Blockly.ALIGN_LEFT=-1;Blockly.ALIGN_CENTRE=0;Blockly.ALIGN_RIGHT=1;Blockly.DRAG_NONE=0;Blockly.DRAG_STICKY=1;Blockly.DRAG_BEGIN=1;Blockly.DRAG_FREE=2;Blockly.OPPOSITE_TYPE=[];Blockly.OPPOSITE_TYPE[Blockly.INPUT_VALUE]=Blockly.OUTPUT_VALUE;Blockly.OPPOSITE_TYPE[Blockly.OUTPUT_VALUE]=Blockly.INPUT_VALUE;Blockly.OPPOSITE_TYPE[Blockly.NEXT_STATEMENT]=Blockly.PREVIOUS_STATEMENT;\nBlockly.OPPOSITE_TYPE[Blockly.PREVIOUS_STATEMENT]=Blockly.NEXT_STATEMENT;Blockly.TOOLBOX_AT_TOP=0;Blockly.TOOLBOX_AT_BOTTOM=1;Blockly.TOOLBOX_AT_LEFT=2;Blockly.TOOLBOX_AT_RIGHT=3;Blockly.DELETE_AREA_NONE=null;Blockly.DELETE_AREA_TRASH=1;Blockly.DELETE_AREA_TOOLBOX=2;Blockly.VARIABLE_CATEGORY_NAME=\"VARIABLE\";Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME=\"VARIABLE_DYNAMIC\";Blockly.PROCEDURE_CATEGORY_NAME=\"PROCEDURE\";Blockly.RENAME_VARIABLE_ID=\"RENAME_VARIABLE_ID\";Blockly.DELETE_VARIABLE_ID=\"DELETE_VARIABLE_ID\";Blockly.utils={};Blockly.utils.global=function(){return\"object\"===typeof self?self:\"object\"===typeof window?window:\"object\"===typeof global?global:this}();Blockly.Msg={};Blockly.utils.global.Blockly||(Blockly.utils.global.Blockly={});Blockly.utils.global.Blockly.Msg||(Blockly.utils.global.Blockly.Msg=Blockly.Msg);Blockly.utils.colour={};\nBlockly.utils.colour.parse=function(a){a=String(a).toLowerCase().trim();var b=Blockly.utils.colour.names[a];if(b)return b;b=\"0x\"==a.substring(0,2)?\"#\"+a.substring(2):a;b=\"#\"==b[0]?b:\"#\"+b;if(/^#[0-9a-f]{6}$/.test(b))return b;if(/^#[0-9a-f]{3}$/.test(b))return[\"#\",b[1],b[1],b[2],b[2],b[3],b[3]].join(\"\");var c=a.match(/^(?:rgb)?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/);return c&&(a=Number(c[1]),b=Number(c[2]),c=Number(c[3]),0<=a&&256>a&&0<=b&&256>b&&0<=c&&256>c)?Blockly.utils.colour.rgbToHex(a,b,\nc):null};Blockly.utils.colour.rgbToHex=function(a,b,c){b=a<<16|b<<8|c;return 16>a?\"#\"+(16777216|b).toString(16).substr(1):\"#\"+b.toString(16)};Blockly.utils.colour.hexToRgb=function(a){a=Blockly.utils.colour.parse(a);if(!a)return[0,0,0];a=parseInt(a.substr(1),16);return[a>>16,a>>8&255,a&255]};\nBlockly.utils.colour.hsvToHex=function(a,b,c){var d=0,e=0,f=0;if(0==b)f=e=d=c;else{var g=Math.floor(a/60),h=a/60-g;a=c*(1-b);var k=c*(1-b*h);b=c*(1-b*(1-h));switch(g){case 1:d=k;e=c;f=a;break;case 2:d=a;e=c;f=b;break;case 3:d=a;e=k;f=c;break;case 4:d=b;e=a;f=c;break;case 5:d=c;e=a;f=k;break;case 6:case 0:d=c,e=b,f=a}}return Blockly.utils.colour.rgbToHex(Math.floor(d),Math.floor(e),Math.floor(f))};\nBlockly.utils.colour.blend=function(a,b,c){a=Blockly.utils.colour.parse(a);if(!a)return null;b=Blockly.utils.colour.parse(b);if(!b)return null;a=Blockly.utils.colour.hexToRgb(a);b=Blockly.utils.colour.hexToRgb(b);return Blockly.utils.colour.rgbToHex(Math.round(b[0]+c*(a[0]-b[0])),Math.round(b[1]+c*(a[1]-b[1])),Math.round(b[2]+c*(a[2]-b[2])))};\nBlockly.utils.colour.names={aqua:\"#00ffff\",black:\"#000000\",blue:\"#0000ff\",fuchsia:\"#ff00ff\",gray:\"#808080\",green:\"#008000\",lime:\"#00ff00\",maroon:\"#800000\",navy:\"#000080\",olive:\"#808000\",purple:\"#800080\",red:\"#ff0000\",silver:\"#c0c0c0\",teal:\"#008080\",white:\"#ffffff\",yellow:\"#ffff00\"};Blockly.utils.Coordinate=function(a,b){this.x=a;this.y=b};Blockly.utils.Coordinate.equals=function(a,b){return a==b?!0:a&&b?a.x==b.x&&a.y==b.y:!1};Blockly.utils.Coordinate.distance=function(a,b){var c=a.x-b.x;a=a.y-b.y;return Math.sqrt(c*c+a*a)};Blockly.utils.Coordinate.magnitude=function(a){return Math.sqrt(a.x*a.x+a.y*a.y)};Blockly.utils.Coordinate.difference=function(a,b){return new Blockly.utils.Coordinate(a.x-b.x,a.y-b.y)};\nBlockly.utils.Coordinate.sum=function(a,b){return new Blockly.utils.Coordinate(a.x+b.x,a.y+b.y)};Blockly.utils.Coordinate.prototype.scale=function(a){this.x*=a;this.y*=a;return this};Blockly.utils.Coordinate.prototype.translate=function(a,b){this.x+=a;this.y+=b;return this};Blockly.utils.string={};Blockly.utils.string.startsWith=function(a,b){return 0==a.lastIndexOf(b,0)};Blockly.utils.string.shortestStringLength=function(a){return a.length?a.reduce(function(a,c){return a.length<c.length?a:c}).length:0};\nBlockly.utils.string.commonWordPrefix=function(a,b){if(!a.length)return 0;if(1==a.length)return a[0].length;var c=0;b=b||Blockly.utils.string.shortestStringLength(a);for(var d=0;d<b;d++){for(var e=a[0][d],f=1;f<a.length;f++)if(e!=a[f][d])return c;\" \"==e&&(c=d+1)}for(f=1;f<a.length;f++)if((e=a[f][d])&&\" \"!=e)return c;return b};\nBlockly.utils.string.commonWordSuffix=function(a,b){if(!a.length)return 0;if(1==a.length)return a[0].length;var c=0;b=b||Blockly.utils.string.shortestStringLength(a);for(var d=0;d<b;d++){for(var e=a[0].substr(-d-1,1),f=1;f<a.length;f++)if(e!=a[f].substr(-d-1,1))return c;\" \"==e&&(c=d+1)}for(f=1;f<a.length;f++)if((e=a[f].charAt(a[f].length-d-1))&&\" \"!=e)return c;return b};Blockly.utils.string.wrap=function(a,b){a=a.split(\"\\n\");for(var c=0;c<a.length;c++)a[c]=Blockly.utils.string.wrapLine_(a[c],b);return a.join(\"\\n\")};\nBlockly.utils.string.wrapLine_=function(a,b){if(a.length<=b)return a;for(var c=a.trim().split(/\\s+/),d=0;d<c.length;d++)c[d].length>b&&(b=c[d].length);d=-Infinity;var e=1;do{var f=d;var g=a;a=[];var h=c.length/e,k=1;for(d=0;d<c.length-1;d++)k<(d+1.5)/h?(k++,a[d]=!0):a[d]=!1;a=Blockly.utils.string.wrapMutate_(c,a,b);d=Blockly.utils.string.wrapScore_(c,a,b);a=Blockly.utils.string.wrapToText_(c,a);e++}while(d>f);return g};\nBlockly.utils.string.wrapScore_=function(a,b,c){for(var d=[0],e=[],f=0;f<a.length;f++)d[d.length-1]+=a[f].length,!0===b[f]?(d.push(0),e.push(a[f].charAt(a[f].length-1))):!1===b[f]&&d[d.length-1]++;a=Math.max.apply(Math,d);for(f=b=0;f<d.length;f++)b-=2*Math.pow(Math.abs(c-d[f]),1.5),b-=Math.pow(a-d[f],1.5),-1!=\".?!\".indexOf(e[f])?b+=c/3:-1!=\",;)]}\".indexOf(e[f])&&(b+=c/4);1<d.length&&d[d.length-1]<=d[d.length-2]&&(b+=.5);return b};\nBlockly.utils.string.wrapMutate_=function(a,b,c){for(var d=Blockly.utils.string.wrapScore_(a,b,c),e,f=0;f<b.length-1;f++)if(b[f]!=b[f+1]){var g=[].concat(b);g[f]=!g[f];g[f+1]=!g[f+1];var h=Blockly.utils.string.wrapScore_(a,g,c);h>d&&(d=h,e=g)}return e?Blockly.utils.string.wrapMutate_(a,e,c):b};Blockly.utils.string.wrapToText_=function(a,b){for(var c=[],d=0;d<a.length;d++)c.push(a[d]),void 0!==b[d]&&c.push(b[d]?\"\\n\":\" \");return c.join(\"\")};Blockly.utils.Size=function(a,b){this.width=a;this.height=b};Blockly.utils.Size.equals=function(a,b){return a==b?!0:a&&b?a.width==b.width&&a.height==b.height:!1};Blockly.utils.style={};Blockly.utils.style.getSize=function(a){if(\"none\"!=Blockly.utils.style.getStyle_(a,\"display\"))return Blockly.utils.style.getSizeWithDisplay_(a);var b=a.style,c=b.display,d=b.visibility,e=b.position;b.visibility=\"hidden\";b.position=\"absolute\";b.display=\"inline\";var f=a.offsetWidth;a=a.offsetHeight;b.display=c;b.position=e;b.visibility=d;return new Blockly.utils.Size(f,a)};Blockly.utils.style.getSizeWithDisplay_=function(a){return new Blockly.utils.Size(a.offsetWidth,a.offsetHeight)};\nBlockly.utils.style.getStyle_=function(a,b){return Blockly.utils.style.getComputedStyle(a,b)||Blockly.utils.style.getCascadedStyle(a,b)||a.style&&a.style[b]};Blockly.utils.style.getComputedStyle=function(a,b){return document.defaultView&&document.defaultView.getComputedStyle&&(a=document.defaultView.getComputedStyle(a,null))?a[b]||a.getPropertyValue(b)||\"\":\"\"};Blockly.utils.style.getCascadedStyle=function(a,b){return a.currentStyle?a.currentStyle[b]:null};\nBlockly.utils.style.getPageOffset=function(a){var b=new Blockly.utils.Coordinate(0,0);a=a.getBoundingClientRect();var c=document.documentElement;c=new Blockly.utils.Coordinate(window.pageXOffset||c.scrollLeft,window.pageYOffset||c.scrollTop);b.x=a.left+c.x;b.y=a.top+c.y;return b};Blockly.utils.style.getViewportPageOffset=function(){var a=document.body,b=document.documentElement;return new Blockly.utils.Coordinate(a.scrollLeft||b.scrollLeft,a.scrollTop||b.scrollTop)};\nBlockly.utils.style.setElementShown=function(a,b){a.style.display=b?\"\":\"none\"};Blockly.utils.style.isRightToLeft=function(a){return\"rtl\"==Blockly.utils.style.getStyle_(a,\"direction\")};\nBlockly.utils.style.getBorderBox=function(a){var b=Blockly.utils.style.getComputedStyle(a,\"borderLeftWidth\"),c=Blockly.utils.style.getComputedStyle(a,\"borderRightWidth\"),d=Blockly.utils.style.getComputedStyle(a,\"borderTopWidth\");a=Blockly.utils.style.getComputedStyle(a,\"borderBottomWidth\");return{top:parseFloat(d),right:parseFloat(c),bottom:parseFloat(a),left:parseFloat(b)}};\nBlockly.utils.style.scrollIntoContainerView=function(a,b,c){a=Blockly.utils.style.getContainerOffsetToScrollInto(a,b,c);b.scrollLeft=a.x;b.scrollTop=a.y};\nBlockly.utils.style.getContainerOffsetToScrollInto=function(a,b,c){var d=Blockly.utils.style.getPageOffset(a),e=Blockly.utils.style.getPageOffset(b),f=Blockly.utils.style.getBorderBox(b),g=d.x-e.x-f.left;d=d.y-e.y-f.top;e=Blockly.utils.style.getSizeWithDisplay_(a);a=b.clientWidth-e.width;e=b.clientHeight-e.height;f=b.scrollLeft;b=b.scrollTop;c?(f+=g-a/2,b+=d-e/2):(f+=Math.min(g,Math.max(g-a,0)),b+=Math.min(d,Math.max(d-e,0)));return new Blockly.utils.Coordinate(f,b)};Blockly.utils.userAgent={};\n(function(a){function b(a){return-1!=c.indexOf(a.toUpperCase())}Blockly.utils.userAgent.raw=a;var c=Blockly.utils.userAgent.raw.toUpperCase();Blockly.utils.userAgent.IE=b(\"Trident\")||b(\"MSIE\");Blockly.utils.userAgent.EDGE=b(\"Edge\");Blockly.utils.userAgent.JAVA_FX=b(\"JavaFX\");Blockly.utils.userAgent.CHROME=(b(\"Chrome\")||b(\"CriOS\"))&&!Blockly.utils.userAgent.EDGE;Blockly.utils.userAgent.WEBKIT=b(\"WebKit\")&&!Blockly.utils.userAgent.EDGE;Blockly.utils.userAgent.GECKO=b(\"Gecko\")&&!Blockly.utils.userAgent.WEBKIT&&\n!Blockly.utils.userAgent.IE&&!Blockly.utils.userAgent.EDGE;Blockly.utils.userAgent.ANDROID=b(\"Android\");Blockly.utils.userAgent.IPAD=b(\"iPad\");Blockly.utils.userAgent.IPOD=b(\"iPod\");Blockly.utils.userAgent.IPHONE=b(\"iPhone\")&&!Blockly.utils.userAgent.IPAD&&!Blockly.utils.userAgent.IPOD;Blockly.utils.userAgent.MAC=b(\"Macintosh\");Blockly.utils.userAgent.TABLET=Blockly.utils.userAgent.IPAD||Blockly.utils.userAgent.ANDROID&&!b(\"Mobile\")||b(\"Silk\");Blockly.utils.userAgent.MOBILE=!Blockly.utils.userAgent.TABLET&&\n(Blockly.utils.userAgent.IPOD||Blockly.utils.userAgent.IPHONE||Blockly.utils.userAgent.ANDROID||b(\"IEMobile\"))})(Blockly.utils.global.navigator&&Blockly.utils.global.navigator.userAgent||\"\");Blockly.utils.noEvent=function(a){a.preventDefault();a.stopPropagation()};Blockly.utils.isTargetInput=function(a){return\"textarea\"==a.target.type||\"text\"==a.target.type||\"number\"==a.target.type||\"email\"==a.target.type||\"password\"==a.target.type||\"search\"==a.target.type||\"tel\"==a.target.type||\"url\"==a.target.type||a.target.isContentEditable};\nBlockly.utils.getRelativeXY=function(a){var b=new Blockly.utils.Coordinate(0,0),c=a.getAttribute(\"x\");c&&(b.x=parseInt(c,10));if(c=a.getAttribute(\"y\"))b.y=parseInt(c,10);if(c=(c=a.getAttribute(\"transform\"))&&c.match(Blockly.utils.getRelativeXY.XY_REGEX_))b.x+=Number(c[1]),c[3]&&(b.y+=Number(c[3]));(a=a.getAttribute(\"style\"))&&-1<a.indexOf(\"translate\")&&(a=a.match(Blockly.utils.getRelativeXY.XY_STYLE_REGEX_))&&(b.x+=Number(a[1]),a[3]&&(b.y+=Number(a[3])));return b};\nBlockly.utils.getInjectionDivXY_=function(a){for(var b=0,c=0;a;){var d=Blockly.utils.getRelativeXY(a);b+=d.x;c+=d.y;if(-1!=(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").indexOf(\" injectionDiv \"))break;a=a.parentNode}return new Blockly.utils.Coordinate(b,c)};Blockly.utils.getRelativeXY.XY_REGEX_=/translate\\(\\s*([-+\\d.e]+)([ ,]\\s*([-+\\d.e]+)\\s*)?/;Blockly.utils.getRelativeXY.XY_STYLE_REGEX_=/transform:\\s*translate(?:3d)?\\(\\s*([-+\\d.e]+)\\s*px([ ,]\\s*([-+\\d.e]+)\\s*px)?/;\nBlockly.utils.isRightButton=function(a){return a.ctrlKey&&Blockly.utils.userAgent.MAC?!0:2==a.button};Blockly.utils.mouseToSvg=function(a,b,c){var d=b.createSVGPoint();d.x=a.clientX;d.y=a.clientY;c||(c=b.getScreenCTM().inverse());return d.matrixTransform(c)};\nBlockly.utils.getScrollDeltaPixels=function(a){switch(a.deltaMode){default:return{x:a.deltaX,y:a.deltaY};case 1:return{x:a.deltaX*Blockly.LINE_MODE_MULTIPLIER,y:a.deltaY*Blockly.LINE_MODE_MULTIPLIER};case 2:return{x:a.deltaX*Blockly.PAGE_MODE_MULTIPLIER,y:a.deltaY*Blockly.PAGE_MODE_MULTIPLIER}}};Blockly.utils.tokenizeInterpolation=function(a){return Blockly.utils.tokenizeInterpolation_(a,!0)};\nBlockly.utils.replaceMessageReferences=function(a){if(\"string\"!=typeof a)return a;a=Blockly.utils.tokenizeInterpolation_(a,!1);return a.length?String(a[0]):\"\"};Blockly.utils.checkMessageReferences=function(a){for(var b=!0,c=Blockly.Msg,d=a.match(/%{BKY_[A-Z]\\w*}/ig),e=0;e<d.length;e++){var f=d[e].toUpperCase();void 0==c[f.slice(6,-1)]&&(console.log(\"WARNING: No message string for \"+d[e]+\" in \"+a),b=!1)}return b};\nBlockly.utils.tokenizeInterpolation_=function(a,b){var c=[],d=a.split(\"\");d.push(\"\");var e=0;a=[];for(var f=null,g=0;g<d.length;g++){var h=d[g];0==e?\"%\"==h?((h=a.join(\"\"))&&c.push(h),a.length=0,e=1):a.push(h):1==e?\"%\"==h?(a.push(h),e=0):b&&\"0\"<=h&&\"9\">=h?(e=2,f=h,(h=a.join(\"\"))&&c.push(h),a.length=0):\"{\"==h?e=3:(a.push(\"%\",h),e=0):2==e?\"0\"<=h&&\"9\">=h?f+=h:(c.push(parseInt(f,10)),g--,e=0):3==e&&(\"\"==h?(a.splice(0,0,\"%{\"),g--,e=0):\"}\"!=h?a.push(h):(e=a.join(\"\"),/[A-Z]\\w*/i.test(e)?(h=e.toUpperCase(),\n(h=Blockly.utils.string.startsWith(h,\"BKY_\")?h.substring(4):null)&&h in Blockly.Msg?(e=Blockly.Msg[h],\"string\"==typeof e?Array.prototype.push.apply(c,Blockly.utils.tokenizeInterpolation_(e,b)):b?c.push(String(e)):c.push(e)):c.push(\"%{\"+e+\"}\")):c.push(\"%{\"+e+\"}\"),e=a.length=0))}(h=a.join(\"\"))&&c.push(h);b=[];for(g=a.length=0;g<c.length;++g)\"string\"==typeof c[g]?a.push(c[g]):((h=a.join(\"\"))&&b.push(h),a.length=0,b.push(c[g]));(h=a.join(\"\"))&&b.push(h);a.length=0;return b};\nBlockly.utils.genUid=function(){for(var a=Blockly.utils.genUid.soup_.length,b=[],c=0;20>c;c++)b[c]=Blockly.utils.genUid.soup_.charAt(Math.random()*a);return b.join(\"\")};Blockly.utils.genUid.soup_=\"!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nBlockly.utils.is3dSupported=function(){if(void 0!==Blockly.utils.is3dSupported.cached_)return Blockly.utils.is3dSupported.cached_;if(!Blockly.utils.global.getComputedStyle)return!1;var a=document.createElement(\"p\"),b=\"none\",c={webkitTransform:\"-webkit-transform\",OTransform:\"-o-transform\",msTransform:\"-ms-transform\",MozTransform:\"-moz-transform\",transform:\"transform\"};document.body.insertBefore(a,null);for(var d in c)if(void 0!==a.style[d]){a.style[d]=\"translate3d(1px,1px,1px)\";b=Blockly.utils.global.getComputedStyle(a);\nif(!b)return document.body.removeChild(a),!1;b=b.getPropertyValue(c[d])}document.body.removeChild(a);Blockly.utils.is3dSupported.cached_=\"none\"!==b;return Blockly.utils.is3dSupported.cached_};Blockly.utils.runAfterPageLoad=function(a){if(\"object\"!=typeof document)throw Error(\"Blockly.utils.runAfterPageLoad() requires browser document.\");if(\"complete\"==document.readyState)a();else var b=setInterval(function(){\"complete\"==document.readyState&&(clearInterval(b),a())},10)};\nBlockly.utils.getViewportBBox=function(){var a=Blockly.utils.style.getViewportPageOffset();return{right:document.documentElement.clientWidth+a.x,bottom:document.documentElement.clientHeight+a.y,top:a.y,left:a.x}};Blockly.utils.arrayRemove=function(a,b){b=a.indexOf(b);if(-1==b)return!1;a.splice(b,1);return!0};\nBlockly.utils.getDocumentScroll=function(){var a=document.documentElement,b=window;return Blockly.utils.userAgent.IE&&b.pageYOffset!=a.scrollTop?new Blockly.utils.Coordinate(a.scrollLeft,a.scrollTop):new Blockly.utils.Coordinate(b.pageXOffset||a.scrollLeft,b.pageYOffset||a.scrollTop)};Blockly.utils.getBlockTypeCounts=function(a,b){var c=Object.create(null),d=a.getDescendants(!0);b&&(a=a.getNextBlock())&&(a=d.indexOf(a),d.splice(a,d.length-a));for(a=0;b=d[a];a++)c[b.type]?c[b.type]++:c[b.type]=1;return c};\nBlockly.utils.screenToWsCoordinates=function(a,b){var c=b.x;b=b.y;var d=a.getInjectionDiv().getBoundingClientRect();c=new Blockly.utils.Coordinate(c-d.left,b-d.top);b=a.getOriginOffsetInPixels();return Blockly.utils.Coordinate.difference(c,b).scale(1/a.scale)};\nBlockly.utils.parseBlockColour=function(a){var b=\"string\"==typeof a?Blockly.utils.replaceMessageReferences(a):a,c=Number(b);if(!isNaN(c)&&0<=c&&360>=c)return{hue:c,hex:Blockly.utils.colour.hsvToHex(c,Blockly.HSV_SATURATION,255*Blockly.HSV_VALUE)};if(c=Blockly.utils.colour.parse(b))return{hue:null,hex:c};c='Invalid colour: \"'+b+'\"';a!=b&&(c+=' (from \"'+a+'\")');throw Error(c);};Blockly.Events={};Blockly.Events.group_=\"\";Blockly.Events.recordUndo=!0;Blockly.Events.disabled_=0;Blockly.Events.CREATE=\"create\";Blockly.Events.BLOCK_CREATE=Blockly.Events.CREATE;Blockly.Events.DELETE=\"delete\";Blockly.Events.BLOCK_DELETE=Blockly.Events.DELETE;Blockly.Events.CHANGE=\"change\";Blockly.Events.BLOCK_CHANGE=Blockly.Events.CHANGE;Blockly.Events.MOVE=\"move\";Blockly.Events.BLOCK_MOVE=Blockly.Events.MOVE;Blockly.Events.VAR_CREATE=\"var_create\";Blockly.Events.VAR_DELETE=\"var_delete\";\nBlockly.Events.VAR_RENAME=\"var_rename\";Blockly.Events.UI=\"ui\";Blockly.Events.COMMENT_CREATE=\"comment_create\";Blockly.Events.COMMENT_DELETE=\"comment_delete\";Blockly.Events.COMMENT_CHANGE=\"comment_change\";Blockly.Events.COMMENT_MOVE=\"comment_move\";Blockly.Events.FINISHED_LOADING=\"finished_loading\";Blockly.Events.BUMP_EVENTS=[Blockly.Events.BLOCK_CREATE,Blockly.Events.BLOCK_MOVE,Blockly.Events.COMMENT_CREATE,Blockly.Events.COMMENT_MOVE];Blockly.Events.FIRE_QUEUE_=[];\nBlockly.Events.fire=function(a){Blockly.Events.isEnabled()&&(Blockly.Events.FIRE_QUEUE_.length||setTimeout(Blockly.Events.fireNow_,0),Blockly.Events.FIRE_QUEUE_.push(a))};Blockly.Events.fireNow_=function(){for(var a=Blockly.Events.filter(Blockly.Events.FIRE_QUEUE_,!0),b=Blockly.Events.FIRE_QUEUE_.length=0,c;c=a[b];b++)if(c.workspaceId){var d=Blockly.Workspace.getById(c.workspaceId);d&&d.fireChangeListener(c)}};\nBlockly.Events.filter=function(a,b){a=a.slice();b||a.reverse();for(var c=[],d=Object.create(null),e=0,f;f=a[e];e++)if(!f.isNull()){var g=[f.type,f.blockId,f.workspaceId].join(\" \"),h=d[g],k=h?h.event:null;if(!h)d[g]={event:f,index:e},c.push(f);else if(f.type==Blockly.Events.MOVE&&h.index==e-1)k.newParentId=f.newParentId,k.newInputName=f.newInputName,k.newCoordinate=f.newCoordinate,h.index=e;else if(f.type==Blockly.Events.CHANGE&&f.element==k.element&&f.name==k.name)k.newValue=f.newValue;else if(f.type!=\nBlockly.Events.UI||\"click\"!=f.element||\"commentOpen\"!=k.element&&\"mutatorOpen\"!=k.element&&\"warningOpen\"!=k.element)d[g]={event:f,index:1},c.push(f)}a=c.filter(function(a){return!a.isNull()});b||a.reverse();for(e=1;f=a[e];e++)f.type==Blockly.Events.CHANGE&&\"mutation\"==f.element&&a.unshift(a.splice(e,1)[0]);return a};Blockly.Events.clearPendingUndo=function(){for(var a=0,b;b=Blockly.Events.FIRE_QUEUE_[a];a++)b.recordUndo=!1};Blockly.Events.disable=function(){Blockly.Events.disabled_++};\nBlockly.Events.enable=function(){Blockly.Events.disabled_--};Blockly.Events.isEnabled=function(){return 0==Blockly.Events.disabled_};Blockly.Events.getGroup=function(){return Blockly.Events.group_};Blockly.Events.setGroup=function(a){Blockly.Events.group_=\"boolean\"==typeof a?a?Blockly.utils.genUid():\"\":a};Blockly.Events.getDescendantIds=function(a){var b=[];a=a.getDescendants(!1);for(var c=0,d;d=a[c];c++)b[c]=d.id;return b};\nBlockly.Events.fromJson=function(a,b){switch(a.type){case Blockly.Events.CREATE:var c=new Blockly.Events.Create(null);break;case Blockly.Events.DELETE:c=new Blockly.Events.Delete(null);break;case Blockly.Events.CHANGE:c=new Blockly.Events.Change(null,\"\",\"\",\"\",\"\");break;case Blockly.Events.MOVE:c=new Blockly.Events.Move(null);break;case Blockly.Events.VAR_CREATE:c=new Blockly.Events.VarCreate(null);break;case Blockly.Events.VAR_DELETE:c=new Blockly.Events.VarDelete(null);break;case Blockly.Events.VAR_RENAME:c=\nnew Blockly.Events.VarRename(null,\"\");break;case Blockly.Events.UI:c=new Blockly.Events.Ui(null,\"\",\"\",\"\");break;case Blockly.Events.COMMENT_CREATE:c=new Blockly.Events.CommentCreate(null);break;case Blockly.Events.COMMENT_CHANGE:c=new Blockly.Events.CommentChange(null,\"\",\"\");break;case Blockly.Events.COMMENT_MOVE:c=new Blockly.Events.CommentMove(null);break;case Blockly.Events.COMMENT_DELETE:c=new Blockly.Events.CommentDelete(null);break;case Blockly.Events.FINISHED_LOADING:c=new Blockly.Events.FinishedLoading(b);\nbreak;default:throw Error(\"Unknown event type.\");}c.fromJson(a);c.workspaceId=b.id;return c};\nBlockly.Events.disableOrphans=function(a){if((a.type==Blockly.Events.MOVE||a.type==Blockly.Events.CREATE)&&a.workspaceId){var b=Blockly.Workspace.getById(a.workspaceId);if(a=b.getBlockById(a.blockId)){var c=a.getParent();if(c&&c.isEnabled())for(b=a.getDescendants(!1),a=0;c=b[a];a++)c.setEnabled(!0);else if((a.outputConnection||a.previousConnection)&&!b.isDragging()){do a.setEnabled(!1),a=a.getNextBlock();while(a)}}}};Blockly.Events.Abstract=function(){this.workspaceId=void 0;this.group=Blockly.Events.getGroup();this.recordUndo=Blockly.Events.recordUndo};Blockly.Events.Abstract.prototype.toJson=function(){var a={type:this.type};this.group&&(a.group=this.group);return a};Blockly.Events.Abstract.prototype.fromJson=function(a){this.group=a.group};Blockly.Events.Abstract.prototype.isNull=function(){return!1};Blockly.Events.Abstract.prototype.run=function(a){};\nBlockly.Events.Abstract.prototype.getEventWorkspace_=function(){if(this.workspaceId)var a=Blockly.Workspace.getById(this.workspaceId);if(!a)throw Error(\"Workspace is null. Event must have been generated from real Blockly events.\");return a};Blockly.utils.object={};Blockly.utils.object.inherits=function(a,b){a.superClass_=b.prototype;a.prototype=Object.create(b.prototype);a.prototype.constructor=a};Blockly.utils.object.mixin=function(a,b){for(var c in b)a[c]=b[c]};Blockly.utils.object.deepMerge=function(a,b){for(var c in b)a[c]=\"object\"===typeof b[c]?Blockly.utils.object.deepMerge(a[c]||Object.create(null),b[c]):b[c];return a};Blockly.utils.object.values=function(a){return Object.values?Object.values(a):Object.keys(a).map(function(b){return a[b]})};Blockly.Events.Ui=function(a,b,c,d){Blockly.Events.Ui.superClass_.constructor.call(this);this.blockId=a?a.id:null;this.workspaceId=a?a.workspace.id:void 0;this.element=b;this.oldValue=c;this.newValue=d;this.recordUndo=!1};Blockly.utils.object.inherits(Blockly.Events.Ui,Blockly.Events.Abstract);Blockly.Events.Ui.prototype.type=Blockly.Events.UI;\nBlockly.Events.Ui.prototype.toJson=function(){var a=Blockly.Events.Ui.superClass_.toJson.call(this);a.element=this.element;void 0!==this.newValue&&(a.newValue=this.newValue);this.blockId&&(a.blockId=this.blockId);return a};Blockly.Events.Ui.prototype.fromJson=function(a){Blockly.Events.Ui.superClass_.fromJson.call(this,a);this.element=a.element;this.newValue=a.newValue;this.blockId=a.blockId};Blockly.utils.dom={};Blockly.utils.dom.SVG_NS=\"http://www.w3.org/2000/svg\";Blockly.utils.dom.HTML_NS=\"http://www.w3.org/1999/xhtml\";Blockly.utils.dom.XLINK_NS=\"http://www.w3.org/1999/xlink\";Blockly.utils.dom.Node={ELEMENT_NODE:1,TEXT_NODE:3,COMMENT_NODE:8,DOCUMENT_POSITION_CONTAINED_BY:16};Blockly.utils.dom.cacheWidths_=null;Blockly.utils.dom.cacheReference_=0;Blockly.utils.dom.canvasContext_=null;\nBlockly.utils.dom.createSvgElement=function(a,b,c){a=document.createElementNS(Blockly.utils.dom.SVG_NS,a);for(var d in b)a.setAttribute(d,b[d]);document.body.runtimeStyle&&(a.runtimeStyle=a.currentStyle=a.style);c&&c.appendChild(a);return a};Blockly.utils.dom.addClass=function(a,b){var c=a.getAttribute(\"class\")||\"\";if(-1!=(\" \"+c+\" \").indexOf(\" \"+b+\" \"))return!1;c&&(c+=\" \");a.setAttribute(\"class\",c+b);return!0};\nBlockly.utils.dom.removeClass=function(a,b){var c=a.getAttribute(\"class\");if(-1==(\" \"+c+\" \").indexOf(\" \"+b+\" \"))return!1;c=c.split(/\\s+/);for(var d=0;d<c.length;d++)c[d]&&c[d]!=b||(c.splice(d,1),d--);c.length?a.setAttribute(\"class\",c.join(\" \")):a.removeAttribute(\"class\");return!0};Blockly.utils.dom.hasClass=function(a,b){return-1!=(\" \"+a.getAttribute(\"class\")+\" \").indexOf(\" \"+b+\" \")};Blockly.utils.dom.removeNode=function(a){return a&&a.parentNode?a.parentNode.removeChild(a):null};\nBlockly.utils.dom.insertAfter=function(a,b){var c=b.nextSibling;b=b.parentNode;if(!b)throw Error(\"Reference node has no parent.\");c?b.insertBefore(a,c):b.appendChild(a)};Blockly.utils.dom.containsNode=function(a,b){return!!(a.compareDocumentPosition(b)&Blockly.utils.dom.Node.DOCUMENT_POSITION_CONTAINED_BY)};Blockly.utils.dom.setCssTransform=function(a,b){a.style.transform=b;a.style[\"-webkit-transform\"]=b};\nBlockly.utils.dom.startTextWidthCache=function(){Blockly.utils.dom.cacheReference_++;Blockly.utils.dom.cacheWidths_||(Blockly.utils.dom.cacheWidths_={})};Blockly.utils.dom.stopTextWidthCache=function(){Blockly.utils.dom.cacheReference_--;Blockly.utils.dom.cacheReference_||(Blockly.utils.dom.cacheWidths_=null)};\nBlockly.utils.dom.getTextWidth=function(a){var b=a.textContent+\"\\n\"+a.className.baseVal,c;if(Blockly.utils.dom.cacheWidths_&&(c=Blockly.utils.dom.cacheWidths_[b]))return c;try{c=Blockly.utils.userAgent.IE||Blockly.utils.userAgent.EDGE?a.getBBox().width:a.getComputedTextLength()}catch(d){return 8*a.textContent.length}Blockly.utils.dom.cacheWidths_&&(Blockly.utils.dom.cacheWidths_[b]=c);return c};\nBlockly.utils.dom.getFastTextWidth=function(a,b,c,d){return Blockly.utils.dom.getFastTextWidthWithSizeString(a,b+\"pt\",c,d)};\nBlockly.utils.dom.getFastTextWidthWithSizeString=function(a,b,c,d){var e=a.textContent;a=e+\"\\n\"+a.className.baseVal;var f;if(Blockly.utils.dom.cacheWidths_&&(f=Blockly.utils.dom.cacheWidths_[a]))return f;Blockly.utils.dom.canvasContext_||(f=document.createElement(\"canvas\"),f.className=\"blocklyComputeCanvas\",document.body.appendChild(f),Blockly.utils.dom.canvasContext_=f.getContext(\"2d\"));Blockly.utils.dom.canvasContext_.font=c+\" \"+b+\" \"+d;f=Blockly.utils.dom.canvasContext_.measureText(e).width;Blockly.utils.dom.cacheWidths_&&\n(Blockly.utils.dom.cacheWidths_[a]=f);return f};\nBlockly.utils.dom.measureFontMetrics=function(a,b,c,d){var e=document.createElement(\"span\");e.style.font=c+\" \"+b+\" \"+d;e.textContent=a;a=document.createElement(\"div\");a.style.width=\"1px\";a.style.height=\"0px\";b=document.createElement(\"div\");b.setAttribute(\"style\",\"position: fixed; top: 0; left: 0; display: flex;\");b.appendChild(e);b.appendChild(a);document.body.appendChild(b);try{c={},b.style.alignItems=\"baseline\",c.baseline=a.offsetTop-e.offsetTop,b.style.alignItems=\"flex-end\",c.height=a.offsetTop-\ne.offsetTop}finally{document.body.removeChild(b)}return c};Blockly.BlockDragSurfaceSvg=function(a){this.container_=a;this.createDom()};Blockly.BlockDragSurfaceSvg.prototype.SVG_=null;Blockly.BlockDragSurfaceSvg.prototype.dragGroup_=null;Blockly.BlockDragSurfaceSvg.prototype.container_=null;Blockly.BlockDragSurfaceSvg.prototype.scale_=1;Blockly.BlockDragSurfaceSvg.prototype.surfaceXY_=null;\nBlockly.BlockDragSurfaceSvg.prototype.createDom=function(){this.SVG_||(this.SVG_=Blockly.utils.dom.createSvgElement(\"svg\",{xmlns:Blockly.utils.dom.SVG_NS,\"xmlns:html\":Blockly.utils.dom.HTML_NS,\"xmlns:xlink\":Blockly.utils.dom.XLINK_NS,version:\"1.1\",\"class\":\"blocklyBlockDragSurface\"},this.container_),this.dragGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},this.SVG_))};\nBlockly.BlockDragSurfaceSvg.prototype.setBlocksAndShow=function(a){if(this.dragGroup_.childNodes.length)throw Error(\"Already dragging a block.\");this.dragGroup_.appendChild(a);this.SVG_.style.display=\"block\";this.surfaceXY_=new Blockly.utils.Coordinate(0,0)};Blockly.BlockDragSurfaceSvg.prototype.translateAndScaleGroup=function(a,b,c){this.scale_=c;a=a.toFixed(0);b=b.toFixed(0);this.dragGroup_.setAttribute(\"transform\",\"translate(\"+a+\",\"+b+\") scale(\"+c+\")\")};\nBlockly.BlockDragSurfaceSvg.prototype.translateSurfaceInternal_=function(){var a=this.surfaceXY_.x,b=this.surfaceXY_.y;a=a.toFixed(0);b=b.toFixed(0);this.SVG_.style.display=\"block\";Blockly.utils.dom.setCssTransform(this.SVG_,\"translate3d(\"+a+\"px, \"+b+\"px, 0px)\")};Blockly.BlockDragSurfaceSvg.prototype.translateSurface=function(a,b){this.surfaceXY_=new Blockly.utils.Coordinate(a*this.scale_,b*this.scale_);this.translateSurfaceInternal_()};\nBlockly.BlockDragSurfaceSvg.prototype.getSurfaceTranslation=function(){var a=Blockly.utils.getRelativeXY(this.SVG_);return new Blockly.utils.Coordinate(a.x/this.scale_,a.y/this.scale_)};Blockly.BlockDragSurfaceSvg.prototype.getGroup=function(){return this.dragGroup_};Blockly.BlockDragSurfaceSvg.prototype.getCurrentBlock=function(){return this.dragGroup_.firstChild};\nBlockly.BlockDragSurfaceSvg.prototype.clearAndHide=function(a){a?a.appendChild(this.getCurrentBlock()):this.dragGroup_.removeChild(this.getCurrentBlock());this.SVG_.style.display=\"none\";if(this.dragGroup_.childNodes.length)throw Error(\"Drag group was not cleared.\");this.surfaceXY_=null};Blockly.utils.IdGenerator={};Blockly.utils.IdGenerator.nextId_=0;Blockly.utils.IdGenerator.getNextUniqueId=function(){return\"blockly:\"+(Blockly.utils.IdGenerator.nextId_++).toString(36)};Blockly.Component=function(){this.rightToLeft_=Blockly.Component.defaultRightToLeft;this.id_=null;this.inDocument_=!1;this.parent_=this.element_=null;this.children_=[];this.childIndex_={}};Blockly.Component.defaultRightToLeft=!1;Blockly.Component.Error={ALREADY_RENDERED:\"Component already rendered\",PARENT_UNABLE_TO_BE_SET:\"Unable to set parent component\",CHILD_INDEX_OUT_OF_BOUNDS:\"Child component index out of bounds\"};Blockly.Component.prototype.getId=function(){return this.id_||(this.id_=Blockly.utils.IdGenerator.getNextUniqueId())};\nBlockly.Component.prototype.getElement=function(){return this.element_};Blockly.Component.prototype.setElementInternal=function(a){this.element_=a};Blockly.Component.prototype.setParent=function(a){if(this==a)throw Error(Blockly.Component.Error.PARENT_UNABLE_TO_BE_SET);if(a&&this.parent_&&this.id_&&this.parent_.getChild(this.id_)&&this.parent_!=a)throw Error(Blockly.Component.Error.PARENT_UNABLE_TO_BE_SET);this.parent_=a};Blockly.Component.prototype.getParent=function(){return this.parent_};\nBlockly.Component.prototype.isInDocument=function(){return this.inDocument_};Blockly.Component.prototype.createDom=function(){this.element_=document.createElement(\"div\")};Blockly.Component.prototype.render=function(a){this.render_(a)};Blockly.Component.prototype.renderBefore=function(a){this.render_(a.parentNode,a)};\nBlockly.Component.prototype.render_=function(a,b){if(this.inDocument_)throw Error(Blockly.Component.Error.ALREADY_RENDERED);this.element_||this.createDom();a?a.insertBefore(this.element_,b||null):document.body.appendChild(this.element_);this.parent_&&!this.parent_.isInDocument()||this.enterDocument()};Blockly.Component.prototype.enterDocument=function(){this.inDocument_=!0;this.forEachChild(function(a){!a.isInDocument()&&a.getElement()&&a.enterDocument()})};\nBlockly.Component.prototype.exitDocument=function(){this.forEachChild(function(a){a.isInDocument()&&a.exitDocument()});this.inDocument_=!1};Blockly.Component.prototype.dispose=function(){this.disposed_||(this.disposed_=!0,this.disposeInternal())};\nBlockly.Component.prototype.disposeInternal=function(){this.inDocument_&&this.exitDocument();this.forEachChild(function(a){a.dispose()});this.element_&&Blockly.utils.dom.removeNode(this.element_);this.parent_=this.element_=this.childIndex_=this.children_=null};Blockly.Component.prototype.addChild=function(a,b){this.addChildAt(a,this.getChildCount(),b)};\nBlockly.Component.prototype.addChildAt=function(a,b,c){if(a.inDocument_&&(c||!this.inDocument_))throw Error(Blockly.Component.Error.ALREADY_RENDERED);if(0>b||b>this.getChildCount())throw Error(Blockly.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);this.childIndex_[a.getId()]=a;if(a.getParent()==this){var d=this.children_.indexOf(a);-1<d&&this.children_.splice(d,1)}a.setParent(this);this.children_.splice(b,0,a);a.inDocument_&&this.inDocument_&&a.getParent()==this?(c=this.getContentElement(),b=c.childNodes[b]||\nnull,b!=a.getElement()&&c.insertBefore(a.getElement(),b)):c?(this.element_||this.createDom(),b=this.getChildAt(b+1),a.render_(this.getContentElement(),b?b.element_:null)):this.inDocument_&&!a.inDocument_&&a.element_&&a.element_.parentNode&&a.element_.parentNode.nodeType==Blockly.utils.dom.Node.ELEMENT_NODE&&a.enterDocument()};Blockly.Component.prototype.getContentElement=function(){return this.element_};\nBlockly.Component.prototype.setRightToLeft=function(a){if(this.inDocument_)throw Error(Blockly.Component.Error.ALREADY_RENDERED);this.rightToLeft_=a};Blockly.Component.prototype.hasChildren=function(){return 0!=this.children_.length};Blockly.Component.prototype.getChildCount=function(){return this.children_.length};Blockly.Component.prototype.getChild=function(a){return a?this.childIndex_[a]||null:null};Blockly.Component.prototype.getChildAt=function(a){return this.children_[a]||null};\nBlockly.Component.prototype.forEachChild=function(a,b){for(var c=0;c<this.children_.length;c++)a.call(b,this.children_[c],c)};Blockly.Component.prototype.indexOfChild=function(a){return this.children_.indexOf(a)};Blockly.Css={};Blockly.Css.injected_=!1;Blockly.Css.register=function(a){if(Blockly.Css.injected_)throw Error(\"CSS already injected\");Array.prototype.push.apply(Blockly.Css.CONTENT,a);a.length=0};\nBlockly.Css.inject=function(a,b){if(!Blockly.Css.injected_){Blockly.Css.injected_=!0;var c=Blockly.Css.CONTENT.join(\"\\n\");Blockly.Css.CONTENT.length=0;a&&(a=b.replace(/[\\\\/]$/,\"\"),c=c.replace(/<<<PATH>>>/g,a),a=document.createElement(\"style\"),a.id=\"blockly-common-style\",c=document.createTextNode(c),a.appendChild(c),document.head.insertBefore(a,document.head.firstChild))}};Blockly.Css.setCursor=function(a){console.warn(\"Deprecated call to Blockly.Css.setCursor. See https://github.com/google/blockly/issues/981 for context\")};\nBlockly.Css.CONTENT=[\".blocklySvg {\",\"background-color: #fff;\",\"outline: none;\",\"overflow: hidden;\",\"position: absolute;\",\"display: block;\",\"}\",\".blocklyWidgetDiv {\",\"display: none;\",\"position: absolute;\",\"z-index: 99999;\",\"}\",\".injectionDiv {\",\"height: 100%;\",\"position: relative;\",\"overflow: hidden;\",\"touch-action: none;\",\"}\",\".blocklyNonSelectable {\",\"user-select: none;\",\"-ms-user-select: none;\",\"-webkit-user-select: none;\",\"}\",\".blocklyWsDragSurface {\",\"display: none;\",\"position: absolute;\",\"top: 0;\",\n\"left: 0;\",\"}\",\".blocklyWsDragSurface.blocklyOverflowVisible {\",\"overflow: visible;\",\"}\",\".blocklyBlockDragSurface {\",\"display: none;\",\"position: absolute;\",\"top: 0;\",\"left: 0;\",\"right: 0;\",\"bottom: 0;\",\"overflow: visible !important;\",\"z-index: 50;\",\"}\",\".blocklyBlockCanvas.blocklyCanvasTransitioning,\",\".blocklyBubbleCanvas.blocklyCanvasTransitioning {\",\"transition: transform .5s;\",\"}\",\".blocklyTooltipDiv {\",\"background-color: #ffffc7;\",\"border: 1px solid #ddc;\",\"box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);\",\n\"color: #000;\",\"display: none;\",\"font-family: sans-serif;\",\"font-size: 9pt;\",\"opacity: .9;\",\"padding: 2px;\",\"position: absolute;\",\"z-index: 100000;\",\"}\",\".blocklyDropDownDiv {\",\"position: absolute;\",\"left: 0;\",\"top: 0;\",\"z-index: 1000;\",\"display: none;\",\"border: 1px solid;\",\"border-color: #dadce0;\",\"background-color: #fff;\",\"border-radius: 2px;\",\"padding: 4px;\",\"box-shadow: 0px 0px 3px 1px rgba(0,0,0,.3);\",\"}\",\".blocklyDropDownDiv.focused {\",\"box-shadow: 0px 0px 6px 1px rgba(0,0,0,.3);\",\"}\",\".blocklyDropDownContent {\",\n\"max-height: 300px;\",\"overflow: auto;\",\"overflow-x: hidden;\",\"}\",\".blocklyDropDownArrow {\",\"position: absolute;\",\"left: 0;\",\"top: 0;\",\"width: 16px;\",\"height: 16px;\",\"z-index: -1;\",\"background-color: inherit;\",\"border-color: inherit;\",\"}\",\".blocklyDropDownButton {\",\"display: inline-block;\",\"float: left;\",\"padding: 0;\",\"margin: 4px;\",\"border-radius: 4px;\",\"outline: none;\",\"border: 1px solid;\",\"transition: box-shadow .1s;\",\"cursor: pointer;\",\"}\",\".blocklyArrowTop {\",\"border-top: 1px solid;\",\"border-left: 1px solid;\",\n\"border-top-left-radius: 4px;\",\"border-color: inherit;\",\"}\",\".blocklyArrowBottom {\",\"border-bottom: 1px solid;\",\"border-right: 1px solid;\",\"border-bottom-right-radius: 4px;\",\"border-color: inherit;\",\"}\",\".blocklyResizeSE {\",\"cursor: se-resize;\",\"fill: #aaa;\",\"}\",\".blocklyResizeSW {\",\"cursor: sw-resize;\",\"fill: #aaa;\",\"}\",\".blocklyResizeLine {\",\"stroke: #515A5A;\",\"stroke-width: 1;\",\"}\",\".blocklyHighlightedConnectionPath {\",\"fill: none;\",\"stroke: #fc3;\",\"stroke-width: 4px;\",\"}\",\".blocklyPathLight {\",\n\"fill: none;\",\"stroke-linecap: round;\",\"stroke-width: 1;\",\"}\",\".blocklySelected>.blocklyPathLight {\",\"display: none;\",\"}\",\".blocklyDraggable {\",'cursor: url(\"<<<PATH>>>/handopen.cur\"), auto;',\"cursor: grab;\",\"cursor: -webkit-grab;\",\"}\",\".blocklyDragging {\",'cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;',\"cursor: grabbing;\",\"cursor: -webkit-grabbing;\",\"}\",\".blocklyDraggable:active {\",'cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;',\"cursor: grabbing;\",\"cursor: -webkit-grabbing;\",\"}\",\".blocklyBlockDragSurface .blocklyDraggable {\",\n'cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;',\"cursor: grabbing;\",\"cursor: -webkit-grabbing;\",\"}\",\".blocklyDragging.blocklyDraggingDelete {\",'cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;',\"}\",\".blocklyDragging>.blocklyPath,\",\".blocklyDragging>.blocklyPathLight {\",\"fill-opacity: .8;\",\"stroke-opacity: .8;\",\"}\",\".blocklyDragging>.blocklyPathDark {\",\"display: none;\",\"}\",\".blocklyDisabled>.blocklyPath {\",\"fill-opacity: .5;\",\"stroke-opacity: .5;\",\"}\",\".blocklyDisabled>.blocklyPathLight,\",\".blocklyDisabled>.blocklyPathDark {\",\n\"display: none;\",\"}\",\".blocklyInsertionMarker>.blocklyPath,\",\".blocklyInsertionMarker>.blocklyPathLight,\",\".blocklyInsertionMarker>.blocklyPathDark {\",\"fill-opacity: .2;\",\"stroke: none\",\"}\",\".blocklyMultilineText {\",\"font-family: monospace;\",\"}\",\".blocklyNonEditableText>text {\",\"pointer-events: none;\",\"}\",\".blocklyFlyout {\",\"position: absolute;\",\"z-index: 20;\",\"}\",\".blocklyText text {\",\"cursor: default;\",\"}\",\".blocklySvg text, .blocklyBlockDragSurface text {\",\"user-select: none;\",\"-ms-user-select: none;\",\n\"-webkit-user-select: none;\",\"cursor: inherit;\",\"}\",\".blocklyHidden {\",\"display: none;\",\"}\",\".blocklyFieldDropdown:not(.blocklyHidden) {\",\"display: block;\",\"}\",\".blocklyIconGroup {\",\"cursor: default;\",\"}\",\".blocklyIconGroup:not(:hover),\",\".blocklyIconGroupReadonly {\",\"opacity: .6;\",\"}\",\".blocklyIconShape {\",\"fill: #00f;\",\"stroke: #fff;\",\"stroke-width: 1px;\",\"}\",\".blocklyIconSymbol {\",\"fill: #fff;\",\"}\",\".blocklyMinimalBody {\",\"margin: 0;\",\"padding: 0;\",\"}\",\".blocklyHtmlInput {\",\"border: none;\",\"border-radius: 4px;\",\n\"height: 100%;\",\"margin: 0;\",\"outline: none;\",\"padding: 0;\",\"width: 100%;\",\"text-align: center;\",\"display: block;\",\"box-sizing: border-box;\",\"}\",\".blocklyHtmlInput::-ms-clear {\",\"display: none;\",\"}\",\".blocklyMainBackground {\",\"stroke-width: 1;\",\"stroke: #c6c6c6;\",\"}\",\".blocklyMutatorBackground {\",\"fill: #fff;\",\"stroke: #ddd;\",\"stroke-width: 1;\",\"}\",\".blocklyFlyoutBackground {\",\"fill: #ddd;\",\"fill-opacity: .8;\",\"}\",\".blocklyMainWorkspaceScrollbar {\",\"z-index: 20;\",\"}\",\".blocklyFlyoutScrollbar {\",\"z-index: 30;\",\n\"}\",\".blocklyScrollbarHorizontal, .blocklyScrollbarVertical {\",\"position: absolute;\",\"outline: none;\",\"}\",\".blocklyScrollbarBackground {\",\"opacity: 0;\",\"}\",\".blocklyScrollbarHandle {\",\"fill: #ccc;\",\"}\",\".blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\",\".blocklyScrollbarHandle:hover {\",\"fill: #bbb;\",\"}\",\".blocklyFlyout .blocklyScrollbarHandle {\",\"fill: #bbb;\",\"}\",\".blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,\",\".blocklyFlyout .blocklyScrollbarHandle:hover {\",\n\"fill: #aaa;\",\"}\",\".blocklyInvalidInput {\",\"background: #faa;\",\"}\",\".blocklyContextMenu {\",\"border-radius: 4px;\",\"max-height: 100%;\",\"}\",\".blocklyDropdownMenu {\",\"border-radius: 2px;\",\"padding: 0 !important;\",\"}\",\".blocklyWidgetDiv .blocklyDropdownMenu .goog-menuitem,\",\".blocklyDropDownDiv .blocklyDropdownMenu .goog-menuitem {\",\"padding-left: 28px;\",\"}\",\".blocklyWidgetDiv .blocklyDropdownMenu .goog-menuitem.goog-menuitem-rtl,\",\".blocklyDropDownDiv .blocklyDropdownMenu .goog-menuitem.goog-menuitem-rtl {\",\n\"padding-left: 5px;\",\"padding-right: 28px;\",\"}\",\".blocklyVerticalMarker {\",\"stroke-width: 3px;\",\"fill: rgba(255,255,255,.5);\",\"pointer-events: none\",\"}\",\".blocklyWidgetDiv .goog-option-selected .goog-menuitem-checkbox,\",\".blocklyWidgetDiv .goog-option-selected .goog-menuitem-icon,\",\".blocklyDropDownDiv .goog-option-selected .goog-menuitem-checkbox,\",\".blocklyDropDownDiv .goog-option-selected .goog-menuitem-icon {\",\"background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;\",\"}\",\".blocklyWidgetDiv .goog-menu {\",\n\"background: #fff;\",\"border-color: transparent;\",\"border-style: solid;\",\"border-width: 1px;\",\"cursor: default;\",\"font: normal 13px Arial, sans-serif;\",\"margin: 0;\",\"outline: none;\",\"padding: 4px 0;\",\"position: absolute;\",\"overflow-y: auto;\",\"overflow-x: hidden;\",\"max-height: 100%;\",\"z-index: 20000;\",\"box-shadow: 0px 0px 3px 1px rgba(0,0,0,.3);\",\"}\",\".blocklyWidgetDiv .goog-menu.focused {\",\"box-shadow: 0px 0px 6px 1px rgba(0,0,0,.3);\",\"}\",\".blocklyDropDownDiv .goog-menu {\",\"cursor: default;\",'font: normal 13px \"Helvetica Neue\", Helvetica, sans-serif;',\n\"outline: none;\",\"z-index: 20000;\",\"}\",\".blocklyWidgetDiv .goog-menuitem,\",\".blocklyDropDownDiv .goog-menuitem {\",\"color: #000;\",\"font: normal 13px Arial, sans-serif;\",\"list-style: none;\",\"margin: 0;\",\"min-width: 7em;\",\"border: none;\",\"padding: 6px 15px;\",\"white-space: nowrap;\",\"cursor: pointer;\",\"}\",\".blocklyWidgetDiv .goog-menu-nocheckbox .goog-menuitem,\",\".blocklyWidgetDiv .goog-menu-noicon .goog-menuitem,\",\".blocklyDropDownDiv .goog-menu-nocheckbox .goog-menuitem,\",\".blocklyDropDownDiv .goog-menu-noicon .goog-menuitem {\",\n\"padding-left: 12px;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-content,\",\".blocklyDropDownDiv .goog-menuitem-content {\",\"font-family: Arial, sans-serif;\",\"font-size: 13px;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-content {\",\"color: #000;\",\"}\",\".blocklyDropDownDiv .goog-menuitem-content {\",\"color: #000;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-disabled,\",\".blocklyDropDownDiv .goog-menuitem-disabled {\",\"cursor: inherit;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-disabled .goog-menuitem-content,\",\".blocklyDropDownDiv .goog-menuitem-disabled .goog-menuitem-content {\",\n\"color: #ccc !important;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-disabled .goog-menuitem-icon,\",\".blocklyDropDownDiv .goog-menuitem-disabled .goog-menuitem-icon {\",\"opacity: .3;\",\"filter: alpha(opacity=30);\",\"}\",\".blocklyWidgetDiv .goog-menuitem-highlight ,\",\".blocklyDropDownDiv .goog-menuitem-highlight {\",\"background-color: rgba(0,0,0,.1);\",\"}\",\".blocklyWidgetDiv .goog-menuitem-checkbox,\",\".blocklyWidgetDiv .goog-menuitem-icon,\",\".blocklyDropDownDiv .goog-menuitem-checkbox,\",\".blocklyDropDownDiv .goog-menuitem-icon {\",\n\"background-repeat: no-repeat;\",\"height: 16px;\",\"left: 6px;\",\"position: absolute;\",\"right: auto;\",\"vertical-align: middle;\",\"width: 16px;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-checkbox,\",\".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-icon,\",\".blocklyDropDownDiv .goog-menuitem-rtl .goog-menuitem-checkbox,\",\".blocklyDropDownDiv .goog-menuitem-rtl .goog-menuitem-icon {\",\"left: auto;\",\"right: 6px;\",\"}\",\".blocklyWidgetDiv .goog-option-selected .goog-menuitem-checkbox,\",\".blocklyWidgetDiv .goog-option-selected .goog-menuitem-icon,\",\n\".blocklyDropDownDiv .goog-option-selected .goog-menuitem-checkbox,\",\".blocklyDropDownDiv .goog-option-selected .goog-menuitem-icon {\",\"position: static;\",\"float: left;\",\"margin-left: -24px;\",\"}\",\".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-checkbox,\",\".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-icon,\",\".blocklyDropDownDiv .goog-menuitem-rtl .goog-menuitem-checkbox,\",\".blocklyDropDownDiv .goog-menuitem-rtl .goog-menuitem-icon {\",\"float: right;\",\"margin-right: -24px;\",\"}\",\".blocklyComputeCanvas {\",\n\"position: absolute;\",\"width: 0;\",\"height: 0;\",\"}\",\".blocklyNoPointerEvents {\",\"pointer-events: none;\",\"}\"];Blockly.utils.math={};Blockly.utils.math.toRadians=function(a){return a*Math.PI/180};Blockly.utils.math.toDegrees=function(a){return 180*a/Math.PI};Blockly.utils.math.clamp=function(a,b,c){if(c<a){var d=c;c=a;a=d}return Math.max(a,Math.min(b,c))};Blockly.DropDownDiv=function(){};Blockly.DropDownDiv.boundsElement_=null;Blockly.DropDownDiv.owner_=null;Blockly.DropDownDiv.positionToField_=null;Blockly.DropDownDiv.ARROW_SIZE=16;Blockly.DropDownDiv.BORDER_SIZE=1;Blockly.DropDownDiv.ARROW_HORIZONTAL_PADDING=12;Blockly.DropDownDiv.PADDING_Y=16;Blockly.DropDownDiv.ANIMATION_TIME=.25;Blockly.DropDownDiv.animateOutTimer_=null;Blockly.DropDownDiv.onHide_=null;Blockly.DropDownDiv.rendererClassName_=\"\";Blockly.DropDownDiv.themeClassName_=\"\";\nBlockly.DropDownDiv.createDom=function(){if(!Blockly.DropDownDiv.DIV_){var a=document.createElement(\"div\");a.className=\"blocklyDropDownDiv\";(Blockly.parentContainer||document.body).appendChild(a);Blockly.DropDownDiv.DIV_=a;var b=document.createElement(\"div\");b.className=\"blocklyDropDownContent\";a.appendChild(b);Blockly.DropDownDiv.content_=b;b=document.createElement(\"div\");b.className=\"blocklyDropDownArrow\";a.appendChild(b);Blockly.DropDownDiv.arrow_=b;Blockly.DropDownDiv.DIV_.style.opacity=0;Blockly.DropDownDiv.DIV_.style.transition=\n\"transform \"+Blockly.DropDownDiv.ANIMATION_TIME+\"s, opacity \"+Blockly.DropDownDiv.ANIMATION_TIME+\"s\";a.addEventListener(\"focusin\",function(){Blockly.utils.dom.addClass(a,\"focused\")});a.addEventListener(\"focusout\",function(){Blockly.utils.dom.removeClass(a,\"focused\")})}};Blockly.DropDownDiv.setBoundsElement=function(a){Blockly.DropDownDiv.boundsElement_=a};Blockly.DropDownDiv.getContentDiv=function(){return Blockly.DropDownDiv.content_};\nBlockly.DropDownDiv.clearContent=function(){Blockly.DropDownDiv.content_.textContent=\"\";Blockly.DropDownDiv.content_.style.width=\"\"};Blockly.DropDownDiv.setColour=function(a,b){Blockly.DropDownDiv.DIV_.style.backgroundColor=a;Blockly.DropDownDiv.DIV_.style.borderColor=b};Blockly.DropDownDiv.showPositionedByBlock=function(a,b,c,d){return Blockly.DropDownDiv.showPositionedByRect_(Blockly.DropDownDiv.getScaledBboxOfBlock_(b),a,c,d)};\nBlockly.DropDownDiv.showPositionedByField=function(a,b,c){Blockly.DropDownDiv.positionToField_=!0;return Blockly.DropDownDiv.showPositionedByRect_(Blockly.DropDownDiv.getScaledBboxOfField_(a),a,b,c)};Blockly.DropDownDiv.getScaledBboxOfBlock_=function(a){var b=a.getSvgRoot(),c=b.getBBox(),d=a.workspace.scale;a=c.height*d;c=c.width*d;b=Blockly.utils.style.getPageOffset(b);return new Blockly.utils.Rect(b.y,b.y+a,b.x,b.x+c)};\nBlockly.DropDownDiv.getScaledBboxOfField_=function(a){a=a.getScaledBBox();return new Blockly.utils.Rect(a.top,a.bottom,a.left,a.right)};Blockly.DropDownDiv.showPositionedByRect_=function(a,b,c,d){var e=a.left+(a.right-a.left)/2,f=a.bottom;a=a.top;d&&(a+=d);d=b.getSourceBlock();Blockly.DropDownDiv.setBoundsElement(d.workspace.getParentSvg().parentNode);return Blockly.DropDownDiv.show(b,d.RTL,e,f,e,a,c)};\nBlockly.DropDownDiv.show=function(a,b,c,d,e,f,g){Blockly.DropDownDiv.owner_=a;Blockly.DropDownDiv.onHide_=g||null;a=Blockly.DropDownDiv.DIV_;a.style.direction=b?\"rtl\":\"ltr\";Blockly.DropDownDiv.rendererClassName_=Blockly.getMainWorkspace().getRenderer().getClassName();Blockly.DropDownDiv.themeClassName_=Blockly.getMainWorkspace().getTheme().getClassName();Blockly.utils.dom.addClass(a,Blockly.DropDownDiv.rendererClassName_);Blockly.utils.dom.addClass(a,Blockly.DropDownDiv.themeClassName_);return Blockly.DropDownDiv.positionInternal_(c,\nd,e,f)};Blockly.DropDownDiv.getBoundsInfo_=function(){var a=Blockly.utils.style.getPageOffset(Blockly.DropDownDiv.boundsElement_),b=Blockly.utils.style.getSize(Blockly.DropDownDiv.boundsElement_);return{left:a.x,right:a.x+b.width,top:a.y,bottom:a.y+b.height,width:b.width,height:b.height}};\nBlockly.DropDownDiv.getPositionMetrics_=function(a,b,c,d){var e=Blockly.DropDownDiv.getBoundsInfo_(),f=Blockly.utils.style.getSize(Blockly.DropDownDiv.DIV_);return b+f.height<e.bottom?Blockly.DropDownDiv.getPositionBelowMetrics_(a,b,e,f):d-f.height>e.top?Blockly.DropDownDiv.getPositionAboveMetrics_(c,d,e,f):b+f.height<document.documentElement.clientHeight?Blockly.DropDownDiv.getPositionBelowMetrics_(a,b,e,f):d-f.height>document.documentElement.clientTop?Blockly.DropDownDiv.getPositionAboveMetrics_(c,\nd,e,f):Blockly.DropDownDiv.getPositionTopOfPageMetrics_(a,e,f)};Blockly.DropDownDiv.getPositionBelowMetrics_=function(a,b,c,d){a=Blockly.DropDownDiv.getPositionX(a,c.left,c.right,d.width);return{initialX:a.divX,initialY:b,finalX:a.divX,finalY:b+Blockly.DropDownDiv.PADDING_Y,arrowX:a.arrowX,arrowY:-(Blockly.DropDownDiv.ARROW_SIZE/2+Blockly.DropDownDiv.BORDER_SIZE),arrowAtTop:!0,arrowVisible:!0}};\nBlockly.DropDownDiv.getPositionAboveMetrics_=function(a,b,c,d){a=Blockly.DropDownDiv.getPositionX(a,c.left,c.right,d.width);return{initialX:a.divX,initialY:b-d.height,finalX:a.divX,finalY:b-d.height-Blockly.DropDownDiv.PADDING_Y,arrowX:a.arrowX,arrowY:d.height-2*Blockly.DropDownDiv.BORDER_SIZE-Blockly.DropDownDiv.ARROW_SIZE/2,arrowAtTop:!1,arrowVisible:!0}};\nBlockly.DropDownDiv.getPositionTopOfPageMetrics_=function(a,b,c){a=Blockly.DropDownDiv.getPositionX(a,b.left,b.right,c.width);return{initialX:a.divX,initialY:0,finalX:a.divX,finalY:0,arrowVisible:!1}};Blockly.DropDownDiv.getPositionX=function(a,b,c,d){var e=a;a=Blockly.utils.math.clamp(b,a-d/2,c-d);e-=Blockly.DropDownDiv.ARROW_SIZE/2;b=Blockly.DropDownDiv.ARROW_HORIZONTAL_PADDING;d=Blockly.utils.math.clamp(b,e-a,d-b-Blockly.DropDownDiv.ARROW_SIZE);return{arrowX:d,divX:a}};\nBlockly.DropDownDiv.isVisible=function(){return!!Blockly.DropDownDiv.owner_};Blockly.DropDownDiv.hideIfOwner=function(a,b){return Blockly.DropDownDiv.owner_===a?(b?Blockly.DropDownDiv.hideWithoutAnimation():Blockly.DropDownDiv.hide(),!0):!1};\nBlockly.DropDownDiv.hide=function(){var a=Blockly.DropDownDiv.DIV_;a.style.transform=\"translate(0, 0)\";a.style.opacity=0;Blockly.DropDownDiv.animateOutTimer_=setTimeout(function(){Blockly.DropDownDiv.hideWithoutAnimation()},1E3*Blockly.DropDownDiv.ANIMATION_TIME);Blockly.DropDownDiv.onHide_&&(Blockly.DropDownDiv.onHide_(),Blockly.DropDownDiv.onHide_=null)};\nBlockly.DropDownDiv.hideWithoutAnimation=function(){if(Blockly.DropDownDiv.isVisible()){Blockly.DropDownDiv.animateOutTimer_&&clearTimeout(Blockly.DropDownDiv.animateOutTimer_);var a=Blockly.DropDownDiv.DIV_;a.style.transform=\"\";a.style.left=\"\";a.style.top=\"\";a.style.opacity=0;a.style.display=\"none\";a.style.backgroundColor=\"\";a.style.borderColor=\"\";Blockly.DropDownDiv.onHide_&&(Blockly.DropDownDiv.onHide_(),Blockly.DropDownDiv.onHide_=null);Blockly.DropDownDiv.clearContent();Blockly.DropDownDiv.owner_=\nnull;Blockly.DropDownDiv.rendererClassName_&&(Blockly.utils.dom.removeClass(a,Blockly.DropDownDiv.rendererClassName_),Blockly.DropDownDiv.rendererClassName_=\"\");Blockly.DropDownDiv.themeClassName_&&(Blockly.utils.dom.removeClass(a,Blockly.DropDownDiv.themeClassName_),Blockly.DropDownDiv.themeClassName_=\"\");Blockly.getMainWorkspace().markFocused()}};\nBlockly.DropDownDiv.positionInternal_=function(a,b,c,d){a=Blockly.DropDownDiv.getPositionMetrics_(a,b,c,d);a.arrowVisible?(Blockly.DropDownDiv.arrow_.style.display=\"\",Blockly.DropDownDiv.arrow_.style.transform=\"translate(\"+a.arrowX+\"px,\"+a.arrowY+\"px) rotate(45deg)\",Blockly.DropDownDiv.arrow_.setAttribute(\"class\",a.arrowAtTop?\"blocklyDropDownArrow blocklyArrowTop\":\"blocklyDropDownArrow blocklyArrowBottom\")):Blockly.DropDownDiv.arrow_.style.display=\"none\";b=Math.floor(a.initialX);c=Math.floor(a.initialY);\nd=Math.floor(a.finalX);var e=Math.floor(a.finalY),f=Blockly.DropDownDiv.DIV_;f.style.left=b+\"px\";f.style.top=c+\"px\";f.style.display=\"block\";f.style.opacity=1;f.style.transform=\"translate(\"+(d-b)+\"px,\"+(e-c)+\"px)\";return a.arrowAtTop};\nBlockly.DropDownDiv.repositionForWindowResize=function(){if(Blockly.DropDownDiv.owner_){var a=Blockly.DropDownDiv.owner_,b=Blockly.DropDownDiv.owner_.getSourceBlock();a=Blockly.DropDownDiv.positionToField_?Blockly.DropDownDiv.getScaledBboxOfField_(a):Blockly.DropDownDiv.getScaledBboxOfBlock_(b);b=a.left+(a.right-a.left)/2;Blockly.DropDownDiv.positionInternal_(b,a.bottom,b,a.top)}else Blockly.DropDownDiv.hide()};Blockly.Grid=function(a,b){this.gridPattern_=a;this.spacing_=b.spacing;this.length_=b.length;this.line2_=(this.line1_=a.firstChild)&&this.line1_.nextSibling;this.snapToGrid_=b.snap};Blockly.Grid.prototype.scale_=1;Blockly.Grid.prototype.dispose=function(){this.gridPattern_=null};Blockly.Grid.prototype.shouldSnap=function(){return this.snapToGrid_};Blockly.Grid.prototype.getSpacing=function(){return this.spacing_};Blockly.Grid.prototype.getPatternId=function(){return this.gridPattern_.id};\nBlockly.Grid.prototype.update=function(a){this.scale_=a;var b=this.spacing_*a||100;this.gridPattern_.setAttribute(\"width\",b);this.gridPattern_.setAttribute(\"height\",b);b=Math.floor(this.spacing_/2)+.5;var c=b-this.length_/2,d=b+this.length_/2;b*=a;c*=a;d*=a;this.setLineAttributes_(this.line1_,a,c,d,b,b);this.setLineAttributes_(this.line2_,a,b,b,c,d)};\nBlockly.Grid.prototype.setLineAttributes_=function(a,b,c,d,e,f){a&&(a.setAttribute(\"stroke-width\",b),a.setAttribute(\"x1\",c),a.setAttribute(\"y1\",e),a.setAttribute(\"x2\",d),a.setAttribute(\"y2\",f))};Blockly.Grid.prototype.moveTo=function(a,b){this.gridPattern_.setAttribute(\"x\",a);this.gridPattern_.setAttribute(\"y\",b);(Blockly.utils.userAgent.IE||Blockly.utils.userAgent.EDGE)&&this.update(this.scale_)};\nBlockly.Grid.createDom=function(a,b,c){a=Blockly.utils.dom.createSvgElement(\"pattern\",{id:\"blocklyGridPattern\"+a,patternUnits:\"userSpaceOnUse\"},c);0<b.length&&0<b.spacing?(Blockly.utils.dom.createSvgElement(\"line\",{stroke:b.colour},a),1<b.length&&Blockly.utils.dom.createSvgElement(\"line\",{stroke:b.colour},a)):Blockly.utils.dom.createSvgElement(\"line\",{},a);return a};Blockly.Theme=function(a,b,c,d){this.name=a;this.blockStyles=b||Object.create(null);this.categoryStyles=c||Object.create(null);this.componentStyles=d||Object.create(null);this.fontStyle=Object.create(null);this.startHats=null};Blockly.Theme.prototype.getClassName=function(){return this.name+\"-theme\"};Blockly.Theme.prototype.setBlockStyle=function(a,b){this.blockStyles[a]=b};Blockly.Theme.prototype.setCategoryStyle=function(a,b){this.categoryStyles[a]=b};\nBlockly.Theme.prototype.getComponentStyle=function(a){return(a=this.componentStyles[a])&&\"string\"==typeof propertyValue&&this.getComponentStyle(a)?this.getComponentStyle(a):a?String(a):null};Blockly.Theme.prototype.setComponentStyle=function(a,b){this.componentStyles[a]=b};Blockly.Theme.prototype.setFontStyle=function(a){this.fontStyle=a};Blockly.Theme.prototype.setStartHats=function(a){this.startHats=a};\nBlockly.Theme.defineTheme=function(a,b){var c=new Blockly.Theme(a),d=b.base;d&&d instanceof Blockly.Theme&&(Blockly.utils.object.deepMerge(c,d),c.name=a);Blockly.utils.object.deepMerge(c.blockStyles,b.blockStyles);Blockly.utils.object.deepMerge(c.categoryStyles,b.categoryStyles);Blockly.utils.object.deepMerge(c.componentStyles,b.componentStyles);Blockly.utils.object.deepMerge(c.fontStyle,b.fontStyle);null!=b.startHats&&(c.startHats=b.startHats);return c};Blockly.Themes={};Blockly.Themes.Classic={};Blockly.Themes.Classic.defaultBlockStyles={colour_blocks:{colourPrimary:\"20\"},list_blocks:{colourPrimary:\"260\"},logic_blocks:{colourPrimary:\"210\"},loop_blocks:{colourPrimary:\"120\"},math_blocks:{colourPrimary:\"230\"},procedure_blocks:{colourPrimary:\"290\"},text_blocks:{colourPrimary:\"160\"},variable_blocks:{colourPrimary:\"330\"},variable_dynamic_blocks:{colourPrimary:\"310\"},hat_blocks:{colourPrimary:\"330\",hat:\"cap\"}};\nBlockly.Themes.Classic.categoryStyles={colour_category:{colour:\"20\"},list_category:{colour:\"260\"},logic_category:{colour:\"210\"},loop_category:{colour:\"120\"},math_category:{colour:\"230\"},procedure_category:{colour:\"290\"},text_category:{colour:\"160\"},variable_category:{colour:\"330\"},variable_dynamic_category:{colour:\"310\"}};Blockly.Themes.Classic=new Blockly.Theme(\"classic\",Blockly.Themes.Classic.defaultBlockStyles,Blockly.Themes.Classic.categoryStyles);Blockly.utils.KeyCodes={WIN_KEY_FF_LINUX:0,MAC_ENTER:3,BACKSPACE:8,TAB:9,NUM_CENTER:12,ENTER:13,SHIFT:16,CTRL:17,ALT:18,PAUSE:19,CAPS_LOCK:20,ESC:27,SPACE:32,PAGE_UP:33,PAGE_DOWN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,PLUS_SIGN:43,PRINT_SCREEN:44,INSERT:45,DELETE:46,ZERO:48,ONE:49,TWO:50,THREE:51,FOUR:52,FIVE:53,SIX:54,SEVEN:55,EIGHT:56,NINE:57,FF_SEMICOLON:59,FF_EQUALS:61,FF_DASH:173,FF_HASH:163,QUESTION_MARK:63,AT_SIGN:64,A:65,B:66,C:67,D:68,E:69,F:70,G:71,H:72,I:73,J:74,K:75,L:76,M:77,\nN:78,O:79,P:80,Q:81,R:82,S:83,T:84,U:85,V:86,W:87,X:88,Y:89,Z:90,META:91,WIN_KEY_RIGHT:92,CONTEXT_MENU:93,NUM_ZERO:96,NUM_ONE:97,NUM_TWO:98,NUM_THREE:99,NUM_FOUR:100,NUM_FIVE:101,NUM_SIX:102,NUM_SEVEN:103,NUM_EIGHT:104,NUM_NINE:105,NUM_MULTIPLY:106,NUM_PLUS:107,NUM_MINUS:109,NUM_PERIOD:110,NUM_DIVISION:111,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUMLOCK:144,SCROLL_LOCK:145,FIRST_MEDIA_KEY:166,LAST_MEDIA_KEY:183,SEMICOLON:186,DASH:189,EQUALS:187,COMMA:188,\nPERIOD:190,SLASH:191,APOSTROPHE:192,TILDE:192,SINGLE_QUOTE:222,OPEN_SQUARE_BRACKET:219,BACKSLASH:220,CLOSE_SQUARE_BRACKET:221,WIN_KEY:224,MAC_FF_META:224,MAC_WK_CMD_LEFT:91,MAC_WK_CMD_RIGHT:93,WIN_IME:229,VK_NONAME:252,PHANTOM:255};Blockly.user={};Blockly.user.keyMap={};Blockly.user.keyMap.map_={};Blockly.user.keyMap.modifierKeys={SHIFT:\"Shift\",CONTROL:\"Control\",ALT:\"Alt\",META:\"Meta\"};Blockly.user.keyMap.setActionForKey=function(a,b){var c=Blockly.user.keyMap.getKeyByAction(b);c&&delete Blockly.user.keyMap.map_[c];Blockly.user.keyMap.map_[a]=b};Blockly.user.keyMap.setKeyMap=function(a){Blockly.user.keyMap.map_=a};Blockly.user.keyMap.getKeyMap=function(){var a={};Blockly.utils.object.mixin(a,Blockly.user.keyMap.map_);return a};\nBlockly.user.keyMap.getActionByKeyCode=function(a){return Blockly.user.keyMap.map_[a]};Blockly.user.keyMap.getKeyByAction=function(a){for(var b=Object.keys(Blockly.user.keyMap.map_),c=0,d;d=b[c];c++)if(Blockly.user.keyMap.map_[d].name===a.name)return d;return null};Blockly.user.keyMap.serializeKeyEvent=function(a){for(var b=Blockly.utils.object.values(Blockly.user.keyMap.modifierKeys),c=\"\",d=0,e;e=b[d];d++)a.getModifierState(e)&&(c+=e);return c+=a.keyCode};\nBlockly.user.keyMap.checkModifiers_=function(a,b){for(var c=0,d;d=a[c];c++)if(0>b.indexOf(d))throw Error(d+\" is not a valid modifier key.\");};Blockly.user.keyMap.createSerializedKey=function(a,b){var c=\"\",d=Blockly.utils.object.values(Blockly.user.keyMap.modifierKeys);Blockly.user.keyMap.checkModifiers_(b,d);for(var e=0,f;f=d[e];e++)-1<b.indexOf(f)&&(c+=f);return c+a};\nBlockly.user.keyMap.createDefaultKeyMap=function(){var a={},b=Blockly.user.keyMap.createSerializedKey(Blockly.utils.KeyCodes.K,[Blockly.user.keyMap.modifierKeys.CONTROL,Blockly.user.keyMap.modifierKeys.SHIFT]),c=Blockly.user.keyMap.createSerializedKey(Blockly.utils.KeyCodes.W,[Blockly.user.keyMap.modifierKeys.SHIFT]),d=Blockly.user.keyMap.createSerializedKey(Blockly.utils.KeyCodes.A,[Blockly.user.keyMap.modifierKeys.SHIFT]),e=Blockly.user.keyMap.createSerializedKey(Blockly.utils.KeyCodes.S,[Blockly.user.keyMap.modifierKeys.SHIFT]),\nf=Blockly.user.keyMap.createSerializedKey(Blockly.utils.KeyCodes.D,[Blockly.user.keyMap.modifierKeys.SHIFT]);a[Blockly.utils.KeyCodes.W]=Blockly.navigation.ACTION_PREVIOUS;a[Blockly.utils.KeyCodes.A]=Blockly.navigation.ACTION_OUT;a[Blockly.utils.KeyCodes.S]=Blockly.navigation.ACTION_NEXT;a[Blockly.utils.KeyCodes.D]=Blockly.navigation.ACTION_IN;a[Blockly.utils.KeyCodes.I]=Blockly.navigation.ACTION_INSERT;a[Blockly.utils.KeyCodes.ENTER]=Blockly.navigation.ACTION_MARK;a[Blockly.utils.KeyCodes.X]=Blockly.navigation.ACTION_DISCONNECT;\na[Blockly.utils.KeyCodes.T]=Blockly.navigation.ACTION_TOOLBOX;a[Blockly.utils.KeyCodes.E]=Blockly.navigation.ACTION_EXIT;a[Blockly.utils.KeyCodes.ESC]=Blockly.navigation.ACTION_EXIT;a[b]=Blockly.navigation.ACTION_TOGGLE_KEYBOARD_NAV;a[c]=Blockly.navigation.ACTION_MOVE_WS_CURSOR_UP;a[d]=Blockly.navigation.ACTION_MOVE_WS_CURSOR_LEFT;a[e]=Blockly.navigation.ACTION_MOVE_WS_CURSOR_DOWN;a[f]=Blockly.navigation.ACTION_MOVE_WS_CURSOR_RIGHT;return a};Blockly.utils.xml={};Blockly.utils.xml.NAME_SPACE=\"https://developers.google.com/blockly/xml\";Blockly.utils.xml.document=function(){return document};Blockly.utils.xml.createElement=function(a){return Blockly.utils.xml.document().createElementNS(Blockly.utils.xml.NAME_SPACE,a)};Blockly.utils.xml.createTextNode=function(a){return Blockly.utils.xml.document().createTextNode(a)};Blockly.utils.xml.textToDomDocument=function(a){return(new DOMParser).parseFromString(a,\"text/xml\")};\nBlockly.utils.xml.domToText=function(a){return(new XMLSerializer).serializeToString(a)};Blockly.Events.BlockBase=function(a){Blockly.Events.BlockBase.superClass_.constructor.call(this);this.blockId=a.id;this.workspaceId=a.workspace.id};Blockly.utils.object.inherits(Blockly.Events.BlockBase,Blockly.Events.Abstract);Blockly.Events.BlockBase.prototype.toJson=function(){var a=Blockly.Events.BlockBase.superClass_.toJson.call(this);a.blockId=this.blockId;return a};\nBlockly.Events.BlockBase.prototype.fromJson=function(a){Blockly.Events.BlockBase.superClass_.fromJson.call(this,a);this.blockId=a.blockId};Blockly.Events.Change=function(a,b,c,d,e){a&&(Blockly.Events.Change.superClass_.constructor.call(this,a),this.element=b,this.name=c,this.oldValue=d,this.newValue=e)};Blockly.utils.object.inherits(Blockly.Events.Change,Blockly.Events.BlockBase);Blockly.Events.BlockChange=Blockly.Events.Change;Blockly.Events.Change.prototype.type=Blockly.Events.CHANGE;\nBlockly.Events.Change.prototype.toJson=function(){var a=Blockly.Events.Change.superClass_.toJson.call(this);a.element=this.element;this.name&&(a.name=this.name);a.newValue=this.newValue;return a};Blockly.Events.Change.prototype.fromJson=function(a){Blockly.Events.Change.superClass_.fromJson.call(this,a);this.element=a.element;this.name=a.name;this.newValue=a.newValue};Blockly.Events.Change.prototype.isNull=function(){return this.oldValue==this.newValue};\nBlockly.Events.Change.prototype.run=function(a){var b=this.getEventWorkspace_().getBlockById(this.blockId);if(b)switch(b.mutator&&b.mutator.setVisible(!1),a=a?this.newValue:this.oldValue,this.element){case \"field\":(b=b.getField(this.name))?b.setValue(a):console.warn(\"Can't set non-existent field: \"+this.name);break;case \"comment\":b.setCommentText(a||null);break;case \"collapsed\":b.setCollapsed(!!a);break;case \"disabled\":b.setEnabled(!a);break;case \"inline\":b.setInputsInline(!!a);break;case \"mutation\":var c=\n\"\";b.mutationToDom&&(c=(c=b.mutationToDom())&&Blockly.Xml.domToText(c));if(b.domToMutation){var d=Blockly.Xml.textToDom(a||\"<mutation/>\");b.domToMutation(d)}Blockly.Events.fire(new Blockly.Events.Change(b,\"mutation\",null,c,a));break;default:console.warn(\"Unknown change type: \"+this.element)}else console.warn(\"Can't change non-existent block: \"+this.blockId)};\nBlockly.Events.Create=function(a){a&&(Blockly.Events.Create.superClass_.constructor.call(this,a),this.xml=a.workspace.rendered?Blockly.Xml.blockToDomWithXY(a):Blockly.Xml.blockToDom(a),this.ids=Blockly.Events.getDescendantIds(a))};Blockly.utils.object.inherits(Blockly.Events.Create,Blockly.Events.BlockBase);Blockly.Events.BlockCreate=Blockly.Events.Create;Blockly.Events.Create.prototype.type=Blockly.Events.CREATE;\nBlockly.Events.Create.prototype.toJson=function(){var a=Blockly.Events.Create.superClass_.toJson.call(this);a.xml=Blockly.Xml.domToText(this.xml);a.ids=this.ids;return a};Blockly.Events.Create.prototype.fromJson=function(a){Blockly.Events.Create.superClass_.fromJson.call(this,a);this.xml=Blockly.Xml.textToDom(a.xml);this.ids=a.ids};\nBlockly.Events.Create.prototype.run=function(a){var b=this.getEventWorkspace_();if(a)a=Blockly.utils.xml.createElement(\"xml\"),a.appendChild(this.xml),Blockly.Xml.domToWorkspace(a,b);else{a=0;for(var c;c=this.ids[a];a++){var d=b.getBlockById(c);d?d.dispose(!1):c==this.blockId&&console.warn(\"Can't uncreate non-existent block: \"+c)}}};\nBlockly.Events.Delete=function(a){if(a){if(a.getParent())throw Error(\"Connected blocks cannot be deleted.\");Blockly.Events.Delete.superClass_.constructor.call(this,a);this.oldXml=a.workspace.rendered?Blockly.Xml.blockToDomWithXY(a):Blockly.Xml.blockToDom(a);this.ids=Blockly.Events.getDescendantIds(a)}};Blockly.utils.object.inherits(Blockly.Events.Delete,Blockly.Events.BlockBase);Blockly.Events.BlockDelete=Blockly.Events.Delete;Blockly.Events.Delete.prototype.type=Blockly.Events.DELETE;\nBlockly.Events.Delete.prototype.toJson=function(){var a=Blockly.Events.Delete.superClass_.toJson.call(this);a.ids=this.ids;return a};Blockly.Events.Delete.prototype.fromJson=function(a){Blockly.Events.Delete.superClass_.fromJson.call(this,a);this.ids=a.ids};\nBlockly.Events.Delete.prototype.run=function(a){var b=this.getEventWorkspace_();if(a){a=0;for(var c;c=this.ids[a];a++){var d=b.getBlockById(c);d?d.dispose(!1):c==this.blockId&&console.warn(\"Can't delete non-existent block: \"+c)}}else a=Blockly.utils.xml.createElement(\"xml\"),a.appendChild(this.oldXml),Blockly.Xml.domToWorkspace(a,b)};\nBlockly.Events.Move=function(a){a&&(Blockly.Events.Move.superClass_.constructor.call(this,a),a=this.currentLocation_(),this.oldParentId=a.parentId,this.oldInputName=a.inputName,this.oldCoordinate=a.coordinate)};Blockly.utils.object.inherits(Blockly.Events.Move,Blockly.Events.BlockBase);Blockly.Events.BlockMove=Blockly.Events.Move;Blockly.Events.Move.prototype.type=Blockly.Events.MOVE;\nBlockly.Events.Move.prototype.toJson=function(){var a=Blockly.Events.Move.superClass_.toJson.call(this);this.newParentId&&(a.newParentId=this.newParentId);this.newInputName&&(a.newInputName=this.newInputName);this.newCoordinate&&(a.newCoordinate=Math.round(this.newCoordinate.x)+\",\"+Math.round(this.newCoordinate.y));return a};\nBlockly.Events.Move.prototype.fromJson=function(a){Blockly.Events.Move.superClass_.fromJson.call(this,a);this.newParentId=a.newParentId;this.newInputName=a.newInputName;a.newCoordinate&&(a=a.newCoordinate.split(\",\"),this.newCoordinate=new Blockly.utils.Coordinate(Number(a[0]),Number(a[1])))};Blockly.Events.Move.prototype.recordNew=function(){var a=this.currentLocation_();this.newParentId=a.parentId;this.newInputName=a.inputName;this.newCoordinate=a.coordinate};\nBlockly.Events.Move.prototype.currentLocation_=function(){var a=this.getEventWorkspace_().getBlockById(this.blockId),b={},c=a.getParent();if(c){if(b.parentId=c.id,a=c.getInputWithBlock(a))b.inputName=a.name}else b.coordinate=a.getRelativeToSurfaceXY();return b};Blockly.Events.Move.prototype.isNull=function(){return this.oldParentId==this.newParentId&&this.oldInputName==this.newInputName&&Blockly.utils.Coordinate.equals(this.oldCoordinate,this.newCoordinate)};\nBlockly.Events.Move.prototype.run=function(a){var b=this.getEventWorkspace_(),c=b.getBlockById(this.blockId);if(c){var d=a?this.newParentId:this.oldParentId,e=a?this.newInputName:this.oldInputName;a=a?this.newCoordinate:this.oldCoordinate;var f=null;if(d&&(f=b.getBlockById(d),!f)){console.warn(\"Can't connect to non-existent block: \"+d);return}c.getParent()&&c.unplug();if(a)e=c.getRelativeToSurfaceXY(),c.moveBy(a.x-e.x,a.y-e.y);else{c=c.outputConnection||c.previousConnection;if(e){if(b=f.getInput(e))var g=\nb.connection}else c.type==Blockly.PREVIOUS_STATEMENT&&(g=f.nextConnection);g?c.connect(g):console.warn(\"Can't connect to non-existent input: \"+e)}}else console.warn(\"Can't move non-existent block: \"+this.blockId)};Blockly.Events.FinishedLoading=function(a){this.workspaceId=a.id;this.group=Blockly.Events.getGroup();this.recordUndo=!1};Blockly.utils.object.inherits(Blockly.Events.FinishedLoading,Blockly.Events.Ui);Blockly.Events.FinishedLoading.prototype.type=Blockly.Events.FINISHED_LOADING;Blockly.Events.FinishedLoading.prototype.toJson=function(){var a={type:this.type};this.group&&(a.group=this.group);this.workspaceId&&(a.workspaceId=this.workspaceId);return a};\nBlockly.Events.FinishedLoading.prototype.fromJson=function(a){this.workspaceId=a.workspaceId;this.group=a.group};Blockly.Events.VarBase=function(a){Blockly.Events.VarBase.superClass_.constructor.call(this);this.varId=a.getId();this.workspaceId=a.workspace.id};Blockly.utils.object.inherits(Blockly.Events.VarBase,Blockly.Events.Abstract);Blockly.Events.VarBase.prototype.toJson=function(){var a=Blockly.Events.VarBase.superClass_.toJson.call(this);a.varId=this.varId;return a};Blockly.Events.VarBase.prototype.fromJson=function(a){Blockly.Events.VarBase.superClass_.toJson.call(this);this.varId=a.varId};\nBlockly.Events.VarCreate=function(a){a&&(Blockly.Events.VarCreate.superClass_.constructor.call(this,a),this.varType=a.type,this.varName=a.name)};Blockly.utils.object.inherits(Blockly.Events.VarCreate,Blockly.Events.VarBase);Blockly.Events.VarCreate.prototype.type=Blockly.Events.VAR_CREATE;Blockly.Events.VarCreate.prototype.toJson=function(){var a=Blockly.Events.VarCreate.superClass_.toJson.call(this);a.varType=this.varType;a.varName=this.varName;return a};\nBlockly.Events.VarCreate.prototype.fromJson=function(a){Blockly.Events.VarCreate.superClass_.fromJson.call(this,a);this.varType=a.varType;this.varName=a.varName};Blockly.Events.VarCreate.prototype.run=function(a){var b=this.getEventWorkspace_();a?b.createVariable(this.varName,this.varType,this.varId):b.deleteVariableById(this.varId)};Blockly.Events.VarDelete=function(a){a&&(Blockly.Events.VarDelete.superClass_.constructor.call(this,a),this.varType=a.type,this.varName=a.name)};\nBlockly.utils.object.inherits(Blockly.Events.VarDelete,Blockly.Events.VarBase);Blockly.Events.VarDelete.prototype.type=Blockly.Events.VAR_DELETE;Blockly.Events.VarDelete.prototype.toJson=function(){var a=Blockly.Events.VarDelete.superClass_.toJson.call(this);a.varType=this.varType;a.varName=this.varName;return a};Blockly.Events.VarDelete.prototype.fromJson=function(a){Blockly.Events.VarDelete.superClass_.fromJson.call(this,a);this.varType=a.varType;this.varName=a.varName};\nBlockly.Events.VarDelete.prototype.run=function(a){var b=this.getEventWorkspace_();a?b.deleteVariableById(this.varId):b.createVariable(this.varName,this.varType,this.varId)};Blockly.Events.VarRename=function(a,b){a&&(Blockly.Events.VarRename.superClass_.constructor.call(this,a),this.oldName=a.name,this.newName=b)};Blockly.utils.object.inherits(Blockly.Events.VarRename,Blockly.Events.VarBase);Blockly.Events.VarRename.prototype.type=Blockly.Events.VAR_RENAME;\nBlockly.Events.VarRename.prototype.toJson=function(){var a=Blockly.Events.VarRename.superClass_.toJson.call(this);a.oldName=this.oldName;a.newName=this.newName;return a};Blockly.Events.VarRename.prototype.fromJson=function(a){Blockly.Events.VarRename.superClass_.fromJson.call(this,a);this.oldName=a.oldName;this.newName=a.newName};Blockly.Events.VarRename.prototype.run=function(a){var b=this.getEventWorkspace_();a?b.renameVariableById(this.varId,this.newName):b.renameVariableById(this.varId,this.oldName)};Blockly.Xml={};Blockly.Xml.workspaceToDom=function(a,b){var c=Blockly.utils.xml.createElement(\"xml\"),d=Blockly.Xml.variablesToDom(Blockly.Variables.allUsedVarModels(a));d.hasChildNodes()&&c.appendChild(d);var e=a.getTopComments(!0);d=0;for(var f;f=e[d];d++)c.appendChild(f.toXmlWithXY(b));a=a.getTopBlocks(!0);for(d=0;e=a[d];d++)c.appendChild(Blockly.Xml.blockToDomWithXY(e,b));return c};\nBlockly.Xml.variablesToDom=function(a){for(var b=Blockly.utils.xml.createElement(\"variables\"),c=0,d;d=a[c];c++){var e=Blockly.utils.xml.createElement(\"variable\");e.appendChild(Blockly.utils.xml.createTextNode(d.name));d.type&&e.setAttribute(\"type\",d.type);e.id=d.getId();b.appendChild(e)}return b};\nBlockly.Xml.blockToDomWithXY=function(a,b){var c;a.workspace.RTL&&(c=a.workspace.getWidth());b=Blockly.Xml.blockToDom(a,b);var d=a.getRelativeToSurfaceXY();b.setAttribute(\"x\",Math.round(a.workspace.RTL?c-d.x:d.x));b.setAttribute(\"y\",Math.round(d.y));return b};Blockly.Xml.fieldToDom_=function(a){if(a.isSerializable()){var b=Blockly.utils.xml.createElement(\"field\");b.setAttribute(\"name\",a.name||\"\");return a.toXml(b)}return null};\nBlockly.Xml.allFieldsToDom_=function(a,b){for(var c=0,d;d=a.inputList[c];c++)for(var e=0,f;f=d.fieldRow[e];e++)(f=Blockly.Xml.fieldToDom_(f))&&b.appendChild(f)};\nBlockly.Xml.blockToDom=function(a,b){var c=Blockly.utils.xml.createElement(a.isShadow()?\"shadow\":\"block\");c.setAttribute(\"type\",a.type);b||c.setAttribute(\"id\",a.id);if(a.mutationToDom){var d=a.mutationToDom();d&&(d.hasChildNodes()||d.hasAttributes())&&c.appendChild(d)}Blockly.Xml.allFieldsToDom_(a,c);if(d=a.getCommentText()){var e=a.commentModel.size,f=a.commentModel.pinned,g=Blockly.utils.xml.createElement(\"comment\");g.appendChild(Blockly.utils.xml.createTextNode(d));g.setAttribute(\"pinned\",f);g.setAttribute(\"h\",\ne.height);g.setAttribute(\"w\",e.width);c.appendChild(g)}a.data&&(d=Blockly.utils.xml.createElement(\"data\"),d.appendChild(Blockly.utils.xml.createTextNode(a.data)),c.appendChild(d));for(e=0;f=a.inputList[e];e++){var h;g=!0;if(f.type!=Blockly.DUMMY_INPUT){var k=f.connection.targetBlock();f.type==Blockly.INPUT_VALUE?h=Blockly.utils.xml.createElement(\"value\"):f.type==Blockly.NEXT_STATEMENT&&(h=Blockly.utils.xml.createElement(\"statement\"));d=f.connection.getShadowDom();!d||k&&k.isShadow()||h.appendChild(Blockly.Xml.cloneShadow_(d,\nb));k&&(h.appendChild(Blockly.Xml.blockToDom(k,b)),g=!1);h.setAttribute(\"name\",f.name);g||c.appendChild(h)}}void 0!=a.inputsInline&&a.inputsInline!=a.inputsInlineDefault&&c.setAttribute(\"inline\",a.inputsInline);a.isCollapsed()&&c.setAttribute(\"collapsed\",!0);a.isEnabled()||c.setAttribute(\"disabled\",!0);a.isDeletable()||a.isShadow()||c.setAttribute(\"deletable\",!1);a.isMovable()||a.isShadow()||c.setAttribute(\"movable\",!1);a.isEditable()||c.setAttribute(\"editable\",!1);if(e=a.getNextBlock())h=Blockly.utils.xml.createElement(\"next\"),\nh.appendChild(Blockly.Xml.blockToDom(e,b)),c.appendChild(h);d=a.nextConnection&&a.nextConnection.getShadowDom();!d||e&&e.isShadow()||h.appendChild(Blockly.Xml.cloneShadow_(d,b));return c};\nBlockly.Xml.cloneShadow_=function(a,b){for(var c=a=a.cloneNode(!0),d;c;)if(b&&\"shadow\"==c.nodeName&&c.removeAttribute(\"id\"),c.firstChild)c=c.firstChild;else{for(;c&&!c.nextSibling;)d=c,c=c.parentNode,d.nodeType==Blockly.utils.dom.Node.TEXT_NODE&&\"\"==d.data.trim()&&c.firstChild!=d&&Blockly.utils.dom.removeNode(d);c&&(d=c,c=c.nextSibling,d.nodeType==Blockly.utils.dom.Node.TEXT_NODE&&\"\"==d.data.trim()&&Blockly.utils.dom.removeNode(d))}return a};\nBlockly.Xml.domToText=function(a){a=Blockly.utils.xml.domToText(a);var b=/(<[^/](?:[^>]*[^/])?>[^<]*)\\n([^<]*<\\/)/;do{var c=a;a=a.replace(b,\"$1&#10;$2\")}while(a!=c);return a.replace(/<(\\w+)([^<]*)\\/>/g,\"<$1$2></$1>\")};\nBlockly.Xml.domToPrettyText=function(a){a=Blockly.Xml.domToText(a).split(\"<\");for(var b=\"\",c=1;c<a.length;c++){var d=a[c];\"/\"==d[0]&&(b=b.substring(2));a[c]=b+\"<\"+d;\"/\"!=d[0]&&\"/>\"!=d.slice(-2)&&(b+=\"  \")}a=a.join(\"\\n\");a=a.replace(/(<(\\w+)\\b[^>]*>[^\\n]*)\\n *<\\/\\2>/g,\"$1</$2>\");return a.replace(/^\\n/,\"\")};\nBlockly.Xml.textToDom=function(a){var b=Blockly.utils.xml.textToDomDocument(a);if(!b||!b.documentElement||b.getElementsByTagName(\"parsererror\").length)throw Error(\"textToDom was unable to parse: \"+a);return b.documentElement};Blockly.Xml.clearWorkspaceAndLoadFromXml=function(a,b){b.setResizesEnabled(!1);b.clear();a=Blockly.Xml.domToWorkspace(a,b);b.setResizesEnabled(!0);return a};\nBlockly.Xml.domToWorkspace=function(a,b){if(a instanceof Blockly.Workspace){var c=a;a=b;b=c;console.warn(\"Deprecated call to Blockly.Xml.domToWorkspace, swap the arguments.\")}var d;b.RTL&&(d=b.getWidth());c=[];Blockly.utils.dom.startTextWidthCache();var e=Blockly.Events.getGroup();e||Blockly.Events.setGroup(!0);b.setResizesEnabled&&b.setResizesEnabled(!1);var f=!0;try{for(var g=0,h;h=a.childNodes[g];g++){var k=h.nodeName.toLowerCase(),l=h;if(\"block\"==k||\"shadow\"==k&&!Blockly.Events.recordUndo){var m=\nBlockly.Xml.domToBlock(l,b);c.push(m.id);var n=l.hasAttribute(\"x\")?parseInt(l.getAttribute(\"x\"),10):10,p=l.hasAttribute(\"y\")?parseInt(l.getAttribute(\"y\"),10):10;isNaN(n)||isNaN(p)||m.moveBy(b.RTL?d-n:n,p);f=!1}else{if(\"shadow\"==k)throw TypeError(\"Shadow block cannot be a top-level block.\");if(\"comment\"==k)b.rendered?Blockly.WorkspaceCommentSvg?Blockly.WorkspaceCommentSvg.fromXml(l,b,d):console.warn(\"Missing require for Blockly.WorkspaceCommentSvg, ignoring workspace comment.\"):Blockly.WorkspaceComment?\nBlockly.WorkspaceComment.fromXml(l,b):console.warn(\"Missing require for Blockly.WorkspaceComment, ignoring workspace comment.\");else if(\"variables\"==k){if(f)Blockly.Xml.domToVariables(l,b);else throw Error(\"'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.\");f=!1}}}}finally{e||Blockly.Events.setGroup(!1),Blockly.utils.dom.stopTextWidthCache()}b.setResizesEnabled&&b.setResizesEnabled(!0);Blockly.Events.fire(new Blockly.Events.FinishedLoading(b));\nreturn c};Blockly.Xml.appendDomToWorkspace=function(a,b){var c;b.hasOwnProperty(\"scale\")&&(c=b.getBlocksBoundingBox());a=Blockly.Xml.domToWorkspace(a,b);if(c&&c.top!=c.bottom){var d=c.bottom;var e=b.RTL?c.right:c.left;var f=Infinity,g=-Infinity,h=Infinity;for(c=0;c<a.length;c++){var k=b.getBlockById(a[c]).getRelativeToSurfaceXY();k.y<h&&(h=k.y);k.x<f&&(f=k.x);k.x>g&&(g=k.x)}d=d-h+10;e=b.RTL?e-g:e-f;for(c=0;c<a.length;c++)b.getBlockById(a[c]).moveBy(e,d)}return a};\nBlockly.Xml.domToBlock=function(a,b){if(a instanceof Blockly.Workspace){var c=a;a=b;b=c;console.warn(\"Deprecated call to Blockly.Xml.domToBlock, swap the arguments.\")}Blockly.Events.disable();c=b.getAllVariables();try{var d=Blockly.Xml.domToBlockHeadless_(a,b),e=d.getDescendants(!1);if(b.rendered){d.setConnectionTracking(!1);for(var f=e.length-1;0<=f;f--)e[f].initSvg();for(f=e.length-1;0<=f;f--)e[f].render(!1);setTimeout(function(){d.disposed||d.setConnectionTracking(!0)},1);d.updateDisabled();b.resizeContents()}else for(f=\ne.length-1;0<=f;f--)e[f].initModel()}finally{Blockly.Events.enable()}if(Blockly.Events.isEnabled()){a=Blockly.Variables.getAddedVariables(b,c);for(f=0;f<a.length;f++)Blockly.Events.fire(new Blockly.Events.VarCreate(a[f]));Blockly.Events.fire(new Blockly.Events.BlockCreate(d))}return d};\nBlockly.Xml.domToVariables=function(a,b){for(var c=0,d;d=a.childNodes[c];c++)if(d.nodeType==Blockly.utils.dom.Node.ELEMENT_NODE){var e=d.getAttribute(\"type\"),f=d.getAttribute(\"id\");b.createVariable(d.textContent,e,f)}};\nBlockly.Xml.domToBlockHeadless_=function(a,b){var c=null,d=a.getAttribute(\"type\");if(!d)throw TypeError(\"Block type unspecified: \"+a.outerHTML);var e=a.getAttribute(\"id\");c=b.newBlock(d,e);var f=null;e=0;for(var g;g=a.childNodes[e];e++)if(g.nodeType!=Blockly.utils.dom.Node.TEXT_NODE){var h=f=null;var k=0;for(var l;l=g.childNodes[k];k++)l.nodeType==Blockly.utils.dom.Node.ELEMENT_NODE&&(\"block\"==l.nodeName.toLowerCase()?f=l:\"shadow\"==l.nodeName.toLowerCase()&&(h=l));!f&&h&&(f=h);l=g.getAttribute(\"name\");\nk=g;switch(g.nodeName.toLowerCase()){case \"mutation\":c.domToMutation&&(c.domToMutation(k),c.initSvg&&c.initSvg());break;case \"comment\":if(!Blockly.Comment){console.warn(\"Missing require for Blockly.Comment, ignoring block comment.\");break}f=k.textContent;h=\"true\"==k.getAttribute(\"pinned\");g=parseInt(k.getAttribute(\"w\"),10);k=parseInt(k.getAttribute(\"h\"),10);c.setCommentText(f);c.commentModel.pinned=h;isNaN(g)||isNaN(k)||(c.commentModel.size=new Blockly.utils.Size(g,k));h&&c.getCommentIcon&&!c.isInFlyout&&\nsetTimeout(function(){c.getCommentIcon().setVisible(!0)},1);break;case \"data\":c.data=g.textContent;break;case \"title\":case \"field\":Blockly.Xml.domToField_(c,l,k);break;case \"value\":case \"statement\":k=c.getInput(l);if(!k){console.warn(\"Ignoring non-existent input \"+l+\" in block \"+d);break}h&&k.connection.setShadowDom(h);if(f)if(f=Blockly.Xml.domToBlockHeadless_(f,b),f.outputConnection)k.connection.connect(f.outputConnection);else if(f.previousConnection)k.connection.connect(f.previousConnection);else throw TypeError(\"Child block does not have output or previous statement.\");\nbreak;case \"next\":h&&c.nextConnection&&c.nextConnection.setShadowDom(h);if(f){if(!c.nextConnection)throw TypeError(\"Next statement does not exist.\");if(c.nextConnection.isConnected())throw TypeError(\"Next statement is already connected.\");f=Blockly.Xml.domToBlockHeadless_(f,b);if(!f.previousConnection)throw TypeError(\"Next block does not have previous statement.\");c.nextConnection.connect(f.previousConnection)}break;default:console.warn(\"Ignoring unknown tag: \"+g.nodeName)}}(e=a.getAttribute(\"inline\"))&&\nc.setInputsInline(\"true\"==e);(e=a.getAttribute(\"disabled\"))&&c.setEnabled(\"true\"!=e&&\"disabled\"!=e);(e=a.getAttribute(\"deletable\"))&&c.setDeletable(\"true\"==e);(e=a.getAttribute(\"movable\"))&&c.setMovable(\"true\"==e);(e=a.getAttribute(\"editable\"))&&c.setEditable(\"true\"==e);(e=a.getAttribute(\"collapsed\"))&&c.setCollapsed(\"true\"==e);if(\"shadow\"==a.nodeName.toLowerCase()){a=c.getChildren(!1);for(e=0;b=a[e];e++)if(!b.isShadow())throw TypeError(\"Shadow block not allowed non-shadow child.\");if(c.getVarModels().length)throw TypeError(\"Shadow blocks cannot have variable references.\");\nc.setShadow(!0)}return c};Blockly.Xml.domToField_=function(a,b,c){var d=a.getField(b);d?d.fromXml(c):console.warn(\"Ignoring non-existent field \"+b+\" in block \"+a.type)};Blockly.Xml.deleteNext=function(a){for(var b=0,c;c=a.childNodes[b];b++)if(\"next\"==c.nodeName.toLowerCase()){a.removeChild(c);break}};Blockly.Options=function(a){var b=!!a.readOnly;if(b)var c=null,d=!1,e=!1,f=!1,g=!1,h=!1,k=!1;else{c=Blockly.Options.parseToolboxTree(a.toolbox||null);d=!(!c||!c.getElementsByTagName(\"category\").length);e=a.trashcan;void 0===e&&(e=d);var l=a.maxTrashcanContents;e?void 0===l&&(l=32):l=0;f=a.collapse;void 0===f&&(f=d);g=a.comments;void 0===g&&(g=d);h=a.disable;void 0===h&&(h=d);k=a.sounds;void 0===k&&(k=!0)}var m=!!a.rtl,n=a.horizontalLayout;void 0===n&&(n=!1);var p=a.toolboxPosition;p=\"end\"!==p;p=n?\np?Blockly.TOOLBOX_AT_TOP:Blockly.TOOLBOX_AT_BOTTOM:p==m?Blockly.TOOLBOX_AT_RIGHT:Blockly.TOOLBOX_AT_LEFT;var q=a.css;void 0===q&&(q=!0);var r=\"https://blockly-demo.appspot.com/static/media/\";a.media?r=a.media:a.path&&(r=a.path+\"media/\");var t=void 0===a.oneBasedIndex?!0:!!a.oneBasedIndex,u=a.keyMap||Blockly.user.keyMap.createDefaultKeyMap(),v=a.renderer||\"geras\";this.RTL=m;this.oneBasedIndex=t;this.collapse=f;this.comments=g;this.disable=h;this.readOnly=b;this.maxBlocks=a.maxBlocks||Infinity;this.maxInstances=\na.maxInstances;this.pathToMedia=r;this.hasCategories=d;this.moveOptions=Blockly.Options.parseMoveOptions(a,d);this.hasScrollbars=this.moveOptions.scrollbars;this.hasTrashcan=e;this.maxTrashcanContents=l;this.hasSounds=k;this.hasCss=q;this.horizontalLayout=n;this.languageTree=c;this.gridOptions=Blockly.Options.parseGridOptions_(a);this.zoomOptions=Blockly.Options.parseZoomOptions_(a);this.toolboxPosition=p;this.theme=Blockly.Options.parseThemeOptions_(a);this.keyMap=u;this.renderer=v;this.rendererOverrides=\na.rendererOverrides;this.gridPattern=void 0;this.parentWorkspace=a.parentWorkspace};Blockly.BlocklyOptions=function(){};Blockly.Options.parseMoveOptions=function(a,b){var c=a.move||{},d={};d.scrollbars=void 0===c.scrollbars&&void 0===a.scrollbars?b:!!c.scrollbars||!!a.scrollbars;d.wheel=d.scrollbars&&void 0!==c.wheel?!!c.wheel:!1;d.drag=d.scrollbars?void 0===c.drag?!0:!!c.drag:!1;return d};\nBlockly.Options.parseZoomOptions_=function(a){a=a.zoom||{};var b={};b.controls=void 0===a.controls?!1:!!a.controls;b.wheel=void 0===a.wheel?!1:!!a.wheel;b.startScale=void 0===a.startScale?1:Number(a.startScale);b.maxScale=void 0===a.maxScale?3:Number(a.maxScale);b.minScale=void 0===a.minScale?.3:Number(a.minScale);b.scaleSpeed=void 0===a.scaleSpeed?1.2:Number(a.scaleSpeed);b.pinch=void 0===a.pinch?b.wheel||b.controls:!!a.pinch;return b};\nBlockly.Options.parseGridOptions_=function(a){a=a.grid||{};var b={};b.spacing=Number(a.spacing)||0;b.colour=a.colour||\"#888\";b.length=void 0===a.length?1:Number(a.length);b.snap=0<b.spacing&&!!a.snap;return b};Blockly.Options.parseThemeOptions_=function(a){a=a.theme||Blockly.Themes.Classic;return a instanceof Blockly.Theme?a:Blockly.Theme.defineTheme(\"builtin\",a)};\nBlockly.Options.parseToolboxTree=function(a){if(a){if(\"string\"!=typeof a&&(Blockly.utils.userAgent.IE&&a.outerHTML?a=a.outerHTML:a instanceof Element||(a=null)),\"string\"==typeof a&&(a=Blockly.Xml.textToDom(a),\"xml\"!=a.nodeName.toLowerCase()))throw TypeError(\"Toolbox should be an <xml> document.\");}else a=null;return a};Blockly.Touch={};Blockly.Touch.TOUCH_ENABLED=\"ontouchstart\"in Blockly.utils.global||!!(Blockly.utils.global.document&&document.documentElement&&\"ontouchstart\"in document.documentElement)||!(!Blockly.utils.global.navigator||!Blockly.utils.global.navigator.maxTouchPoints&&!Blockly.utils.global.navigator.msMaxTouchPoints);Blockly.Touch.touchIdentifier_=null;Blockly.Touch.TOUCH_MAP={};\nBlockly.utils.global.PointerEvent?Blockly.Touch.TOUCH_MAP={mousedown:[\"pointerdown\"],mouseenter:[\"pointerenter\"],mouseleave:[\"pointerleave\"],mousemove:[\"pointermove\"],mouseout:[\"pointerout\"],mouseover:[\"pointerover\"],mouseup:[\"pointerup\",\"pointercancel\"],touchend:[\"pointerup\"],touchcancel:[\"pointercancel\"]}:Blockly.Touch.TOUCH_ENABLED&&(Blockly.Touch.TOUCH_MAP={mousedown:[\"touchstart\"],mousemove:[\"touchmove\"],mouseup:[\"touchend\",\"touchcancel\"]});Blockly.longPid_=0;\nBlockly.longStart=function(a,b){Blockly.longStop_();a.changedTouches&&1!=a.changedTouches.length||(Blockly.longPid_=setTimeout(function(){a.changedTouches&&(a.button=2,a.clientX=a.changedTouches[0].clientX,a.clientY=a.changedTouches[0].clientY);b&&b.handleRightClick(a)},Blockly.LONGPRESS))};Blockly.longStop_=function(){Blockly.longPid_&&(clearTimeout(Blockly.longPid_),Blockly.longPid_=0)};Blockly.Touch.clearTouchIdentifier=function(){Blockly.Touch.touchIdentifier_=null};\nBlockly.Touch.shouldHandleEvent=function(a){return!Blockly.Touch.isMouseOrTouchEvent(a)||Blockly.Touch.checkTouchIdentifier(a)};Blockly.Touch.getTouchIdentifierFromEvent=function(a){return void 0!=a.pointerId?a.pointerId:a.changedTouches&&a.changedTouches[0]&&void 0!==a.changedTouches[0].identifier&&null!==a.changedTouches[0].identifier?a.changedTouches[0].identifier:\"mouse\"};\nBlockly.Touch.checkTouchIdentifier=function(a){var b=Blockly.Touch.getTouchIdentifierFromEvent(a);return void 0!==Blockly.Touch.touchIdentifier_&&null!==Blockly.Touch.touchIdentifier_?Blockly.Touch.touchIdentifier_==b:\"mousedown\"==a.type||\"touchstart\"==a.type||\"pointerdown\"==a.type?(Blockly.Touch.touchIdentifier_=b,!0):!1};Blockly.Touch.setClientFromTouch=function(a){if(Blockly.utils.string.startsWith(a.type,\"touch\")){var b=a.changedTouches[0];a.clientX=b.clientX;a.clientY=b.clientY}};\nBlockly.Touch.isMouseOrTouchEvent=function(a){return Blockly.utils.string.startsWith(a.type,\"touch\")||Blockly.utils.string.startsWith(a.type,\"mouse\")||Blockly.utils.string.startsWith(a.type,\"pointer\")};Blockly.Touch.isTouchEvent=function(a){return Blockly.utils.string.startsWith(a.type,\"touch\")||Blockly.utils.string.startsWith(a.type,\"pointer\")};\nBlockly.Touch.splitEventByTouches=function(a){var b=[];if(a.changedTouches)for(var c=0;c<a.changedTouches.length;c++)b[c]={type:a.type,changedTouches:[a.changedTouches[c]],target:a.target,stopPropagation:function(){a.stopPropagation()},preventDefault:function(){a.preventDefault()}};else b.push(a);return b};Blockly.ScrollbarPair=function(a){this.workspace_=a;this.hScroll=new Blockly.Scrollbar(a,!0,!0,\"blocklyMainWorkspaceScrollbar\");this.vScroll=new Blockly.Scrollbar(a,!1,!0,\"blocklyMainWorkspaceScrollbar\");this.corner_=Blockly.utils.dom.createSvgElement(\"rect\",{height:Blockly.Scrollbar.scrollbarThickness,width:Blockly.Scrollbar.scrollbarThickness,\"class\":\"blocklyScrollbarBackground\"},null);Blockly.utils.dom.insertAfter(this.corner_,a.getBubbleCanvas())};\nBlockly.ScrollbarPair.prototype.oldHostMetrics_=null;Blockly.ScrollbarPair.prototype.dispose=function(){Blockly.utils.dom.removeNode(this.corner_);this.oldHostMetrics_=this.workspace_=this.corner_=null;this.hScroll.dispose();this.hScroll=null;this.vScroll.dispose();this.vScroll=null};\nBlockly.ScrollbarPair.prototype.resize=function(){var a=this.workspace_.getMetrics();if(a){var b=!1,c=!1;this.oldHostMetrics_&&this.oldHostMetrics_.viewWidth==a.viewWidth&&this.oldHostMetrics_.viewHeight==a.viewHeight&&this.oldHostMetrics_.absoluteTop==a.absoluteTop&&this.oldHostMetrics_.absoluteLeft==a.absoluteLeft?(this.oldHostMetrics_&&this.oldHostMetrics_.contentWidth==a.contentWidth&&this.oldHostMetrics_.viewLeft==a.viewLeft&&this.oldHostMetrics_.contentLeft==a.contentLeft||(b=!0),this.oldHostMetrics_&&\nthis.oldHostMetrics_.contentHeight==a.contentHeight&&this.oldHostMetrics_.viewTop==a.viewTop&&this.oldHostMetrics_.contentTop==a.contentTop||(c=!0)):c=b=!0;b&&this.hScroll.resize(a);c&&this.vScroll.resize(a);this.oldHostMetrics_&&this.oldHostMetrics_.viewWidth==a.viewWidth&&this.oldHostMetrics_.absoluteLeft==a.absoluteLeft||this.corner_.setAttribute(\"x\",this.vScroll.position_.x);this.oldHostMetrics_&&this.oldHostMetrics_.viewHeight==a.viewHeight&&this.oldHostMetrics_.absoluteTop==a.absoluteTop||this.corner_.setAttribute(\"y\",\nthis.hScroll.position_.y);this.oldHostMetrics_=a}};Blockly.ScrollbarPair.prototype.set=function(a,b){var c={};a*=this.hScroll.ratio_;b*=this.vScroll.ratio_;var d=this.vScroll.scrollViewSize_;c.x=this.getRatio_(a,this.hScroll.scrollViewSize_);c.y=this.getRatio_(b,d);this.workspace_.setMetrics(c);this.hScroll.setHandlePosition(a);this.vScroll.setHandlePosition(b)};Blockly.ScrollbarPair.prototype.getRatio_=function(a,b){a/=b;return isNaN(a)?0:a};\nBlockly.Scrollbar=function(a,b,c,d){this.workspace_=a;this.pair_=c||!1;this.horizontal_=b;this.oldHostMetrics_=null;this.createDom_(d);this.position_=new Blockly.utils.Coordinate(0,0);a=Blockly.Scrollbar.scrollbarThickness;b?(this.svgBackground_.setAttribute(\"height\",a),this.outerSvg_.setAttribute(\"height\",a),this.svgHandle_.setAttribute(\"height\",a-5),this.svgHandle_.setAttribute(\"y\",2.5),this.lengthAttribute_=\"width\",this.positionAttribute_=\"x\"):(this.svgBackground_.setAttribute(\"width\",a),this.outerSvg_.setAttribute(\"width\",\na),this.svgHandle_.setAttribute(\"width\",a-5),this.svgHandle_.setAttribute(\"x\",2.5),this.lengthAttribute_=\"height\",this.positionAttribute_=\"y\");this.onMouseDownBarWrapper_=Blockly.bindEventWithChecks_(this.svgBackground_,\"mousedown\",this,this.onMouseDownBar_);this.onMouseDownHandleWrapper_=Blockly.bindEventWithChecks_(this.svgHandle_,\"mousedown\",this,this.onMouseDownHandle_)};Blockly.Scrollbar.prototype.origin_=new Blockly.utils.Coordinate(0,0);Blockly.Scrollbar.prototype.startDragMouse_=0;\nBlockly.Scrollbar.prototype.scrollViewSize_=0;Blockly.Scrollbar.prototype.handleLength_=0;Blockly.Scrollbar.prototype.handlePosition_=0;Blockly.Scrollbar.prototype.isVisible_=!0;Blockly.Scrollbar.prototype.containerVisible_=!0;Blockly.Scrollbar.scrollbarThickness=15;Blockly.Touch.TOUCH_ENABLED&&(Blockly.Scrollbar.scrollbarThickness=25);\nBlockly.Scrollbar.metricsAreEquivalent_=function(a,b){return a&&b&&a.viewWidth==b.viewWidth&&a.viewHeight==b.viewHeight&&a.viewLeft==b.viewLeft&&a.viewTop==b.viewTop&&a.absoluteTop==b.absoluteTop&&a.absoluteLeft==b.absoluteLeft&&a.contentWidth==b.contentWidth&&a.contentHeight==b.contentHeight&&a.contentLeft==b.contentLeft&&a.contentTop==b.contentTop?!0:!1};\nBlockly.Scrollbar.prototype.dispose=function(){this.cleanUp_();Blockly.unbindEvent_(this.onMouseDownBarWrapper_);this.onMouseDownBarWrapper_=null;Blockly.unbindEvent_(this.onMouseDownHandleWrapper_);this.onMouseDownHandleWrapper_=null;Blockly.utils.dom.removeNode(this.outerSvg_);this.svgBackground_=this.svgGroup_=this.outerSvg_=null;this.svgHandle_&&(this.workspace_.getThemeManager().unsubscribe(this.svgHandle_),this.svgHandle_=null);this.workspace_=null};\nBlockly.Scrollbar.prototype.setHandleLength_=function(a){this.handleLength_=a;this.svgHandle_.setAttribute(this.lengthAttribute_,this.handleLength_)};Blockly.Scrollbar.prototype.setHandlePosition=function(a){this.handlePosition_=a;this.svgHandle_.setAttribute(this.positionAttribute_,this.handlePosition_)};\nBlockly.Scrollbar.prototype.setScrollViewSize_=function(a){this.scrollViewSize_=a;this.outerSvg_.setAttribute(this.lengthAttribute_,this.scrollViewSize_);this.svgBackground_.setAttribute(this.lengthAttribute_,this.scrollViewSize_)};Blockly.ScrollbarPair.prototype.setContainerVisible=function(a){this.hScroll.setContainerVisible(a);this.vScroll.setContainerVisible(a)};\nBlockly.Scrollbar.prototype.setPosition_=function(a,b){this.position_.x=a;this.position_.y=b;Blockly.utils.dom.setCssTransform(this.outerSvg_,\"translate(\"+(this.position_.x+this.origin_.x)+\"px,\"+(this.position_.y+this.origin_.y)+\"px)\")};Blockly.Scrollbar.prototype.resize=function(a){if(!a&&(a=this.workspace_.getMetrics(),!a))return;Blockly.Scrollbar.metricsAreEquivalent_(a,this.oldHostMetrics_)||(this.oldHostMetrics_=a,this.horizontal_?this.resizeHorizontal_(a):this.resizeVertical_(a),this.onScroll_())};\nBlockly.Scrollbar.prototype.resizeHorizontal_=function(a){this.resizeViewHorizontal(a)};Blockly.Scrollbar.prototype.resizeViewHorizontal=function(a){var b=a.viewWidth-1;this.pair_&&(b-=Blockly.Scrollbar.scrollbarThickness);this.setScrollViewSize_(Math.max(0,b));b=a.absoluteLeft+.5;this.pair_&&this.workspace_.RTL&&(b+=Blockly.Scrollbar.scrollbarThickness);this.setPosition_(b,a.absoluteTop+a.viewHeight-Blockly.Scrollbar.scrollbarThickness-.5);this.resizeContentHorizontal(a)};\nBlockly.Scrollbar.prototype.resizeContentHorizontal=function(a){this.pair_||this.setVisible(this.scrollViewSize_<a.contentWidth);this.ratio_=this.scrollViewSize_/a.contentWidth;if(-Infinity==this.ratio_||Infinity==this.ratio_||isNaN(this.ratio_))this.ratio_=0;this.setHandleLength_(Math.max(0,a.viewWidth*this.ratio_));this.setHandlePosition(this.constrainHandle_((a.viewLeft-a.contentLeft)*this.ratio_))};Blockly.Scrollbar.prototype.resizeVertical_=function(a){this.resizeViewVertical(a)};\nBlockly.Scrollbar.prototype.resizeViewVertical=function(a){var b=a.viewHeight-1;this.pair_&&(b-=Blockly.Scrollbar.scrollbarThickness);this.setScrollViewSize_(Math.max(0,b));b=a.absoluteLeft+.5;this.workspace_.RTL||(b+=a.viewWidth-Blockly.Scrollbar.scrollbarThickness-1);this.setPosition_(b,a.absoluteTop+.5);this.resizeContentVertical(a)};\nBlockly.Scrollbar.prototype.resizeContentVertical=function(a){this.pair_||this.setVisible(this.scrollViewSize_<a.contentHeight);this.ratio_=this.scrollViewSize_/a.contentHeight;if(-Infinity==this.ratio_||Infinity==this.ratio_||isNaN(this.ratio_))this.ratio_=0;this.setHandleLength_(Math.max(0,a.viewHeight*this.ratio_));this.setHandlePosition(this.constrainHandle_((a.viewTop-a.contentTop)*this.ratio_))};\nBlockly.Scrollbar.prototype.createDom_=function(a){var b=\"blocklyScrollbar\"+(this.horizontal_?\"Horizontal\":\"Vertical\");a&&(b+=\" \"+a);this.outerSvg_=Blockly.utils.dom.createSvgElement(\"svg\",{\"class\":b},null);this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},this.outerSvg_);this.svgBackground_=Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyScrollbarBackground\"},this.svgGroup_);a=Math.floor((Blockly.Scrollbar.scrollbarThickness-5)/2);this.svgHandle_=Blockly.utils.dom.createSvgElement(\"rect\",\n{\"class\":\"blocklyScrollbarHandle\",rx:a,ry:a},this.svgGroup_);this.workspace_.getThemeManager().subscribe(this.svgHandle_,\"scrollbarColour\",\"fill\");this.workspace_.getThemeManager().subscribe(this.svgHandle_,\"scrollbarOpacity\",\"fill-opacity\");Blockly.utils.dom.insertAfter(this.outerSvg_,this.workspace_.getParentSvg())};Blockly.Scrollbar.prototype.isVisible=function(){return this.isVisible_};\nBlockly.Scrollbar.prototype.setContainerVisible=function(a){var b=a!=this.containerVisible_;this.containerVisible_=a;b&&this.updateDisplay_()};Blockly.Scrollbar.prototype.setVisible=function(a){var b=a!=this.isVisible();if(this.pair_)throw Error(\"Unable to toggle visibility of paired scrollbars.\");this.isVisible_=a;b&&this.updateDisplay_()};\nBlockly.Scrollbar.prototype.updateDisplay_=function(){this.containerVisible_&&this.isVisible()?this.outerSvg_.setAttribute(\"display\",\"block\"):this.outerSvg_.setAttribute(\"display\",\"none\")};\nBlockly.Scrollbar.prototype.onMouseDownBar_=function(a){this.workspace_.markFocused();Blockly.Touch.clearTouchIdentifier();this.cleanUp_();if(Blockly.utils.isRightButton(a))a.stopPropagation();else{var b=Blockly.utils.mouseToSvg(a,this.workspace_.getParentSvg(),this.workspace_.getInverseScreenCTM());b=this.horizontal_?b.x:b.y;var c=Blockly.utils.getInjectionDivXY_(this.svgHandle_);c=this.horizontal_?c.x:c.y;var d=this.handlePosition_,e=.95*this.handleLength_;b<=c?d-=e:b>=c+this.handleLength_&&(d+=\ne);this.setHandlePosition(this.constrainHandle_(d));this.onScroll_();a.stopPropagation();a.preventDefault()}};\nBlockly.Scrollbar.prototype.onMouseDownHandle_=function(a){this.workspace_.markFocused();this.cleanUp_();Blockly.utils.isRightButton(a)?a.stopPropagation():(this.startDragHandle=this.handlePosition_,this.workspace_.setupDragSurface(),this.startDragMouse_=this.horizontal_?a.clientX:a.clientY,Blockly.Scrollbar.onMouseUpWrapper_=Blockly.bindEventWithChecks_(document,\"mouseup\",this,this.onMouseUpHandle_),Blockly.Scrollbar.onMouseMoveWrapper_=Blockly.bindEventWithChecks_(document,\"mousemove\",this,this.onMouseMoveHandle_),\na.stopPropagation(),a.preventDefault())};Blockly.Scrollbar.prototype.onMouseMoveHandle_=function(a){this.setHandlePosition(this.constrainHandle_(this.startDragHandle+((this.horizontal_?a.clientX:a.clientY)-this.startDragMouse_)));this.onScroll_()};Blockly.Scrollbar.prototype.onMouseUpHandle_=function(){this.workspace_.resetDragSurface();Blockly.Touch.clearTouchIdentifier();this.cleanUp_()};\nBlockly.Scrollbar.prototype.cleanUp_=function(){Blockly.hideChaff(!0);Blockly.Scrollbar.onMouseUpWrapper_&&(Blockly.unbindEvent_(Blockly.Scrollbar.onMouseUpWrapper_),Blockly.Scrollbar.onMouseUpWrapper_=null);Blockly.Scrollbar.onMouseMoveWrapper_&&(Blockly.unbindEvent_(Blockly.Scrollbar.onMouseMoveWrapper_),Blockly.Scrollbar.onMouseMoveWrapper_=null)};\nBlockly.Scrollbar.prototype.constrainHandle_=function(a){return a=0>=a||isNaN(a)||this.scrollViewSize_<this.handleLength_?0:Math.min(a,this.scrollViewSize_-this.handleLength_)};Blockly.Scrollbar.prototype.onScroll_=function(){var a=this.handlePosition_/this.scrollViewSize_;isNaN(a)&&(a=0);var b={};this.horizontal_?b.x=a:b.y=a;this.workspace_.setMetrics(b)};Blockly.Scrollbar.prototype.set=function(a){this.setHandlePosition(this.constrainHandle_(a*this.ratio_));this.onScroll_()};\nBlockly.Scrollbar.prototype.setOrigin=function(a,b){this.origin_=new Blockly.utils.Coordinate(a,b)};Blockly.Tooltip={};Blockly.Tooltip.visible=!1;Blockly.Tooltip.blocked_=!1;Blockly.Tooltip.LIMIT=50;Blockly.Tooltip.mouseOutPid_=0;Blockly.Tooltip.showPid_=0;Blockly.Tooltip.lastX_=0;Blockly.Tooltip.lastY_=0;Blockly.Tooltip.element_=null;Blockly.Tooltip.poisonedElement_=null;Blockly.Tooltip.OFFSET_X=0;Blockly.Tooltip.OFFSET_Y=10;Blockly.Tooltip.RADIUS_OK=10;Blockly.Tooltip.HOVER_MS=750;Blockly.Tooltip.MARGINS=5;Blockly.Tooltip.DIV=null;\nBlockly.Tooltip.createDom=function(){Blockly.Tooltip.DIV||(Blockly.Tooltip.DIV=document.createElement(\"div\"),Blockly.Tooltip.DIV.className=\"blocklyTooltipDiv\",(Blockly.parentContainer||document.body).appendChild(Blockly.Tooltip.DIV))};\nBlockly.Tooltip.bindMouseEvents=function(a){a.mouseOverWrapper_=Blockly.bindEvent_(a,\"mouseover\",null,Blockly.Tooltip.onMouseOver_);a.mouseOutWrapper_=Blockly.bindEvent_(a,\"mouseout\",null,Blockly.Tooltip.onMouseOut_);a.addEventListener(\"mousemove\",Blockly.Tooltip.onMouseMove_,!1)};Blockly.Tooltip.unbindMouseEvents=function(a){a&&(Blockly.unbindEvent_(a.mouseOverWrapper_),Blockly.unbindEvent_(a.mouseOutWrapper_),a.removeEventListener(\"mousemove\",Blockly.Tooltip.onMouseMove_))};\nBlockly.Tooltip.onMouseOver_=function(a){if(!Blockly.Tooltip.blocked_){for(a=a.currentTarget;\"string\"!=typeof a.tooltip&&\"function\"!=typeof a.tooltip;)a=a.tooltip;Blockly.Tooltip.element_!=a&&(Blockly.Tooltip.hide(),Blockly.Tooltip.poisonedElement_=null,Blockly.Tooltip.element_=a);clearTimeout(Blockly.Tooltip.mouseOutPid_)}};\nBlockly.Tooltip.onMouseOut_=function(a){Blockly.Tooltip.blocked_||(Blockly.Tooltip.mouseOutPid_=setTimeout(function(){Blockly.Tooltip.element_=null;Blockly.Tooltip.poisonedElement_=null;Blockly.Tooltip.hide()},1),clearTimeout(Blockly.Tooltip.showPid_))};\nBlockly.Tooltip.onMouseMove_=function(a){if(Blockly.Tooltip.element_&&Blockly.Tooltip.element_.tooltip&&!Blockly.Tooltip.blocked_)if(Blockly.Tooltip.visible){var b=Blockly.Tooltip.lastX_-a.pageX;a=Blockly.Tooltip.lastY_-a.pageY;Math.sqrt(b*b+a*a)>Blockly.Tooltip.RADIUS_OK&&Blockly.Tooltip.hide()}else Blockly.Tooltip.poisonedElement_!=Blockly.Tooltip.element_&&(clearTimeout(Blockly.Tooltip.showPid_),Blockly.Tooltip.lastX_=a.pageX,Blockly.Tooltip.lastY_=a.pageY,Blockly.Tooltip.showPid_=setTimeout(Blockly.Tooltip.show_,\nBlockly.Tooltip.HOVER_MS))};Blockly.Tooltip.dispose=function(){Blockly.Tooltip.element_=null;Blockly.Tooltip.poisonedElement_=null;Blockly.Tooltip.hide()};Blockly.Tooltip.hide=function(){Blockly.Tooltip.visible&&(Blockly.Tooltip.visible=!1,Blockly.Tooltip.DIV&&(Blockly.Tooltip.DIV.style.display=\"none\"));Blockly.Tooltip.showPid_&&clearTimeout(Blockly.Tooltip.showPid_)};Blockly.Tooltip.block=function(){Blockly.Tooltip.hide();Blockly.Tooltip.blocked_=!0};\nBlockly.Tooltip.unblock=function(){Blockly.Tooltip.blocked_=!1};\nBlockly.Tooltip.show_=function(){if(!Blockly.Tooltip.blocked_&&(Blockly.Tooltip.poisonedElement_=Blockly.Tooltip.element_,Blockly.Tooltip.DIV)){Blockly.Tooltip.DIV.textContent=\"\";for(var a=Blockly.Tooltip.element_.tooltip;\"function\"==typeof a;)a=a();a=Blockly.utils.string.wrap(a,Blockly.Tooltip.LIMIT);a=a.split(\"\\n\");for(var b=0;b<a.length;b++){var c=document.createElement(\"div\");c.appendChild(document.createTextNode(a[b]));Blockly.Tooltip.DIV.appendChild(c)}a=Blockly.Tooltip.element_.RTL;b=document.documentElement.clientWidth;\nc=document.documentElement.clientHeight;Blockly.Tooltip.DIV.style.direction=a?\"rtl\":\"ltr\";Blockly.Tooltip.DIV.style.display=\"block\";Blockly.Tooltip.visible=!0;var d=Blockly.Tooltip.lastX_;d=a?d-(Blockly.Tooltip.OFFSET_X+Blockly.Tooltip.DIV.offsetWidth):d+Blockly.Tooltip.OFFSET_X;var e=Blockly.Tooltip.lastY_+Blockly.Tooltip.OFFSET_Y;e+Blockly.Tooltip.DIV.offsetHeight>c+window.scrollY&&(e-=Blockly.Tooltip.DIV.offsetHeight+2*Blockly.Tooltip.OFFSET_Y);a?d=Math.max(Blockly.Tooltip.MARGINS-window.scrollX,\nd):d+Blockly.Tooltip.DIV.offsetWidth>b+window.scrollX-2*Blockly.Tooltip.MARGINS&&(d=b-Blockly.Tooltip.DIV.offsetWidth-2*Blockly.Tooltip.MARGINS);Blockly.Tooltip.DIV.style.top=e+\"px\";Blockly.Tooltip.DIV.style.left=d+\"px\"}};Blockly.WorkspaceDragSurfaceSvg=function(a){this.container_=a;this.createDom()};Blockly.WorkspaceDragSurfaceSvg.prototype.SVG_=null;Blockly.WorkspaceDragSurfaceSvg.prototype.dragGroup_=null;Blockly.WorkspaceDragSurfaceSvg.prototype.container_=null;\nBlockly.WorkspaceDragSurfaceSvg.prototype.createDom=function(){this.SVG_||(this.SVG_=Blockly.utils.dom.createSvgElement(\"svg\",{xmlns:Blockly.utils.dom.SVG_NS,\"xmlns:html\":Blockly.utils.dom.HTML_NS,\"xmlns:xlink\":Blockly.utils.dom.XLINK_NS,version:\"1.1\",\"class\":\"blocklyWsDragSurface blocklyOverflowVisible\"},null),this.container_.appendChild(this.SVG_))};\nBlockly.WorkspaceDragSurfaceSvg.prototype.translateSurface=function(a,b){a=a.toFixed(0);b=b.toFixed(0);this.SVG_.style.display=\"block\";Blockly.utils.dom.setCssTransform(this.SVG_,\"translate3d(\"+a+\"px, \"+b+\"px, 0px)\")};Blockly.WorkspaceDragSurfaceSvg.prototype.getSurfaceTranslation=function(){return Blockly.utils.getRelativeXY(this.SVG_)};\nBlockly.WorkspaceDragSurfaceSvg.prototype.clearAndHide=function(a){if(!a)throw Error(\"Couldn't clear and hide the drag surface: missing new surface.\");var b=this.SVG_.childNodes[0],c=this.SVG_.childNodes[1];if(!(b&&c&&Blockly.utils.dom.hasClass(b,\"blocklyBlockCanvas\")&&Blockly.utils.dom.hasClass(c,\"blocklyBubbleCanvas\")))throw Error(\"Couldn't clear and hide the drag surface. A node was missing.\");null!=this.previousSibling_?Blockly.utils.dom.insertAfter(b,this.previousSibling_):a.insertBefore(b,a.firstChild);\nBlockly.utils.dom.insertAfter(c,b);this.SVG_.style.display=\"none\";if(this.SVG_.childNodes.length)throw Error(\"Drag surface was not cleared.\");Blockly.utils.dom.setCssTransform(this.SVG_,\"\");this.previousSibling_=null};\nBlockly.WorkspaceDragSurfaceSvg.prototype.setContentsAndShow=function(a,b,c,d,e,f){if(this.SVG_.childNodes.length)throw Error(\"Already dragging a block.\");this.previousSibling_=c;a.setAttribute(\"transform\",\"translate(0, 0) scale(\"+f+\")\");b.setAttribute(\"transform\",\"translate(0, 0) scale(\"+f+\")\");this.SVG_.setAttribute(\"width\",d);this.SVG_.setAttribute(\"height\",e);this.SVG_.appendChild(a);this.SVG_.appendChild(b);this.SVG_.style.display=\"block\"};Blockly.ASTNode=function(a,b,c){if(!b)throw Error(\"Cannot create a node without a location.\");this.type_=a;this.isConnection_=Blockly.ASTNode.isConnectionType_(a);this.location_=b;this.processParams_(c||null)};Blockly.ASTNode.types={FIELD:\"field\",BLOCK:\"block\",INPUT:\"input\",OUTPUT:\"output\",NEXT:\"next\",PREVIOUS:\"previous\",STACK:\"stack\",WORKSPACE:\"workspace\"};Blockly.ASTNode.NAVIGATE_ALL_FIELDS=!1;Blockly.ASTNode.DEFAULT_OFFSET_Y=-20;Blockly.ASTNode.isConnectionType_=function(a){switch(a){case Blockly.ASTNode.types.PREVIOUS:case Blockly.ASTNode.types.NEXT:case Blockly.ASTNode.types.INPUT:case Blockly.ASTNode.types.OUTPUT:return!0}return!1};\nBlockly.ASTNode.createFieldNode=function(a){return a?new Blockly.ASTNode(Blockly.ASTNode.types.FIELD,a):null};\nBlockly.ASTNode.createConnectionNode=function(a){return a?a.type==Blockly.INPUT_VALUE||a.type==Blockly.NEXT_STATEMENT&&a.getParentInput()?Blockly.ASTNode.createInputNode(a.getParentInput()):a.type==Blockly.NEXT_STATEMENT?new Blockly.ASTNode(Blockly.ASTNode.types.NEXT,a):a.type==Blockly.OUTPUT_VALUE?new Blockly.ASTNode(Blockly.ASTNode.types.OUTPUT,a):a.type==Blockly.PREVIOUS_STATEMENT?new Blockly.ASTNode(Blockly.ASTNode.types.PREVIOUS,a):null:null};\nBlockly.ASTNode.createInputNode=function(a){return a&&a.connection?new Blockly.ASTNode(Blockly.ASTNode.types.INPUT,a.connection):null};Blockly.ASTNode.createBlockNode=function(a){return a?new Blockly.ASTNode(Blockly.ASTNode.types.BLOCK,a):null};Blockly.ASTNode.createStackNode=function(a){return a?new Blockly.ASTNode(Blockly.ASTNode.types.STACK,a):null};Blockly.ASTNode.createWorkspaceNode=function(a,b){return b&&a?new Blockly.ASTNode(Blockly.ASTNode.types.WORKSPACE,a,{wsCoordinate:b}):null};\nBlockly.ASTNode.prototype.processParams_=function(a){a&&a.wsCoordinate&&(this.wsCoordinate_=a.wsCoordinate)};Blockly.ASTNode.prototype.getLocation=function(){return this.location_};Blockly.ASTNode.prototype.getType=function(){return this.type_};Blockly.ASTNode.prototype.getWsCoordinate=function(){return this.wsCoordinate_};Blockly.ASTNode.prototype.isConnection=function(){return this.isConnection_};\nBlockly.ASTNode.prototype.findNextForInput_=function(){var a=this.location_.getParentInput(),b=a.getSourceBlock();a=b.inputList.indexOf(a)+1;for(var c;c=b.inputList[a];a++){for(var d=c.fieldRow,e=0,f;f=d[e];e++)if(f.isClickable()||Blockly.ASTNode.NAVIGATE_ALL_FIELDS)return Blockly.ASTNode.createFieldNode(f);if(c.connection)return Blockly.ASTNode.createInputNode(c)}return null};\nBlockly.ASTNode.prototype.findNextForField_=function(){var a=this.location_,b=a.getParentInput(),c=a.getSourceBlock(),d=c.inputList.indexOf(b);for(a=b.fieldRow.indexOf(a)+1;b=c.inputList[d];d++){for(var e=b.fieldRow;a<e.length;){if(e[a].isClickable()||Blockly.ASTNode.NAVIGATE_ALL_FIELDS)return Blockly.ASTNode.createFieldNode(e[a]);a++}a=0;if(b.connection)return Blockly.ASTNode.createInputNode(b)}return null};\nBlockly.ASTNode.prototype.findPrevForInput_=function(){for(var a=this.location_.getParentInput(),b=a.getSourceBlock(),c=b.inputList.indexOf(a),d;d=b.inputList[c];c--){if(d.connection&&d!==a)return Blockly.ASTNode.createInputNode(d);d=d.fieldRow;for(var e=d.length-1,f;f=d[e];e--)if(f.isClickable()||Blockly.ASTNode.NAVIGATE_ALL_FIELDS)return Blockly.ASTNode.createFieldNode(f)}return null};\nBlockly.ASTNode.prototype.findPrevForField_=function(){var a=this.location_,b=a.getParentInput(),c=a.getSourceBlock(),d=c.inputList.indexOf(b);a=b.fieldRow.indexOf(a)-1;for(var e;e=c.inputList[d];d--){if(e.connection&&e!==b)return Blockly.ASTNode.createInputNode(e);for(e=e.fieldRow;-1<a;){if(e[a].isClickable()||Blockly.ASTNode.NAVIGATE_ALL_FIELDS)return Blockly.ASTNode.createFieldNode(e[a]);a--}0<=d-1&&(a=c.inputList[d-1].fieldRow.length-1)}return null};\nBlockly.ASTNode.prototype.navigateBetweenStacks_=function(a){var b=this.getLocation();b instanceof Blockly.Block||(b=b.getSourceBlock());if(!b||!b.workspace)return null;var c=b.getRootBlock();b=c.workspace.getTopBlocks(!0);for(var d=0,e;e=b[d];d++)if(c.id==e.id)return a=d+(a?1:-1),-1==a||a==b.length?null:Blockly.ASTNode.createStackNode(b[a]);throw Error(\"Couldn't find \"+(a?\"next\":\"previous\")+\" stack?!\");};\nBlockly.ASTNode.prototype.findTopASTNodeForBlock_=function(a){var b=a.previousConnection||a.outputConnection;return b?Blockly.ASTNode.createConnectionNode(b):Blockly.ASTNode.createBlockNode(a)};Blockly.ASTNode.prototype.getOutAstNodeForBlock_=function(a){if(!a)return null;a=a.getTopStackBlock();var b=a.previousConnection||a.outputConnection;return b&&b.targetConnection&&b.targetConnection.getParentInput()?Blockly.ASTNode.createInputNode(b.targetConnection.getParentInput()):Blockly.ASTNode.createStackNode(a)};\nBlockly.ASTNode.prototype.findFirstFieldOrInput_=function(a){a=a.inputList;for(var b=0,c;c=a[b];b++){for(var d=c.fieldRow,e=0,f;f=d[e];e++)if(f.isClickable()||Blockly.ASTNode.NAVIGATE_ALL_FIELDS)return Blockly.ASTNode.createFieldNode(f);if(c.connection)return Blockly.ASTNode.createInputNode(c)}return null};\nBlockly.ASTNode.prototype.getSourceBlock=function(){return this.getType()===Blockly.ASTNode.types.BLOCK?this.getLocation():this.getType()===Blockly.ASTNode.types.STACK?this.getLocation():this.getType()===Blockly.ASTNode.types.WORKSPACE?null:this.getLocation().getSourceBlock()};\nBlockly.ASTNode.prototype.next=function(){switch(this.type_){case Blockly.ASTNode.types.STACK:return this.navigateBetweenStacks_(!0);case Blockly.ASTNode.types.OUTPUT:return Blockly.ASTNode.createBlockNode(this.location_.getSourceBlock());case Blockly.ASTNode.types.FIELD:return this.findNextForField_();case Blockly.ASTNode.types.INPUT:return this.findNextForInput_();case Blockly.ASTNode.types.BLOCK:return Blockly.ASTNode.createConnectionNode(this.location_.nextConnection);case Blockly.ASTNode.types.PREVIOUS:return Blockly.ASTNode.createBlockNode(this.location_.getSourceBlock());\ncase Blockly.ASTNode.types.NEXT:return Blockly.ASTNode.createConnectionNode(this.location_.targetConnection)}return null};Blockly.ASTNode.prototype.in=function(){switch(this.type_){case Blockly.ASTNode.types.WORKSPACE:var a=this.location_.getTopBlocks(!0);if(0<a.length)return Blockly.ASTNode.createStackNode(a[0]);break;case Blockly.ASTNode.types.STACK:return a=this.location_,this.findTopASTNodeForBlock_(a);case Blockly.ASTNode.types.BLOCK:return a=this.location_,this.findFirstFieldOrInput_(a);case Blockly.ASTNode.types.INPUT:return Blockly.ASTNode.createConnectionNode(this.location_.targetConnection)}return null};\nBlockly.ASTNode.prototype.prev=function(){switch(this.type_){case Blockly.ASTNode.types.STACK:return this.navigateBetweenStacks_(!1);case Blockly.ASTNode.types.FIELD:return this.findPrevForField_();case Blockly.ASTNode.types.INPUT:return this.findPrevForInput_();case Blockly.ASTNode.types.BLOCK:var a=this.location_;return Blockly.ASTNode.createConnectionNode(a.previousConnection||a.outputConnection);case Blockly.ASTNode.types.PREVIOUS:if((a=this.location_.targetConnection)&&!a.getParentInput())return Blockly.ASTNode.createConnectionNode(a);\nbreak;case Blockly.ASTNode.types.NEXT:return Blockly.ASTNode.createBlockNode(this.location_.getSourceBlock())}return null};\nBlockly.ASTNode.prototype.out=function(){switch(this.type_){case Blockly.ASTNode.types.STACK:var a=this.location_.getRelativeToSurfaceXY();a=new Blockly.utils.Coordinate(a.x,a.y+Blockly.ASTNode.DEFAULT_OFFSET_Y);return Blockly.ASTNode.createWorkspaceNode(this.location_.workspace,a);case Blockly.ASTNode.types.OUTPUT:return(a=this.location_.targetConnection)?Blockly.ASTNode.createConnectionNode(a):Blockly.ASTNode.createStackNode(this.location_.getSourceBlock());case Blockly.ASTNode.types.FIELD:return Blockly.ASTNode.createBlockNode(this.location_.getSourceBlock());\ncase Blockly.ASTNode.types.INPUT:return Blockly.ASTNode.createBlockNode(this.location_.getSourceBlock());case Blockly.ASTNode.types.BLOCK:return this.getOutAstNodeForBlock_(this.location_);case Blockly.ASTNode.types.PREVIOUS:return this.getOutAstNodeForBlock_(this.location_.getSourceBlock());case Blockly.ASTNode.types.NEXT:return this.getOutAstNodeForBlock_(this.location_.getSourceBlock())}return null};Blockly.Blocks=Object.create(null);Blockly.Connection=function(a,b){this.sourceBlock_=a;this.type=b};Blockly.Connection.CAN_CONNECT=0;Blockly.Connection.REASON_SELF_CONNECTION=1;Blockly.Connection.REASON_WRONG_TYPE=2;Blockly.Connection.REASON_TARGET_NULL=3;Blockly.Connection.REASON_CHECKS_FAILED=4;Blockly.Connection.REASON_DIFFERENT_WORKSPACES=5;Blockly.Connection.REASON_SHADOW_PARENT=6;Blockly.Connection.prototype.targetConnection=null;Blockly.Connection.prototype.disposed=!1;Blockly.Connection.prototype.check_=null;\nBlockly.Connection.prototype.shadowDom_=null;Blockly.Connection.prototype.x=0;Blockly.Connection.prototype.y=0;\nBlockly.Connection.prototype.connect_=function(a){var b=this,c=b.getSourceBlock(),d=a.getSourceBlock();a.isConnected()&&a.disconnect();if(b.isConnected()){var e=b.targetBlock(),f=b.getShadowDom();b.setShadowDom(null);if(e.isShadow())f=Blockly.Xml.blockToDom(e),e.dispose(!1),e=null;else if(b.type==Blockly.INPUT_VALUE){if(!e.outputConnection)throw Error(\"Orphan block does not have an output connection.\");var g=Blockly.Connection.lastConnectionInRow(d,e);g&&(e.outputConnection.connect(g),e=null)}else if(b.type==\nBlockly.NEXT_STATEMENT){if(!e.previousConnection)throw Error(\"Orphan block does not have a previous connection.\");for(g=d;g.nextConnection;){var h=g.getNextBlock();if(h&&!h.isShadow())g=h;else{e.previousConnection.checkType(g.nextConnection)&&(g.nextConnection.connect(e.previousConnection),e=null);break}}}if(e&&(b.disconnect(),Blockly.Events.recordUndo)){var k=Blockly.Events.getGroup();setTimeout(function(){if(e.workspace&&!e.getParent()){Blockly.Events.setGroup(k);if(e.outputConnection)e.outputConnection.onFailedConnect(b);\nelse if(e.previousConnection)e.previousConnection.onFailedConnect(b);Blockly.Events.setGroup(!1)}},Blockly.BUMP_DELAY)}b.setShadowDom(f)}var l;Blockly.Events.isEnabled()&&(l=new Blockly.Events.BlockMove(d));Blockly.Connection.connectReciprocally_(b,a);d.setParent(c);l&&(l.recordNew(),Blockly.Events.fire(l))};Blockly.Connection.prototype.dispose=function(){if(this.isConnected()){this.setShadowDom(null);var a=this.targetBlock();a.isShadow()?a.dispose(!1):a.unplug()}this.disposed=!0};\nBlockly.Connection.prototype.getSourceBlock=function(){return this.sourceBlock_};Blockly.Connection.prototype.isSuperior=function(){return this.type==Blockly.INPUT_VALUE||this.type==Blockly.NEXT_STATEMENT};Blockly.Connection.prototype.isConnected=function(){return!!this.targetConnection};\nBlockly.Connection.prototype.canConnectWithReason=function(a){if(!a)return Blockly.Connection.REASON_TARGET_NULL;if(this.isSuperior())var b=this.sourceBlock_,c=a.getSourceBlock();else c=this.sourceBlock_,b=a.getSourceBlock();return b&&b==c?Blockly.Connection.REASON_SELF_CONNECTION:a.type!=Blockly.OPPOSITE_TYPE[this.type]?Blockly.Connection.REASON_WRONG_TYPE:b&&c&&b.workspace!==c.workspace?Blockly.Connection.REASON_DIFFERENT_WORKSPACES:this.checkType(a)?b.isShadow()&&!c.isShadow()?Blockly.Connection.REASON_SHADOW_PARENT:\nBlockly.Connection.CAN_CONNECT:Blockly.Connection.REASON_CHECKS_FAILED};\nBlockly.Connection.prototype.checkConnection=function(a){switch(this.canConnectWithReason(a)){case Blockly.Connection.CAN_CONNECT:break;case Blockly.Connection.REASON_SELF_CONNECTION:throw Error(\"Attempted to connect a block to itself.\");case Blockly.Connection.REASON_DIFFERENT_WORKSPACES:throw Error(\"Blocks not on same workspace.\");case Blockly.Connection.REASON_WRONG_TYPE:throw Error(\"Attempt to connect incompatible types.\");case Blockly.Connection.REASON_TARGET_NULL:throw Error(\"Target connection is null.\");\ncase Blockly.Connection.REASON_CHECKS_FAILED:throw Error(\"Connection checks failed. \"+(this+\" expected \"+this.check_+\", found \"+a.check_));case Blockly.Connection.REASON_SHADOW_PARENT:throw Error(\"Connecting non-shadow to shadow block.\");default:throw Error(\"Unknown connection failure: this should never happen!\");}};\nBlockly.Connection.prototype.canConnectToPrevious_=function(a){if(this.targetConnection||-1!=Blockly.draggingConnections.indexOf(a))return!1;if(!a.targetConnection)return!0;a=a.targetBlock();return a.isInsertionMarker()?!a.getPreviousBlock():!1};\nBlockly.Connection.prototype.isConnectionAllowed=function(a){if(a.sourceBlock_.isInsertionMarker()||this.canConnectWithReason(a)!=Blockly.Connection.CAN_CONNECT)return!1;switch(a.type){case Blockly.PREVIOUS_STATEMENT:return this.canConnectToPrevious_(a);case Blockly.OUTPUT_VALUE:if(a.isConnected()&&!a.targetBlock().isInsertionMarker()||this.isConnected())return!1;break;case Blockly.INPUT_VALUE:if(a.isConnected()&&!a.targetBlock().isMovable()&&!a.targetBlock().isShadow())return!1;break;case Blockly.NEXT_STATEMENT:if(a.isConnected()&&\n!this.sourceBlock_.nextConnection&&!a.targetBlock().isShadow()&&a.targetBlock().nextConnection)return!1;break;default:throw Error(\"Unknown connection type in isConnectionAllowed\");}return-1!=Blockly.draggingConnections.indexOf(a)?!1:!0};Blockly.Connection.prototype.onFailedConnect=function(a){};\nBlockly.Connection.prototype.connect=function(a){if(this.targetConnection!=a){this.checkConnection(a);var b=Blockly.Events.getGroup();b||Blockly.Events.setGroup(!0);this.isSuperior()?this.connect_(a):a.connect_(this);b||Blockly.Events.setGroup(!1)}};Blockly.Connection.connectReciprocally_=function(a,b){if(!a||!b)throw Error(\"Cannot connect null connections.\");a.targetConnection=b;b.targetConnection=a};\nBlockly.Connection.singleConnection_=function(a,b){for(var c=null,d=0;d<a.inputList.length;d++){var e=a.inputList[d].connection;if(e&&e.type==Blockly.INPUT_VALUE&&b.outputConnection.checkType(e)){if(c)return null;c=e}}return c};Blockly.Connection.lastConnectionInRow=function(a,b){for(var c;c=Blockly.Connection.singleConnection_(a,b);)if(a=c.targetBlock(),!a||a.isShadow())return c;return null};\nBlockly.Connection.prototype.disconnect=function(){var a=this.targetConnection;if(!a)throw Error(\"Source connection not connected.\");if(a.targetConnection!=this)throw Error(\"Target connection not connected to source connection.\");if(this.isSuperior()){var b=this.sourceBlock_;var c=a.getSourceBlock();a=this}else b=a.getSourceBlock(),c=this.sourceBlock_;var d=Blockly.Events.getGroup();d||Blockly.Events.setGroup(!0);this.disconnectInternal_(b,c);a.respawnShadow_();d||Blockly.Events.setGroup(!1)};\nBlockly.Connection.prototype.disconnectInternal_=function(a,b){var c;Blockly.Events.isEnabled()&&(c=new Blockly.Events.BlockMove(b));this.targetConnection=this.targetConnection.targetConnection=null;b.setParent(null);c&&(c.recordNew(),Blockly.Events.fire(c))};\nBlockly.Connection.prototype.respawnShadow_=function(){var a=this.getSourceBlock(),b=this.getShadowDom();if(a.workspace&&b&&Blockly.Events.recordUndo)if(a=Blockly.Xml.domToBlock(b,a.workspace),a.outputConnection)this.connect(a.outputConnection);else if(a.previousConnection)this.connect(a.previousConnection);else throw Error(\"Child block does not have output or previous statement.\");};\nBlockly.Connection.prototype.targetBlock=function(){return this.isConnected()?this.targetConnection.getSourceBlock():null};Blockly.Connection.prototype.checkType=function(a){if(!this.check_||!a.check_)return!0;for(var b=0;b<this.check_.length;b++)if(-1!=a.check_.indexOf(this.check_[b]))return!0;return!1};Blockly.Connection.prototype.checkType_=function(a){console.warn(\"Deprecated call to Blockly.Connection.prototype.checkType_, use Blockly.Connection.prototype.checkType instead.\");return this.checkType(a)};\nBlockly.Connection.prototype.onCheckChanged_=function(){!this.isConnected()||this.targetConnection&&this.checkType(this.targetConnection)||(this.isSuperior()?this.targetBlock():this.sourceBlock_).unplug()};Blockly.Connection.prototype.setCheck=function(a){a?(Array.isArray(a)||(a=[a]),this.check_=a,this.onCheckChanged_()):this.check_=null;return this};Blockly.Connection.prototype.getCheck=function(){return this.check_};Blockly.Connection.prototype.setShadowDom=function(a){this.shadowDom_=a};\nBlockly.Connection.prototype.getShadowDom=function(){return this.shadowDom_};Blockly.Connection.prototype.neighbours=function(a){return[]};Blockly.Connection.prototype.getParentInput=function(){for(var a=null,b=this.sourceBlock_,c=b.inputList,d=0;d<b.inputList.length;d++)if(c[d].connection===this){a=c[d];break}return a};\nBlockly.Connection.prototype.toString=function(){var a=this.sourceBlock_;if(a)if(a.outputConnection==this)var b=\"Output Connection of \";else if(a.previousConnection==this)b=\"Previous Connection of \";else if(a.nextConnection==this)b=\"Next Connection of \";else{b=null;for(var c=0,d;d=a.inputList[c];c++)if(d.connection==this){b=d;break}if(b)b='Input \"'+b.name+'\" connection on ';else return console.warn(\"Connection not actually connected to sourceBlock_\"),\"Orphan Connection\"}else return\"Orphan Connection\";\nreturn b+a.toDevString()};Blockly.Extensions={};Blockly.Extensions.ALL_={};Blockly.Extensions.register=function(a,b){if(\"string\"!=typeof a||\"\"==a.trim())throw Error('Error: Invalid extension name \"'+a+'\"');if(Blockly.Extensions.ALL_[a])throw Error('Error: Extension \"'+a+'\" is already registered.');if(\"function\"!=typeof b)throw Error('Error: Extension \"'+a+'\" must be a function');Blockly.Extensions.ALL_[a]=b};\nBlockly.Extensions.registerMixin=function(a,b){if(!b||\"object\"!=typeof b)throw Error('Error: Mixin \"'+a+'\" must be a object');Blockly.Extensions.register(a,function(){this.mixin(b)})};\nBlockly.Extensions.registerMutator=function(a,b,c,d){var e='Error when registering mutator \"'+a+'\": ';Blockly.Extensions.checkHasFunction_(e,b.domToMutation,\"domToMutation\");Blockly.Extensions.checkHasFunction_(e,b.mutationToDom,\"mutationToDom\");var f=Blockly.Extensions.checkMutatorDialog_(b,e);if(c&&\"function\"!=typeof c)throw Error('Extension \"'+a+'\" is not a function');Blockly.Extensions.register(a,function(){if(f){if(!Blockly.Mutator)throw Error(e+\"Missing require for Blockly.Mutator\");this.setMutator(new Blockly.Mutator(d||\n[]))}this.mixin(b);c&&c.apply(this)})};Blockly.Extensions.unregister=function(a){Blockly.Extensions.ALL_[a]?delete Blockly.Extensions.ALL_[a]:console.warn('No extension mapping for name \"'+a+'\" found to unregister')};\nBlockly.Extensions.apply=function(a,b,c){var d=Blockly.Extensions.ALL_[a];if(\"function\"!=typeof d)throw Error('Error: Extension \"'+a+'\" not found.');if(c)Blockly.Extensions.checkNoMutatorProperties_(a,b);else var e=Blockly.Extensions.getMutatorProperties_(b);d.apply(b);if(c)Blockly.Extensions.checkBlockHasMutatorProperties_('Error after applying mutator \"'+a+'\": ',b);else if(!Blockly.Extensions.mutatorPropertiesMatch_(e,b))throw Error('Error when applying extension \"'+a+'\": mutation properties changed when applying a non-mutator extension.');\n};Blockly.Extensions.checkHasFunction_=function(a,b,c){if(!b)throw Error(a+'missing required property \"'+c+'\"');if(\"function\"!=typeof b)throw Error(a+'\" required property \"'+c+'\" must be a function');};Blockly.Extensions.checkNoMutatorProperties_=function(a,b){if(Blockly.Extensions.getMutatorProperties_(b).length)throw Error('Error: tried to apply mutation \"'+a+'\" to a block that already has mutator functions.  Block id: '+b.id);};\nBlockly.Extensions.checkMutatorDialog_=function(a,b){var c=void 0!==a.compose,d=void 0!==a.decompose;if(c&&d){if(\"function\"!=typeof a.compose)throw Error(b+\"compose must be a function.\");if(\"function\"!=typeof a.decompose)throw Error(b+\"decompose must be a function.\");return!0}if(c||d)throw Error(b+'Must have both or neither of \"compose\" and \"decompose\"');return!1};\nBlockly.Extensions.checkBlockHasMutatorProperties_=function(a,b){if(\"function\"!=typeof b.domToMutation)throw Error(a+'Applying a mutator didn\\'t add \"domToMutation\"');if(\"function\"!=typeof b.mutationToDom)throw Error(a+'Applying a mutator didn\\'t add \"mutationToDom\"');Blockly.Extensions.checkMutatorDialog_(b,a)};\nBlockly.Extensions.getMutatorProperties_=function(a){var b=[];void 0!==a.domToMutation&&b.push(a.domToMutation);void 0!==a.mutationToDom&&b.push(a.mutationToDom);void 0!==a.compose&&b.push(a.compose);void 0!==a.decompose&&b.push(a.decompose);return b};Blockly.Extensions.mutatorPropertiesMatch_=function(a,b){b=Blockly.Extensions.getMutatorProperties_(b);if(b.length!=a.length)return!1;for(var c=0;c<b.length;c++)if(a[c]!=b[c])return!1;return!0};\nBlockly.Extensions.buildTooltipForDropdown=function(a,b){var c=[];\"object\"==typeof document&&Blockly.utils.runAfterPageLoad(function(){for(var a in b)Blockly.utils.checkMessageReferences(b[a])});return function(){this.type&&-1==c.indexOf(this.type)&&(Blockly.Extensions.checkDropdownOptionsInTable_(this,a,b),c.push(this.type));this.setTooltip(function(){var d=String(this.getFieldValue(a)),e=b[d];null==e?-1==c.indexOf(this.type)&&(d=\"No tooltip mapping for value \"+d+\" of field \"+a,null!=this.type&&\n(d+=\" of block type \"+this.type),console.warn(d+\".\")):e=Blockly.utils.replaceMessageReferences(e);return e}.bind(this))}};Blockly.Extensions.checkDropdownOptionsInTable_=function(a,b,c){var d=a.getField(b);if(!d.isOptionListDynamic()){d=d.getOptions();for(var e=0;e<d.length;++e){var f=d[e][1];null==c[f]&&console.warn(\"No tooltip mapping for value \"+f+\" of field \"+b+\" of block type \"+a.type)}}};\nBlockly.Extensions.buildTooltipWithFieldText=function(a,b){\"object\"==typeof document&&Blockly.utils.runAfterPageLoad(function(){Blockly.utils.checkMessageReferences(a)});return function(){this.setTooltip(function(){var c=this.getField(b);return Blockly.utils.replaceMessageReferences(a).replace(\"%1\",c?c.getText():\"\")}.bind(this))}};\nBlockly.Extensions.extensionParentTooltip_=function(){this.tooltipWhenNotConnected_=this.tooltip;this.setTooltip(function(){var a=this.getParent();return a&&a.getInputsInline()&&a.tooltip||this.tooltipWhenNotConnected_}.bind(this))};Blockly.Extensions.register(\"parent_tooltip_when_inline\",Blockly.Extensions.extensionParentTooltip_);Blockly.fieldRegistry={};Blockly.fieldRegistry.typeMap_={};Blockly.fieldRegistry.register=function(a,b){if(\"string\"!=typeof a||\"\"==a.trim())throw Error('Invalid field type \"'+a+'\". The type must be a non-empty string.');if(Blockly.fieldRegistry.typeMap_[a])throw Error('Error: Field \"'+a+'\" is already registered.');if(!b||\"function\"!=typeof b.fromJson)throw Error('Field \"'+b+'\" must have a fromJson function');a=a.toLowerCase();Blockly.fieldRegistry.typeMap_[a]=b};\nBlockly.fieldRegistry.unregister=function(a){Blockly.fieldRegistry.typeMap_[a]?delete Blockly.fieldRegistry.typeMap_[a]:console.warn('No field mapping for type \"'+a+'\" found to unregister')};\nBlockly.fieldRegistry.fromJson=function(a){var b=a.type.toLowerCase();b=Blockly.fieldRegistry.typeMap_[b];return b?b.fromJson(a):(console.warn(\"Blockly could not create a field of type \"+a.type+\". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached.\"),null)};Blockly.blockAnimations={};Blockly.blockAnimations.disconnectPid_=0;Blockly.blockAnimations.disconnectGroup_=null;Blockly.blockAnimations.disposeUiEffect=function(a){var b=a.workspace,c=a.getSvgRoot();b.getAudioManager().play(\"delete\");a=b.getSvgXY(c);c=c.cloneNode(!0);c.translateX_=a.x;c.translateY_=a.y;c.setAttribute(\"transform\",\"translate(\"+a.x+\",\"+a.y+\")\");b.getParentSvg().appendChild(c);c.bBox_=c.getBBox();Blockly.blockAnimations.disposeUiStep_(c,b.RTL,new Date,b.scale)};\nBlockly.blockAnimations.disposeUiStep_=function(a,b,c,d){var e=(new Date-c)/150;1<e?Blockly.utils.dom.removeNode(a):(a.setAttribute(\"transform\",\"translate(\"+(a.translateX_+(b?-1:1)*a.bBox_.width*d/2*e)+\",\"+(a.translateY_+a.bBox_.height*d*e)+\") scale(\"+(1-e)*d+\")\"),setTimeout(Blockly.blockAnimations.disposeUiStep_,10,a,b,c,d))};\nBlockly.blockAnimations.connectionUiEffect=function(a){var b=a.workspace,c=b.scale;b.getAudioManager().play(\"click\");if(!(1>c)){var d=b.getSvgXY(a.getSvgRoot());a.outputConnection?(d.x+=(a.RTL?3:-3)*c,d.y+=13*c):a.previousConnection&&(d.x+=(a.RTL?-23:23)*c,d.y+=3*c);a=Blockly.utils.dom.createSvgElement(\"circle\",{cx:d.x,cy:d.y,r:0,fill:\"none\",stroke:\"#888\",\"stroke-width\":10},b.getParentSvg());Blockly.blockAnimations.connectionUiStep_(a,new Date,c)}};\nBlockly.blockAnimations.connectionUiStep_=function(a,b,c){var d=(new Date-b)/150;1<d?Blockly.utils.dom.removeNode(a):(a.setAttribute(\"r\",25*d*c),a.style.opacity=1-d,Blockly.blockAnimations.disconnectPid_=setTimeout(Blockly.blockAnimations.connectionUiStep_,10,a,b,c))};\nBlockly.blockAnimations.disconnectUiEffect=function(a){a.workspace.getAudioManager().play(\"disconnect\");if(!(1>a.workspace.scale)){var b=a.getHeightWidth().height;b=Math.atan(10/b)/Math.PI*180;a.RTL||(b*=-1);Blockly.blockAnimations.disconnectUiStep_(a.getSvgRoot(),b,new Date)}};\nBlockly.blockAnimations.disconnectUiStep_=function(a,b,c){var d=(new Date-c)/200;1<d?a.skew_=\"\":(a.skew_=\"skewX(\"+Math.round(Math.sin(d*Math.PI*3)*(1-d)*b)+\")\",Blockly.blockAnimations.disconnectGroup_=a,Blockly.blockAnimations.disconnectPid_=setTimeout(Blockly.blockAnimations.disconnectUiStep_,10,a,b,c));a.setAttribute(\"transform\",a.translate_+a.skew_)};\nBlockly.blockAnimations.disconnectUiStop=function(){if(Blockly.blockAnimations.disconnectGroup_){clearTimeout(Blockly.blockAnimations.disconnectPid_);var a=Blockly.blockAnimations.disconnectGroup_;a.skew_=\"\";a.setAttribute(\"transform\",a.translate_);Blockly.blockAnimations.disconnectGroup_=null}};Blockly.InsertionMarkerManager=function(a){this.topBlock_=Blockly.selected=a;this.workspace_=a.workspace;this.lastMarker_=this.lastOnStack_=null;this.firstMarker_=this.createMarkerBlock_(this.topBlock_);this.localConnection_=this.closestConnection_=null;this.wouldDeleteBlock_=!1;this.fadedBlock_=this.highlightedBlock_=this.markerConnection_=null;this.availableConnections_=this.initAvailableConnections_()};Blockly.InsertionMarkerManager.PREVIEW_TYPE={INSERTION_MARKER:0,INPUT_OUTLINE:1,REPLACEMENT_FADE:2};\nBlockly.InsertionMarkerManager.prototype.dispose=function(){this.availableConnections_.length=0;Blockly.Events.disable();try{this.firstMarker_&&this.firstMarker_.dispose(),this.lastMarker_&&this.lastMarker_.dispose()}finally{Blockly.Events.enable()}};Blockly.InsertionMarkerManager.prototype.wouldDeleteBlock=function(){return this.wouldDeleteBlock_};Blockly.InsertionMarkerManager.prototype.wouldConnectBlock=function(){return!!this.closestConnection_};\nBlockly.InsertionMarkerManager.prototype.applyConnections=function(){if(this.closestConnection_&&(Blockly.Events.disable(),this.hidePreview_(),Blockly.Events.enable(),this.localConnection_.connect(this.closestConnection_),this.topBlock_.rendered)){var a=this.localConnection_.isSuperior()?this.closestConnection_:this.localConnection_;Blockly.blockAnimations.connectionUiEffect(a.getSourceBlock());this.topBlock_.getRootBlock().bringToFront()}};\nBlockly.InsertionMarkerManager.prototype.update=function(a,b){var c=this.getCandidate_(a);if((this.wouldDeleteBlock_=this.shouldDelete_(c,b))||this.shouldUpdatePreviews_(c,a))Blockly.Events.disable(),this.maybeHidePreview_(c),this.maybeShowPreview_(c),Blockly.Events.enable()};\nBlockly.InsertionMarkerManager.prototype.createMarkerBlock_=function(a){var b=a.type;Blockly.Events.disable();try{var c=this.workspace_.newBlock(b);c.setInsertionMarker(!0);if(a.mutationToDom){var d=a.mutationToDom();d&&c.domToMutation(d)}c.setCollapsed(a.isCollapsed());c.setInputsInline(a.getInputsInline());for(b=0;b<a.inputList.length;b++){var e=a.inputList[b];if(e.isVisible()){var f=c.inputList[b];for(d=0;d<e.fieldRow.length;d++)f.fieldRow[d].setValue(e.fieldRow[d].getValue())}}c.initSvg();c.getSvgRoot().setAttribute(\"visibility\",\n\"hidden\")}finally{Blockly.Events.enable()}return c};Blockly.InsertionMarkerManager.prototype.initAvailableConnections_=function(){var a=this.topBlock_.getConnections_(!1),b=this.topBlock_.lastConnectionInStack();b&&b!=this.topBlock_.nextConnection&&(a.push(b),this.lastOnStack_=b,this.lastMarker_=this.createMarkerBlock_(b.getSourceBlock()));return a};\nBlockly.InsertionMarkerManager.prototype.shouldUpdatePreviews_=function(a,b){var c=a.local,d=a.closest;a=a.radius;if(c&&d){if(this.localConnection_&&this.closestConnection_){if(this.closestConnection_==d&&this.localConnection_==c)return!1;c=this.localConnection_.x+b.x-this.closestConnection_.x;b=this.localConnection_.y+b.y-this.closestConnection_.y;b=Math.sqrt(c*c+b*b);return!(d&&a>b-Blockly.CURRENT_CONNECTION_PREFERENCE)}if(this.localConnection_||this.closestConnection_)console.error(\"Only one of localConnection_ and closestConnection_ was set.\");\nelse return!0}else return!(!this.localConnection_||!this.closestConnection_);console.error(\"Returning true from shouldUpdatePreviews, but it's not clear why.\");return!0};Blockly.InsertionMarkerManager.prototype.getCandidate_=function(a){for(var b=this.getStartRadius_(),c=null,d=null,e=0;e<this.availableConnections_.length;e++){var f=this.availableConnections_[e],g=f.closest(b,a);g.connection&&(c=g.connection,d=f,b=g.radius)}return{closest:c,local:d,radius:b}};\nBlockly.InsertionMarkerManager.prototype.getStartRadius_=function(){return this.closestConnection_&&this.localConnection_?Blockly.CONNECTING_SNAP_RADIUS:Blockly.SNAP_RADIUS};Blockly.InsertionMarkerManager.prototype.shouldDelete_=function(a,b){a=a&&!!a.closest&&b!=Blockly.DELETE_AREA_TOOLBOX;return!!b&&!this.topBlock_.getParent()&&this.topBlock_.isDeletable()&&!a};\nBlockly.InsertionMarkerManager.prototype.maybeShowPreview_=function(a){if(!this.wouldDeleteBlock_){var b=a.closest;a=a.local;b&&(b==this.closestConnection_||b.getSourceBlock().isInsertionMarker()?console.log(\"Trying to connect to an insertion marker\"):(this.closestConnection_=b,this.localConnection_=a,this.showPreview_()))}};\nBlockly.InsertionMarkerManager.prototype.showPreview_=function(){var a=this.closestConnection_,b=this.workspace_.getRenderer();switch(b.getConnectionPreviewMethod(a,this.localConnection_,this.topBlock_)){case Blockly.InsertionMarkerManager.PREVIEW_TYPE.INPUT_OUTLINE:this.showInsertionInputOutline_();break;case Blockly.InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER:this.showInsertionMarker_();break;case Blockly.InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE:this.showReplacementFade_()}a&&\nb.shouldHighlightConnection(a)&&a.highlight()};Blockly.InsertionMarkerManager.prototype.maybeHidePreview_=function(a){if(a.closest){var b=this.closestConnection_!=a.closest;a=this.localConnection_!=a.local;this.closestConnection_&&this.localConnection_&&(b||a||this.wouldDeleteBlock_)&&this.hidePreview_()}else this.hidePreview_();this.localConnection_=this.closestConnection_=this.markerConnection_=null};\nBlockly.InsertionMarkerManager.prototype.hidePreview_=function(){this.closestConnection_&&this.closestConnection_.targetBlock()&&this.workspace_.getRenderer().shouldHighlightConnection(this.closestConnection_)&&this.closestConnection_.unhighlight();this.fadedBlock_?this.hideReplacementFade_():this.highlightedBlock_?this.hideInsertionInputOutline_():this.markerConnection_&&this.hideInsertionMarker_()};\nBlockly.InsertionMarkerManager.prototype.showInsertionMarker_=function(){var a=this.localConnection_,b=this.closestConnection_,c=this.lastOnStack_&&a==this.lastOnStack_?this.lastMarker_:this.firstMarker_;a=c.getMatchingConnection(a.getSourceBlock(),a);if(a==this.markerConnection_)throw Error(\"Made it to showInsertionMarker_ even though the marker isn't changing\");c.render();c.rendered=!0;c.getSvgRoot().setAttribute(\"visibility\",\"visible\");a&&b&&c.positionNearConnection(a,b);b&&a.connect(b);this.markerConnection_=\na};\nBlockly.InsertionMarkerManager.prototype.hideInsertionMarker_=function(){if(this.markerConnection_){var a=this.markerConnection_,b=a.getSourceBlock(),c=b.nextConnection,d=b.previousConnection,e=b.outputConnection;e=a.type==Blockly.INPUT_VALUE&&!(e&&e.targetConnection);!(a!=c||d&&d.targetConnection)||e?a.targetBlock().unplug(!1):a.type==Blockly.NEXT_STATEMENT&&a!=c?(c=a.targetConnection,c.getSourceBlock().unplug(!1),d=d?d.targetConnection:null,b.unplug(!0),d&&d.connect(c)):b.unplug(!0);if(a.targetConnection)throw Error(\"markerConnection_ still connected at the end of disconnectInsertionMarker\");this.markerConnection_=\nnull;b.getSvgRoot().setAttribute(\"visibility\",\"hidden\")}else console.log(\"No insertion marker connection to disconnect\")};Blockly.InsertionMarkerManager.prototype.showInsertionInputOutline_=function(){var a=this.closestConnection_;this.highlightedBlock_=a.getSourceBlock();this.highlightedBlock_.highlightShapeForInput(a,!0)};\nBlockly.InsertionMarkerManager.prototype.hideInsertionInputOutline_=function(){this.highlightedBlock_.highlightShapeForInput(this.closestConnection_,!1);this.highlightedBlock_=null};Blockly.InsertionMarkerManager.prototype.showReplacementFade_=function(){this.fadedBlock_=this.closestConnection_.targetBlock();this.fadedBlock_.fadeForReplacement(!0)};Blockly.InsertionMarkerManager.prototype.hideReplacementFade_=function(){this.fadedBlock_.fadeForReplacement(!1);this.fadedBlock_=null};\nBlockly.InsertionMarkerManager.prototype.getInsertionMarkers=function(){var a=[];this.firstMarker_&&a.push(this.firstMarker_);this.lastMarker_&&a.push(this.lastMarker_);return a};Blockly.BlockDragger=function(a,b){this.draggingBlock_=a;this.workspace_=b;this.draggedConnectionManager_=new Blockly.InsertionMarkerManager(this.draggingBlock_);this.deleteArea_=null;this.wouldDeleteBlock_=!1;this.startXY_=this.draggingBlock_.getRelativeToSurfaceXY();this.dragIconData_=Blockly.BlockDragger.initIconData_(a)};Blockly.BlockDragger.prototype.dispose=function(){this.dragIconData_.length=0;this.draggedConnectionManager_&&this.draggedConnectionManager_.dispose()};\nBlockly.BlockDragger.initIconData_=function(a){var b=[];a=a.getDescendants(!1);for(var c=0,d;d=a[c];c++){d=d.getIcons();for(var e=0;e<d.length;e++){var f={location:d[e].getIconLocation(),icon:d[e]};b.push(f)}}return b};\nBlockly.BlockDragger.prototype.startBlockDrag=function(a,b){Blockly.Events.getGroup()||Blockly.Events.setGroup(!0);this.fireDragStartEvent_();this.workspace_.isMutator&&this.draggingBlock_.bringToFront();Blockly.utils.dom.startTextWidthCache();this.workspace_.setResizesEnabled(!1);Blockly.blockAnimations.disconnectUiStop();if(this.draggingBlock_.getParent()||b&&this.draggingBlock_.nextConnection&&this.draggingBlock_.nextConnection.targetBlock())this.draggingBlock_.unplug(b),a=this.pixelsToWorkspaceUnits_(a),\na=Blockly.utils.Coordinate.sum(this.startXY_,a),this.draggingBlock_.translate(a.x,a.y),Blockly.blockAnimations.disconnectUiEffect(this.draggingBlock_);this.draggingBlock_.setDragging(!0);this.draggingBlock_.moveToDragSurface();if(a=this.workspace_.getToolbox())b=this.draggingBlock_.isDeletable()?\"blocklyToolboxDelete\":\"blocklyToolboxGrab\",a.addStyle(b)};\nBlockly.BlockDragger.prototype.fireDragStartEvent_=function(){var a=new Blockly.Events.Ui(this.draggingBlock_,\"dragStart\",null,this.draggingBlock_.getDescendants(!1));Blockly.Events.fire(a)};Blockly.BlockDragger.prototype.dragBlock=function(a,b){b=this.pixelsToWorkspaceUnits_(b);var c=Blockly.utils.Coordinate.sum(this.startXY_,b);this.draggingBlock_.moveDuringDrag(c);this.dragIcons_(b);this.deleteArea_=this.workspace_.isDeleteArea(a);this.draggedConnectionManager_.update(b,this.deleteArea_);this.updateCursorDuringBlockDrag_()};\nBlockly.BlockDragger.prototype.endBlockDrag=function(a,b){this.dragBlock(a,b);this.dragIconData_=[];this.fireDragEndEvent_();Blockly.utils.dom.stopTextWidthCache();Blockly.blockAnimations.disconnectUiStop();a=this.pixelsToWorkspaceUnits_(b);b=Blockly.utils.Coordinate.sum(this.startXY_,a);this.draggingBlock_.moveOffDragSurface(b);this.maybeDeleteBlock_()||(this.draggingBlock_.moveConnections(a.x,a.y),this.draggingBlock_.setDragging(!1),this.fireMoveEvent_(),this.draggedConnectionManager_.wouldConnectBlock()?\nthis.draggedConnectionManager_.applyConnections():this.draggingBlock_.render(),this.draggingBlock_.scheduleSnapAndBump());this.workspace_.setResizesEnabled(!0);if(a=this.workspace_.getToolbox())b=this.draggingBlock_.isDeletable()?\"blocklyToolboxDelete\":\"blocklyToolboxGrab\",a.removeStyle(b);Blockly.Events.setGroup(!1)};Blockly.BlockDragger.prototype.fireDragEndEvent_=function(){var a=new Blockly.Events.Ui(this.draggingBlock_,\"dragStop\",this.draggingBlock_.getDescendants(!1),null);Blockly.Events.fire(a)};\nBlockly.BlockDragger.prototype.fireMoveEvent_=function(){var a=new Blockly.Events.BlockMove(this.draggingBlock_);a.oldCoordinate=this.startXY_;a.recordNew();Blockly.Events.fire(a)};Blockly.BlockDragger.prototype.maybeDeleteBlock_=function(){var a=this.workspace_.trashcan;this.wouldDeleteBlock_?(a&&setTimeout(a.close.bind(a),100),this.fireMoveEvent_(),this.draggingBlock_.dispose(!1,!0),Blockly.draggingConnections=[]):a&&a.close();return this.wouldDeleteBlock_};\nBlockly.BlockDragger.prototype.updateCursorDuringBlockDrag_=function(){this.wouldDeleteBlock_=this.draggedConnectionManager_.wouldDeleteBlock();var a=this.workspace_.trashcan;this.wouldDeleteBlock_?(this.draggingBlock_.setDeleteStyle(!0),this.deleteArea_==Blockly.DELETE_AREA_TRASH&&a&&a.setOpen(!0)):(this.draggingBlock_.setDeleteStyle(!1),a&&a.setOpen(!1))};\nBlockly.BlockDragger.prototype.pixelsToWorkspaceUnits_=function(a){a=new Blockly.utils.Coordinate(a.x/this.workspace_.scale,a.y/this.workspace_.scale);this.workspace_.isMutator&&a.scale(1/this.workspace_.options.parentWorkspace.scale);return a};Blockly.BlockDragger.prototype.dragIcons_=function(a){for(var b=0;b<this.dragIconData_.length;b++){var c=this.dragIconData_[b];c.icon.setIconLocation(Blockly.utils.Coordinate.sum(c.location,a))}};\nBlockly.BlockDragger.prototype.getInsertionMarkers=function(){return this.draggedConnectionManager_&&this.draggedConnectionManager_.getInsertionMarkers?this.draggedConnectionManager_.getInsertionMarkers():[]};Blockly.VariableMap=function(a){this.variableMap_=Object.create(null);this.workspace=a};Blockly.VariableMap.prototype.clear=function(){this.variableMap_=Object.create(null)};Blockly.VariableMap.prototype.renameVariable=function(a,b){var c=this.getVariable(b,a.type),d=this.workspace.getAllBlocks(!1);Blockly.Events.setGroup(!0);try{c&&c.getId()!=a.getId()?this.renameVariableWithConflict_(a,b,c,d):this.renameVariableAndUses_(a,b,d)}finally{Blockly.Events.setGroup(!1)}};\nBlockly.VariableMap.prototype.renameVariableById=function(a,b){var c=this.getVariableById(a);if(!c)throw Error(\"Tried to rename a variable that didn't exist. ID: \"+a);this.renameVariable(c,b)};Blockly.VariableMap.prototype.renameVariableAndUses_=function(a,b,c){Blockly.Events.fire(new Blockly.Events.VarRename(a,b));a.name=b;for(b=0;b<c.length;b++)c[b].updateVarName(a)};\nBlockly.VariableMap.prototype.renameVariableWithConflict_=function(a,b,c,d){var e=a.type;b!=c.name&&this.renameVariableAndUses_(c,b,d);for(b=0;b<d.length;b++)d[b].renameVarById(a.getId(),c.getId());Blockly.Events.fire(new Blockly.Events.VarDelete(a));a=this.getVariablesOfType(e).indexOf(a);this.variableMap_[e].splice(a,1)};\nBlockly.VariableMap.prototype.createVariable=function(a,b,c){var d=this.getVariable(a,b);if(d){if(c&&d.getId()!=c)throw Error('Variable \"'+a+'\" is already in use and its id is \"'+d.getId()+'\" which conflicts with the passed in id, \"'+c+'\".');return d}if(c&&this.getVariableById(c))throw Error('Variable id, \"'+c+'\", is already in use.');d=c||Blockly.utils.genUid();b=b||\"\";d=new Blockly.VariableModel(this.workspace,a,b,d);a=this.variableMap_[b]||[];a.push(d);delete this.variableMap_[b];this.variableMap_[b]=\na;return d};Blockly.VariableMap.prototype.deleteVariable=function(a){for(var b=this.variableMap_[a.type],c=0,d;d=b[c];c++)if(d.getId()==a.getId()){b.splice(c,1);Blockly.Events.fire(new Blockly.Events.VarDelete(a));break}};\nBlockly.VariableMap.prototype.deleteVariableById=function(a){var b=this.getVariableById(a);if(b){var c=b.name,d=this.getVariableUsesById(a);a=0;for(var e;e=d[a];a++)if(\"procedures_defnoreturn\"==e.type||\"procedures_defreturn\"==e.type){a=e.getFieldValue(\"NAME\");c=Blockly.Msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace(\"%1\",c).replace(\"%2\",a);Blockly.alert(c);return}var f=this;1<d.length?(c=Blockly.Msg.DELETE_VARIABLE_CONFIRMATION.replace(\"%1\",String(d.length)).replace(\"%2\",c),Blockly.confirm(c,function(a){a&&\nb&&f.deleteVariableInternal(b,d)})):f.deleteVariableInternal(b,d)}else console.warn(\"Can't delete non-existent variable: \"+a)};Blockly.VariableMap.prototype.deleteVariableInternal=function(a,b){var c=Blockly.Events.getGroup();c||Blockly.Events.setGroup(!0);try{for(var d=0;d<b.length;d++)b[d].dispose(!0);this.deleteVariable(a)}finally{c||Blockly.Events.setGroup(!1)}};\nBlockly.VariableMap.prototype.getVariable=function(a,b){if(b=this.variableMap_[b||\"\"])for(var c=0,d;d=b[c];c++)if(Blockly.Names.equals(d.name,a))return d;return null};Blockly.VariableMap.prototype.getVariableById=function(a){for(var b=Object.keys(this.variableMap_),c=0;c<b.length;c++)for(var d=b[c],e=0,f;f=this.variableMap_[d][e];e++)if(f.getId()==a)return f;return null};Blockly.VariableMap.prototype.getVariablesOfType=function(a){return(a=this.variableMap_[a||\"\"])?a.slice():[]};\nBlockly.VariableMap.prototype.getVariableTypes=function(a){var b={};Blockly.utils.object.mixin(b,this.variableMap_);a&&a.getPotentialVariableMap()&&Blockly.utils.object.mixin(b,a.getPotentialVariableMap().variableMap_);a=Object.keys(b);b=!1;for(var c=0;c<a.length;c++)\"\"==a[c]&&(b=!0);b||a.push(\"\");return a};Blockly.VariableMap.prototype.getAllVariables=function(){var a=[],b;for(b in this.variableMap_)a=a.concat(this.variableMap_[b]);return a};\nBlockly.VariableMap.prototype.getAllVariableNames=function(){var a=[],b;for(b in this.variableMap_)for(var c=this.variableMap_[b],d=0,e;e=c[d];d++)a.push(e.name);return a};Blockly.VariableMap.prototype.getVariableUsesById=function(a){for(var b=[],c=this.workspace.getAllBlocks(!1),d=0;d<c.length;d++){var e=c[d].getVarModels();if(e)for(var f=0;f<e.length;f++)e[f].getId()==a&&b.push(c[d])}return b};Blockly.Workspace=function(a){this.id=Blockly.utils.genUid();Blockly.Workspace.WorkspaceDB_[this.id]=this;this.options=a||new Blockly.Options({});this.RTL=!!this.options.RTL;this.horizontalLayout=!!this.options.horizontalLayout;this.toolboxPosition=this.options.toolboxPosition;this.topBlocks_=[];this.topComments_=[];this.commentDB_=Object.create(null);this.listeners_=[];this.undoStack_=[];this.redoStack_=[];this.blockDB_=Object.create(null);this.typedBlocksDB_=Object.create(null);this.variableMap_=\nnew Blockly.VariableMap(this);this.potentialVariableMap_=null};Blockly.Workspace.prototype.rendered=!1;Blockly.Workspace.prototype.isClearing=!1;Blockly.Workspace.prototype.MAX_UNDO=1024;Blockly.Workspace.prototype.connectionDBList=null;Blockly.Workspace.prototype.dispose=function(){this.listeners_.length=0;this.clear();delete Blockly.Workspace.WorkspaceDB_[this.id]};Blockly.Workspace.SCAN_ANGLE=3;\nBlockly.Workspace.prototype.sortObjects_=function(a,b){a=a.getRelativeToSurfaceXY();b=b.getRelativeToSurfaceXY();return a.y+Blockly.Workspace.prototype.sortObjects_.offset*a.x-(b.y+Blockly.Workspace.prototype.sortObjects_.offset*b.x)};Blockly.Workspace.prototype.addTopBlock=function(a){this.topBlocks_.push(a)};Blockly.Workspace.prototype.removeTopBlock=function(a){if(!Blockly.utils.arrayRemove(this.topBlocks_,a))throw Error(\"Block not present in workspace's list of top-most blocks.\");};\nBlockly.Workspace.prototype.getTopBlocks=function(a){var b=[].concat(this.topBlocks_);a&&1<b.length&&(this.sortObjects_.offset=Math.sin(Blockly.utils.math.toRadians(Blockly.Workspace.SCAN_ANGLE)),this.RTL&&(this.sortObjects_.offset*=-1),b.sort(this.sortObjects_));return b};Blockly.Workspace.prototype.addTypedBlock=function(a){this.typedBlocksDB_[a.type]||(this.typedBlocksDB_[a.type]=[]);this.typedBlocksDB_[a.type].push(a)};\nBlockly.Workspace.prototype.removeTypedBlock=function(a){this.typedBlocksDB_[a.type].splice(this.typedBlocksDB_[a.type].indexOf(a),1);this.typedBlocksDB_[a.type].length||delete this.typedBlocksDB_[a.type]};\nBlockly.Workspace.prototype.getBlocksByType=function(a,b){if(!this.typedBlocksDB_[a])return[];a=this.typedBlocksDB_[a].slice(0);b&&1<a.length&&(this.sortObjects_.offset=Math.sin(Blockly.utils.math.toRadians(Blockly.Workspace.SCAN_ANGLE)),this.RTL&&(this.sortObjects_.offset*=-1),a.sort(this.sortObjects_));return a};\nBlockly.Workspace.prototype.addTopComment=function(a){this.topComments_.push(a);this.commentDB_[a.id]&&console.warn('Overriding an existing comment on this workspace, with id \"'+a.id+'\"');this.commentDB_[a.id]=a};Blockly.Workspace.prototype.removeTopComment=function(a){if(!Blockly.utils.arrayRemove(this.topComments_,a))throw Error(\"Comment not present in workspace's list of top-most comments.\");delete this.commentDB_[a.id]};\nBlockly.Workspace.prototype.getTopComments=function(a){var b=[].concat(this.topComments_);a&&1<b.length&&(this.sortObjects_.offset=Math.sin(Blockly.utils.math.toRadians(Blockly.Workspace.SCAN_ANGLE)),this.RTL&&(this.sortObjects_.offset*=-1),b.sort(this.sortObjects_));return b};\nBlockly.Workspace.prototype.getAllBlocks=function(a){if(a){a=this.getTopBlocks(!0);for(var b=[],c=0;c<a.length;c++)b.push.apply(b,a[c].getDescendants(!0))}else for(b=this.getTopBlocks(!1),c=0;c<b.length;c++)b.push.apply(b,b[c].getChildren(!1));return b.filter(function(a){return!a.isInsertionMarker()})};\nBlockly.Workspace.prototype.clear=function(){this.isClearing=!0;try{var a=Blockly.Events.getGroup();for(a||Blockly.Events.setGroup(!0);this.topBlocks_.length;)this.topBlocks_[0].dispose(!1);for(;this.topComments_.length;)this.topComments_[this.topComments_.length-1].dispose(!1);a||Blockly.Events.setGroup(!1);this.variableMap_.clear();this.potentialVariableMap_&&this.potentialVariableMap_.clear()}finally{this.isClearing=!1}};\nBlockly.Workspace.prototype.renameVariableById=function(a,b){this.variableMap_.renameVariableById(a,b)};Blockly.Workspace.prototype.createVariable=function(a,b,c){return this.variableMap_.createVariable(a,b,c)};Blockly.Workspace.prototype.getVariableUsesById=function(a){return this.variableMap_.getVariableUsesById(a)};Blockly.Workspace.prototype.deleteVariableById=function(a){this.variableMap_.deleteVariableById(a)};\nBlockly.Workspace.prototype.deleteVariableInternal_=function(a,b){this.variableMap_.deleteVariableInternal(a,b)};Blockly.Workspace.prototype.variableIndexOf=function(a){console.warn(\"Deprecated call to Blockly.Workspace.prototype.variableIndexOf\");return-1};Blockly.Workspace.prototype.getVariable=function(a,b){return this.variableMap_.getVariable(a,b)};Blockly.Workspace.prototype.getVariableById=function(a){return this.variableMap_.getVariableById(a)};\nBlockly.Workspace.prototype.getVariablesOfType=function(a){return this.variableMap_.getVariablesOfType(a)};Blockly.Workspace.prototype.getVariableTypes=function(){return this.variableMap_.getVariableTypes(this)};Blockly.Workspace.prototype.getAllVariables=function(){return this.variableMap_.getAllVariables()};Blockly.Workspace.prototype.getAllVariableNames=function(){return this.variableMap_.getAllVariableNames()};Blockly.Workspace.prototype.getWidth=function(){return 0};\nBlockly.Workspace.prototype.newBlock=function(a,b){return new Blockly.Block(this,a,b)};Blockly.Workspace.prototype.remainingCapacity=function(){return isNaN(this.options.maxBlocks)?Infinity:this.options.maxBlocks-this.getAllBlocks(!1).length};Blockly.Workspace.prototype.remainingCapacityOfType=function(a){return this.options.maxInstances?(this.options.maxInstances[a]||Infinity)-this.getBlocksByType(a,!1).length:Infinity};\nBlockly.Workspace.prototype.isCapacityAvailable=function(a){if(!this.hasBlockLimits())return!0;var b=0,c;for(c in a){if(a[c]>this.remainingCapacityOfType(c))return!1;b+=a[c]}return b>this.remainingCapacity()?!1:!0};Blockly.Workspace.prototype.hasBlockLimits=function(){return Infinity!=this.options.maxBlocks||!!this.options.maxInstances};\nBlockly.Workspace.prototype.undo=function(a){var b=a?this.redoStack_:this.undoStack_,c=a?this.undoStack_:this.redoStack_,d=b.pop();if(d){for(var e=[d];b.length&&d.group&&d.group==b[b.length-1].group;)e.push(b.pop());for(b=0;d=e[b];b++)c.push(d);e=Blockly.Events.filter(e,a);Blockly.Events.recordUndo=!1;try{for(b=0;d=e[b];b++)d.run(a)}finally{Blockly.Events.recordUndo=!0}}};Blockly.Workspace.prototype.clearUndo=function(){this.undoStack_.length=0;this.redoStack_.length=0;Blockly.Events.clearPendingUndo()};\nBlockly.Workspace.prototype.addChangeListener=function(a){this.listeners_.push(a);return a};Blockly.Workspace.prototype.removeChangeListener=function(a){Blockly.utils.arrayRemove(this.listeners_,a)};Blockly.Workspace.prototype.fireChangeListener=function(a){if(a.recordUndo)for(this.undoStack_.push(a),this.redoStack_.length=0;this.undoStack_.length>this.MAX_UNDO&&0<=this.MAX_UNDO;)this.undoStack_.shift();for(var b=0,c;c=this.listeners_[b];b++)c(a)};\nBlockly.Workspace.prototype.getBlockById=function(a){return this.blockDB_[a]||null};Blockly.Workspace.prototype.setBlockById=function(a,b){this.blockDB_[a]=b};Blockly.Workspace.prototype.removeBlockById=function(a){delete this.blockDB_[a]};Blockly.Workspace.prototype.getCommentById=function(a){return this.commentDB_[a]||null};Blockly.Workspace.prototype.allInputsFilled=function(a){for(var b=this.getTopBlocks(!1),c=0,d;d=b[c];c++)if(!d.allInputsFilled(a))return!1;return!0};\nBlockly.Workspace.prototype.getPotentialVariableMap=function(){return this.potentialVariableMap_};Blockly.Workspace.prototype.createPotentialVariableMap=function(){this.potentialVariableMap_=new Blockly.VariableMap(this)};Blockly.Workspace.prototype.getVariableMap=function(){return this.variableMap_};Blockly.Workspace.prototype.setVariableMap=function(a){this.variableMap_=a};Blockly.Workspace.WorkspaceDB_=Object.create(null);\nBlockly.Workspace.getById=function(a){return Blockly.Workspace.WorkspaceDB_[a]||null};Blockly.Workspace.getAll=function(){var a=[],b;for(b in Blockly.Workspace.WorkspaceDB_)a.push(Blockly.Workspace.WorkspaceDB_[b]);return a};Blockly.Bubble=function(a,b,c,d,e,f){this.workspace_=a;this.content_=b;this.shape_=c;this.onMouseDownResizeWrapper_=this.onMouseDownBubbleWrapper_=this.moveCallback_=this.resizeCallback_=null;this.disposed=!1;c=Blockly.Bubble.ARROW_ANGLE;this.workspace_.RTL&&(c=-c);this.arrow_radians_=Blockly.utils.math.toRadians(c);a.getBubbleCanvas().appendChild(this.createDom_(b,!(!e||!f)));this.setAnchorLocation(d);e&&f||(a=this.content_.getBBox(),e=a.width+2*Blockly.Bubble.BORDER_WIDTH,f=a.height+2*Blockly.Bubble.BORDER_WIDTH);\nthis.setBubbleSize(e,f);this.positionBubble_();this.renderArrow_();this.rendered_=!0};Blockly.Bubble.BORDER_WIDTH=6;Blockly.Bubble.ARROW_THICKNESS=5;Blockly.Bubble.ARROW_ANGLE=20;Blockly.Bubble.ARROW_BEND=4;Blockly.Bubble.ANCHOR_RADIUS=8;Blockly.Bubble.onMouseUpWrapper_=null;Blockly.Bubble.onMouseMoveWrapper_=null;\nBlockly.Bubble.unbindDragEvents_=function(){Blockly.Bubble.onMouseUpWrapper_&&(Blockly.unbindEvent_(Blockly.Bubble.onMouseUpWrapper_),Blockly.Bubble.onMouseUpWrapper_=null);Blockly.Bubble.onMouseMoveWrapper_&&(Blockly.unbindEvent_(Blockly.Bubble.onMouseMoveWrapper_),Blockly.Bubble.onMouseMoveWrapper_=null)};Blockly.Bubble.bubbleMouseUp_=function(a){Blockly.Touch.clearTouchIdentifier();Blockly.Bubble.unbindDragEvents_()};Blockly.Bubble.prototype.rendered_=!1;Blockly.Bubble.prototype.anchorXY_=null;\nBlockly.Bubble.prototype.relativeLeft_=0;Blockly.Bubble.prototype.relativeTop_=0;Blockly.Bubble.prototype.width_=0;Blockly.Bubble.prototype.height_=0;Blockly.Bubble.prototype.autoLayout_=!0;\nBlockly.Bubble.prototype.createDom_=function(a,b){this.bubbleGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},null);var c={filter:\"url(#\"+this.workspace_.getRenderer().getConstants().embossFilterId+\")\"};Blockly.utils.userAgent.JAVA_FX&&(c={});c=Blockly.utils.dom.createSvgElement(\"g\",c,this.bubbleGroup_);this.bubbleArrow_=Blockly.utils.dom.createSvgElement(\"path\",{},c);this.bubbleBack_=Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyDraggable\",x:0,y:0,rx:Blockly.Bubble.BORDER_WIDTH,ry:Blockly.Bubble.BORDER_WIDTH},\nc);b?(this.resizeGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":this.workspace_.RTL?\"blocklyResizeSW\":\"blocklyResizeSE\"},this.bubbleGroup_),b=2*Blockly.Bubble.BORDER_WIDTH,Blockly.utils.dom.createSvgElement(\"polygon\",{points:\"0,x x,x x,0\".replace(/x/g,b.toString())},this.resizeGroup_),Blockly.utils.dom.createSvgElement(\"line\",{\"class\":\"blocklyResizeLine\",x1:b/3,y1:b-1,x2:b-1,y2:b/3},this.resizeGroup_),Blockly.utils.dom.createSvgElement(\"line\",{\"class\":\"blocklyResizeLine\",x1:2*b/3,y1:b-1,x2:b-\n1,y2:2*b/3},this.resizeGroup_)):this.resizeGroup_=null;this.workspace_.options.readOnly||(this.onMouseDownBubbleWrapper_=Blockly.bindEventWithChecks_(this.bubbleBack_,\"mousedown\",this,this.bubbleMouseDown_),this.resizeGroup_&&(this.onMouseDownResizeWrapper_=Blockly.bindEventWithChecks_(this.resizeGroup_,\"mousedown\",this,this.resizeMouseDown_)));this.bubbleGroup_.appendChild(a);return this.bubbleGroup_};Blockly.Bubble.prototype.getSvgRoot=function(){return this.bubbleGroup_};\nBlockly.Bubble.prototype.setSvgId=function(a){this.bubbleGroup_.dataset&&(this.bubbleGroup_.dataset.blockId=a)};Blockly.Bubble.prototype.bubbleMouseDown_=function(a){var b=this.workspace_.getGesture(a);b&&b.handleBubbleStart(a,this)};Blockly.Bubble.prototype.showContextMenu=function(a){};Blockly.Bubble.prototype.isDeletable=function(){return!1};\nBlockly.Bubble.prototype.resizeMouseDown_=function(a){this.promote();Blockly.Bubble.unbindDragEvents_();Blockly.utils.isRightButton(a)||(this.workspace_.startDrag(a,new Blockly.utils.Coordinate(this.workspace_.RTL?-this.width_:this.width_,this.height_)),Blockly.Bubble.onMouseUpWrapper_=Blockly.bindEventWithChecks_(document,\"mouseup\",this,Blockly.Bubble.bubbleMouseUp_),Blockly.Bubble.onMouseMoveWrapper_=Blockly.bindEventWithChecks_(document,\"mousemove\",this,this.resizeMouseMove_),Blockly.hideChaff());\na.stopPropagation()};Blockly.Bubble.prototype.resizeMouseMove_=function(a){this.autoLayout_=!1;a=this.workspace_.moveDrag(a);this.setBubbleSize(this.workspace_.RTL?-a.x:a.x,a.y);this.workspace_.RTL&&this.positionBubble_()};Blockly.Bubble.prototype.registerResizeEvent=function(a){this.resizeCallback_=a};Blockly.Bubble.prototype.registerMoveEvent=function(a){this.moveCallback_=a};\nBlockly.Bubble.prototype.promote=function(){var a=this.bubbleGroup_.parentNode;return a.lastChild!==this.bubbleGroup_?(a.appendChild(this.bubbleGroup_),!0):!1};Blockly.Bubble.prototype.setAnchorLocation=function(a){this.anchorXY_=a;this.rendered_&&this.positionBubble_()};\nBlockly.Bubble.prototype.layoutBubble_=function(){var a=this.workspace_.getMetrics();a.viewLeft/=this.workspace_.scale;a.viewWidth/=this.workspace_.scale;a.viewTop/=this.workspace_.scale;a.viewHeight/=this.workspace_.scale;var b=this.getOptimalRelativeLeft_(a),c=this.getOptimalRelativeTop_(a),d=this.shape_.getBBox(),e={x:b,y:-this.height_-this.workspace_.getRenderer().getConstants().MIN_BLOCK_HEIGHT},f={x:-this.width_-30,y:c};c={x:d.width,y:c};var g={x:b,y:d.height};b=d.width<d.height?c:g;d=d.width<\nd.height?g:c;c=this.getOverlap_(e,a);g=this.getOverlap_(f,a);var h=this.getOverlap_(b,a);a=this.getOverlap_(d,a);a=Math.max(c,g,h,a);c==a?(this.relativeLeft_=e.x,this.relativeTop_=e.y):g==a?(this.relativeLeft_=f.x,this.relativeTop_=f.y):h==a?(this.relativeLeft_=b.x,this.relativeTop_=b.y):(this.relativeLeft_=d.x,this.relativeTop_=d.y)};\nBlockly.Bubble.prototype.getOverlap_=function(a,b){var c=this.workspace_.RTL?this.anchorXY_.x-a.x-this.width_:a.x+this.anchorXY_.x;a=a.y+this.anchorXY_.y;return Math.max(0,Math.min(1,(Math.min(c+this.width_,b.viewLeft+b.viewWidth)-Math.max(c,b.viewLeft))*(Math.min(a+this.height_,b.viewTop+b.viewHeight)-Math.max(a,b.viewTop))/(this.width_*this.height_)))};\nBlockly.Bubble.prototype.getOptimalRelativeLeft_=function(a){var b=-this.width_/4;if(this.width_>a.viewWidth)return b;if(this.workspace_.RTL)var c=this.anchorXY_.x-b,d=c-this.width_,e=a.viewLeft+a.viewWidth,f=a.viewLeft+Blockly.Scrollbar.scrollbarThickness/this.workspace_.scale;else d=b+this.anchorXY_.x,c=d+this.width_,f=a.viewLeft,e=a.viewLeft+a.viewWidth-Blockly.Scrollbar.scrollbarThickness/this.workspace_.scale;this.workspace_.RTL?d<f?b=-(f-this.anchorXY_.x+this.width_):c>e&&(b=-(e-this.anchorXY_.x)):\nd<f?b=f-this.anchorXY_.x:c>e&&(b=e-this.anchorXY_.x-this.width_);return b};Blockly.Bubble.prototype.getOptimalRelativeTop_=function(a){var b=-this.height_/4;if(this.height_>a.viewHeight)return b;var c=this.anchorXY_.y+b,d=c+this.height_,e=a.viewTop;a=a.viewTop+a.viewHeight-Blockly.Scrollbar.scrollbarThickness/this.workspace_.scale;var f=this.anchorXY_.y;c<e?b=e-f:d>a&&(b=a-f-this.height_);return b};\nBlockly.Bubble.prototype.positionBubble_=function(){var a=this.anchorXY_.x;a=this.workspace_.RTL?a-(this.relativeLeft_+this.width_):a+this.relativeLeft_;this.moveTo(a,this.relativeTop_+this.anchorXY_.y)};Blockly.Bubble.prototype.moveTo=function(a,b){this.bubbleGroup_.setAttribute(\"transform\",\"translate(\"+a+\",\"+b+\")\")};Blockly.Bubble.prototype.setDragging=function(a){!a&&this.moveCallback_&&this.moveCallback_()};\nBlockly.Bubble.prototype.getBubbleSize=function(){return new Blockly.utils.Size(this.width_,this.height_)};\nBlockly.Bubble.prototype.setBubbleSize=function(a,b){var c=2*Blockly.Bubble.BORDER_WIDTH;a=Math.max(a,c+45);b=Math.max(b,c+20);this.width_=a;this.height_=b;this.bubbleBack_.setAttribute(\"width\",a);this.bubbleBack_.setAttribute(\"height\",b);this.resizeGroup_&&(this.workspace_.RTL?this.resizeGroup_.setAttribute(\"transform\",\"translate(\"+2*Blockly.Bubble.BORDER_WIDTH+\",\"+(b-c)+\") scale(-1 1)\"):this.resizeGroup_.setAttribute(\"transform\",\"translate(\"+(a-c)+\",\"+(b-c)+\")\"));this.autoLayout_&&this.layoutBubble_();\nthis.positionBubble_();this.renderArrow_();this.resizeCallback_&&this.resizeCallback_()};\nBlockly.Bubble.prototype.renderArrow_=function(){var a=[],b=this.width_/2,c=this.height_/2,d=-this.relativeLeft_,e=-this.relativeTop_;if(b==d&&c==e)a.push(\"M \"+b+\",\"+c);else{e-=c;d-=b;this.workspace_.RTL&&(d*=-1);var f=Math.sqrt(e*e+d*d),g=Math.acos(d/f);0>e&&(g=2*Math.PI-g);var h=g+Math.PI/2;h>2*Math.PI&&(h-=2*Math.PI);var k=Math.sin(h),l=Math.cos(h),m=this.getBubbleSize();h=(m.width+m.height)/Blockly.Bubble.ARROW_THICKNESS;h=Math.min(h,m.width,m.height)/4;m=1-Blockly.Bubble.ANCHOR_RADIUS/f;d=b+\nm*d;e=c+m*e;m=b+h*l;var n=c+h*k;b-=h*l;c-=h*k;k=g+this.arrow_radians_;k>2*Math.PI&&(k-=2*Math.PI);g=Math.sin(k)*f/Blockly.Bubble.ARROW_BEND;f=Math.cos(k)*f/Blockly.Bubble.ARROW_BEND;a.push(\"M\"+m+\",\"+n);a.push(\"C\"+(m+f)+\",\"+(n+g)+\" \"+d+\",\"+e+\" \"+d+\",\"+e);a.push(\"C\"+d+\",\"+e+\" \"+(b+f)+\",\"+(c+g)+\" \"+b+\",\"+c)}a.push(\"z\");this.bubbleArrow_.setAttribute(\"d\",a.join(\" \"))};Blockly.Bubble.prototype.setColour=function(a){this.bubbleBack_.setAttribute(\"fill\",a);this.bubbleArrow_.setAttribute(\"fill\",a)};\nBlockly.Bubble.prototype.dispose=function(){this.onMouseDownBubbleWrapper_&&Blockly.unbindEvent_(this.onMouseDownBubbleWrapper_);this.onMouseDownResizeWrapper_&&Blockly.unbindEvent_(this.onMouseDownResizeWrapper_);Blockly.Bubble.unbindDragEvents_();Blockly.utils.dom.removeNode(this.bubbleGroup_);this.disposed=!0};\nBlockly.Bubble.prototype.moveDuringDrag=function(a,b){a?a.translateSurface(b.x,b.y):this.moveTo(b.x,b.y);this.relativeLeft_=this.workspace_.RTL?this.anchorXY_.x-b.x-this.width_:b.x-this.anchorXY_.x;this.relativeTop_=b.y-this.anchorXY_.y;this.renderArrow_()};Blockly.Bubble.prototype.getRelativeToSurfaceXY=function(){return new Blockly.utils.Coordinate(this.workspace_.RTL?-this.relativeLeft_+this.anchorXY_.x-this.width_:this.anchorXY_.x+this.relativeLeft_,this.anchorXY_.y+this.relativeTop_)};\nBlockly.Bubble.prototype.setAutoLayout=function(a){this.autoLayout_=a};Blockly.Events.CommentBase=function(a){this.commentId=a.id;this.workspaceId=a.workspace.id;this.group=Blockly.Events.getGroup();this.recordUndo=Blockly.Events.recordUndo};Blockly.utils.object.inherits(Blockly.Events.CommentBase,Blockly.Events.Abstract);Blockly.Events.CommentBase.prototype.toJson=function(){var a=Blockly.Events.CommentBase.superClass_.toJson.call(this);this.commentId&&(a.commentId=this.commentId);return a};\nBlockly.Events.CommentBase.prototype.fromJson=function(a){Blockly.Events.CommentBase.superClass_.fromJson.call(this,a);this.commentId=a.commentId};Blockly.Events.CommentChange=function(a,b,c){a&&(Blockly.Events.CommentChange.superClass_.constructor.call(this,a),this.oldContents_=b,this.newContents_=c)};Blockly.utils.object.inherits(Blockly.Events.CommentChange,Blockly.Events.CommentBase);Blockly.Events.CommentChange.prototype.type=Blockly.Events.COMMENT_CHANGE;\nBlockly.Events.CommentChange.prototype.toJson=function(){var a=Blockly.Events.CommentChange.superClass_.toJson.call(this);a.newContents=this.newContents_;return a};Blockly.Events.CommentChange.prototype.fromJson=function(a){Blockly.Events.CommentChange.superClass_.fromJson.call(this,a);this.newContents_=a.newValue};Blockly.Events.CommentChange.prototype.isNull=function(){return this.oldContents_==this.newContents_};\nBlockly.Events.CommentChange.prototype.run=function(a){var b=this.getEventWorkspace_().getCommentById(this.commentId);b?b.setContent(a?this.newContents_:this.oldContents_):console.warn(\"Can't change non-existent comment: \"+this.commentId)};Blockly.Events.CommentCreate=function(a){a&&(Blockly.Events.CommentCreate.superClass_.constructor.call(this,a),this.xml=a.toXmlWithXY())};Blockly.utils.object.inherits(Blockly.Events.CommentCreate,Blockly.Events.CommentBase);\nBlockly.Events.CommentCreate.prototype.type=Blockly.Events.COMMENT_CREATE;Blockly.Events.CommentCreate.prototype.toJson=function(){var a=Blockly.Events.CommentCreate.superClass_.toJson.call(this);a.xml=Blockly.Xml.domToText(this.xml);return a};Blockly.Events.CommentCreate.prototype.fromJson=function(a){Blockly.Events.CommentCreate.superClass_.fromJson.call(this,a);this.xml=Blockly.Xml.textToDom(a.xml)};\nBlockly.Events.CommentCreate.prototype.run=function(a){Blockly.Events.CommentCreateDeleteHelper(this,a)};Blockly.Events.CommentCreateDeleteHelper=function(a,b){var c=a.getEventWorkspace_();b?(b=Blockly.utils.xml.createElement(\"xml\"),b.appendChild(a.xml),Blockly.Xml.domToWorkspace(b,c)):(c=c.getCommentById(a.commentId))?c.dispose(!1,!1):console.warn(\"Can't uncreate non-existent comment: \"+a.commentId)};\nBlockly.Events.CommentDelete=function(a){a&&(Blockly.Events.CommentDelete.superClass_.constructor.call(this,a),this.xml=a.toXmlWithXY())};Blockly.utils.object.inherits(Blockly.Events.CommentDelete,Blockly.Events.CommentBase);Blockly.Events.CommentDelete.prototype.type=Blockly.Events.COMMENT_DELETE;Blockly.Events.CommentDelete.prototype.toJson=function(){return Blockly.Events.CommentDelete.superClass_.toJson.call(this)};\nBlockly.Events.CommentDelete.prototype.fromJson=function(a){Blockly.Events.CommentDelete.superClass_.fromJson.call(this,a)};Blockly.Events.CommentDelete.prototype.run=function(a){Blockly.Events.CommentCreateDeleteHelper(this,!a)};Blockly.Events.CommentMove=function(a){a&&(Blockly.Events.CommentMove.superClass_.constructor.call(this,a),this.comment_=a,this.oldCoordinate_=a.getXY(),this.newCoordinate_=null)};Blockly.utils.object.inherits(Blockly.Events.CommentMove,Blockly.Events.CommentBase);\nBlockly.Events.CommentMove.prototype.recordNew=function(){if(!this.comment_)throw Error(\"Tried to record the new position of a comment on the same event twice.\");this.newCoordinate_=this.comment_.getXY();this.comment_=null};Blockly.Events.CommentMove.prototype.type=Blockly.Events.COMMENT_MOVE;Blockly.Events.CommentMove.prototype.setOldCoordinate=function(a){this.oldCoordinate_=a};\nBlockly.Events.CommentMove.prototype.toJson=function(){var a=Blockly.Events.CommentMove.superClass_.toJson.call(this);this.newCoordinate_&&(a.newCoordinate=Math.round(this.newCoordinate_.x)+\",\"+Math.round(this.newCoordinate_.y));return a};Blockly.Events.CommentMove.prototype.fromJson=function(a){Blockly.Events.CommentMove.superClass_.fromJson.call(this,a);a.newCoordinate&&(a=a.newCoordinate.split(\",\"),this.newCoordinate_=new Blockly.utils.Coordinate(Number(a[0]),Number(a[1])))};\nBlockly.Events.CommentMove.prototype.isNull=function(){return Blockly.utils.Coordinate.equals(this.oldCoordinate_,this.newCoordinate_)};Blockly.Events.CommentMove.prototype.run=function(a){var b=this.getEventWorkspace_().getCommentById(this.commentId);if(b){a=a?this.newCoordinate_:this.oldCoordinate_;var c=b.getXY();b.moveBy(a.x-c.x,a.y-c.y)}else console.warn(\"Can't move non-existent comment: \"+this.commentId)};Blockly.BubbleDragger=function(a,b){this.draggingBubble_=a;this.workspace_=b;this.deleteArea_=null;this.wouldDeleteBubble_=!1;this.startXY_=this.draggingBubble_.getRelativeToSurfaceXY();this.dragSurface_=Blockly.utils.is3dSupported()&&b.getBlockDragSurface()?b.getBlockDragSurface():null};Blockly.BubbleDragger.prototype.dispose=function(){this.dragSurface_=this.workspace_=this.draggingBubble_=null};\nBlockly.BubbleDragger.prototype.startBubbleDrag=function(){Blockly.Events.getGroup()||Blockly.Events.setGroup(!0);this.workspace_.setResizesEnabled(!1);this.draggingBubble_.setAutoLayout(!1);this.dragSurface_&&this.moveToDragSurface_();this.draggingBubble_.setDragging&&this.draggingBubble_.setDragging(!0);var a=this.workspace_.getToolbox();if(a){var b=this.draggingBubble_.isDeletable()?\"blocklyToolboxDelete\":\"blocklyToolboxGrab\";a.addStyle(b)}};\nBlockly.BubbleDragger.prototype.dragBubble=function(a,b){b=this.pixelsToWorkspaceUnits_(b);b=Blockly.utils.Coordinate.sum(this.startXY_,b);this.draggingBubble_.moveDuringDrag(this.dragSurface_,b);this.draggingBubble_.isDeletable()&&(this.deleteArea_=this.workspace_.isDeleteArea(a),this.updateCursorDuringBubbleDrag_())};\nBlockly.BubbleDragger.prototype.maybeDeleteBubble_=function(){var a=this.workspace_.trashcan;this.wouldDeleteBubble_?(a&&setTimeout(a.close.bind(a),100),this.fireMoveEvent_(),this.draggingBubble_.dispose(!1,!0)):a&&a.close();return this.wouldDeleteBubble_};\nBlockly.BubbleDragger.prototype.updateCursorDuringBubbleDrag_=function(){this.wouldDeleteBubble_=this.deleteArea_!=Blockly.DELETE_AREA_NONE;var a=this.workspace_.trashcan;this.wouldDeleteBubble_?(this.draggingBubble_.setDeleteStyle(!0),this.deleteArea_==Blockly.DELETE_AREA_TRASH&&a&&a.setOpen(!0)):(this.draggingBubble_.setDeleteStyle(!1),a&&a.setOpen(!1))};\nBlockly.BubbleDragger.prototype.endBubbleDrag=function(a,b){this.dragBubble(a,b);a=this.pixelsToWorkspaceUnits_(b);a=Blockly.utils.Coordinate.sum(this.startXY_,a);this.draggingBubble_.moveTo(a.x,a.y);this.maybeDeleteBubble_()||(this.dragSurface_&&this.dragSurface_.clearAndHide(this.workspace_.getBubbleCanvas()),this.draggingBubble_.setDragging&&this.draggingBubble_.setDragging(!1),this.fireMoveEvent_());this.workspace_.setResizesEnabled(!0);this.workspace_.getToolbox()&&(a=this.draggingBubble_.isDeletable()?\n\"blocklyToolboxDelete\":\"blocklyToolboxGrab\",this.workspace_.getToolbox().removeStyle(a));Blockly.Events.setGroup(!1)};Blockly.BubbleDragger.prototype.fireMoveEvent_=function(){if(this.draggingBubble_.isComment){var a=new Blockly.Events.CommentMove(this.draggingBubble_);a.setOldCoordinate(this.startXY_);a.recordNew();Blockly.Events.fire(a)}};\nBlockly.BubbleDragger.prototype.pixelsToWorkspaceUnits_=function(a){a=new Blockly.utils.Coordinate(a.x/this.workspace_.scale,a.y/this.workspace_.scale);this.workspace_.isMutator&&a.scale(1/this.workspace_.options.parentWorkspace.scale);return a};Blockly.BubbleDragger.prototype.moveToDragSurface_=function(){this.draggingBubble_.moveTo(0,0);this.dragSurface_.translateSurface(this.startXY_.x,this.startXY_.y);this.dragSurface_.setBlocksAndShow(this.draggingBubble_.getSvgRoot())};Blockly.WorkspaceDragger=function(a){this.workspace_=a;this.startScrollXY_=new Blockly.utils.Coordinate(a.scrollX,a.scrollY)};Blockly.WorkspaceDragger.prototype.dispose=function(){this.workspace_=null};Blockly.WorkspaceDragger.prototype.startDrag=function(){Blockly.selected&&Blockly.selected.unselect();this.workspace_.setupDragSurface()};Blockly.WorkspaceDragger.prototype.endDrag=function(a){this.drag(a);this.workspace_.resetDragSurface()};\nBlockly.WorkspaceDragger.prototype.drag=function(a){a=Blockly.utils.Coordinate.sum(this.startScrollXY_,a);this.workspace_.scroll(a.x,a.y)};Blockly.FlyoutDragger=function(a){Blockly.FlyoutDragger.superClass_.constructor.call(this,a.getWorkspace());this.scrollbar_=a.scrollbar_;this.horizontalLayout_=a.horizontalLayout_};Blockly.utils.object.inherits(Blockly.FlyoutDragger,Blockly.WorkspaceDragger);Blockly.FlyoutDragger.prototype.drag=function(a){a=Blockly.utils.Coordinate.sum(this.startScrollXY_,a);this.horizontalLayout_?this.scrollbar_.set(-a.x):this.scrollbar_.set(-a.y)};Blockly.Action=function(a,b){this.name=a;this.desc=b};Blockly.navigation={};Blockly.navigation.loggingCallback=null;Blockly.navigation.STATE_FLYOUT=1;Blockly.navigation.STATE_WS=2;Blockly.navigation.STATE_TOOLBOX=3;Blockly.navigation.WS_MOVE_DISTANCE=40;Blockly.navigation.currentState_=Blockly.navigation.STATE_WS;\nBlockly.navigation.actionNames={PREVIOUS:\"previous\",NEXT:\"next\",IN:\"in\",OUT:\"out\",INSERT:\"insert\",MARK:\"mark\",DISCONNECT:\"disconnect\",TOOLBOX:\"toolbox\",EXIT:\"exit\",TOGGLE_KEYBOARD_NAV:\"toggle_keyboard_nav\",MOVE_WS_CURSOR_UP:\"move workspace cursor up\",MOVE_WS_CURSOR_DOWN:\"move workspace cursor down\",MOVE_WS_CURSOR_LEFT:\"move workspace cursor left\",MOVE_WS_CURSOR_RIGHT:\"move workspace cursor right\"};Blockly.navigation.MARKER_NAME=\"local_marker_1\";Blockly.navigation.getMarker=function(){return Blockly.getMainWorkspace().getMarker(Blockly.navigation.MARKER_NAME)};\nBlockly.navigation.focusToolbox_=function(){var a=Blockly.getMainWorkspace().getToolbox();a&&(Blockly.navigation.currentState_=Blockly.navigation.STATE_TOOLBOX,Blockly.navigation.resetFlyout_(!1),Blockly.navigation.getMarker().getCurNode()||Blockly.navigation.markAtCursor_(),a.selectFirstCategory())};\nBlockly.navigation.focusFlyout_=function(){Blockly.navigation.currentState_=Blockly.navigation.STATE_FLYOUT;var a=Blockly.getMainWorkspace();var b=a.getToolbox();a=b?b.flyout_:a.getFlyout();Blockly.navigation.getMarker().getCurNode()||Blockly.navigation.markAtCursor_();a&&a.getWorkspace()&&(a=a.getWorkspace().getTopBlocks(!0),0<a.length&&(a=a[0],a=Blockly.ASTNode.createStackNode(a),Blockly.navigation.getFlyoutCursor_().setCurNode(a)))};\nBlockly.navigation.focusWorkspace_=function(){Blockly.hideChaff();var a=Blockly.getMainWorkspace(),b=a.getCursor(),c=!!a.getToolbox(),d=a.getTopBlocks(!0);Blockly.navigation.resetFlyout_(c);Blockly.navigation.currentState_=Blockly.navigation.STATE_WS;0<d.length?b.setCurNode(Blockly.navigation.getTopNode(d[0])):(c=new Blockly.utils.Coordinate(100,100),a=Blockly.ASTNode.createWorkspaceNode(a,c),b.setCurNode(a))};\nBlockly.navigation.getFlyoutCursor_=function(){var a=Blockly.getMainWorkspace(),b=null;a.rendered&&(b=(a=(b=a.getToolbox())?b.flyout_:a.getFlyout())?a.workspace_.getCursor():null);return b};\nBlockly.navigation.insertFromFlyout=function(){var a=Blockly.getMainWorkspace(),b=a.getFlyout();if(b&&b.isVisible()){var c=Blockly.navigation.getFlyoutCursor_().getCurNode().getLocation();c.isEnabled()?(b=b.createBlock(c),b.render(),b.setConnectionTracking(!0),a.getCursor().setCurNode(Blockly.ASTNode.createBlockNode(b)),Blockly.navigation.modify_()||Blockly.navigation.warn_(\"Something went wrong while inserting a block from the flyout.\"),Blockly.navigation.focusWorkspace_(),a.getCursor().setCurNode(Blockly.navigation.getTopNode(b)),\nBlockly.navigation.removeMark_()):Blockly.navigation.warn_(\"Can't insert a disabled block.\")}else Blockly.navigation.warn_(\"Trying to insert from the flyout when the flyout does not  exist or is not visible\")};Blockly.navigation.resetFlyout_=function(a){Blockly.navigation.getFlyoutCursor_()&&(Blockly.navigation.getFlyoutCursor_().hide(),a&&Blockly.getMainWorkspace().getFlyout().hide())};\nBlockly.navigation.modifyWarn_=function(){var a=Blockly.navigation.getMarker().getCurNode(),b=Blockly.getMainWorkspace().getCursor().getCurNode();if(!a)return Blockly.navigation.warn_(\"Cannot insert with no marked node.\"),!1;if(!b)return Blockly.navigation.warn_(\"Cannot insert with no cursor node.\"),!1;a=a.getType();b=b.getType();return a==Blockly.ASTNode.types.FIELD?(Blockly.navigation.warn_(\"Should not have been able to mark a field.\"),!1):a==Blockly.ASTNode.types.BLOCK?(Blockly.navigation.warn_(\"Should not have been able to mark a block.\"),\n!1):a==Blockly.ASTNode.types.STACK?(Blockly.navigation.warn_(\"Should not have been able to mark a stack.\"),!1):b==Blockly.ASTNode.types.FIELD?(Blockly.navigation.warn_(\"Cannot attach a field to anything else.\"),!1):b==Blockly.ASTNode.types.WORKSPACE?(Blockly.navigation.warn_(\"Cannot attach a workspace to anything else.\"),!1):!0};\nBlockly.navigation.moveBlockToWorkspace_=function(a,b){if(!a)return!1;if(a.isShadow())return Blockly.navigation.warn_(\"Cannot move a shadow block to the workspace.\"),!1;a.getParent()&&a.unplug(!1);a.moveTo(b.getWsCoordinate());return!0};\nBlockly.navigation.modify_=function(){var a=Blockly.navigation.getMarker().getCurNode(),b=Blockly.getMainWorkspace().getCursor().getCurNode();if(!Blockly.navigation.modifyWarn_())return!1;var c=a.getType(),d=b.getType(),e=b.getLocation(),f=a.getLocation();if(a.isConnection()&&b.isConnection())return Blockly.navigation.connect_(e,f);if(a.isConnection()&&(d==Blockly.ASTNode.types.BLOCK||d==Blockly.ASTNode.types.STACK))return Blockly.navigation.insertBlock(e,f);if(c==Blockly.ASTNode.types.WORKSPACE)return b=\nb?b.getSourceBlock():null,Blockly.navigation.moveBlockToWorkspace_(b,a);Blockly.navigation.warn_(\"Unexpected state in Blockly.navigation.modify_.\");return!1};Blockly.navigation.disconnectChild_=function(a,b){var c=a.getSourceBlock(),d=b.getSourceBlock();c.getRootBlock()==d.getRootBlock()&&(-1<c.getDescendants(!1).indexOf(d)?Blockly.navigation.getInferiorConnection_(b).disconnect():Blockly.navigation.getInferiorConnection_(a).disconnect())};\nBlockly.navigation.moveAndConnect_=function(a,b){if(!a||!b)return!1;var c=a.getSourceBlock();return b.canConnectWithReason(a)==Blockly.Connection.CAN_CONNECT?(Blockly.navigation.disconnectChild_(a,b),b.isSuperior()||c.getRootBlock().positionNearConnection(a,b),b.connect(a),!0):!1};Blockly.navigation.getInferiorConnection_=function(a){var b=a.getSourceBlock();return a.isSuperior()?b.previousConnection?b.previousConnection:b.outputConnection?b.outputConnection:null:a};\nBlockly.navigation.getSuperiorConnection_=function(a){return a.isSuperior()?a:a.targetConnection?a.targetConnection:null};\nBlockly.navigation.connect_=function(a,b){if(!a||!b)return!1;var c=Blockly.navigation.getInferiorConnection_(a),d=Blockly.navigation.getSuperiorConnection_(b),e=Blockly.navigation.getSuperiorConnection_(a),f=Blockly.navigation.getInferiorConnection_(b);if(c&&d&&Blockly.navigation.moveAndConnect_(c,d)||e&&f&&Blockly.navigation.moveAndConnect_(e,f)||Blockly.navigation.moveAndConnect_(a,b))return!0;try{b.checkConnection(a)}catch(g){Blockly.navigation.warn_(\"Connection failed with error: \"+g)}return!1};\nBlockly.navigation.insertBlock=function(a,b){switch(b.type){case Blockly.PREVIOUS_STATEMENT:if(Blockly.navigation.connect_(a.nextConnection,b))return!0;break;case Blockly.NEXT_STATEMENT:if(Blockly.navigation.connect_(a.previousConnection,b))return!0;break;case Blockly.INPUT_VALUE:if(Blockly.navigation.connect_(a.outputConnection,b))return!0;break;case Blockly.OUTPUT_VALUE:for(var c=0;c<a.inputList.length;c++){var d=a.inputList[c].connection;if(d&&d.type===Blockly.INPUT_VALUE&&Blockly.navigation.connect_(d,\nb))return!0}if(a.outputConnection&&Blockly.navigation.connect_(a.outputConnection,b))return!0}Blockly.navigation.warn_(\"This block can not be inserted at the marked location.\");return!1};\nBlockly.navigation.disconnectBlocks_=function(){var a=Blockly.getMainWorkspace(),b=a.getCursor().getCurNode();if(b.isConnection()){var c=b.getLocation();c.isConnected()?(b=c.isSuperior()?c:c.targetConnection,c=c.isSuperior()?c.targetConnection:c,c.getSourceBlock().isShadow()?Blockly.navigation.log_(\"Cannot disconnect a shadow block\"):(b.disconnect(),c.bumpAwayFrom(b),b.getSourceBlock().getRootBlock().bringToFront(),b=Blockly.ASTNode.createConnectionNode(b),a.getCursor().setCurNode(b))):Blockly.navigation.log_(\"Cannot disconnect unconnected connection\")}else Blockly.navigation.log_(\"Cannot disconnect blocks when the cursor is not on a connection\")};\nBlockly.navigation.markAtCursor_=function(){Blockly.navigation.getMarker().setCurNode(Blockly.getMainWorkspace().getCursor().getCurNode())};Blockly.navigation.removeMark_=function(){var a=Blockly.navigation.getMarker();a.setCurNode(null);a.hide()};Blockly.navigation.setState=function(a){Blockly.navigation.currentState_=a};Blockly.navigation.getTopNode=function(a){var b=a.previousConnection||a.outputConnection;return b?Blockly.ASTNode.createConnectionNode(b):Blockly.ASTNode.createBlockNode(a)};\nBlockly.navigation.moveCursorOnBlockDelete=function(a){var b=Blockly.getMainWorkspace();if(b&&(b=b.getCursor())){var c=b.getCurNode();c=c?c.getSourceBlock():null;c===a?c.getParent()?(a=c.previousConnection||c.outputConnection)&&b.setCurNode(Blockly.ASTNode.createConnectionNode(a.targetConnection)):b.setCurNode(Blockly.ASTNode.createWorkspaceNode(c.workspace,c.getRelativeToSurfaceXY())):c&&-1<a.getChildren(!1).indexOf(c)&&b.setCurNode(Blockly.ASTNode.createWorkspaceNode(c.workspace,c.getRelativeToSurfaceXY()))}};\nBlockly.navigation.moveCursorOnBlockMutation=function(a){var b=Blockly.getMainWorkspace().getCursor();if(b){var c=b.getCurNode();c=c?c.getSourceBlock():null;c===a&&b.setCurNode(Blockly.ASTNode.createBlockNode(c))}};Blockly.navigation.enableKeyboardAccessibility=function(){Blockly.getMainWorkspace().keyboardAccessibilityMode||(Blockly.getMainWorkspace().keyboardAccessibilityMode=!0,Blockly.navigation.focusWorkspace_())};\nBlockly.navigation.disableKeyboardAccessibility=function(){if(Blockly.getMainWorkspace().keyboardAccessibilityMode){var a=Blockly.getMainWorkspace();Blockly.getMainWorkspace().keyboardAccessibilityMode=!1;a.getCursor().hide();Blockly.navigation.getMarker().hide();Blockly.navigation.getFlyoutCursor_()&&Blockly.navigation.getFlyoutCursor_().hide()}};Blockly.navigation.log_=function(a){Blockly.navigation.loggingCallback?Blockly.navigation.loggingCallback(\"log\",a):console.log(a)};\nBlockly.navigation.warn_=function(a){Blockly.navigation.loggingCallback?Blockly.navigation.loggingCallback(\"warn\",a):console.warn(a)};Blockly.navigation.error_=function(a){Blockly.navigation.loggingCallback?Blockly.navigation.loggingCallback(\"error\",a):console.error(a)};Blockly.navigation.onKeyPress=function(a){a=Blockly.user.keyMap.serializeKeyEvent(a);return(a=Blockly.user.keyMap.getActionByKeyCode(a))?Blockly.navigation.onBlocklyAction(a):!1};\nBlockly.navigation.onBlocklyAction=function(a){var b=Blockly.getMainWorkspace().options.readOnly,c=!1;Blockly.getMainWorkspace().keyboardAccessibilityMode?b?-1<Blockly.navigation.READONLY_ACTION_LIST.indexOf(a)&&(c=Blockly.navigation.handleActions_(a)):c=Blockly.navigation.handleActions_(a):a.name===Blockly.navigation.actionNames.TOGGLE_KEYBOARD_NAV&&(Blockly.navigation.enableKeyboardAccessibility(),c=!0);return c};\nBlockly.navigation.handleActions_=function(a){return a.name==Blockly.navigation.actionNames.TOOLBOX||Blockly.navigation.currentState_==Blockly.navigation.STATE_TOOLBOX?Blockly.navigation.toolboxOnAction_(a):a.name==Blockly.navigation.actionNames.TOGGLE_KEYBOARD_NAV?(Blockly.navigation.disableKeyboardAccessibility(),!0):Blockly.navigation.currentState_==Blockly.navigation.STATE_WS?Blockly.navigation.workspaceOnAction_(a):Blockly.navigation.currentState_==Blockly.navigation.STATE_FLYOUT?Blockly.navigation.flyoutOnAction_(a):\n!1};Blockly.navigation.flyoutOnAction_=function(a){var b=Blockly.getMainWorkspace(),c=b.getToolbox();if((b=c?c.flyout_:b.getFlyout())&&b.onBlocklyAction(a))return!0;switch(a.name){case Blockly.navigation.actionNames.OUT:return Blockly.navigation.focusToolbox_(),!0;case Blockly.navigation.actionNames.MARK:return Blockly.navigation.insertFromFlyout(),!0;case Blockly.navigation.actionNames.EXIT:return Blockly.navigation.focusWorkspace_(),!0;default:return!1}};\nBlockly.navigation.toolboxOnAction_=function(a){var b=Blockly.getMainWorkspace(),c=b.getToolbox();return c&&c.onBlocklyAction(a)?!0:a.name===Blockly.navigation.actionNames.TOOLBOX?(b.getToolbox()?Blockly.navigation.focusToolbox_():Blockly.navigation.focusFlyout_(),!0):a.name===Blockly.navigation.actionNames.IN?(Blockly.navigation.focusFlyout_(),!0):a.name===Blockly.navigation.actionNames.EXIT?(Blockly.navigation.focusWorkspace_(),!0):!1};\nBlockly.navigation.moveWSCursor_=function(a,b){var c=Blockly.getMainWorkspace().getCursor(),d=Blockly.getMainWorkspace().getCursor().getCurNode();if(d.getType()!==Blockly.ASTNode.types.WORKSPACE)return!1;d=d.getWsCoordinate();a=a*Blockly.navigation.WS_MOVE_DISTANCE+d.x;b=b*Blockly.navigation.WS_MOVE_DISTANCE+d.y;c.setCurNode(Blockly.ASTNode.createWorkspaceNode(Blockly.getMainWorkspace(),new Blockly.utils.Coordinate(a,b)));return!0};\nBlockly.navigation.workspaceOnAction_=function(a){if(Blockly.getMainWorkspace().getCursor().onBlocklyAction(a))return!0;switch(a.name){case Blockly.navigation.actionNames.INSERT:return Blockly.navigation.modify_(),!0;case Blockly.navigation.actionNames.MARK:return Blockly.navigation.handleEnterForWS_(),!0;case Blockly.navigation.actionNames.DISCONNECT:return Blockly.navigation.disconnectBlocks_(),!0;case Blockly.navigation.actionNames.MOVE_WS_CURSOR_UP:return Blockly.navigation.moveWSCursor_(0,-1);\ncase Blockly.navigation.actionNames.MOVE_WS_CURSOR_DOWN:return Blockly.navigation.moveWSCursor_(0,1);case Blockly.navigation.actionNames.MOVE_WS_CURSOR_LEFT:return Blockly.navigation.moveWSCursor_(-1,0);case Blockly.navigation.actionNames.MOVE_WS_CURSOR_RIGHT:return Blockly.navigation.moveWSCursor_(1,0);default:return!1}};\nBlockly.navigation.handleEnterForWS_=function(){var a=Blockly.getMainWorkspace().getCursor().getCurNode(),b=a.getType();b==Blockly.ASTNode.types.FIELD?a.getLocation().showEditor():a.isConnection()||b==Blockly.ASTNode.types.WORKSPACE?Blockly.navigation.markAtCursor_():b==Blockly.ASTNode.types.BLOCK?Blockly.navigation.warn_(\"Cannot mark a block.\"):b==Blockly.ASTNode.types.STACK&&Blockly.navigation.warn_(\"Cannot mark a stack.\")};\nBlockly.navigation.ACTION_PREVIOUS=new Blockly.Action(Blockly.navigation.actionNames.PREVIOUS,\"Go to the previous location.\");Blockly.navigation.ACTION_OUT=new Blockly.Action(Blockly.navigation.actionNames.OUT,\"Go to the parent of the current location.\");Blockly.navigation.ACTION_NEXT=new Blockly.Action(Blockly.navigation.actionNames.NEXT,\"Go to the next location.\");Blockly.navigation.ACTION_IN=new Blockly.Action(Blockly.navigation.actionNames.IN,\"Go to the first child of the current location.\");\nBlockly.navigation.ACTION_INSERT=new Blockly.Action(Blockly.navigation.actionNames.INSERT,\"Connect the current location to the marked location.\");Blockly.navigation.ACTION_MARK=new Blockly.Action(Blockly.navigation.actionNames.MARK,\"Mark the current location.\");Blockly.navigation.ACTION_DISCONNECT=new Blockly.Action(Blockly.navigation.actionNames.DISCONNECT,\"Disconnect the block at the current location from its parent.\");\nBlockly.navigation.ACTION_TOOLBOX=new Blockly.Action(Blockly.navigation.actionNames.TOOLBOX,\"Open the toolbox.\");Blockly.navigation.ACTION_EXIT=new Blockly.Action(Blockly.navigation.actionNames.EXIT,\"Close the current modal, such as a toolbox or field editor.\");Blockly.navigation.ACTION_TOGGLE_KEYBOARD_NAV=new Blockly.Action(Blockly.navigation.actionNames.TOGGLE_KEYBOARD_NAV,\"Turns on and off keyboard navigation.\");\nBlockly.navigation.ACTION_MOVE_WS_CURSOR_LEFT=new Blockly.Action(Blockly.navigation.actionNames.MOVE_WS_CURSOR_LEFT,\"Move the workspace cursor to the lefts.\");Blockly.navigation.ACTION_MOVE_WS_CURSOR_RIGHT=new Blockly.Action(Blockly.navigation.actionNames.MOVE_WS_CURSOR_RIGHT,\"Move the workspace cursor to the right.\");Blockly.navigation.ACTION_MOVE_WS_CURSOR_UP=new Blockly.Action(Blockly.navigation.actionNames.MOVE_WS_CURSOR_UP,\"Move the workspace cursor up.\");\nBlockly.navigation.ACTION_MOVE_WS_CURSOR_DOWN=new Blockly.Action(Blockly.navigation.actionNames.MOVE_WS_CURSOR_DOWN,\"Move the workspace cursor down.\");Blockly.navigation.READONLY_ACTION_LIST=[Blockly.navigation.ACTION_PREVIOUS,Blockly.navigation.ACTION_OUT,Blockly.navigation.ACTION_IN,Blockly.navigation.ACTION_NEXT,Blockly.navigation.ACTION_TOGGLE_KEYBOARD_NAV];Blockly.Gesture=function(a,b){this.mouseDownXY_=null;this.currentDragDeltaXY_=new Blockly.utils.Coordinate(0,0);this.startWorkspace_=this.targetBlock_=this.startBlock_=this.startField_=this.startBubble_=null;this.creatorWorkspace_=b;this.isDraggingBubble_=this.isDraggingBlock_=this.isDraggingWorkspace_=this.hasExceededDragRadius_=!1;this.mostRecentEvent_=a;this.flyout_=this.workspaceDragger_=this.blockDragger_=this.bubbleDragger_=this.onUpWrapper_=this.onMoveWrapper_=null;this.isEnding_=this.hasStarted_=\nthis.calledUpdateIsDragging_=!1;this.healStack_=!Blockly.DRAG_STACK};Blockly.Gesture.prototype.dispose=function(){Blockly.Touch.clearTouchIdentifier();Blockly.Tooltip.unblock();this.creatorWorkspace_.clearGesture();this.onMoveWrapper_&&Blockly.unbindEvent_(this.onMoveWrapper_);this.onUpWrapper_&&Blockly.unbindEvent_(this.onUpWrapper_);this.blockDragger_&&this.blockDragger_.dispose();this.workspaceDragger_&&this.workspaceDragger_.dispose();this.bubbleDragger_&&this.bubbleDragger_.dispose()};\nBlockly.Gesture.prototype.updateFromEvent_=function(a){var b=new Blockly.utils.Coordinate(a.clientX,a.clientY);this.updateDragDelta_(b)&&(this.updateIsDragging_(),Blockly.longStop_());this.mostRecentEvent_=a};\nBlockly.Gesture.prototype.updateDragDelta_=function(a){this.currentDragDeltaXY_=Blockly.utils.Coordinate.difference(a,this.mouseDownXY_);return this.hasExceededDragRadius_?!1:this.hasExceededDragRadius_=Blockly.utils.Coordinate.magnitude(this.currentDragDeltaXY_)>(this.flyout_?Blockly.FLYOUT_DRAG_RADIUS:Blockly.DRAG_RADIUS)};\nBlockly.Gesture.prototype.updateIsDraggingFromFlyout_=function(){return this.targetBlock_&&this.flyout_.isBlockCreatable_(this.targetBlock_)?!this.flyout_.isScrollable()||this.flyout_.isDragTowardWorkspace(this.currentDragDeltaXY_)?(this.startWorkspace_=this.flyout_.targetWorkspace_,this.startWorkspace_.updateScreenCalculationsIfScrolled(),Blockly.Events.getGroup()||Blockly.Events.setGroup(!0),this.startBlock_=null,this.targetBlock_=this.flyout_.createBlock(this.targetBlock_),this.targetBlock_.select(),\n!0):!1:!1};Blockly.Gesture.prototype.updateIsDraggingBubble_=function(){if(!this.startBubble_)return!1;this.isDraggingBubble_=!0;this.startDraggingBubble_();return!0};Blockly.Gesture.prototype.updateIsDraggingBlock_=function(){if(!this.targetBlock_)return!1;this.flyout_?this.isDraggingBlock_=this.updateIsDraggingFromFlyout_():this.targetBlock_.isMovable()&&(this.isDraggingBlock_=!0);return this.isDraggingBlock_?(this.startDraggingBlock_(),!0):!1};\nBlockly.Gesture.prototype.updateIsDraggingWorkspace_=function(){if(this.flyout_?this.flyout_.isScrollable():this.startWorkspace_&&this.startWorkspace_.isDraggable())this.workspaceDragger_=this.flyout_?new Blockly.FlyoutDragger(this.flyout_):new Blockly.WorkspaceDragger(this.startWorkspace_),this.isDraggingWorkspace_=!0,this.workspaceDragger_.startDrag()};\nBlockly.Gesture.prototype.updateIsDragging_=function(){if(this.calledUpdateIsDragging_)throw Error(\"updateIsDragging_ should only be called once per gesture.\");this.calledUpdateIsDragging_=!0;this.updateIsDraggingBubble_()||this.updateIsDraggingBlock_()||this.updateIsDraggingWorkspace_()};\nBlockly.Gesture.prototype.startDraggingBlock_=function(){this.blockDragger_=new Blockly.BlockDragger(this.targetBlock_,this.startWorkspace_);this.blockDragger_.startBlockDrag(this.currentDragDeltaXY_,this.healStack_);this.blockDragger_.dragBlock(this.mostRecentEvent_,this.currentDragDeltaXY_)};\nBlockly.Gesture.prototype.startDraggingBubble_=function(){this.bubbleDragger_=new Blockly.BubbleDragger(this.startBubble_,this.startWorkspace_);this.bubbleDragger_.startBubbleDrag();this.bubbleDragger_.dragBubble(this.mostRecentEvent_,this.currentDragDeltaXY_)};\nBlockly.Gesture.prototype.doStart=function(a){Blockly.utils.isTargetInput(a)?this.cancel():(this.hasStarted_=!0,Blockly.blockAnimations.disconnectUiStop(),this.startWorkspace_.updateScreenCalculationsIfScrolled(),this.startWorkspace_.isMutator&&this.startWorkspace_.resize(),Blockly.hideChaff(!!this.flyout_),this.startWorkspace_.markFocused(),this.mostRecentEvent_=a,Blockly.Tooltip.block(),this.targetBlock_&&(!this.targetBlock_.isInFlyout&&a.shiftKey&&this.targetBlock_.workspace.keyboardAccessibilityMode?\nthis.creatorWorkspace_.getCursor().setCurNode(Blockly.navigation.getTopNode(this.targetBlock_)):this.targetBlock_.select()),Blockly.utils.isRightButton(a)?this.handleRightClick(a):(\"touchstart\"!=a.type.toLowerCase()&&\"pointerdown\"!=a.type.toLowerCase()||\"mouse\"==a.pointerType||Blockly.longStart(a,this),this.mouseDownXY_=new Blockly.utils.Coordinate(a.clientX,a.clientY),this.healStack_=a.altKey||a.ctrlKey||a.metaKey,this.bindMouseEvents(a)))};\nBlockly.Gesture.prototype.bindMouseEvents=function(a){this.onMoveWrapper_=Blockly.bindEventWithChecks_(document,\"mousemove\",null,this.handleMove.bind(this));this.onUpWrapper_=Blockly.bindEventWithChecks_(document,\"mouseup\",null,this.handleUp.bind(this));a.preventDefault();a.stopPropagation()};\nBlockly.Gesture.prototype.handleMove=function(a){this.updateFromEvent_(a);this.isDraggingWorkspace_?this.workspaceDragger_.drag(this.currentDragDeltaXY_):this.isDraggingBlock_?this.blockDragger_.dragBlock(this.mostRecentEvent_,this.currentDragDeltaXY_):this.isDraggingBubble_&&this.bubbleDragger_.dragBubble(this.mostRecentEvent_,this.currentDragDeltaXY_);a.preventDefault();a.stopPropagation()};\nBlockly.Gesture.prototype.handleUp=function(a){this.updateFromEvent_(a);Blockly.longStop_();this.isEnding_?console.log(\"Trying to end a gesture recursively.\"):(this.isEnding_=!0,this.isDraggingBubble_?this.bubbleDragger_.endBubbleDrag(a,this.currentDragDeltaXY_):this.isDraggingBlock_?this.blockDragger_.endBlockDrag(a,this.currentDragDeltaXY_):this.isDraggingWorkspace_?this.workspaceDragger_.endDrag(this.currentDragDeltaXY_):this.isBubbleClick_()?this.doBubbleClick_():this.isFieldClick_()?this.doFieldClick_():\nthis.isBlockClick_()?this.doBlockClick_():this.isWorkspaceClick_()&&this.doWorkspaceClick_(a),a.preventDefault(),a.stopPropagation(),this.dispose())};\nBlockly.Gesture.prototype.cancel=function(){this.isEnding_||(Blockly.longStop_(),this.isDraggingBubble_?this.bubbleDragger_.endBubbleDrag(this.mostRecentEvent_,this.currentDragDeltaXY_):this.isDraggingBlock_?this.blockDragger_.endBlockDrag(this.mostRecentEvent_,this.currentDragDeltaXY_):this.isDraggingWorkspace_&&this.workspaceDragger_.endDrag(this.currentDragDeltaXY_),this.dispose())};\nBlockly.Gesture.prototype.handleRightClick=function(a){this.targetBlock_?(this.bringBlockToFront_(),Blockly.hideChaff(!!this.flyout_),this.targetBlock_.showContextMenu(a)):this.startBubble_?this.startBubble_.showContextMenu(a):this.startWorkspace_&&!this.flyout_&&(Blockly.hideChaff(),this.startWorkspace_.showContextMenu(a));a.preventDefault();a.stopPropagation();this.dispose()};\nBlockly.Gesture.prototype.handleWsStart=function(a,b){if(this.hasStarted_)throw Error(\"Tried to call gesture.handleWsStart, but the gesture had already been started.\");this.setStartWorkspace_(b);this.mostRecentEvent_=a;this.doStart(a);this.startWorkspace_.keyboardAccessibilityMode&&Blockly.navigation.setState(Blockly.navigation.STATE_WS)};\nBlockly.Gesture.prototype.handleFlyoutStart=function(a,b){if(this.hasStarted_)throw Error(\"Tried to call gesture.handleFlyoutStart, but the gesture had already been started.\");this.setStartFlyout_(b);this.handleWsStart(a,b.getWorkspace())};Blockly.Gesture.prototype.handleBlockStart=function(a,b){if(this.hasStarted_)throw Error(\"Tried to call gesture.handleBlockStart, but the gesture had already been started.\");this.setStartBlock(b);this.mostRecentEvent_=a};\nBlockly.Gesture.prototype.handleBubbleStart=function(a,b){if(this.hasStarted_)throw Error(\"Tried to call gesture.handleBubbleStart, but the gesture had already been started.\");this.setStartBubble(b);this.mostRecentEvent_=a};Blockly.Gesture.prototype.doBubbleClick_=function(){this.startBubble_.setFocus&&this.startBubble_.setFocus();this.startBubble_.select&&this.startBubble_.select()};Blockly.Gesture.prototype.doFieldClick_=function(){this.startField_.showEditor(this.mostRecentEvent_);this.bringBlockToFront_()};\nBlockly.Gesture.prototype.doBlockClick_=function(){this.flyout_&&this.flyout_.autoClose?this.targetBlock_.isEnabled()&&(Blockly.Events.getGroup()||Blockly.Events.setGroup(!0),this.flyout_.createBlock(this.targetBlock_).scheduleSnapAndBump()):Blockly.Events.fire(new Blockly.Events.Ui(this.startBlock_,\"click\",void 0,void 0));this.bringBlockToFront_();Blockly.Events.setGroup(!1)};\nBlockly.Gesture.prototype.doWorkspaceClick_=function(a){var b=this.creatorWorkspace_;a.shiftKey&&b.keyboardAccessibilityMode?(a=new Blockly.utils.Coordinate(a.clientX,a.clientY),a=Blockly.utils.screenToWsCoordinates(b,a),a=Blockly.ASTNode.createWorkspaceNode(b,a),b.getCursor().setCurNode(a)):Blockly.selected&&Blockly.selected.unselect()};Blockly.Gesture.prototype.bringBlockToFront_=function(){this.targetBlock_&&!this.flyout_&&this.targetBlock_.bringToFront()};\nBlockly.Gesture.prototype.setStartField=function(a){if(this.hasStarted_)throw Error(\"Tried to call gesture.setStartField, but the gesture had already been started.\");this.startField_||(this.startField_=a)};Blockly.Gesture.prototype.setStartBubble=function(a){this.startBubble_||(this.startBubble_=a)};Blockly.Gesture.prototype.setStartBlock=function(a){this.startBlock_||this.startBubble_||(this.startBlock_=a,a.isInFlyout&&a!=a.getRootBlock()?this.setTargetBlock_(a.getRootBlock()):this.setTargetBlock_(a))};\nBlockly.Gesture.prototype.setTargetBlock_=function(a){a.isShadow()?this.setTargetBlock_(a.getParent()):this.targetBlock_=a};Blockly.Gesture.prototype.setStartWorkspace_=function(a){this.startWorkspace_||(this.startWorkspace_=a)};Blockly.Gesture.prototype.setStartFlyout_=function(a){this.flyout_||(this.flyout_=a)};Blockly.Gesture.prototype.isBubbleClick_=function(){return!!this.startBubble_&&!this.hasExceededDragRadius_};\nBlockly.Gesture.prototype.isBlockClick_=function(){return!!this.startBlock_&&!this.hasExceededDragRadius_&&!this.isFieldClick_()};Blockly.Gesture.prototype.isFieldClick_=function(){return(this.startField_?this.startField_.isClickable():!1)&&!this.hasExceededDragRadius_&&(!this.flyout_||!this.flyout_.autoClose)};Blockly.Gesture.prototype.isWorkspaceClick_=function(){return!this.startBlock_&&!this.startBubble_&&!this.startField_&&!this.hasExceededDragRadius_};\nBlockly.Gesture.prototype.isDragging=function(){return this.isDraggingWorkspace_||this.isDraggingBlock_||this.isDraggingBubble_};Blockly.Gesture.prototype.hasStarted=function(){return this.hasStarted_};Blockly.Gesture.prototype.getInsertionMarkers=function(){return this.blockDragger_?this.blockDragger_.getInsertionMarkers():[]};Blockly.Gesture.inProgress=function(){for(var a=Blockly.Workspace.getAll(),b=0,c;c=a[b];b++)if(c.currentGesture_)return!0;return!1};Blockly.Field=function(a,b,c){this.tooltip_=this.validator_=this.value_=null;this.size_=new Blockly.utils.Size(0,0);this.constants_=this.mouseDownWrapper_=this.textContent_=this.textElement_=this.borderRect_=this.fieldGroup_=this.markerSvg_=this.cursorSvg_=null;c&&this.configure_(c);this.setValue(a);b&&this.setValidator(b)};Blockly.Field.prototype.name=void 0;Blockly.Field.prototype.disposed=!1;Blockly.Field.prototype.maxDisplayLength=50;Blockly.Field.prototype.sourceBlock_=null;\nBlockly.Field.prototype.isDirty_=!0;Blockly.Field.prototype.visible_=!0;Blockly.Field.prototype.clickTarget_=null;Blockly.Field.NBSP=\"\\u00a0\";Blockly.Field.prototype.EDITABLE=!0;Blockly.Field.prototype.SERIALIZABLE=!1;Blockly.Field.prototype.configure_=function(a){var b=a.tooltip;\"string\"==typeof b&&(b=Blockly.utils.replaceMessageReferences(a.tooltip));b&&this.setTooltip(b)};\nBlockly.Field.prototype.setSourceBlock=function(a){if(this.sourceBlock_)throw Error(\"Field already bound to a block.\");this.sourceBlock_=a};Blockly.Field.prototype.getConstants=function(){!this.constants_&&this.sourceBlock_&&this.sourceBlock_.workspace&&this.sourceBlock_.workspace.rendered&&(this.constants_=this.sourceBlock_.workspace.getRenderer().getConstants());return this.constants_};Blockly.Field.prototype.getSourceBlock=function(){return this.sourceBlock_};\nBlockly.Field.prototype.init=function(){this.fieldGroup_||(this.fieldGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},null),this.isVisible()||(this.fieldGroup_.style.display=\"none\"),this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_),this.initView(),this.updateEditable(),this.setTooltip(this.tooltip_),this.bindEvents_(),this.initModel())};Blockly.Field.prototype.initView=function(){this.createBorderRect_();this.createTextElement_()};Blockly.Field.prototype.initModel=function(){};\nBlockly.Field.prototype.createBorderRect_=function(){this.borderRect_=Blockly.utils.dom.createSvgElement(\"rect\",{rx:this.getConstants().FIELD_BORDER_RECT_RADIUS,ry:this.getConstants().FIELD_BORDER_RECT_RADIUS,x:0,y:0,height:this.size_.height,width:this.size_.width,\"class\":\"blocklyFieldRect\"},this.fieldGroup_)};\nBlockly.Field.prototype.createTextElement_=function(){this.textElement_=Blockly.utils.dom.createSvgElement(\"text\",{\"class\":\"blocklyText\"},this.fieldGroup_);this.getConstants().FIELD_TEXT_BASELINE_CENTER&&this.textElement_.setAttribute(\"dominant-baseline\",\"central\");this.textContent_=document.createTextNode(\"\");this.textElement_.appendChild(this.textContent_)};\nBlockly.Field.prototype.bindEvents_=function(){Blockly.Tooltip.bindMouseEvents(this.getClickTarget_());this.mouseDownWrapper_=Blockly.bindEventWithChecks_(this.getClickTarget_(),\"mousedown\",this,this.onMouseDown_)};Blockly.Field.prototype.fromXml=function(a){this.setValue(a.textContent)};Blockly.Field.prototype.toXml=function(a){a.textContent=this.getValue();return a};\nBlockly.Field.prototype.dispose=function(){Blockly.DropDownDiv.hideIfOwner(this);Blockly.WidgetDiv.hideIfOwner(this);Blockly.Tooltip.unbindMouseEvents(this.getClickTarget_());this.mouseDownWrapper_&&Blockly.unbindEvent_(this.mouseDownWrapper_);Blockly.utils.dom.removeNode(this.fieldGroup_);this.disposed=!0};\nBlockly.Field.prototype.updateEditable=function(){var a=this.fieldGroup_;this.EDITABLE&&a&&(this.sourceBlock_.isEditable()?(Blockly.utils.dom.addClass(a,\"blocklyEditableText\"),Blockly.utils.dom.removeClass(a,\"blocklyNonEditableText\"),a.style.cursor=this.CURSOR):(Blockly.utils.dom.addClass(a,\"blocklyNonEditableText\"),Blockly.utils.dom.removeClass(a,\"blocklyEditableText\"),a.style.cursor=\"\"))};\nBlockly.Field.prototype.isClickable=function(){return!!this.sourceBlock_&&this.sourceBlock_.isEditable()&&!!this.showEditor_&&\"function\"===typeof this.showEditor_};Blockly.Field.prototype.isCurrentlyEditable=function(){return this.EDITABLE&&!!this.sourceBlock_&&this.sourceBlock_.isEditable()};\nBlockly.Field.prototype.isSerializable=function(){var a=!1;this.name&&(this.SERIALIZABLE?a=!0:this.EDITABLE&&(console.warn(\"Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization.\"),a=!0));return a};Blockly.Field.prototype.isVisible=function(){return this.visible_};\nBlockly.Field.prototype.setVisible=function(a){if(this.visible_!=a){this.visible_=a;var b=this.getSvgRoot();b&&(b.style.display=a?\"block\":\"none\")}};Blockly.Field.prototype.setValidator=function(a){this.validator_=a};Blockly.Field.prototype.getValidator=function(){return this.validator_};Blockly.Field.prototype.classValidator=function(a){return a};\nBlockly.Field.prototype.callValidator=function(a){var b=this.classValidator(a);if(null===b)return null;void 0!==b&&(a=b);if(b=this.getValidator()){b=b.call(this,a);if(null===b)return null;void 0!==b&&(a=b)}return a};Blockly.Field.prototype.getSvgRoot=function(){return this.fieldGroup_};Blockly.Field.prototype.applyColour=function(){};Blockly.Field.prototype.render_=function(){this.textContent_&&(this.textContent_.nodeValue=this.getDisplayText_());this.updateSize_()};\nBlockly.Field.prototype.showEditor=function(a){this.isClickable()&&this.showEditor_(a)};Blockly.Field.prototype.updateWidth=function(){console.warn(\"Deprecated call to updateWidth, call Blockly.Field.updateSize_ to force an update to the size of the field, or Blockly.utils.dom.getTextWidth() to check the size of the field.\");this.updateSize_()};\nBlockly.Field.prototype.updateSize_=function(a){var b=this.getConstants();a=void 0!=a?a:this.borderRect_?this.getConstants().FIELD_BORDER_RECT_X_PADDING:0;var c=2*a,d=b.FIELD_TEXT_HEIGHT,e=0;this.textElement_&&(e=Blockly.utils.dom.getFastTextWidth(this.textElement_,b.FIELD_TEXT_FONTSIZE,b.FIELD_TEXT_FONTWEIGHT,b.FIELD_TEXT_FONTFAMILY),c+=e);this.borderRect_&&(d=Math.max(d,b.FIELD_BORDER_RECT_HEIGHT));this.size_.height=d;this.size_.width=c;this.positionTextElement_(a,e);this.positionBorderRect_()};\nBlockly.Field.prototype.positionTextElement_=function(a,b){if(this.textElement_){var c=this.getConstants(),d=this.size_.height/2;this.textElement_.setAttribute(\"x\",this.sourceBlock_.RTL?this.size_.width-b-a:a);this.textElement_.setAttribute(\"y\",c.FIELD_TEXT_BASELINE_CENTER?d:d-c.FIELD_TEXT_HEIGHT/2+c.FIELD_TEXT_BASELINE)}};\nBlockly.Field.prototype.positionBorderRect_=function(){this.borderRect_&&(this.borderRect_.setAttribute(\"width\",this.size_.width),this.borderRect_.setAttribute(\"height\",this.size_.height),this.borderRect_.setAttribute(\"rx\",this.getConstants().FIELD_BORDER_RECT_RADIUS),this.borderRect_.setAttribute(\"ry\",this.getConstants().FIELD_BORDER_RECT_RADIUS))};\nBlockly.Field.prototype.getSize=function(){if(!this.isVisible())return new Blockly.utils.Size(0,0);this.isDirty_?(this.render_(),this.isDirty_=!1):this.visible_&&0==this.size_.width&&(console.warn(\"Deprecated use of setting size_.width to 0 to rerender a field. Set field.isDirty_ to true instead.\"),this.render_());return this.size_};\nBlockly.Field.prototype.getScaledBBox=function(){if(this.borderRect_)a=this.borderRect_.getBoundingClientRect(),c=Blockly.utils.style.getPageOffset(this.borderRect_),d=a.width,a=a.height;else{var a=this.sourceBlock_.getHeightWidth(),b=this.sourceBlock_.workspace.scale,c=this.getAbsoluteXY_(),d=a.width*b;a=a.height*b;Blockly.utils.userAgent.GECKO?(c.x+=1.5*b,c.y+=1.5*b):Blockly.utils.userAgent.EDGE||Blockly.utils.userAgent.IE||(c.x-=.5*b,c.y-=.5*b);d+=1*b;a+=1*b}return{top:c.y,bottom:c.y+a,left:c.x,\nright:c.x+d}};Blockly.Field.prototype.getDisplayText_=function(){var a=this.getText();if(!a)return Blockly.Field.NBSP;a.length>this.maxDisplayLength&&(a=a.substring(0,this.maxDisplayLength-2)+\"\\u2026\");a=a.replace(/\\s/g,Blockly.Field.NBSP);this.sourceBlock_&&this.sourceBlock_.RTL&&(a+=\"\\u200f\");return a};Blockly.Field.prototype.getText=function(){if(this.getText_){var a=this.getText_.call(this);if(null!==a)return String(a)}return String(this.getValue())};\nBlockly.Field.prototype.setText=function(a){throw Error(\"setText method is deprecated\");};Blockly.Field.prototype.markDirty=function(){this.isDirty_=!0;this.constants_=null};Blockly.Field.prototype.forceRerender=function(){this.isDirty_=!0;this.sourceBlock_&&this.sourceBlock_.rendered&&(this.sourceBlock_.render(),this.sourceBlock_.bumpNeighbours(),this.updateMarkers_())};\nBlockly.Field.prototype.setValue=function(a){if(null!==a){var b=this.doClassValidation_(a);a=this.processValidation_(a,b);if(!(a instanceof Error)){if(b=this.getValidator())if(b=b.call(this,a),a=this.processValidation_(a,b),a instanceof Error)return;b=this.getValue();b!==a&&(this.sourceBlock_&&Blockly.Events.isEnabled()&&Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_,\"field\",this.name||null,b,a)),this.doValueUpdate_(a),this.isDirty_&&this.forceRerender())}}};\nBlockly.Field.prototype.processValidation_=function(a,b){if(null===b)return this.doValueInvalid_(a),this.isDirty_&&this.forceRerender(),Error();void 0!==b&&(a=b);return a};Blockly.Field.prototype.getValue=function(){return this.value_};Blockly.Field.prototype.doClassValidation_=function(a){return null===a||void 0===a?null:a=this.classValidator(a)};Blockly.Field.prototype.doValueUpdate_=function(a){this.value_=a;this.isDirty_=!0};Blockly.Field.prototype.doValueInvalid_=function(a){};\nBlockly.Field.prototype.onMouseDown_=function(a){this.sourceBlock_&&this.sourceBlock_.workspace&&(a=this.sourceBlock_.workspace.getGesture(a))&&a.setStartField(this)};Blockly.Field.prototype.setTooltip=function(a){var b=this.getClickTarget_();b?b.tooltip=a||\"\"===a?a:this.sourceBlock_:this.tooltip_=a};Blockly.Field.prototype.getClickTarget_=function(){return this.clickTarget_||this.getSvgRoot()};Blockly.Field.prototype.getAbsoluteXY_=function(){return Blockly.utils.style.getPageOffset(this.getClickTarget_())};\nBlockly.Field.prototype.referencesVariables=function(){return!1};Blockly.Field.prototype.getParentInput=function(){for(var a=null,b=this.sourceBlock_,c=b.inputList,d=0;d<b.inputList.length;d++)for(var e=c[d],f=e.fieldRow,g=0;g<f.length;g++)if(f[g]===this){a=e;break}return a};Blockly.Field.prototype.getFlipRtl=function(){return!1};Blockly.Field.prototype.isTabNavigable=function(){return!1};Blockly.Field.prototype.onBlocklyAction=function(a){return!1};\nBlockly.Field.prototype.setCursorSvg=function(a){a?(this.fieldGroup_.appendChild(a),this.cursorSvg_=a):this.cursorSvg_=null};Blockly.Field.prototype.setMarkerSvg=function(a){a?(this.fieldGroup_.appendChild(a),this.markerSvg_=a):this.markerSvg_=null};Blockly.Field.prototype.updateMarkers_=function(){var a=this.sourceBlock_.workspace;a.keyboardAccessibilityMode&&this.cursorSvg_&&a.getCursor().draw();a.keyboardAccessibilityMode&&this.markerSvg_&&a.getMarker(Blockly.navigation.MARKER_NAME).draw()};Blockly.FieldLabel=function(a,b,c){this.class_=null;null==a&&(a=\"\");Blockly.FieldLabel.superClass_.constructor.call(this,a,null,c);c||(this.class_=b||null)};Blockly.utils.object.inherits(Blockly.FieldLabel,Blockly.Field);Blockly.FieldLabel.fromJson=function(a){var b=Blockly.utils.replaceMessageReferences(a.text);return new Blockly.FieldLabel(b,void 0,a)};Blockly.FieldLabel.prototype.EDITABLE=!1;\nBlockly.FieldLabel.prototype.configure_=function(a){Blockly.FieldLabel.superClass_.configure_.call(this,a);this.class_=a[\"class\"]};Blockly.FieldLabel.prototype.initView=function(){this.createTextElement_();this.class_&&Blockly.utils.dom.addClass(this.textElement_,this.class_)};Blockly.FieldLabel.prototype.doClassValidation_=function(a){return null===a||void 0===a?null:String(a)};\nBlockly.FieldLabel.prototype.setClass=function(a){this.textElement_&&(this.class_&&Blockly.utils.dom.removeClass(this.textElement_,this.class_),a&&Blockly.utils.dom.addClass(this.textElement_,a));this.class_=a};Blockly.fieldRegistry.register(\"field_label\",Blockly.FieldLabel);Blockly.Input=function(a,b,c,d){if(a!=Blockly.DUMMY_INPUT&&!b)throw Error(\"Value inputs and statement inputs must have non-empty name.\");this.type=a;this.name=b;this.sourceBlock_=c;this.connection=d;this.fieldRow=[]};Blockly.Input.prototype.align=Blockly.ALIGN_LEFT;Blockly.Input.prototype.visible_=!0;Blockly.Input.prototype.getSourceBlock=function(){return this.sourceBlock_};Blockly.Input.prototype.appendField=function(a,b){this.insertFieldAt(this.fieldRow.length,a,b);return this};\nBlockly.Input.prototype.insertFieldAt=function(a,b,c){if(0>a||a>this.fieldRow.length)throw Error(\"index \"+a+\" out of bounds.\");if(!(b||\"\"==b&&c))return a;\"string\"==typeof b&&(b=new Blockly.FieldLabel(b));b.setSourceBlock(this.sourceBlock_);this.sourceBlock_.rendered&&b.init();b.name=c;b.prefixField&&(a=this.insertFieldAt(a,b.prefixField));this.fieldRow.splice(a,0,b);++a;b.suffixField&&(a=this.insertFieldAt(a,b.suffixField));this.sourceBlock_.rendered&&(this.sourceBlock_.render(),this.sourceBlock_.bumpNeighbours());\nreturn a};Blockly.Input.prototype.removeField=function(a){for(var b=0,c;c=this.fieldRow[b];b++)if(c.name===a){c.dispose();this.fieldRow.splice(b,1);this.sourceBlock_.rendered&&(this.sourceBlock_.render(),this.sourceBlock_.bumpNeighbours());return}throw Error('Field \"%s\" not found.',a);};Blockly.Input.prototype.isVisible=function(){return this.visible_};\nBlockly.Input.prototype.setVisible=function(a){var b=[];if(this.visible_==a)return b;for(var c=(this.visible_=a)?\"block\":\"none\",d=0,e;e=this.fieldRow[d];d++)e.setVisible(a);this.connection&&(a?b=this.connection.startTrackingAll():this.connection.stopTrackingAll(),d=this.connection.targetBlock())&&(d.getSvgRoot().style.display=c,a||(d.rendered=!1));return b};Blockly.Input.prototype.markDirty=function(){for(var a=0,b;b=this.fieldRow[a];a++)b.markDirty()};\nBlockly.Input.prototype.setCheck=function(a){if(!this.connection)throw Error(\"This input does not have a connection.\");this.connection.setCheck(a);return this};Blockly.Input.prototype.setAlign=function(a){this.align=a;this.sourceBlock_.rendered&&this.sourceBlock_.render();return this};Blockly.Input.prototype.init=function(){if(this.sourceBlock_.workspace.rendered)for(var a=0;a<this.fieldRow.length;a++)this.fieldRow[a].init()};\nBlockly.Input.prototype.dispose=function(){for(var a=0,b;b=this.fieldRow[a];a++)b.dispose();this.connection&&this.connection.dispose();this.sourceBlock_=null};Blockly.Block=function(a,b,c){if(Blockly.Generator&&\"undefined\"!=typeof Blockly.Generator.prototype[b])throw Error('Block prototypeName \"'+b+'\" conflicts with Blockly.Generator members.');this.id=c&&!a.getBlockById(c)?c:Blockly.utils.genUid();a.setBlockById(this.id,this);this.previousConnection=this.nextConnection=this.outputConnection=null;this.inputList=[];this.inputsInline=void 0;this.disabled=!1;this.tooltip=\"\";this.contextMenu=!0;this.parentBlock_=null;this.childBlocks_=[];this.editable_=this.movable_=\nthis.deletable_=!0;this.collapsed_=this.isShadow_=!1;this.comment=this.outputShape_=null;this.commentModel={text:null,pinned:!1,size:new Blockly.utils.Size(160,80)};this.xy_=new Blockly.utils.Coordinate(0,0);this.workspace=a;this.isInFlyout=a.isFlyout;this.isInMutator=a.isMutator;this.RTL=a.RTL;this.isInsertionMarker_=!1;this.hat=void 0;this.statementInputCount=0;if(b){this.type=b;c=Blockly.Blocks[b];if(!c||\"object\"!=typeof c)throw TypeError(\"Unknown block type: \"+b);Blockly.utils.object.mixin(this,\nc)}a.addTopBlock(this);a.addTypedBlock(this);\"function\"==typeof this.init&&this.init();this.inputsInlineDefault=this.inputsInline;if(Blockly.Events.isEnabled()){(a=Blockly.Events.getGroup())||Blockly.Events.setGroup(!0);try{Blockly.Events.fire(new Blockly.Events.BlockCreate(this))}finally{a||Blockly.Events.setGroup(!1)}}\"function\"==typeof this.onchange&&this.setOnChange(this.onchange)};Blockly.Block.prototype.data=null;Blockly.Block.prototype.disposed=!1;Blockly.Block.prototype.hue_=null;\nBlockly.Block.prototype.colour_=\"#000000\";Blockly.Block.prototype.styleName_=null;\nBlockly.Block.prototype.dispose=function(a){if(this.workspace){this.onchangeWrapper_&&this.workspace.removeChangeListener(this.onchangeWrapper_);this.unplug(a);Blockly.Events.isEnabled()&&Blockly.Events.fire(new Blockly.Events.BlockDelete(this));Blockly.Events.disable();try{this.workspace&&(this.workspace.removeTopBlock(this),this.workspace.removeTypedBlock(this),this.workspace.removeBlockById(this.id),this.workspace=null);Blockly.selected==this&&(Blockly.selected=null);for(var b=this.childBlocks_.length-\n1;0<=b;b--)this.childBlocks_[b].dispose(!1);b=0;for(var c;c=this.inputList[b];b++)c.dispose();this.inputList.length=0;var d=this.getConnections_(!0);b=0;for(var e;e=d[b];b++)e.dispose()}finally{Blockly.Events.enable(),this.disposed=!0}}};Blockly.Block.prototype.initModel=function(){for(var a=0,b;b=this.inputList[a];a++)for(var c=0,d;d=b.fieldRow[c];c++)d.initModel&&d.initModel()};Blockly.Block.prototype.unplug=function(a){this.outputConnection?this.unplugFromRow_(a):this.previousConnection&&this.unplugFromStack_(a)};\nBlockly.Block.prototype.unplugFromRow_=function(a){var b=null;this.outputConnection.isConnected()&&(b=this.outputConnection.targetConnection,this.outputConnection.disconnect());if(b&&a&&(a=this.getOnlyValueConnection_())&&a.isConnected()&&!a.targetBlock().isShadow())if(a=a.targetConnection,a.disconnect(),a.checkType(b))b.connect(a);else a.onFailedConnect(b)};\nBlockly.Block.prototype.getOnlyValueConnection_=function(){for(var a=null,b=0;b<this.inputList.length;b++){var c=this.inputList[b].connection;if(c&&c.type==Blockly.INPUT_VALUE&&c.targetConnection){if(a)return null;a=c}}return a};\nBlockly.Block.prototype.unplugFromStack_=function(a){var b=null;this.previousConnection.isConnected()&&(b=this.previousConnection.targetConnection,this.previousConnection.disconnect());var c=this.getNextBlock();a&&c&&!c.isShadow()&&(a=this.nextConnection.targetConnection,a.disconnect(),b&&b.checkType(a)&&b.connect(a))};\nBlockly.Block.prototype.getConnections_=function(a){a=[];this.outputConnection&&a.push(this.outputConnection);this.previousConnection&&a.push(this.previousConnection);this.nextConnection&&a.push(this.nextConnection);for(var b=0,c;c=this.inputList[b];b++)c.connection&&a.push(c.connection);return a};Blockly.Block.prototype.lastConnectionInStack=function(){for(var a=this.nextConnection;a;){var b=a.targetBlock();if(!b)return a;a=b.nextConnection}return null};Blockly.Block.prototype.bumpNeighbours=function(){console.warn(\"Not expected to reach Block.bumpNeighbours function. BlockSvg.bumpNeighbours was expected to be called instead.\")};\nBlockly.Block.prototype.getParent=function(){return this.parentBlock_};Blockly.Block.prototype.getInputWithBlock=function(a){for(var b=0,c;c=this.inputList[b];b++)if(c.connection&&c.connection.targetBlock()==a)return c;return null};Blockly.Block.prototype.getSurroundParent=function(){var a=this;do{var b=a;a=a.getParent();if(!a)return null}while(a.getNextBlock()==b);return a};Blockly.Block.prototype.getNextBlock=function(){return this.nextConnection&&this.nextConnection.targetBlock()};\nBlockly.Block.prototype.getPreviousBlock=function(){return this.previousConnection&&this.previousConnection.targetBlock()};Blockly.Block.prototype.getFirstStatementConnection=function(){for(var a=0,b;b=this.inputList[a];a++)if(b.connection&&b.connection.type==Blockly.NEXT_STATEMENT)return b.connection;return null};Blockly.Block.prototype.getRootBlock=function(){var a=this;do{var b=a;a=b.parentBlock_}while(a);return b};\nBlockly.Block.prototype.getTopStackBlock=function(){var a=this;do var b=a.getPreviousBlock();while(b&&b.getNextBlock()==a&&(a=b));return a};Blockly.Block.prototype.getChildren=function(a){if(!a)return this.childBlocks_;a=[];for(var b=0,c;c=this.inputList[b];b++)c.connection&&(c=c.connection.targetBlock())&&a.push(c);(b=this.getNextBlock())&&a.push(b);return a};\nBlockly.Block.prototype.setParent=function(a){if(a!=this.parentBlock_){if(this.parentBlock_){Blockly.utils.arrayRemove(this.parentBlock_.childBlocks_,this);if(this.previousConnection&&this.previousConnection.isConnected())throw Error(\"Still connected to previous block.\");if(this.outputConnection&&this.outputConnection.isConnected())throw Error(\"Still connected to parent block.\");this.parentBlock_=null}else this.workspace.removeTopBlock(this);(this.parentBlock_=a)?a.childBlocks_.push(this):this.workspace.addTopBlock(this)}};\nBlockly.Block.prototype.getDescendants=function(a){for(var b=[this],c=this.getChildren(a),d,e=0;d=c[e];e++)b.push.apply(b,d.getDescendants(a));return b};Blockly.Block.prototype.isDeletable=function(){return this.deletable_&&!this.isShadow_&&!(this.workspace&&this.workspace.options.readOnly)};Blockly.Block.prototype.setDeletable=function(a){this.deletable_=a};Blockly.Block.prototype.isMovable=function(){return this.movable_&&!this.isShadow_&&!(this.workspace&&this.workspace.options.readOnly)};\nBlockly.Block.prototype.setMovable=function(a){this.movable_=a};Blockly.Block.prototype.isDuplicatable=function(){return this.workspace.hasBlockLimits()?this.workspace.isCapacityAvailable(Blockly.utils.getBlockTypeCounts(this,!0)):!0};Blockly.Block.prototype.isShadow=function(){return this.isShadow_};Blockly.Block.prototype.setShadow=function(a){this.isShadow_=a};Blockly.Block.prototype.isInsertionMarker=function(){return this.isInsertionMarker_};\nBlockly.Block.prototype.setInsertionMarker=function(a){this.isInsertionMarker_=a};Blockly.Block.prototype.isEditable=function(){return this.editable_&&!(this.workspace&&this.workspace.options.readOnly)};Blockly.Block.prototype.setEditable=function(a){this.editable_=a;a=0;for(var b;b=this.inputList[a];a++)for(var c=0,d;d=b.fieldRow[c];c++)d.updateEditable()};Blockly.Block.prototype.isDisposed=function(){return this.disposed};\nBlockly.Block.prototype.getMatchingConnection=function(a,b){var c=this.getConnections_(!0);a=a.getConnections_(!0);if(c.length!=a.length)throw Error(\"Connection lists did not match in length.\");for(var d=0;d<a.length;d++)if(a[d]==b)return c[d];return null};Blockly.Block.prototype.setHelpUrl=function(a){this.helpUrl=a};Blockly.Block.prototype.setTooltip=function(a){this.tooltip=a};Blockly.Block.prototype.getColour=function(){return this.colour_};Blockly.Block.prototype.getStyleName=function(){return this.styleName_};\nBlockly.Block.prototype.getHue=function(){return this.hue_};Blockly.Block.prototype.setColour=function(a){a=Blockly.utils.parseBlockColour(a);this.hue_=a.hue;this.colour_=a.hex};Blockly.Block.prototype.setStyle=function(a){this.styleName_=a};Blockly.Block.prototype.setOnChange=function(a){if(a&&\"function\"!=typeof a)throw Error(\"onchange must be a function.\");this.onchangeWrapper_&&this.workspace.removeChangeListener(this.onchangeWrapper_);if(this.onchange=a)this.onchangeWrapper_=a.bind(this),this.workspace.addChangeListener(this.onchangeWrapper_)};\nBlockly.Block.prototype.getField=function(a){for(var b=0,c;c=this.inputList[b];b++)for(var d=0,e;e=c.fieldRow[d];d++)if(e.name==a)return e;return null};Blockly.Block.prototype.getVars=function(){for(var a=[],b=0,c;c=this.inputList[b];b++)for(var d=0,e;e=c.fieldRow[d];d++)e.referencesVariables()&&a.push(e.getValue());return a};\nBlockly.Block.prototype.getVarModels=function(){for(var a=[],b=0,c;c=this.inputList[b];b++)for(var d=0,e;e=c.fieldRow[d];d++)e.referencesVariables()&&(e=this.workspace.getVariableById(e.getValue()))&&a.push(e);return a};Blockly.Block.prototype.updateVarName=function(a){for(var b=0,c;c=this.inputList[b];b++)for(var d=0,e;e=c.fieldRow[d];d++)e.referencesVariables()&&a.getId()==e.getValue()&&e.refreshVariableName()};\nBlockly.Block.prototype.renameVarById=function(a,b){for(var c=0,d;d=this.inputList[c];c++)for(var e=0,f;f=d.fieldRow[e];e++)f.referencesVariables()&&a==f.getValue()&&f.setValue(b)};Blockly.Block.prototype.getFieldValue=function(a){return(a=this.getField(a))?a.getValue():null};Blockly.Block.prototype.setFieldValue=function(a,b){var c=this.getField(b);if(!c)throw Error('Field \"'+b+'\" not found.');c.setValue(a)};\nBlockly.Block.prototype.setPreviousStatement=function(a,b){if(a){void 0===b&&(b=null);if(!this.previousConnection){if(this.outputConnection)throw Error(\"Remove output connection prior to adding previous connection.\");this.previousConnection=this.makeConnection_(Blockly.PREVIOUS_STATEMENT)}this.previousConnection.setCheck(b)}else if(this.previousConnection){if(this.previousConnection.isConnected())throw Error(\"Must disconnect previous statement before removing connection.\");this.previousConnection.dispose();\nthis.previousConnection=null}};Blockly.Block.prototype.setNextStatement=function(a,b){if(a)void 0===b&&(b=null),this.nextConnection||(this.nextConnection=this.makeConnection_(Blockly.NEXT_STATEMENT)),this.nextConnection.setCheck(b);else if(this.nextConnection){if(this.nextConnection.isConnected())throw Error(\"Must disconnect next statement before removing connection.\");this.nextConnection.dispose();this.nextConnection=null}};\nBlockly.Block.prototype.setOutput=function(a,b){if(a){void 0===b&&(b=null);if(!this.outputConnection){if(this.previousConnection)throw Error(\"Remove previous connection prior to adding output connection.\");this.outputConnection=this.makeConnection_(Blockly.OUTPUT_VALUE)}this.outputConnection.setCheck(b)}else if(this.outputConnection){if(this.outputConnection.isConnected())throw Error(\"Must disconnect output value before removing connection.\");this.outputConnection.dispose();this.outputConnection=\nnull}};Blockly.Block.prototype.setInputsInline=function(a){this.inputsInline!=a&&(Blockly.Events.fire(new Blockly.Events.BlockChange(this,\"inline\",null,this.inputsInline,a)),this.inputsInline=a)};\nBlockly.Block.prototype.getInputsInline=function(){if(void 0!=this.inputsInline)return this.inputsInline;for(var a=1;a<this.inputList.length;a++)if(this.inputList[a-1].type==Blockly.DUMMY_INPUT&&this.inputList[a].type==Blockly.DUMMY_INPUT)return!1;for(a=1;a<this.inputList.length;a++)if(this.inputList[a-1].type==Blockly.INPUT_VALUE&&this.inputList[a].type==Blockly.DUMMY_INPUT)return!0;return!1};Blockly.Block.prototype.setOutputShape=function(a){this.outputShape_=a};\nBlockly.Block.prototype.getOutputShape=function(){return this.outputShape_};Blockly.Block.prototype.setDisabled=function(a){console.warn(\"Deprecated call to Blockly.Block.prototype.setDisabled, use Blockly.Block.prototype.setEnabled instead.\");this.setEnabled(!a)};Blockly.Block.prototype.isEnabled=function(){return!this.disabled};\nBlockly.Block.prototype.setEnabled=function(a){this.isEnabled()!=a&&(Blockly.Events.fire(new Blockly.Events.BlockChange(this,\"disabled\",null,this.disabled,!a)),this.disabled=!a)};Blockly.Block.prototype.getInheritedDisabled=function(){for(var a=this.getSurroundParent();a;){if(a.disabled)return!0;a=a.getSurroundParent()}return!1};Blockly.Block.prototype.isCollapsed=function(){return this.collapsed_};\nBlockly.Block.prototype.setCollapsed=function(a){this.collapsed_!=a&&(Blockly.Events.fire(new Blockly.Events.BlockChange(this,\"collapsed\",null,this.collapsed_,a)),this.collapsed_=a)};\nBlockly.Block.prototype.toString=function(a,b){var c=[],d=b||\"?\";if(this.collapsed_)c.push(this.getInput(\"_TEMP_COLLAPSED_INPUT\").fieldRow[0].getText());else for(var e=0,f;f=this.inputList[e];e++){for(var g=0,h;h=f.fieldRow[g];g++)c.push(h.getText());f.connection&&((f=f.connection.targetBlock())?c.push(f.toString(void 0,b)):c.push(d))}c=c.join(\" \").trim()||\"???\";a&&c.length>a&&(c=c.substring(0,a-3)+\"...\");return c};\nBlockly.Block.prototype.appendValueInput=function(a){return this.appendInput_(Blockly.INPUT_VALUE,a)};Blockly.Block.prototype.appendStatementInput=function(a){return this.appendInput_(Blockly.NEXT_STATEMENT,a)};Blockly.Block.prototype.appendDummyInput=function(a){return this.appendInput_(Blockly.DUMMY_INPUT,a||\"\")};\nBlockly.Block.prototype.jsonInit=function(a){var b=a.type?'Block \"'+a.type+'\": ':\"\";if(a.output&&a.previousStatement)throw Error(b+\"Must not have both an output and a previousStatement.\");a.style&&a.style.hat&&(this.hat=a.style.hat,a.style=null);if(a.style&&a.colour)throw Error(b+\"Must not have both a colour and a style.\");a.style?this.jsonInitStyle_(a,b):this.jsonInitColour_(a,b);for(var c=0;void 0!==a[\"message\"+c];)this.interpolate_(a[\"message\"+c],a[\"args\"+c]||[],a[\"lastDummyAlign\"+c],b),c++;void 0!==\na.inputsInline&&this.setInputsInline(a.inputsInline);void 0!==a.output&&this.setOutput(!0,a.output);void 0!==a.outputShape&&this.setOutputShape(a.outputShape);void 0!==a.previousStatement&&this.setPreviousStatement(!0,a.previousStatement);void 0!==a.nextStatement&&this.setNextStatement(!0,a.nextStatement);void 0!==a.tooltip&&(c=a.tooltip,c=Blockly.utils.replaceMessageReferences(c),this.setTooltip(c));void 0!==a.enableContextMenu&&(c=a.enableContextMenu,this.contextMenu=!!c);void 0!==a.helpUrl&&(c=\na.helpUrl,c=Blockly.utils.replaceMessageReferences(c),this.setHelpUrl(c));\"string\"==typeof a.extensions&&(console.warn(b+\"JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '\"+a.type+\"' block.\"),a.extensions=[a.extensions]);void 0!==a.mutator&&Blockly.Extensions.apply(a.mutator,this,!0);if(Array.isArray(a.extensions))for(a=a.extensions,b=0;b<a.length;++b)Blockly.Extensions.apply(a[b],this,!1)};\nBlockly.Block.prototype.jsonInitColour_=function(a,b){if(\"colour\"in a)if(void 0===a.colour)console.warn(b+\"Undefined colour value.\");else{a=a.colour;try{this.setColour(a)}catch(c){console.warn(b+\"Illegal colour value: \",a)}}};Blockly.Block.prototype.jsonInitStyle_=function(a,b){a=a.style;try{this.setStyle(a)}catch(c){console.warn(b+\"Style does not exist: \",a)}};\nBlockly.Block.prototype.mixin=function(a,b){if(void 0!==b&&\"boolean\"!=typeof b)throw Error(\"opt_disableCheck must be a boolean if provided\");if(!b){b=[];for(var c in a)void 0!==this[c]&&b.push(c);if(b.length)throw Error(\"Mixin will overwrite block members: \"+JSON.stringify(b));}Blockly.utils.object.mixin(this,a)};\nBlockly.Block.prototype.interpolate_=function(a,b,c,d){var e=Blockly.utils.tokenizeInterpolation(a),f=[],g=0;a=[];for(var h=0;h<e.length;h++){var k=e[h];if(\"number\"==typeof k){if(0>=k||k>b.length)throw Error('Block \"'+this.type+'\": Message index %'+k+\" out of range.\");if(f[k])throw Error('Block \"'+this.type+'\": Message index %'+k+\" duplicated.\");f[k]=!0;g++;a.push(b[k-1])}else(k=k.trim())&&a.push(k)}if(g!=b.length)throw Error('Block \"'+this.type+'\": Message does not reference all '+b.length+\" arg(s).\");\na.length&&(\"string\"==typeof a[a.length-1]||Blockly.utils.string.startsWith(a[a.length-1].type,\"field_\"))&&(h={type:\"input_dummy\"},c&&(h.align=c),a.push(h));c={LEFT:Blockly.ALIGN_LEFT,RIGHT:Blockly.ALIGN_RIGHT,CENTRE:Blockly.ALIGN_CENTRE,CENTER:Blockly.ALIGN_CENTRE};b=[];for(h=0;h<a.length;h++)if(f=a[h],\"string\"==typeof f)b.push([f,void 0]);else{e=g=null;do if(k=!1,\"string\"==typeof f)g=new Blockly.FieldLabel(f);else switch(f.type){case \"input_value\":e=this.appendValueInput(f.name);break;case \"input_statement\":e=\nthis.appendStatementInput(f.name);break;case \"input_dummy\":e=this.appendDummyInput(f.name);break;default:g=Blockly.fieldRegistry.fromJson(f),!g&&f.alt&&(f=f.alt,k=!0)}while(k);if(g)b.push([g,f.name]);else if(e){f.check&&e.setCheck(f.check);f.align&&(g=c[f.align.toUpperCase()],void 0===g?console.warn(d+\"Illegal align value: \",f.align):e.setAlign(g));for(f=0;f<b.length;f++)e.appendField(b[f][0],b[f][1]);b.length=0}}};\nBlockly.Block.prototype.appendInput_=function(a,b){var c=null;if(a==Blockly.INPUT_VALUE||a==Blockly.NEXT_STATEMENT)c=this.makeConnection_(a);a==Blockly.NEXT_STATEMENT&&this.statementInputCount++;a=new Blockly.Input(a,b,this,c);this.inputList.push(a);return a};\nBlockly.Block.prototype.moveInputBefore=function(a,b){if(a!=b){for(var c=-1,d=b?-1:this.inputList.length,e=0,f;f=this.inputList[e];e++)if(f.name==a){if(c=e,-1!=d)break}else if(b&&f.name==b&&(d=e,-1!=c))break;if(-1==c)throw Error('Named input \"'+a+'\" not found.');if(-1==d)throw Error('Reference input \"'+b+'\" not found.');this.moveNumberedInputBefore(c,d)}};\nBlockly.Block.prototype.moveNumberedInputBefore=function(a,b){if(a==b)throw Error(\"Can't move input to itself.\");if(a>=this.inputList.length)throw RangeError(\"Input index \"+a+\" out of bounds.\");if(b>this.inputList.length)throw RangeError(\"Reference input \"+b+\" out of bounds.\");var c=this.inputList[a];this.inputList.splice(a,1);a<b&&b--;this.inputList.splice(b,0,c)};\nBlockly.Block.prototype.removeInput=function(a,b){for(var c=0,d;d=this.inputList[c];c++)if(d.name==a){d.type==Blockly.NEXT_STATEMENT&&this.statementInputCount--;d.dispose();this.inputList.splice(c,1);return}if(!b)throw Error(\"Input not found: \"+a);};Blockly.Block.prototype.getInput=function(a){for(var b=0,c;c=this.inputList[b];b++)if(c.name==a)return c;return null};Blockly.Block.prototype.getInputTargetBlock=function(a){return(a=this.getInput(a))&&a.connection&&a.connection.targetBlock()};\nBlockly.Block.prototype.getCommentText=function(){return this.commentModel.text};Blockly.Block.prototype.setCommentText=function(a){this.commentModel.text!=a&&(Blockly.Events.fire(new Blockly.Events.BlockChange(this,\"comment\",null,this.commentModel.text,a)),this.comment=this.commentModel.text=a)};Blockly.Block.prototype.setWarningText=function(a,b){};Blockly.Block.prototype.setMutator=function(a){};Blockly.Block.prototype.getRelativeToSurfaceXY=function(){return this.xy_};\nBlockly.Block.prototype.moveBy=function(a,b){if(this.parentBlock_)throw Error(\"Block has parent.\");var c=new Blockly.Events.BlockMove(this);this.xy_.translate(a,b);c.recordNew();Blockly.Events.fire(c)};Blockly.Block.prototype.makeConnection_=function(a){return new Blockly.Connection(this,a)};\nBlockly.Block.prototype.allInputsFilled=function(a){void 0===a&&(a=!0);if(!a&&this.isShadow())return!1;for(var b=0,c;c=this.inputList[b];b++)if(c.connection&&(c=c.connection.targetBlock(),!c||!c.allInputsFilled(a)))return!1;return(b=this.getNextBlock())?b.allInputsFilled(a):!0};Blockly.Block.prototype.toDevString=function(){var a=this.type?'\"'+this.type+'\" block':\"Block\";this.id&&(a+=' (id=\"'+this.id+'\")');return a};Blockly.blockRendering={};Blockly.blockRendering.IPathObject=function(a,b){};Blockly.utils.aria={};Blockly.utils.aria.ARIA_PREFIX_=\"aria-\";Blockly.utils.aria.ROLE_ATTRIBUTE_=\"role\";Blockly.utils.aria.Role={GRID:\"grid\",GRIDCELL:\"gridcell\",GROUP:\"group\",LISTBOX:\"listbox\",MENU:\"menu\",MENUITEM:\"menuitem\",MENUITEMCHECKBOX:\"menuitemcheckbox\",OPTION:\"option\",PRESENTATION:\"presentation\",ROW:\"row\",TREE:\"tree\",TREEITEM:\"treeitem\"};\nBlockly.utils.aria.State={ACTIVEDESCENDANT:\"activedescendant\",COLCOUNT:\"colcount\",EXPANDED:\"expanded\",INVALID:\"invalid\",LABEL:\"label\",LABELLEDBY:\"labelledby\",LEVEL:\"level\",ORIENTATION:\"orientation\",POSINSET:\"posinset\",ROWCOUNT:\"rowcount\",SELECTED:\"selected\",SETSIZE:\"setsize\",VALUEMAX:\"valuemax\",VALUEMIN:\"valuemin\"};Blockly.utils.aria.setRole=function(a,b){a.setAttribute(Blockly.utils.aria.ROLE_ATTRIBUTE_,b)};\nBlockly.utils.aria.setState=function(a,b,c){Array.isArray(c)&&(c=c.join(\" \"));a.setAttribute(Blockly.utils.aria.ARIA_PREFIX_+b,c)};Blockly.Menu=function(){Blockly.Component.call(this);this.openingCoords=null;this.highlightedIndex_=-1;this.onKeyDownWrapper_=this.mouseLeaveHandler_=this.mouseEnterHandler_=this.clickHandler_=this.mouseOverHandler_=null};Blockly.utils.object.inherits(Blockly.Menu,Blockly.Component);\nBlockly.Menu.prototype.createDom=function(){var a=document.createElement(\"div\");a.id=this.getId();this.setElementInternal(a);a.className=\"goog-menu goog-menu-vertical blocklyNonSelectable\";a.tabIndex=0;Blockly.utils.aria.setRole(a,this.roleName_||Blockly.utils.aria.Role.MENU)};Blockly.Menu.prototype.focus=function(){var a=this.getElement();a&&(a.focus({preventScroll:!0}),Blockly.utils.dom.addClass(a,\"focused\"))};\nBlockly.Menu.prototype.blur=function(){var a=this.getElement();a&&(a.blur(),Blockly.utils.dom.removeClass(a,\"focused\"))};Blockly.Menu.prototype.setRole=function(a){this.roleName_=a};Blockly.Menu.prototype.enterDocument=function(){Blockly.Menu.superClass_.enterDocument.call(this);this.forEachChild(function(a){a.isInDocument()&&this.registerChildId_(a)},this);this.attachEvents_()};Blockly.Menu.prototype.exitDocument=function(){this.setHighlightedIndex(-1);Blockly.Menu.superClass_.exitDocument.call(this)};\nBlockly.Menu.prototype.disposeInternal=function(){Blockly.Menu.superClass_.disposeInternal.call(this);this.detachEvents_()};\nBlockly.Menu.prototype.attachEvents_=function(){var a=this.getElement();this.mouseOverHandler_=Blockly.bindEventWithChecks_(a,\"mouseover\",this,this.handleMouseOver_,!0);this.clickHandler_=Blockly.bindEventWithChecks_(a,\"click\",this,this.handleClick_,!0);this.mouseEnterHandler_=Blockly.bindEventWithChecks_(a,\"mouseenter\",this,this.handleMouseEnter_,!0);this.mouseLeaveHandler_=Blockly.bindEventWithChecks_(a,\"mouseleave\",this,this.handleMouseLeave_,!0);this.onKeyDownWrapper_=Blockly.bindEventWithChecks_(a,\n\"keydown\",this,this.handleKeyEvent)};\nBlockly.Menu.prototype.detachEvents_=function(){this.mouseOverHandler_&&(Blockly.unbindEvent_(this.mouseOverHandler_),this.mouseOverHandler_=null);this.clickHandler_&&(Blockly.unbindEvent_(this.clickHandler_),this.clickHandler_=null);this.mouseEnterHandler_&&(Blockly.unbindEvent_(this.mouseEnterHandler_),this.mouseEnterHandler_=null);this.mouseLeaveHandler_&&(Blockly.unbindEvent_(this.mouseLeaveHandler_),this.mouseLeaveHandler_=null);this.onKeyDownWrapper_&&(Blockly.unbindEvent_(this.onKeyDownWrapper_),this.onKeyDownWrapper_=\nnull)};Blockly.Menu.prototype.childElementIdMap_=null;Blockly.Menu.prototype.registerChildId_=function(a){var b=a.getElement();b=b.id||(b.id=a.getId());this.childElementIdMap_||(this.childElementIdMap_={});this.childElementIdMap_[b]=a};Blockly.Menu.prototype.getMenuItem=function(a){if(this.childElementIdMap_)for(var b=this.getElement();a&&a!==b;){var c=a.id;if(c in this.childElementIdMap_)return this.childElementIdMap_[c];a=a.parentNode}return null};\nBlockly.Menu.prototype.unhighlightCurrent=function(){var a=this.getHighlighted();a&&a.setHighlighted(!1)};Blockly.Menu.prototype.clearHighlighted=function(){this.unhighlightCurrent();this.setHighlightedIndex(-1)};Blockly.Menu.prototype.getHighlighted=function(){return this.getChildAt(this.highlightedIndex_)};\nBlockly.Menu.prototype.setHighlightedIndex=function(a){var b=this.getChildAt(a);b?(b.setHighlighted(!0),this.highlightedIndex_=a):-1<this.highlightedIndex_&&(this.getHighlighted().setHighlighted(!1),this.highlightedIndex_=-1);b&&Blockly.utils.style.scrollIntoContainerView(b.getElement(),this.getElement())};Blockly.Menu.prototype.setHighlighted=function(a){this.setHighlightedIndex(this.indexOfChild(a))};\nBlockly.Menu.prototype.highlightNext=function(){this.unhighlightCurrent();this.highlightHelper(function(a,b){return(a+1)%b},this.highlightedIndex_)};Blockly.Menu.prototype.highlightPrevious=function(){this.unhighlightCurrent();this.highlightHelper(function(a,b){a--;return 0>a?b-1:a},this.highlightedIndex_)};\nBlockly.Menu.prototype.highlightHelper=function(a,b){b=0>b?-1:b;var c=this.getChildCount();b=a.call(this,b,c);for(var d=0;d<=c;){var e=this.getChildAt(b);if(e&&this.canHighlightItem(e))return this.setHighlightedIndex(b),!0;d++;b=a.call(this,b,c)}return!1};Blockly.Menu.prototype.canHighlightItem=function(a){return a.isEnabled()};\nBlockly.Menu.prototype.handleMouseOver_=function(a){if(a=this.getMenuItem(a.target))a.isEnabled()?this.getHighlighted()!==a&&(this.unhighlightCurrent(),this.setHighlighted(a)):this.unhighlightCurrent()};Blockly.Menu.prototype.handleClick_=function(a){var b=this.openingCoords;this.openingCoords=null;if(b&&\"number\"===typeof a.clientX){var c=new Blockly.utils.Coordinate(a.clientX,a.clientY);if(1>Blockly.utils.Coordinate.distance(b,c))return}(b=this.getMenuItem(a.target))&&b.handleClick(a)&&a.preventDefault()};\nBlockly.Menu.prototype.handleMouseEnter_=function(a){this.focus()};Blockly.Menu.prototype.handleMouseLeave_=function(a){this.getElement()&&(this.blur(),this.clearHighlighted())};Blockly.Menu.prototype.handleKeyEvent=function(a){return 0!=this.getChildCount()&&this.handleKeyEventInternal(a)?(a.preventDefault(),a.stopPropagation(),!0):!1};\nBlockly.Menu.prototype.handleKeyEventInternal=function(a){var b=this.getHighlighted();if(b&&\"function\"==typeof b.handleKeyEvent&&b.handleKeyEvent(a))return!0;if(a.shiftKey||a.ctrlKey||a.metaKey||a.altKey)return!1;switch(a.keyCode){case Blockly.utils.KeyCodes.ENTER:b&&b.performActionInternal(a);break;case Blockly.utils.KeyCodes.UP:this.highlightPrevious();break;case Blockly.utils.KeyCodes.DOWN:this.highlightNext();break;default:return!1}return!0};Blockly.MenuItem=function(a,b){Blockly.Component.call(this);this.setContentInternal(a);this.setValue(b);this.enabled_=!0};Blockly.utils.object.inherits(Blockly.MenuItem,Blockly.Component);\nBlockly.MenuItem.prototype.createDom=function(){var a=document.createElement(\"div\");a.id=this.getId();this.setElementInternal(a);a.className=\"goog-menuitem goog-option \"+(this.enabled_?\"\":\"goog-menuitem-disabled \")+(this.checked_?\"goog-option-selected \":\"\")+(this.rightToLeft_?\"goog-menuitem-rtl \":\"\");var b=this.getContentWrapperDom();a.appendChild(b);var c=this.getCheckboxDom();c&&b.appendChild(c);b.appendChild(this.getContentDom());Blockly.utils.aria.setRole(a,this.roleName_||(this.checkable_?Blockly.utils.aria.Role.MENUITEMCHECKBOX:\nBlockly.utils.aria.Role.MENUITEM));Blockly.utils.aria.setState(a,Blockly.utils.aria.State.SELECTED,this.checkable_&&this.checked_||!1)};Blockly.MenuItem.prototype.getCheckboxDom=function(){if(!this.checkable_)return null;var a=document.createElement(\"div\");a.className=\"goog-menuitem-checkbox\";return a};Blockly.MenuItem.prototype.getContentDom=function(){var a=this.content_;\"string\"===typeof a&&(a=document.createTextNode(a));return a};\nBlockly.MenuItem.prototype.getContentWrapperDom=function(){var a=document.createElement(\"div\");a.className=\"goog-menuitem-content\";return a};Blockly.MenuItem.prototype.setContentInternal=function(a){this.content_=a};Blockly.MenuItem.prototype.setValue=function(a){this.value_=a};Blockly.MenuItem.prototype.getValue=function(){return this.value_};Blockly.MenuItem.prototype.setRole=function(a){this.roleName_=a};Blockly.MenuItem.prototype.setCheckable=function(a){this.checkable_=a};\nBlockly.MenuItem.prototype.setChecked=function(a){if(this.checkable_){this.checked_=a;var b=this.getElement();b&&this.isEnabled()&&(a?(Blockly.utils.dom.addClass(b,\"goog-option-selected\"),Blockly.utils.aria.setState(b,Blockly.utils.aria.State.SELECTED,!0)):(Blockly.utils.dom.removeClass(b,\"goog-option-selected\"),Blockly.utils.aria.setState(b,Blockly.utils.aria.State.SELECTED,!1)))}};\nBlockly.MenuItem.prototype.setHighlighted=function(a){this.highlight_=a;var b=this.getElement();b&&this.isEnabled()&&(a?Blockly.utils.dom.addClass(b,\"goog-menuitem-highlight\"):Blockly.utils.dom.removeClass(b,\"goog-menuitem-highlight\"))};Blockly.MenuItem.prototype.isEnabled=function(){return this.enabled_};Blockly.MenuItem.prototype.setEnabled=function(a){this.enabled_=a;(a=this.getElement())&&(this.enabled_?Blockly.utils.dom.removeClass(a,\"goog-menuitem-disabled\"):Blockly.utils.dom.addClass(a,\"goog-menuitem-disabled\"))};\nBlockly.MenuItem.prototype.handleClick=function(a){this.isEnabled()&&(this.setHighlighted(!0),this.performActionInternal())};Blockly.MenuItem.prototype.performActionInternal=function(){this.checkable_&&this.setChecked(!this.checked_);this.actionHandler_&&this.actionHandler_.call(this.actionHandlerObj_,this)};Blockly.MenuItem.prototype.onAction=function(a,b){this.actionHandler_=a;this.actionHandlerObj_=b};Blockly.utils.uiMenu={};Blockly.utils.uiMenu.getSize=function(a){a=a.getElement();var b=Blockly.utils.style.getSize(a);b.height=a.scrollHeight;return b};Blockly.utils.uiMenu.adjustBBoxesForRTL=function(a,b,c){b.left+=c.width;b.right+=c.width;a.left+=c.width;a.right+=c.width};Blockly.ContextMenu={};Blockly.ContextMenu.currentBlock=null;Blockly.ContextMenu.eventWrapper_=null;Blockly.ContextMenu.show=function(a,b,c){Blockly.WidgetDiv.show(Blockly.ContextMenu,c,null);if(b.length){var d=Blockly.ContextMenu.populate_(b,c);Blockly.ContextMenu.position_(d,a,c);setTimeout(function(){d.getElement().focus()},1);Blockly.ContextMenu.currentBlock=null}else Blockly.ContextMenu.hide()};\nBlockly.ContextMenu.populate_=function(a,b){var c=new Blockly.Menu;c.setRightToLeft(b);for(var d=0,e;e=a[d];d++){var f=new Blockly.MenuItem(e.text);f.setRightToLeft(b);c.addChild(f,!0);f.setEnabled(e.enabled);if(e.enabled)f.onAction(function(){Blockly.ContextMenu.hide();this.callback()},e)}return c};\nBlockly.ContextMenu.position_=function(a,b,c){var d=Blockly.utils.getViewportBBox();b={top:b.clientY+d.top,bottom:b.clientY+d.top,left:b.clientX+d.left,right:b.clientX+d.left};Blockly.ContextMenu.createWidget_(a);var e=Blockly.utils.uiMenu.getSize(a);c&&Blockly.utils.uiMenu.adjustBBoxesForRTL(d,b,e);Blockly.WidgetDiv.positionWithAnchor(d,b,e,c);a.getElement().focus()};\nBlockly.ContextMenu.createWidget_=function(a){a.render(Blockly.WidgetDiv.DIV);var b=a.getElement();Blockly.utils.dom.addClass(b,\"blocklyContextMenu\");Blockly.bindEventWithChecks_(b,\"contextmenu\",null,Blockly.utils.noEvent);a.focus()};Blockly.ContextMenu.hide=function(){Blockly.WidgetDiv.hideIfOwner(Blockly.ContextMenu);Blockly.ContextMenu.currentBlock=null;Blockly.ContextMenu.eventWrapper_&&(Blockly.unbindEvent_(Blockly.ContextMenu.eventWrapper_),Blockly.ContextMenu.eventWrapper_=null)};\nBlockly.ContextMenu.callbackFactory=function(a,b){return function(){Blockly.Events.disable();try{var c=Blockly.Xml.domToBlock(b,a.workspace),d=a.getRelativeToSurfaceXY();d.x=a.RTL?d.x-Blockly.SNAP_RADIUS:d.x+Blockly.SNAP_RADIUS;d.y+=2*Blockly.SNAP_RADIUS;c.moveBy(d.x,d.y)}finally{Blockly.Events.enable()}Blockly.Events.isEnabled()&&!c.isShadow()&&Blockly.Events.fire(new Blockly.Events.BlockCreate(c));c.select()}};\nBlockly.ContextMenu.blockDeleteOption=function(a){var b=a.getDescendants(!1).length,c=a.getNextBlock();c&&(b-=c.getDescendants(!1).length);return{text:1==b?Blockly.Msg.DELETE_BLOCK:Blockly.Msg.DELETE_X_BLOCKS.replace(\"%1\",String(b)),enabled:!0,callback:function(){Blockly.Events.setGroup(!0);a.dispose(!0,!0);Blockly.Events.setGroup(!1)}}};Blockly.ContextMenu.blockHelpOption=function(a){return{enabled:!(\"function\"==typeof a.helpUrl?!a.helpUrl():!a.helpUrl),text:Blockly.Msg.HELP,callback:function(){a.showHelp()}}};\nBlockly.ContextMenu.blockDuplicateOption=function(a){var b=a.isDuplicatable();return{text:Blockly.Msg.DUPLICATE_BLOCK,enabled:b,callback:function(){Blockly.duplicate(a)}}};Blockly.ContextMenu.blockCommentOption=function(a){var b={enabled:!Blockly.utils.userAgent.IE};a.getCommentIcon()?(b.text=Blockly.Msg.REMOVE_COMMENT,b.callback=function(){a.setCommentText(null)}):(b.text=Blockly.Msg.ADD_COMMENT,b.callback=function(){a.setCommentText(\"\")});return b};\nBlockly.ContextMenu.commentDeleteOption=function(a){return{text:Blockly.Msg.REMOVE_COMMENT,enabled:!0,callback:function(){Blockly.Events.setGroup(!0);a.dispose(!0,!0);Blockly.Events.setGroup(!1)}}};Blockly.ContextMenu.commentDuplicateOption=function(a){return{text:Blockly.Msg.DUPLICATE_COMMENT,enabled:!0,callback:function(){Blockly.duplicate(a)}}};\nBlockly.ContextMenu.workspaceCommentOption=function(a,b){if(!Blockly.WorkspaceCommentSvg)throw Error(\"Missing require for Blockly.WorkspaceCommentSvg\");var c={enabled:!Blockly.utils.userAgent.IE};c.text=Blockly.Msg.ADD_COMMENT;c.callback=function(){var c=new Blockly.WorkspaceCommentSvg(a,Blockly.Msg.WORKSPACE_COMMENT_DEFAULT_TEXT,Blockly.WorkspaceCommentSvg.DEFAULT_SIZE,Blockly.WorkspaceCommentSvg.DEFAULT_SIZE),e=a.getInjectionDiv().getBoundingClientRect();e=new Blockly.utils.Coordinate(b.clientX-\ne.left,b.clientY-e.top);var f=a.getOriginOffsetInPixels();e=Blockly.utils.Coordinate.difference(e,f);e.scale(1/a.scale);c.moveBy(e.x,e.y);a.rendered&&(c.initSvg(),c.render(),c.select())};return c};Blockly.RenderedConnection=function(a,b){Blockly.RenderedConnection.superClass_.constructor.call(this,a,b);this.db_=a.workspace.connectionDBList[b];this.dbOpposite_=a.workspace.connectionDBList[Blockly.OPPOSITE_TYPE[b]];this.offsetInBlock_=new Blockly.utils.Coordinate(0,0);this.trackedState_=Blockly.RenderedConnection.TrackedState.WILL_TRACK};Blockly.utils.object.inherits(Blockly.RenderedConnection,Blockly.Connection);Blockly.RenderedConnection.TrackedState={WILL_TRACK:-1,UNTRACKED:0,TRACKED:1};\nBlockly.RenderedConnection.prototype.dispose=function(){Blockly.RenderedConnection.superClass_.dispose.call(this);this.trackedState_==Blockly.RenderedConnection.TrackedState.TRACKED&&this.db_.removeConnection(this,this.y)};Blockly.RenderedConnection.prototype.getSourceBlock=function(){return Blockly.RenderedConnection.superClass_.getSourceBlock.call(this)};Blockly.RenderedConnection.prototype.targetBlock=function(){return Blockly.RenderedConnection.superClass_.targetBlock.call(this)};\nBlockly.RenderedConnection.prototype.distanceFrom=function(a){var b=this.x-a.x;a=this.y-a.y;return Math.sqrt(b*b+a*a)};\nBlockly.RenderedConnection.prototype.bumpAwayFrom=function(a){if(!this.sourceBlock_.workspace.isDragging()){var b=this.sourceBlock_.getRootBlock();if(!b.isInFlyout){var c=!1;if(!b.isMovable()){b=a.getSourceBlock().getRootBlock();if(!b.isMovable())return;a=this;c=!0}var d=Blockly.selected==b;d||b.addSelect();var e=a.x+Blockly.SNAP_RADIUS+Math.floor(Math.random()*Blockly.BUMP_RANDOMNESS)-this.x,f=a.y+Blockly.SNAP_RADIUS+Math.floor(Math.random()*Blockly.BUMP_RANDOMNESS)-this.y;c&&(f=-f);b.RTL&&(e=a.x-\nBlockly.SNAP_RADIUS-Math.floor(Math.random()*Blockly.BUMP_RANDOMNESS)-this.x);b.moveBy(e,f);d||b.removeSelect()}}};\nBlockly.RenderedConnection.prototype.moveTo=function(a,b){this.trackedState_==Blockly.RenderedConnection.TrackedState.WILL_TRACK?(this.db_.addConnection(this,b),this.trackedState_=Blockly.RenderedConnection.TrackedState.TRACKED):this.trackedState_==Blockly.RenderedConnection.TrackedState.TRACKED&&(this.db_.removeConnection(this,this.y),this.db_.addConnection(this,b));this.x=a;this.y=b};Blockly.RenderedConnection.prototype.moveBy=function(a,b){this.moveTo(this.x+a,this.y+b)};\nBlockly.RenderedConnection.prototype.moveToOffset=function(a){this.moveTo(a.x+this.offsetInBlock_.x,a.y+this.offsetInBlock_.y)};Blockly.RenderedConnection.prototype.setOffsetInBlock=function(a,b){this.offsetInBlock_.x=a;this.offsetInBlock_.y=b};Blockly.RenderedConnection.prototype.getOffsetInBlock=function(){return this.offsetInBlock_};\nBlockly.RenderedConnection.prototype.tighten=function(){var a=this.targetConnection.x-this.x,b=this.targetConnection.y-this.y;if(0!=a||0!=b){var c=this.targetBlock(),d=c.getSvgRoot();if(!d)throw Error(\"block is not rendered.\");d=Blockly.utils.getRelativeXY(d);c.getSvgRoot().setAttribute(\"transform\",\"translate(\"+(d.x-a)+\",\"+(d.y-b)+\")\");c.moveConnections(-a,-b)}};Blockly.RenderedConnection.prototype.closest=function(a,b){return this.dbOpposite_.searchForClosest(this,a,b)};\nBlockly.RenderedConnection.prototype.highlight=function(){var a=this.sourceBlock_.workspace.getRenderer().getConstants();var b=a.shapeFor(this);this.type==Blockly.INPUT_VALUE||this.type==Blockly.OUTPUT_VALUE?(a=a.TAB_OFFSET_FROM_TOP,b=Blockly.utils.svgPaths.moveBy(0,-a)+Blockly.utils.svgPaths.lineOnAxis(\"v\",a)+b.pathDown+Blockly.utils.svgPaths.lineOnAxis(\"v\",a)):(a=a.NOTCH_OFFSET_LEFT-a.CORNER_RADIUS,b=Blockly.utils.svgPaths.moveBy(-a,0)+Blockly.utils.svgPaths.lineOnAxis(\"h\",a)+b.pathLeft+Blockly.utils.svgPaths.lineOnAxis(\"h\",\na));a=this.sourceBlock_.getRelativeToSurfaceXY();Blockly.Connection.highlightedPath_=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyHighlightedConnectionPath\",d:b,transform:\"translate(\"+(this.x-a.x)+\",\"+(this.y-a.y)+\")\"+(this.sourceBlock_.RTL?\" scale(-1 1)\":\"\")},this.sourceBlock_.getSvgRoot())};Blockly.RenderedConnection.prototype.unhighlight=function(){Blockly.utils.dom.removeNode(Blockly.Connection.highlightedPath_);delete Blockly.Connection.highlightedPath_};\nBlockly.RenderedConnection.prototype.setTracking=function(a){a&&this.trackedState_==Blockly.RenderedConnection.TrackedState.TRACKED||!a&&this.trackedState_==Blockly.RenderedConnection.TrackedState.UNTRACKED||this.sourceBlock_.isInFlyout||(a?(this.db_.addConnection(this,this.y),this.trackedState_=Blockly.RenderedConnection.TrackedState.TRACKED):(this.trackedState_==Blockly.RenderedConnection.TrackedState.TRACKED&&this.db_.removeConnection(this,this.y),this.trackedState_=Blockly.RenderedConnection.TrackedState.UNTRACKED))};\nBlockly.RenderedConnection.prototype.stopTrackingAll=function(){this.setTracking(!1);if(this.targetConnection)for(var a=this.targetBlock().getDescendants(!1),b=0;b<a.length;b++){for(var c=a[b],d=c.getConnections_(!0),e=0;e<d.length;e++)d[e].setTracking(!1);c=c.getIcons();for(e=0;e<c.length;e++)c[e].setVisible(!1)}};\nBlockly.RenderedConnection.prototype.startTrackingAll=function(){this.setTracking(!0);var a=[];if(this.type!=Blockly.INPUT_VALUE&&this.type!=Blockly.NEXT_STATEMENT)return a;var b=this.targetBlock();if(b){if(b.isCollapsed()){var c=[];b.outputConnection&&c.push(b.outputConnection);b.nextConnection&&c.push(b.nextConnection);b.previousConnection&&c.push(b.previousConnection)}else c=b.getConnections_(!0);for(var d=0;d<c.length;d++)a.push.apply(a,c[d].startTrackingAll());a.length||(a[0]=b)}return a};\nBlockly.RenderedConnection.prototype.isConnectionAllowed=function(a,b){return this.distanceFrom(a)>b?!1:Blockly.RenderedConnection.superClass_.isConnectionAllowed.call(this,a)};Blockly.RenderedConnection.prototype.onFailedConnect=function(a){this.bumpAwayFrom(a)};Blockly.RenderedConnection.prototype.disconnectInternal_=function(a,b){Blockly.RenderedConnection.superClass_.disconnectInternal_.call(this,a,b);a.rendered&&a.render();b.rendered&&(b.updateDisabled(),b.render())};\nBlockly.RenderedConnection.prototype.respawnShadow_=function(){var a=this.getSourceBlock(),b=this.getShadowDom();if(a.workspace&&b&&Blockly.Events.recordUndo){Blockly.RenderedConnection.superClass_.respawnShadow_.call(this);b=this.targetBlock();if(!b)throw Error(\"Couldn't respawn the shadow block that should exist here.\");b.initSvg();b.render(!1);a.rendered&&a.render()}};Blockly.RenderedConnection.prototype.neighbours=function(a){return this.dbOpposite_.getNeighbours(this,a)};\nBlockly.RenderedConnection.prototype.connect_=function(a){Blockly.RenderedConnection.superClass_.connect_.call(this,a);var b=this.getSourceBlock();a=a.getSourceBlock();b.rendered&&b.updateDisabled();a.rendered&&a.updateDisabled();b.rendered&&a.rendered&&(this.type==Blockly.NEXT_STATEMENT||this.type==Blockly.PREVIOUS_STATEMENT?a.render():b.render())};\nBlockly.RenderedConnection.prototype.onCheckChanged_=function(){!this.isConnected()||this.targetConnection&&this.checkType(this.targetConnection)||((this.isSuperior()?this.targetBlock():this.sourceBlock_).unplug(),this.sourceBlock_.bumpNeighbours())};Blockly.Marker=function(){this.drawer_=this.curNode_=this.colour=null;this.type=\"marker\"};Blockly.Marker.prototype.setDrawer=function(a){this.drawer_=a};Blockly.Marker.prototype.getDrawer=function(){return this.drawer_};Blockly.Marker.prototype.getCurNode=function(){return this.curNode_};Blockly.Marker.prototype.setCurNode=function(a){var b=this.curNode_;this.curNode_=a;this.drawer_&&this.drawer_.draw(b,this.curNode_)};\nBlockly.Marker.prototype.draw=function(){this.drawer_&&this.drawer_.draw(this.curNode_,this.curNode_)};Blockly.Marker.prototype.hide=function(){this.drawer_&&this.drawer_.hide()};Blockly.Marker.prototype.dispose=function(){this.getDrawer()&&this.getDrawer().dispose()};Blockly.Cursor=function(){Blockly.Cursor.superClass_.constructor.call(this);this.type=\"cursor\"};Blockly.utils.object.inherits(Blockly.Cursor,Blockly.Marker);Blockly.Cursor.prototype.next=function(){var a=this.getCurNode();if(!a)return null;for(a=a.next();a&&a.next()&&(a.getType()==Blockly.ASTNode.types.NEXT||a.getType()==Blockly.ASTNode.types.BLOCK);)a=a.next();a&&this.setCurNode(a);return a};\nBlockly.Cursor.prototype.in=function(){var a=this.getCurNode();if(!a)return null;if(a.getType()==Blockly.ASTNode.types.PREVIOUS||a.getType()==Blockly.ASTNode.types.OUTPUT)a=a.next();(a=a.in())&&this.setCurNode(a);return a};Blockly.Cursor.prototype.prev=function(){var a=this.getCurNode();if(!a)return null;for(a=a.prev();a&&a.prev()&&(a.getType()==Blockly.ASTNode.types.NEXT||a.getType()==Blockly.ASTNode.types.BLOCK);)a=a.prev();a&&this.setCurNode(a);return a};\nBlockly.Cursor.prototype.out=function(){var a=this.getCurNode();if(!a)return null;(a=a.out())&&a.getType()==Blockly.ASTNode.types.BLOCK&&(a=a.prev()||a);a&&this.setCurNode(a);return a};\nBlockly.Cursor.prototype.onBlocklyAction=function(a){if(this.getCurNode()&&this.getCurNode().getType()===Blockly.ASTNode.types.FIELD&&this.getCurNode().getLocation().onBlocklyAction(a))return!0;switch(a.name){case Blockly.navigation.actionNames.PREVIOUS:return this.prev(),!0;case Blockly.navigation.actionNames.OUT:return this.out(),!0;case Blockly.navigation.actionNames.NEXT:return this.next(),!0;case Blockly.navigation.actionNames.IN:return this.in(),!0;default:return!1}};Blockly.BasicCursor=function(){Blockly.BasicCursor.superClass_.constructor.call(this)};Blockly.utils.object.inherits(Blockly.BasicCursor,Blockly.Cursor);Blockly.BasicCursor.prototype.next=function(){var a=this.getCurNode();if(!a)return null;(a=this.getNextNode_(a,this.validNode_))&&this.setCurNode(a);return a};Blockly.BasicCursor.prototype.in=function(){return this.next()};\nBlockly.BasicCursor.prototype.prev=function(){var a=this.getCurNode();if(!a)return null;(a=this.getPreviousNode_(a,this.validNode_))&&this.setCurNode(a);return a};Blockly.BasicCursor.prototype.out=function(){return this.prev()};Blockly.BasicCursor.prototype.getNextNode_=function(a,b){if(!a)return null;var c=a.in()||a.next();if(b(c))return c;if(c)return this.getNextNode_(c,b);a=this.findSiblingOrParent_(a.out());return b(a)?a:a?this.getNextNode_(a,b):null};\nBlockly.BasicCursor.prototype.getPreviousNode_=function(a,b){if(!a)return null;var c=a.prev();c=c?this.getRightMostChild_(c):a.out();return b(c)?c:c?this.getPreviousNode_(c,b):null};Blockly.BasicCursor.prototype.validNode_=function(a){var b=!1;a=a&&a.getType();if(a==Blockly.ASTNode.types.OUTPUT||a==Blockly.ASTNode.types.INPUT||a==Blockly.ASTNode.types.FIELD||a==Blockly.ASTNode.types.NEXT||a==Blockly.ASTNode.types.PREVIOUS||a==Blockly.ASTNode.types.WORKSPACE)b=!0;return b};\nBlockly.BasicCursor.prototype.findSiblingOrParent_=function(a){if(!a)return null;var b=a.next();return b?b:this.findSiblingOrParent_(a.out())};Blockly.BasicCursor.prototype.getRightMostChild_=function(a){if(!a.in())return a;for(a=a.in();a.next();)a=a.next();return this.getRightMostChild_(a)};Blockly.TabNavigateCursor=function(){Blockly.TabNavigateCursor.superClass_.constructor.call(this)};Blockly.utils.object.inherits(Blockly.TabNavigateCursor,Blockly.BasicCursor);Blockly.TabNavigateCursor.prototype.validNode_=function(a){var b=!1,c=a&&a.getType();a&&(a=a.getLocation(),c==Blockly.ASTNode.types.FIELD&&a&&a.isTabNavigable()&&a.isClickable()&&(b=!0));return b};Blockly.utils.Rect=function(a,b,c,d){this.top=a;this.bottom=b;this.left=c;this.right=d};Blockly.utils.Rect.prototype.contains=function(a,b){return a>=this.left&&a<=this.right&&b>=this.top&&b<=this.bottom};Blockly.BlockSvg=function(a,b,c){this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},null);this.svgGroup_.translate_=\"\";this.style=a.getRenderer().getConstants().getBlockStyle(null);this.pathObject=a.getRenderer().makePathObject(this.svgGroup_,this.style);this.rendered=!1;this.workspace=a;this.previousConnection=this.nextConnection=this.outputConnection=null;this.useDragSurface_=Blockly.utils.is3dSupported()&&!!a.getBlockDragSurface();var d=this.pathObject.svgPath;d.tooltip=this;Blockly.Tooltip.bindMouseEvents(d);\nBlockly.BlockSvg.superClass_.constructor.call(this,a,b,c);this.svgGroup_.dataset&&(this.svgGroup_.dataset.id=this.id)};Blockly.utils.object.inherits(Blockly.BlockSvg,Blockly.Block);Blockly.BlockSvg.prototype.height=0;Blockly.BlockSvg.prototype.width=0;Blockly.BlockSvg.prototype.dragStartXY_=null;Blockly.BlockSvg.prototype.warningTextDb_=null;Blockly.BlockSvg.INLINE=-1;Blockly.BlockSvg.COLLAPSED_WARNING_ID=\"TEMP_COLLAPSED_WARNING_\";\nBlockly.BlockSvg.prototype.initSvg=function(){if(!this.workspace.rendered)throw TypeError(\"Workspace is headless.\");for(var a=0,b;b=this.inputList[a];a++)b.init();b=this.getIcons();for(a=0;a<b.length;a++)b[a].createIcon();this.applyColour();this.pathObject.updateMovable(this.isMovable());a=this.getSvgRoot();this.workspace.options.readOnly||this.eventsInit_||!a||Blockly.bindEventWithChecks_(a,\"mousedown\",this,this.onMouseDown_);this.eventsInit_=!0;a.parentNode||this.workspace.getCanvas().appendChild(a)};\nBlockly.BlockSvg.prototype.getColourSecondary=function(){return this.style.colourSecondary};Blockly.BlockSvg.prototype.getColourTertiary=function(){return this.style.colourTertiary};Blockly.BlockSvg.prototype.getColourShadow=function(){return this.getColourSecondary()};Blockly.BlockSvg.prototype.getColourBorder=function(){return{colourBorder:this.getColourTertiary(),colourLight:null,colourDark:null}};\nBlockly.BlockSvg.prototype.select=function(){if(this.isShadow()&&this.getParent())this.getParent().select();else if(Blockly.selected!=this){var a=null;if(Blockly.selected){a=Blockly.selected.id;Blockly.Events.disable();try{Blockly.selected.unselect()}finally{Blockly.Events.enable()}}a=new Blockly.Events.Ui(null,\"selected\",a,this.id);a.workspaceId=this.workspace.id;Blockly.Events.fire(a);Blockly.selected=this;this.addSelect()}};\nBlockly.BlockSvg.prototype.unselect=function(){if(Blockly.selected==this){var a=new Blockly.Events.Ui(null,\"selected\",this.id,null);a.workspaceId=this.workspace.id;Blockly.Events.fire(a);Blockly.selected=null;this.removeSelect()}};Blockly.BlockSvg.prototype.mutator=null;Blockly.BlockSvg.prototype.comment=null;Blockly.BlockSvg.prototype.commentIcon_=null;Blockly.BlockSvg.prototype.warning=null;\nBlockly.BlockSvg.prototype.getIcons=function(){var a=[];this.mutator&&a.push(this.mutator);this.commentIcon_&&a.push(this.commentIcon_);this.warning&&a.push(this.warning);return a};\nBlockly.BlockSvg.prototype.setParent=function(a){var b=this.parentBlock_;if(a!=b){Blockly.utils.dom.startTextWidthCache();Blockly.BlockSvg.superClass_.setParent.call(this,a);Blockly.utils.dom.stopTextWidthCache();var c=this.getSvgRoot();if(!this.workspace.isClearing&&c){var d=this.getRelativeToSurfaceXY();a?(a.getSvgRoot().appendChild(c),a=this.getRelativeToSurfaceXY(),this.moveConnections(a.x-d.x,a.y-d.y)):b&&(this.workspace.getCanvas().appendChild(c),this.translate(d.x,d.y));this.applyColour()}}};\nBlockly.BlockSvg.prototype.getRelativeToSurfaceXY=function(){var a=0,b=0,c=this.useDragSurface_?this.workspace.getBlockDragSurface().getGroup():null,d=this.getSvgRoot();if(d){do{var e=Blockly.utils.getRelativeXY(d);a+=e.x;b+=e.y;this.useDragSurface_&&this.workspace.getBlockDragSurface().getCurrentBlock()==d&&(e=this.workspace.getBlockDragSurface().getSurfaceTranslation(),a+=e.x,b+=e.y);d=d.parentNode}while(d&&d!=this.workspace.getCanvas()&&d!=c)}return new Blockly.utils.Coordinate(a,b)};\nBlockly.BlockSvg.prototype.moveBy=function(a,b){if(this.parentBlock_)throw Error(\"Block has parent.\");var c=Blockly.Events.isEnabled();if(c)var d=new Blockly.Events.BlockMove(this);var e=this.getRelativeToSurfaceXY();this.translate(e.x+a,e.y+b);this.moveConnections(a,b);c&&(d.recordNew(),Blockly.Events.fire(d));this.workspace.resizeContents()};Blockly.BlockSvg.prototype.translate=function(a,b){this.getSvgRoot().setAttribute(\"transform\",\"translate(\"+a+\",\"+b+\")\")};\nBlockly.BlockSvg.prototype.moveToDragSurface=function(){if(this.useDragSurface_){var a=this.getRelativeToSurfaceXY();this.clearTransformAttributes_();this.workspace.getBlockDragSurface().translateSurface(a.x,a.y);(a=this.getSvgRoot())&&this.workspace.getBlockDragSurface().setBlocksAndShow(a)}};Blockly.BlockSvg.prototype.moveTo=function(a){var b=this.getRelativeToSurfaceXY();this.moveBy(a.x-b.x,a.y-b.y)};\nBlockly.BlockSvg.prototype.moveOffDragSurface=function(a){this.useDragSurface_&&(this.translate(a.x,a.y),this.workspace.getBlockDragSurface().clearAndHide(this.workspace.getCanvas()))};Blockly.BlockSvg.prototype.moveDuringDrag=function(a){this.useDragSurface_?this.workspace.getBlockDragSurface().translateSurface(a.x,a.y):(this.svgGroup_.translate_=\"translate(\"+a.x+\",\"+a.y+\")\",this.svgGroup_.setAttribute(\"transform\",this.svgGroup_.translate_+this.svgGroup_.skew_))};\nBlockly.BlockSvg.prototype.clearTransformAttributes_=function(){this.getSvgRoot().removeAttribute(\"transform\")};Blockly.BlockSvg.prototype.snapToGrid=function(){if(this.workspace&&!this.workspace.isDragging()&&!this.getParent()&&!this.isInFlyout){var a=this.workspace.getGrid();if(a&&a.shouldSnap()){var b=a.getSpacing(),c=b/2,d=this.getRelativeToSurfaceXY();a=Math.round((d.x-c)/b)*b+c-d.x;b=Math.round((d.y-c)/b)*b+c-d.y;a=Math.round(a);b=Math.round(b);0==a&&0==b||this.moveBy(a,b)}}};\nBlockly.BlockSvg.prototype.getBoundingRectangle=function(){var a=this.getRelativeToSurfaceXY(),b=this.getHeightWidth();if(this.RTL){var c=a.x-b.width;var d=a.x}else c=a.x,d=a.x+b.width;return new Blockly.utils.Rect(a.y,a.y+b.height,c,d)};Blockly.BlockSvg.prototype.markDirty=function(){this.pathObject.constants=this.workspace.getRenderer().getConstants();for(var a=0,b;b=this.inputList[a];a++)b.markDirty()};\nBlockly.BlockSvg.prototype.setCollapsed=function(a){if(this.collapsed_!=a){for(var b=[],c=0,d;d=this.inputList[c];c++)b.push.apply(b,d.setVisible(!a));if(a){d=this.getIcons();for(c=0;c<d.length;c++)d[c].setVisible(!1);c=this.toString(Blockly.COLLAPSE_CHARS);this.appendDummyInput(\"_TEMP_COLLAPSED_INPUT\").appendField(c).init();d=this.getDescendants(!0);if(c=this.getNextBlock())c=d.indexOf(c),d.splice(c,d.length-c);c=1;for(var e;e=d[c];c++)if(e.warning){this.setWarningText(Blockly.Msg.COLLAPSED_WARNINGS_WARNING,\nBlockly.BlockSvg.COLLAPSED_WARNING_ID);break}}else this.removeInput(\"_TEMP_COLLAPSED_INPUT\"),this.warning&&(this.warning.setText(\"\",Blockly.BlockSvg.COLLAPSED_WARNING_ID),Object.keys(this.warning.text_).length||this.setWarningText(null));Blockly.BlockSvg.superClass_.setCollapsed.call(this,a);b.length||(b[0]=this);if(this.rendered)for(c=0;e=b[c];c++)e.render()}};\nBlockly.BlockSvg.prototype.tab=function(a,b){var c=new Blockly.TabNavigateCursor;c.setCurNode(Blockly.ASTNode.createFieldNode(a));a=c.getCurNode();c.onBlocklyAction(b?Blockly.navigation.ACTION_NEXT:Blockly.navigation.ACTION_PREVIOUS);(b=c.getCurNode())&&b!==a&&(b.getLocation().showEditor(),this.workspace.keyboardAccessibilityMode&&this.workspace.getCursor().setCurNode(b))};\nBlockly.BlockSvg.prototype.onMouseDown_=function(a){var b=this.workspace&&this.workspace.getGesture(a);b&&b.handleBlockStart(a,this)};Blockly.BlockSvg.prototype.showHelp=function(){var a=\"function\"==typeof this.helpUrl?this.helpUrl():this.helpUrl;a&&window.open(a)};\nBlockly.BlockSvg.prototype.generateContextMenu=function(){if(this.workspace.options.readOnly||!this.contextMenu)return null;var a=this,b=[];if(!this.isInFlyout){this.isDeletable()&&this.isMovable()&&b.push(Blockly.ContextMenu.blockDuplicateOption(a));this.workspace.options.comments&&!this.collapsed_&&this.isEditable()&&b.push(Blockly.ContextMenu.blockCommentOption(a));if(this.isMovable())if(this.collapsed_)this.workspace.options.collapse&&(c={enabled:!0},c.text=Blockly.Msg.EXPAND_BLOCK,c.callback=\nfunction(){a.setCollapsed(!1)},b.push(c));else{for(var c=1;c<this.inputList.length;c++)if(this.inputList[c-1].type!=Blockly.NEXT_STATEMENT&&this.inputList[c].type!=Blockly.NEXT_STATEMENT){c={enabled:!0};var d=this.getInputsInline();c.text=d?Blockly.Msg.EXTERNAL_INPUTS:Blockly.Msg.INLINE_INPUTS;c.callback=function(){a.setInputsInline(!d)};b.push(c);break}this.workspace.options.collapse&&(c={enabled:!0},c.text=Blockly.Msg.COLLAPSE_BLOCK,c.callback=function(){a.setCollapsed(!0)},b.push(c))}this.workspace.options.disable&&\nthis.isEditable()&&(c={text:this.isEnabled()?Blockly.Msg.DISABLE_BLOCK:Blockly.Msg.ENABLE_BLOCK,enabled:!this.getInheritedDisabled(),callback:function(){var b=Blockly.Events.getGroup();b||Blockly.Events.setGroup(!0);a.setEnabled(!a.isEnabled());b||Blockly.Events.setGroup(!1)}},b.push(c));this.isDeletable()&&b.push(Blockly.ContextMenu.blockDeleteOption(a))}b.push(Blockly.ContextMenu.blockHelpOption(a));this.customContextMenu&&this.customContextMenu(b);return b};\nBlockly.BlockSvg.prototype.showContextMenu=function(a){var b=this.generateContextMenu();b&&b.length&&(Blockly.ContextMenu.show(a,b,this.RTL),Blockly.ContextMenu.currentBlock=this)};Blockly.BlockSvg.prototype.moveConnections=function(a,b){if(this.rendered){for(var c=this.getConnections_(!1),d=0;d<c.length;d++)c[d].moveBy(a,b);c=this.getIcons();for(d=0;d<c.length;d++)c[d].computeIconLocation();for(d=0;d<this.childBlocks_.length;d++)this.childBlocks_[d].moveConnections(a,b)}};\nBlockly.BlockSvg.prototype.setDragging=function(a){if(a){var b=this.getSvgRoot();b.translate_=\"\";b.skew_=\"\";Blockly.draggingConnections=Blockly.draggingConnections.concat(this.getConnections_(!0));Blockly.utils.dom.addClass(this.svgGroup_,\"blocklyDragging\")}else Blockly.draggingConnections=[],Blockly.utils.dom.removeClass(this.svgGroup_,\"blocklyDragging\");for(b=0;b<this.childBlocks_.length;b++)this.childBlocks_[b].setDragging(a)};\nBlockly.BlockSvg.prototype.setMovable=function(a){Blockly.BlockSvg.superClass_.setMovable.call(this,a);this.pathObject.updateMovable(a)};Blockly.BlockSvg.prototype.setEditable=function(a){Blockly.BlockSvg.superClass_.setEditable.call(this,a);a=this.getIcons();for(var b=0;b<a.length;b++)a[b].updateEditable()};Blockly.BlockSvg.prototype.setShadow=function(a){Blockly.BlockSvg.superClass_.setShadow.call(this,a);this.applyColour()};\nBlockly.BlockSvg.prototype.setInsertionMarker=function(a){this.isInsertionMarker_!=a&&(this.isInsertionMarker_=a)&&(this.setColour(this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR),this.pathObject.updateInsertionMarker(!0))};Blockly.BlockSvg.prototype.getSvgRoot=function(){return this.svgGroup_};\nBlockly.BlockSvg.prototype.dispose=function(a,b){if(this.workspace){Blockly.Tooltip.dispose();Blockly.Tooltip.unbindMouseEvents(this.pathObject.svgPath);Blockly.utils.dom.startTextWidthCache();var c=this.workspace;Blockly.selected==this&&(this.unselect(),this.workspace.cancelCurrentGesture());Blockly.ContextMenu.currentBlock==this&&Blockly.ContextMenu.hide();this.workspace.keyboardAccessibilityMode&&Blockly.navigation.moveCursorOnBlockDelete(this);b&&this.rendered&&(this.unplug(a),Blockly.blockAnimations.disposeUiEffect(this));\nthis.rendered=!1;if(this.warningTextDb_){for(var d in this.warningTextDb_)clearTimeout(this.warningTextDb_[d]);this.warningTextDb_=null}b=this.getIcons();for(d=0;d<b.length;d++)b[d].dispose();Blockly.BlockSvg.superClass_.dispose.call(this,!!a);Blockly.utils.dom.removeNode(this.svgGroup_);c.resizeContents();this.svgGroup_=null;Blockly.utils.dom.stopTextWidthCache()}};\nBlockly.BlockSvg.prototype.applyColour=function(){this.pathObject.applyColour(this);for(var a=this.getIcons(),b=0;b<a.length;b++)a[b].applyColour();for(a=0;b=this.inputList[a];a++)for(var c=0,d;d=b.fieldRow[c];c++)d.applyColour()};Blockly.BlockSvg.prototype.updateDisabled=function(){var a=this.getChildren(!1);this.applyColour();for(var b=0,c;c=a[b];b++)c.updateDisabled()};Blockly.BlockSvg.prototype.getCommentIcon=function(){return this.commentIcon_};\nBlockly.BlockSvg.prototype.setCommentText=function(a){if(!Blockly.Comment)throw Error(\"Missing require for Blockly.Comment\");this.commentModel.text!=a&&(Blockly.BlockSvg.superClass_.setCommentText.call(this,a),a=null!=a,!!this.commentIcon_==a?this.commentIcon_.updateText():(a?this.comment=this.commentIcon_=new Blockly.Comment(this):(this.commentIcon_.dispose(),this.comment=this.commentIcon_=null),this.rendered&&(this.render(),this.bumpNeighbours())))};\nBlockly.BlockSvg.prototype.setWarningText=function(a,b){if(!Blockly.Warning)throw Error(\"Missing require for Blockly.Warning\");this.warningTextDb_||(this.warningTextDb_=Object.create(null));var c=b||\"\";if(c)this.warningTextDb_[c]&&(clearTimeout(this.warningTextDb_[c]),delete this.warningTextDb_[c]);else for(var d in this.warningTextDb_)clearTimeout(this.warningTextDb_[d]),delete this.warningTextDb_[d];if(this.workspace.isDragging()){var e=this;this.warningTextDb_[c]=setTimeout(function(){e.workspace&&\n(delete e.warningTextDb_[c],e.setWarningText(a,c))},100)}else{this.isInFlyout&&(a=null);b=this.getSurroundParent();for(d=null;b;)b.isCollapsed()&&(d=b),b=b.getSurroundParent();d&&d.setWarningText(Blockly.Msg.COLLAPSED_WARNINGS_WARNING,Blockly.BlockSvg.COLLAPSED_WARNING_ID);b=!1;\"string\"==typeof a?(this.warning||(this.warning=new Blockly.Warning(this),b=!0),this.warning.setText(a,c)):this.warning&&!c?(this.warning.dispose(),b=!0):this.warning&&(b=this.warning.getText(),this.warning.setText(\"\",c),(d=\nthis.warning.getText())||this.warning.dispose(),b=b!=d);b&&this.rendered&&(this.render(),this.bumpNeighbours())}};Blockly.BlockSvg.prototype.setMutator=function(a){this.mutator&&this.mutator!==a&&this.mutator.dispose();a&&(a.setBlock(this),this.mutator=a,a.createIcon());this.rendered&&(this.render(),this.bumpNeighbours())};\nBlockly.BlockSvg.prototype.setDisabled=function(a){console.warn(\"Deprecated call to Blockly.BlockSvg.prototype.setDisabled, use Blockly.BlockSvg.prototype.setEnabled instead.\");this.setEnabled(!a)};Blockly.BlockSvg.prototype.setEnabled=function(a){this.isEnabled()!=a&&(Blockly.BlockSvg.superClass_.setEnabled.call(this,a),this.rendered&&!this.getInheritedDisabled()&&this.updateDisabled())};Blockly.BlockSvg.prototype.setHighlighted=function(a){this.rendered&&this.pathObject.updateHighlighted(a)};\nBlockly.BlockSvg.prototype.addSelect=function(){this.pathObject.updateSelected(!0)};Blockly.BlockSvg.prototype.removeSelect=function(){this.pathObject.updateSelected(!1)};Blockly.BlockSvg.prototype.setDeleteStyle=function(a){this.pathObject.updateDraggingDelete(a)};Blockly.BlockSvg.prototype.getColour=function(){return this.style.colourPrimary};\nBlockly.BlockSvg.prototype.setColour=function(a){Blockly.BlockSvg.superClass_.setColour.call(this,a);a=this.workspace.getRenderer().getConstants().getBlockStyleForColour(this.colour_);this.pathObject.setStyle(a.style);this.style=a.style;this.styleName_=a.name;this.applyColour()};\nBlockly.BlockSvg.prototype.setStyle=function(a){var b=this.workspace.getRenderer().getConstants().getBlockStyle(a);this.styleName_=a;if(b)this.hat=b.hat,this.pathObject.setStyle(b),this.colour_=b.colourPrimary,this.style=b,this.applyColour();else throw Error(\"Invalid style name: \"+a);};Blockly.BlockSvg.prototype.bringToFront=function(){var a=this;do{var b=a.getSvgRoot(),c=b.parentNode,d=c.childNodes;d[d.length-1]!==b&&c.appendChild(b);a=a.getParent()}while(a)};\nBlockly.BlockSvg.prototype.setPreviousStatement=function(a,b){Blockly.BlockSvg.superClass_.setPreviousStatement.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours())};Blockly.BlockSvg.prototype.setNextStatement=function(a,b){Blockly.BlockSvg.superClass_.setNextStatement.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours())};Blockly.BlockSvg.prototype.setOutput=function(a,b){Blockly.BlockSvg.superClass_.setOutput.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours())};\nBlockly.BlockSvg.prototype.setInputsInline=function(a){Blockly.BlockSvg.superClass_.setInputsInline.call(this,a);this.rendered&&(this.render(),this.bumpNeighbours())};Blockly.BlockSvg.prototype.removeInput=function(a,b){Blockly.BlockSvg.superClass_.removeInput.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours())};Blockly.BlockSvg.prototype.moveNumberedInputBefore=function(a,b){Blockly.BlockSvg.superClass_.moveNumberedInputBefore.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours())};\nBlockly.BlockSvg.prototype.appendInput_=function(a,b){a=Blockly.BlockSvg.superClass_.appendInput_.call(this,a,b);this.rendered&&(this.render(),this.bumpNeighbours());return a};\nBlockly.BlockSvg.prototype.setConnectionTracking=function(a){this.previousConnection&&this.previousConnection.setTracking(a);this.outputConnection&&this.outputConnection.setTracking(a);if(this.nextConnection){this.nextConnection.setTracking(a);var b=this.nextConnection.targetBlock();b&&b.setConnectionTracking(a)}if(!this.collapsed_)for(b=0;b<this.inputList.length;b++){var c=this.inputList[b].connection;c&&(c.setTracking(a),(c=c.targetBlock())&&c.setConnectionTracking(a))}};\nBlockly.BlockSvg.prototype.getConnections_=function(a){var b=[];if(a||this.rendered)if(this.outputConnection&&b.push(this.outputConnection),this.previousConnection&&b.push(this.previousConnection),this.nextConnection&&b.push(this.nextConnection),a||!this.collapsed_){a=0;for(var c;c=this.inputList[a];a++)c.connection&&b.push(c.connection)}return b};Blockly.BlockSvg.prototype.lastConnectionInStack=function(){return Blockly.BlockSvg.superClass_.lastConnectionInStack.call(this)};\nBlockly.BlockSvg.prototype.getMatchingConnection=function(a,b){return Blockly.BlockSvg.superClass_.getMatchingConnection.call(this,a,b)};Blockly.BlockSvg.prototype.makeConnection_=function(a){return new Blockly.RenderedConnection(this,a)};\nBlockly.BlockSvg.prototype.bumpNeighbours=function(){if(this.workspace&&!this.workspace.isDragging()){var a=this.getRootBlock();if(!a.isInFlyout)for(var b=this.getConnections_(!1),c=0,d;d=b[c];c++){d.isConnected()&&d.isSuperior()&&d.targetBlock().bumpNeighbours();for(var e=d.neighbours(Blockly.SNAP_RADIUS),f=0,g;g=e[f];f++)d.isConnected()&&g.isConnected()||g.getSourceBlock().getRootBlock()!=a&&(d.isSuperior()?g.bumpAwayFrom(d):d.bumpAwayFrom(g))}}};\nBlockly.BlockSvg.prototype.scheduleSnapAndBump=function(){var a=this,b=Blockly.Events.getGroup();setTimeout(function(){Blockly.Events.setGroup(b);a.snapToGrid();Blockly.Events.setGroup(!1)},Blockly.BUMP_DELAY/2);setTimeout(function(){Blockly.Events.setGroup(b);a.bumpNeighbours();Blockly.Events.setGroup(!1)},Blockly.BUMP_DELAY)};Blockly.BlockSvg.prototype.positionNearConnection=function(a,b){a.type!=Blockly.NEXT_STATEMENT&&a.type!=Blockly.INPUT_VALUE||this.moveBy(b.x-a.x,b.y-a.y)};\nBlockly.BlockSvg.prototype.getParent=function(){return Blockly.BlockSvg.superClass_.getParent.call(this)};Blockly.BlockSvg.prototype.getRootBlock=function(){return Blockly.BlockSvg.superClass_.getRootBlock.call(this)};\nBlockly.BlockSvg.prototype.render=function(a){Blockly.utils.dom.startTextWidthCache();this.rendered=!0;this.workspace.getRenderer().render(this);this.updateConnectionLocations_();!1!==a&&((a=this.getParent())?a.render(!0):this.workspace.resizeContents());Blockly.utils.dom.stopTextWidthCache();this.updateMarkers_()};\nBlockly.BlockSvg.prototype.updateMarkers_=function(){this.workspace.keyboardAccessibilityMode&&this.pathObject.cursorSvg&&this.workspace.getCursor().draw();this.workspace.keyboardAccessibilityMode&&this.pathObject.markerSvg&&this.workspace.getMarker(Blockly.navigation.MARKER_NAME).draw()};\nBlockly.BlockSvg.prototype.updateConnectionLocations_=function(){var a=this.getRelativeToSurfaceXY();this.previousConnection&&this.previousConnection.moveToOffset(a);this.outputConnection&&this.outputConnection.moveToOffset(a);for(var b=0;b<this.inputList.length;b++){var c=this.inputList[b].connection;c&&(c.moveToOffset(a),c.isConnected()&&c.tighten())}this.nextConnection&&(this.nextConnection.moveToOffset(a),this.nextConnection.isConnected()&&this.nextConnection.tighten())};\nBlockly.BlockSvg.prototype.setCursorSvg=function(a){this.pathObject.setCursorSvg(a)};Blockly.BlockSvg.prototype.setMarkerSvg=function(a){this.pathObject.setMarkerSvg(a)};Blockly.BlockSvg.prototype.getHeightWidth=function(){var a=this.height,b=this.width,c=this.getNextBlock();if(c){c=c.getHeightWidth();var d=this.workspace.getRenderer().getConstants().NOTCH_HEIGHT;a+=c.height-d;b=Math.max(b,c.width)}return{height:a,width:b}};Blockly.BlockSvg.prototype.fadeForReplacement=function(a){this.pathObject.updateReplacementFade(a)};\nBlockly.BlockSvg.prototype.highlightShapeForInput=function(a,b){this.pathObject.updateShapeForInputHighlight(a,b)};Blockly.blockRendering.rendererMap_={};Blockly.blockRendering.useDebugger=!1;Blockly.blockRendering.register=function(a,b){if(Blockly.blockRendering.rendererMap_[a])throw Error(\"Renderer has already been registered.\");Blockly.blockRendering.rendererMap_[a]=b};Blockly.blockRendering.unregister=function(a){Blockly.blockRendering.rendererMap_[a]?delete Blockly.blockRendering.rendererMap_[a]:console.warn('No renderer mapping for name \"'+a+'\" found to unregister')};\nBlockly.blockRendering.startDebugger=function(){Blockly.blockRendering.useDebugger=!0};Blockly.blockRendering.stopDebugger=function(){Blockly.blockRendering.useDebugger=!1};Blockly.blockRendering.init=function(a,b,c){if(!Blockly.blockRendering.rendererMap_[a])throw Error(\"Renderer not registered: \",a);a=new Blockly.blockRendering.rendererMap_[a](a);a.init(b,c);return a};Blockly.ConnectionDB=function(){this.connections_=[]};Blockly.ConnectionDB.prototype.addConnection=function(a,b){b=this.calculateIndexForYPos_(b);this.connections_.splice(b,0,a)};\nBlockly.ConnectionDB.prototype.findIndexOfConnection_=function(a,b){if(!this.connections_.length)return-1;var c=this.calculateIndexForYPos_(b);if(c>=this.connections_.length)return-1;b=a.y;for(var d=c;0<=d&&this.connections_[d].y==b;){if(this.connections_[d]==a)return d;d--}for(;c<this.connections_.length&&this.connections_[c].y==b;){if(this.connections_[c]==a)return c;c++}return-1};\nBlockly.ConnectionDB.prototype.calculateIndexForYPos_=function(a){if(!this.connections_.length)return 0;for(var b=0,c=this.connections_.length;b<c;){var d=Math.floor((b+c)/2);if(this.connections_[d].y<a)b=d+1;else if(this.connections_[d].y>a)c=d;else{b=d;break}}return b};Blockly.ConnectionDB.prototype.removeConnection=function(a,b){a=this.findIndexOfConnection_(a,b);if(-1==a)throw Error(\"Unable to find connection in connectionDB.\");this.connections_.splice(a,1)};\nBlockly.ConnectionDB.prototype.getNeighbours=function(a,b){function c(a){var c=e-d[a].x,g=f-d[a].y;Math.sqrt(c*c+g*g)<=b&&k.push(d[a]);return g<b}var d=this.connections_,e=a.x,f=a.y;a=0;for(var g=d.length-2,h=g;a<h;)d[h].y<f?a=h:g=h,h=Math.floor((a+g)/2);var k=[];g=a=h;if(d.length){for(;0<=a&&c(a);)a--;do g++;while(g<d.length&&c(g))}return k};Blockly.ConnectionDB.prototype.isInYRange_=function(a,b,c){return Math.abs(this.connections_[a].y-b)<=c};\nBlockly.ConnectionDB.prototype.searchForClosest=function(a,b,c){if(!this.connections_.length)return{connection:null,radius:b};var d=a.y,e=a.x;a.x=e+c.x;a.y=d+c.y;var f=this.calculateIndexForYPos_(a.y);c=null;for(var g=b,h,k=f-1;0<=k&&this.isInYRange_(k,a.y,b);)h=this.connections_[k],a.isConnectionAllowed(h,g)&&(c=h,g=h.distanceFrom(a)),k--;for(;f<this.connections_.length&&this.isInYRange_(f,a.y,b);)h=this.connections_[f],a.isConnectionAllowed(h,g)&&(c=h,g=h.distanceFrom(a)),f++;a.x=e;a.y=d;return{connection:c,\nradius:g}};Blockly.ConnectionDB.init=function(){var a=[];a[Blockly.INPUT_VALUE]=new Blockly.ConnectionDB;a[Blockly.OUTPUT_VALUE]=new Blockly.ConnectionDB;a[Blockly.NEXT_STATEMENT]=new Blockly.ConnectionDB;a[Blockly.PREVIOUS_STATEMENT]=new Blockly.ConnectionDB;return a};Blockly.MarkerManager=function(a){this.cursorSvg_=this.cursor_=null;this.markers_={};this.workspace_=a};Blockly.MarkerManager.prototype.registerMarker=function(a,b){this.markers_[a]&&this.unregisterMarker(a);b.setDrawer(this.workspace_.getRenderer().makeMarkerDrawer(this.workspace_,b));this.setMarkerSvg(b.getDrawer().createDom());this.markers_[a]=b};\nBlockly.MarkerManager.prototype.unregisterMarker=function(a){var b=this.markers_[a];if(b)b.dispose(),delete this.markers_[a];else throw Error(\"Marker with id \"+a+\" does not exist. Can only unregistermarkers that exist.\");};Blockly.MarkerManager.prototype.getCursor=function(){return this.cursor_};Blockly.MarkerManager.prototype.getMarker=function(a){return this.markers_[a]};\nBlockly.MarkerManager.prototype.setCursor=function(a){this.cursor_&&this.cursor_.getDrawer()&&this.cursor_.getDrawer().dispose();if(this.cursor_=a)a=this.workspace_.getRenderer().makeMarkerDrawer(this.workspace_,this.cursor_),this.cursor_.setDrawer(a),this.setCursorSvg(this.cursor_.getDrawer().createDom())};Blockly.MarkerManager.prototype.setCursorSvg=function(a){a?(this.workspace_.getBlockCanvas().appendChild(a),this.cursorSvg_=a):this.cursorSvg_=null};\nBlockly.MarkerManager.prototype.setMarkerSvg=function(a){a?this.workspace_.getBlockCanvas()&&(this.cursorSvg_?this.workspace_.getBlockCanvas().insertBefore(a,this.cursorSvg_):this.workspace_.getBlockCanvas().appendChild(a)):this.markerSvg_=null};Blockly.MarkerManager.prototype.updateMarkers=function(){this.workspace_.keyboardAccessibilityMode&&this.cursorSvg_&&this.workspace_.getCursor().draw()};\nBlockly.MarkerManager.prototype.dispose=function(){for(var a=Object.keys(this.markers_),b=0,c;c=a[b];b++)this.unregisterMarker(c);this.markers_=null;this.cursor_.dispose();this.cursor_=null};Blockly.ThemeManager=function(a,b){this.workspace_=a;this.theme_=b;this.subscribedWorkspaces_=[];this.componentDB_=Object.create(null)};Blockly.ThemeManager.prototype.getTheme=function(){return this.theme_};\nBlockly.ThemeManager.prototype.setTheme=function(a){var b=this.theme_;this.theme_=a;if(a=this.workspace_.getInjectionDiv())b&&Blockly.utils.dom.removeClass(a,b.getClassName()),Blockly.utils.dom.addClass(a,this.theme_.getClassName());for(b=0;a=this.subscribedWorkspaces_[b];b++)a.refreshTheme();b=0;a=Object.keys(this.componentDB_);for(var c;c=a[b];b++)for(var d=0,e;e=this.componentDB_[c][d];d++){var f=e.element;e=e.propertyName;var g=this.theme_&&this.theme_.getComponentStyle(c);f.style[e]=g||\"\"}Blockly.hideChaff()};\nBlockly.ThemeManager.prototype.subscribeWorkspace=function(a){this.subscribedWorkspaces_.push(a)};Blockly.ThemeManager.prototype.unsubscribeWorkspace=function(a){a=this.subscribedWorkspaces_.indexOf(a);if(0>a)throw Error(\"Cannot unsubscribe a workspace that hasn't been subscribed.\");this.subscribedWorkspaces_.splice(a,1)};\nBlockly.ThemeManager.prototype.subscribe=function(a,b,c){this.componentDB_[b]||(this.componentDB_[b]=[]);this.componentDB_[b].push({element:a,propertyName:c});b=this.theme_&&this.theme_.getComponentStyle(b);a.style[c]=b||\"\"};Blockly.ThemeManager.prototype.unsubscribe=function(a){if(a)for(var b=Object.keys(this.componentDB_),c=0,d;d=b[c];c++){for(var e=this.componentDB_[d],f=e.length-1;0<=f;f--)e[f].element===a&&e.splice(f,1);this.componentDB_[d].length||delete this.componentDB_[d]}};\nBlockly.ThemeManager.prototype.dispose=function(){this.componentDB_=this.subscribedWorkspaces_=this.theme_=this.owner_=null};Blockly.TouchGesture=function(a,b){Blockly.TouchGesture.superClass_.constructor.call(this,a,b);this.isMultiTouch_=!1;this.cachedPoints_=Object.create(null);this.startDistance_=this.previousScale_=0;this.isPinchZoomEnabled_=this.onStartWrapper_=null};Blockly.utils.object.inherits(Blockly.TouchGesture,Blockly.Gesture);Blockly.TouchGesture.ZOOM_IN_MULTIPLIER=5;Blockly.TouchGesture.ZOOM_OUT_MULTIPLIER=6;\nBlockly.TouchGesture.prototype.doStart=function(a){this.isPinchZoomEnabled_=this.startWorkspace_.options.zoomOptions&&this.startWorkspace_.options.zoomOptions.pinch;Blockly.TouchGesture.superClass_.doStart.call(this,a);!this.isEnding_&&Blockly.Touch.isTouchEvent(a)&&this.handleTouchStart(a)};\nBlockly.TouchGesture.prototype.bindMouseEvents=function(a){this.onStartWrapper_=Blockly.bindEventWithChecks_(document,\"mousedown\",null,this.handleStart.bind(this),!0);this.onMoveWrapper_=Blockly.bindEventWithChecks_(document,\"mousemove\",null,this.handleMove.bind(this),!0);this.onUpWrapper_=Blockly.bindEventWithChecks_(document,\"mouseup\",null,this.handleUp.bind(this),!0);a.preventDefault();a.stopPropagation()};\nBlockly.TouchGesture.prototype.handleStart=function(a){!this.isDragging()&&Blockly.Touch.isTouchEvent(a)&&(this.handleTouchStart(a),this.isMultiTouch()&&Blockly.longStop_())};Blockly.TouchGesture.prototype.handleMove=function(a){this.isDragging()?Blockly.Touch.shouldHandleEvent(a)&&Blockly.TouchGesture.superClass_.handleMove.call(this,a):this.isMultiTouch()?(Blockly.Touch.isTouchEvent(a)&&this.handleTouchMove(a),Blockly.longStop_()):Blockly.TouchGesture.superClass_.handleMove.call(this,a)};\nBlockly.TouchGesture.prototype.handleUp=function(a){Blockly.Touch.isTouchEvent(a)&&!this.isDragging()&&this.handleTouchEnd(a);!this.isMultiTouch()||this.isDragging()?Blockly.Touch.shouldHandleEvent(a)&&Blockly.TouchGesture.superClass_.handleUp.call(this,a):(a.preventDefault(),a.stopPropagation(),this.dispose())};Blockly.TouchGesture.prototype.isMultiTouch=function(){return this.isMultiTouch_};\nBlockly.TouchGesture.prototype.dispose=function(){Blockly.TouchGesture.superClass_.dispose.call(this);this.onStartWrapper_&&Blockly.unbindEvent_(this.onStartWrapper_)};Blockly.TouchGesture.prototype.handleTouchStart=function(a){var b=Blockly.Touch.getTouchIdentifierFromEvent(a);this.cachedPoints_[b]=this.getTouchPoint(a);b=Object.keys(this.cachedPoints_);2==b.length&&(this.startDistance_=Blockly.utils.Coordinate.distance(this.cachedPoints_[b[0]],this.cachedPoints_[b[1]]),this.isMultiTouch_=!0,a.preventDefault())};\nBlockly.TouchGesture.prototype.handleTouchMove=function(a){var b=Blockly.Touch.getTouchIdentifierFromEvent(a);this.cachedPoints_[b]=this.getTouchPoint(a);b=Object.keys(this.cachedPoints_);this.isPinchZoomEnabled_&&2===b.length?this.handlePinch_(a):Blockly.TouchGesture.superClass_.handleMove.call(this,a)};\nBlockly.TouchGesture.prototype.handlePinch_=function(a){var b=Object.keys(this.cachedPoints_);b=Blockly.utils.Coordinate.distance(this.cachedPoints_[b[0]],this.cachedPoints_[b[1]])/this.startDistance_;if(0<this.previousScale_&&Infinity>this.previousScale_){var c=b-this.previousScale_;c=0<c?c*Blockly.TouchGesture.ZOOM_IN_MULTIPLIER:c*Blockly.TouchGesture.ZOOM_OUT_MULTIPLIER;var d=this.startWorkspace_,e=Blockly.utils.mouseToSvg(a,d.getParentSvg(),d.getInverseScreenCTM());d.zoom(e.x,e.y,c)}this.previousScale_=\nb;a.preventDefault()};Blockly.TouchGesture.prototype.handleTouchEnd=function(a){a=Blockly.Touch.getTouchIdentifierFromEvent(a);this.cachedPoints_[a]&&delete this.cachedPoints_[a];2>Object.keys(this.cachedPoints_).length&&(this.cachedPoints_=Object.create(null),this.previousScale_=0)};Blockly.TouchGesture.prototype.getTouchPoint=function(a){return this.startWorkspace_?new Blockly.utils.Coordinate(a.pageX?a.pageX:a.changedTouches[0].pageX,a.pageY?a.pageY:a.changedTouches[0].pageY):null};Blockly.WorkspaceAudio=function(a){this.parentWorkspace_=a;this.SOUNDS_=Object.create(null)};Blockly.WorkspaceAudio.prototype.lastSound_=null;Blockly.WorkspaceAudio.prototype.dispose=function(){this.SOUNDS_=this.parentWorkspace_=null};\nBlockly.WorkspaceAudio.prototype.load=function(a,b){if(a.length){try{var c=new Blockly.utils.global.Audio}catch(h){return}for(var d,e=0;e<a.length;e++){var f=a[e],g=f.match(/\\.(\\w+)$/);if(g&&c.canPlayType(\"audio/\"+g[1])){d=new Blockly.utils.global.Audio(f);break}}d&&d.play&&(this.SOUNDS_[b]=d)}};\nBlockly.WorkspaceAudio.prototype.preload=function(){for(var a in this.SOUNDS_){var b=this.SOUNDS_[a];b.volume=.01;var c=b.play();void 0!==c?c.then(b.pause).catch(function(){}):b.pause();if(Blockly.utils.userAgent.IPAD||Blockly.utils.userAgent.IPHONE)break}};\nBlockly.WorkspaceAudio.prototype.play=function(a,b){var c=this.SOUNDS_[a];c?(a=new Date,null!=this.lastSound_&&a-this.lastSound_<Blockly.SOUND_LIMIT||(this.lastSound_=a,c=Blockly.utils.userAgent.IPAD||Blockly.utils.userAgent.ANDROID?c:c.cloneNode(),c.volume=void 0===b?1:b,c.play())):this.parentWorkspace_&&this.parentWorkspace_.getAudioManager().play(a,b)};Blockly.WorkspaceSvg=function(a,b,c){Blockly.WorkspaceSvg.superClass_.constructor.call(this,a);this.getMetrics=a.getMetrics||Blockly.WorkspaceSvg.getTopLevelWorkspaceMetrics_;this.setMetrics=a.setMetrics||Blockly.WorkspaceSvg.setTopLevelWorkspaceMetrics_;this.connectionDBList=Blockly.ConnectionDB.init();b&&(this.blockDragSurface_=b);c&&(this.workspaceDragSurface_=c);this.useWorkspaceDragSurface_=!!this.workspaceDragSurface_&&Blockly.utils.is3dSupported();this.highlightedBlocks_=[];this.audioManager_=\nnew Blockly.WorkspaceAudio(a.parentWorkspace);this.grid_=this.options.gridPattern?new Blockly.Grid(a.gridPattern,a.gridOptions):null;this.markerManager_=new Blockly.MarkerManager(this);this.toolboxCategoryCallbacks_={};this.flyoutButtonCallbacks_={};Blockly.Variables&&Blockly.Variables.flyoutCategory&&this.registerToolboxCategoryCallback(Blockly.VARIABLE_CATEGORY_NAME,Blockly.Variables.flyoutCategory);Blockly.VariablesDynamic&&Blockly.VariablesDynamic.flyoutCategory&&this.registerToolboxCategoryCallback(Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME,\nBlockly.VariablesDynamic.flyoutCategory);Blockly.Procedures&&Blockly.Procedures.flyoutCategory&&(this.registerToolboxCategoryCallback(Blockly.PROCEDURE_CATEGORY_NAME,Blockly.Procedures.flyoutCategory),this.addChangeListener(Blockly.Procedures.mutatorOpenListener));this.themeManager_=this.options.parentWorkspace?this.options.parentWorkspace.getThemeManager():new Blockly.ThemeManager(this,this.options.theme||Blockly.Themes.Classic);this.themeManager_.subscribeWorkspace(this);this.renderer_=Blockly.blockRendering.init(this.options.renderer||\n\"geras\",this.getTheme(),this.options.rendererOverrides);this.cachedParentSvg_=null;this.keyboardAccessibilityMode=!1};Blockly.utils.object.inherits(Blockly.WorkspaceSvg,Blockly.Workspace);Blockly.WorkspaceSvg.prototype.resizeHandlerWrapper_=null;Blockly.WorkspaceSvg.prototype.rendered=!0;Blockly.WorkspaceSvg.prototype.isVisible_=!0;Blockly.WorkspaceSvg.prototype.isFlyout=!1;Blockly.WorkspaceSvg.prototype.isMutator=!1;Blockly.WorkspaceSvg.prototype.resizesEnabled_=!0;\nBlockly.WorkspaceSvg.prototype.scrollX=0;Blockly.WorkspaceSvg.prototype.scrollY=0;Blockly.WorkspaceSvg.prototype.startScrollX=0;Blockly.WorkspaceSvg.prototype.startScrollY=0;Blockly.WorkspaceSvg.prototype.dragDeltaXY_=null;Blockly.WorkspaceSvg.prototype.scale=1;Blockly.WorkspaceSvg.prototype.trashcan=null;Blockly.WorkspaceSvg.prototype.scrollbar=null;Blockly.WorkspaceSvg.prototype.flyout_=null;Blockly.WorkspaceSvg.prototype.toolbox_=null;Blockly.WorkspaceSvg.prototype.currentGesture_=null;\nBlockly.WorkspaceSvg.prototype.blockDragSurface_=null;Blockly.WorkspaceSvg.prototype.workspaceDragSurface_=null;Blockly.WorkspaceSvg.prototype.useWorkspaceDragSurface_=!1;Blockly.WorkspaceSvg.prototype.isDragSurfaceActive_=!1;Blockly.WorkspaceSvg.prototype.injectionDiv_=null;Blockly.WorkspaceSvg.prototype.lastRecordedPageScroll_=null;Blockly.WorkspaceSvg.prototype.targetWorkspace=null;Blockly.WorkspaceSvg.prototype.inverseScreenCTM_=null;Blockly.WorkspaceSvg.prototype.inverseScreenCTMDirty_=!0;\nBlockly.WorkspaceSvg.prototype.getMarkerManager=function(){return this.markerManager_};Blockly.WorkspaceSvg.prototype.setCursorSvg=function(a){this.markerManager_.setCursorSvg(a)};Blockly.WorkspaceSvg.prototype.setMarkerSvg=function(a){this.markerManager_.setMarkerSvg(a)};Blockly.WorkspaceSvg.prototype.getMarker=function(a){return this.markerManager_?this.markerManager_.getMarker(a):null};\nBlockly.WorkspaceSvg.prototype.getCursor=function(){return this.markerManager_?this.markerManager_.getCursor():null};Blockly.WorkspaceSvg.prototype.getRenderer=function(){return this.renderer_};Blockly.WorkspaceSvg.prototype.getThemeManager=function(){return this.themeManager_};Blockly.WorkspaceSvg.prototype.getTheme=function(){return this.themeManager_.getTheme()};Blockly.WorkspaceSvg.prototype.setTheme=function(a){a||(a=Blockly.Themes.Classic);this.themeManager_.setTheme(a)};\nBlockly.WorkspaceSvg.prototype.refreshTheme=function(){this.svgGroup_&&this.renderer_.refreshDom(this.svgGroup_,this.getTheme());this.updateBlockStyles_(this.getAllBlocks(!1).filter(function(a){return void 0!==a.getStyleName()}));this.refreshToolboxSelection();this.toolbox_&&this.toolbox_.updateColourFromTheme();this.isVisible()&&this.setVisible(!0);var a=new Blockly.Events.Ui(null,\"theme\",null,null);a.workspaceId=this.id;Blockly.Events.fire(a)};\nBlockly.WorkspaceSvg.prototype.updateBlockStyles_=function(a){for(var b=0,c;c=a[b];b++){var d=c.getStyleName();d&&(c.setStyle(d),c.mutator&&c.mutator.updateBlockStyle())}};Blockly.WorkspaceSvg.prototype.getInverseScreenCTM=function(){if(this.inverseScreenCTMDirty_){var a=this.getParentSvg().getScreenCTM();a&&(this.inverseScreenCTM_=a.inverse(),this.inverseScreenCTMDirty_=!1)}return this.inverseScreenCTM_};\nBlockly.WorkspaceSvg.prototype.updateInverseScreenCTM=function(){this.inverseScreenCTMDirty_=!0};Blockly.WorkspaceSvg.prototype.isVisible=function(){return this.isVisible_};\nBlockly.WorkspaceSvg.prototype.getSvgXY=function(a){var b=0,c=0,d=1;if(Blockly.utils.dom.containsNode(this.getCanvas(),a)||Blockly.utils.dom.containsNode(this.getBubbleCanvas(),a))d=this.scale;do{var e=Blockly.utils.getRelativeXY(a);if(a==this.getCanvas()||a==this.getBubbleCanvas())d=1;b+=e.x*d;c+=e.y*d;a=a.parentNode}while(a&&a!=this.getParentSvg());return new Blockly.utils.Coordinate(b,c)};Blockly.WorkspaceSvg.prototype.getOriginOffsetInPixels=function(){return Blockly.utils.getInjectionDivXY_(this.getCanvas())};\nBlockly.WorkspaceSvg.prototype.getInjectionDiv=function(){if(!this.injectionDiv_)for(var a=this.svgGroup_;a;){if(-1!=(\" \"+(a.getAttribute(\"class\")||\"\")+\" \").indexOf(\" injectionDiv \")){this.injectionDiv_=a;break}a=a.parentNode}return this.injectionDiv_};Blockly.WorkspaceSvg.prototype.getBlockCanvas=function(){return this.svgBlockCanvas_};Blockly.WorkspaceSvg.prototype.setResizeHandlerWrapper=function(a){this.resizeHandlerWrapper_=a};\nBlockly.WorkspaceSvg.prototype.createDom=function(a){this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyWorkspace\"},null);a&&(this.svgBackground_=Blockly.utils.dom.createSvgElement(\"rect\",{height:\"100%\",width:\"100%\",\"class\":a},this.svgGroup_),\"blocklyMainBackground\"==a&&this.grid_?this.svgBackground_.style.fill=\"url(#\"+this.grid_.getPatternId()+\")\":this.themeManager_.subscribe(this.svgBackground_,\"workspaceBackgroundColour\",\"fill\"));this.svgBlockCanvas_=Blockly.utils.dom.createSvgElement(\"g\",\n{\"class\":\"blocklyBlockCanvas\"},this.svgGroup_);this.svgBubbleCanvas_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyBubbleCanvas\"},this.svgGroup_);this.isFlyout||(Blockly.bindEventWithChecks_(this.svgGroup_,\"mousedown\",this,this.onMouseDown_,!1,!0),Blockly.bindEventWithChecks_(this.svgGroup_,\"wheel\",this,this.onMouseWheel_));if(this.options.hasCategories){if(!Blockly.Toolbox)throw Error(\"Missing require for Blockly.Toolbox\");this.toolbox_=new Blockly.Toolbox(this)}this.grid_&&this.grid_.update(this.scale);\nthis.recordDeleteAreas();this.markerManager_.setCursor(new Blockly.Cursor);this.markerManager_.registerMarker(Blockly.navigation.MARKER_NAME,new Blockly.Marker);this.renderer_.createDom(this.svgGroup_,this.getTheme());return this.svgGroup_};\nBlockly.WorkspaceSvg.prototype.dispose=function(){this.rendered=!1;this.currentGesture_&&this.currentGesture_.cancel();this.svgGroup_&&(Blockly.utils.dom.removeNode(this.svgGroup_),this.svgGroup_=null);this.svgBubbleCanvas_=this.svgBlockCanvas_=null;this.toolbox_&&(this.toolbox_.dispose(),this.toolbox_=null);this.flyout_&&(this.flyout_.dispose(),this.flyout_=null);this.trashcan&&(this.trashcan.dispose(),this.trashcan=null);this.scrollbar&&(this.scrollbar.dispose(),this.scrollbar=null);this.zoomControls_&&\n(this.zoomControls_.dispose(),this.zoomControls_=null);this.audioManager_&&(this.audioManager_.dispose(),this.audioManager_=null);this.grid_&&(this.grid_.dispose(),this.grid_=null);this.renderer_.dispose();this.themeManager_&&(this.themeManager_.unsubscribeWorkspace(this),this.themeManager_.unsubscribe(this.svgBackground_),this.options.parentWorkspace||(this.themeManager_.dispose(),this.themeManager_=null));this.markerManager_&&(this.markerManager_.dispose(),this.markerManager_=null);Blockly.WorkspaceSvg.superClass_.dispose.call(this);\nthis.flyoutButtonCallbacks_=this.toolboxCategoryCallbacks_=this.connectionDBList=null;if(!this.options.parentWorkspace){var a=this.getParentSvg().parentNode;a&&Blockly.utils.dom.removeNode(a)}this.resizeHandlerWrapper_&&(Blockly.unbindEvent_(this.resizeHandlerWrapper_),this.resizeHandlerWrapper_=null)};Blockly.WorkspaceSvg.prototype.newBlock=function(a,b){return new Blockly.BlockSvg(this,a,b)};\nBlockly.WorkspaceSvg.prototype.addTrashcan=function(){if(!Blockly.Trashcan)throw Error(\"Missing require for Blockly.Trashcan\");this.trashcan=new Blockly.Trashcan(this);var a=this.trashcan.createDom();this.svgGroup_.insertBefore(a,this.svgBlockCanvas_)};Blockly.WorkspaceSvg.prototype.addZoomControls=function(){if(!Blockly.ZoomControls)throw Error(\"Missing require for Blockly.ZoomControls\");this.zoomControls_=new Blockly.ZoomControls(this);var a=this.zoomControls_.createDom();this.svgGroup_.appendChild(a)};\nBlockly.WorkspaceSvg.prototype.addFlyout=function(a){var b=new Blockly.Options({parentWorkspace:this,rtl:this.RTL,oneBasedIndex:this.options.oneBasedIndex,horizontalLayout:this.horizontalLayout,renderer:this.options.renderer,rendererOverrides:this.options.rendererOverrides});b.toolboxPosition=this.options.toolboxPosition;if(this.horizontalLayout){if(!Blockly.HorizontalFlyout)throw Error(\"Missing require for Blockly.HorizontalFlyout\");this.flyout_=new Blockly.HorizontalFlyout(b)}else{if(!Blockly.VerticalFlyout)throw Error(\"Missing require for Blockly.VerticalFlyout\");\nthis.flyout_=new Blockly.VerticalFlyout(b)}this.flyout_.autoClose=!1;this.flyout_.getWorkspace().setVisible(!0);return this.flyout_.createDom(a)};Blockly.WorkspaceSvg.prototype.getFlyout=function(a){return this.flyout_||a?this.flyout_:this.toolbox_?this.toolbox_.getFlyout():null};Blockly.WorkspaceSvg.prototype.getToolbox=function(){return this.toolbox_};Blockly.WorkspaceSvg.prototype.updateScreenCalculations_=function(){this.updateInverseScreenCTM();this.recordDeleteAreas()};\nBlockly.WorkspaceSvg.prototype.resizeContents=function(){this.resizesEnabled_&&this.rendered&&(this.scrollbar&&this.scrollbar.resize(),this.updateInverseScreenCTM())};Blockly.WorkspaceSvg.prototype.resize=function(){this.toolbox_&&this.toolbox_.position();this.flyout_&&this.flyout_.position();this.trashcan&&this.trashcan.position();this.zoomControls_&&this.zoomControls_.position();this.scrollbar&&this.scrollbar.resize();this.updateScreenCalculations_()};\nBlockly.WorkspaceSvg.prototype.updateScreenCalculationsIfScrolled=function(){var a=Blockly.utils.getDocumentScroll();Blockly.utils.Coordinate.equals(this.lastRecordedPageScroll_,a)||(this.lastRecordedPageScroll_=a,this.updateScreenCalculations_())};Blockly.WorkspaceSvg.prototype.getCanvas=function(){return this.svgBlockCanvas_};Blockly.WorkspaceSvg.prototype.getBubbleCanvas=function(){return this.svgBubbleCanvas_};\nBlockly.WorkspaceSvg.prototype.getParentSvg=function(){if(!this.cachedParentSvg_)for(var a=this.svgGroup_;a;){if(\"svg\"==a.tagName){this.cachedParentSvg_=a;break}a=a.parentNode}return this.cachedParentSvg_};\nBlockly.WorkspaceSvg.prototype.translate=function(a,b){if(this.useWorkspaceDragSurface_&&this.isDragSurfaceActive_)this.workspaceDragSurface_.translateSurface(a,b);else{var c=\"translate(\"+a+\",\"+b+\") scale(\"+this.scale+\")\";this.svgBlockCanvas_.setAttribute(\"transform\",c);this.svgBubbleCanvas_.setAttribute(\"transform\",c)}this.blockDragSurface_&&this.blockDragSurface_.translateAndScaleGroup(a,b,this.scale);this.grid_&&this.grid_.moveTo(a,b)};\nBlockly.WorkspaceSvg.prototype.resetDragSurface=function(){if(this.useWorkspaceDragSurface_){this.isDragSurfaceActive_=!1;var a=this.workspaceDragSurface_.getSurfaceTranslation();this.workspaceDragSurface_.clearAndHide(this.svgGroup_);a=\"translate(\"+a.x+\",\"+a.y+\") scale(\"+this.scale+\")\";this.svgBlockCanvas_.setAttribute(\"transform\",a);this.svgBubbleCanvas_.setAttribute(\"transform\",a)}};\nBlockly.WorkspaceSvg.prototype.setupDragSurface=function(){if(this.useWorkspaceDragSurface_&&!this.isDragSurfaceActive_){this.isDragSurfaceActive_=!0;var a=this.svgBlockCanvas_.previousSibling,b=parseInt(this.getParentSvg().getAttribute(\"width\"),10),c=parseInt(this.getParentSvg().getAttribute(\"height\"),10),d=Blockly.utils.getRelativeXY(this.getCanvas());this.workspaceDragSurface_.setContentsAndShow(this.getCanvas(),this.getBubbleCanvas(),a,b,c,this.scale);this.workspaceDragSurface_.translateSurface(d.x,\nd.y)}};Blockly.WorkspaceSvg.prototype.getBlockDragSurface=function(){return this.blockDragSurface_};Blockly.WorkspaceSvg.prototype.getWidth=function(){var a=this.getMetrics();return a?a.viewWidth/this.scale:0};\nBlockly.WorkspaceSvg.prototype.setVisible=function(a){this.isVisible_=a;if(this.svgGroup_)if(this.scrollbar&&this.scrollbar.setContainerVisible(a),this.getFlyout()&&this.getFlyout().setContainerVisible(a),this.getParentSvg().style.display=a?\"block\":\"none\",this.toolbox_&&(this.toolbox_.HtmlDiv.style.display=a?\"block\":\"none\"),a){a=this.getAllBlocks(!1);for(var b=a.length-1;0<=b;b--)a[b].markDirty();this.render();this.toolbox_&&this.toolbox_.position()}else Blockly.hideChaff(!0)};\nBlockly.WorkspaceSvg.prototype.render=function(){for(var a=this.getAllBlocks(!1),b=a.length-1;0<=b;b--)a[b].render(!1);if(this.currentGesture_)for(a=this.currentGesture_.getInsertionMarkers(),b=0;b<a.length;b++)a[b].render(!1);this.markerManager_.updateMarkers()};Blockly.WorkspaceSvg.prototype.traceOn=function(){console.warn(\"Deprecated call to traceOn, delete this.\")};\nBlockly.WorkspaceSvg.prototype.highlightBlock=function(a,b){if(void 0===b){for(var c=0,d;d=this.highlightedBlocks_[c];c++)d.setHighlighted(!1);this.highlightedBlocks_.length=0}if(d=a?this.getBlockById(a):null)(a=void 0===b||b)?-1==this.highlightedBlocks_.indexOf(d)&&this.highlightedBlocks_.push(d):Blockly.utils.arrayRemove(this.highlightedBlocks_,d),d.setHighlighted(a)};\nBlockly.WorkspaceSvg.prototype.paste=function(a){!this.rendered||a.getElementsByTagName(\"block\").length>=this.remainingCapacity()||(this.currentGesture_&&this.currentGesture_.cancel(),\"comment\"==a.tagName.toLowerCase()?this.pasteWorkspaceComment_(a):this.pasteBlock_(a))};\nBlockly.WorkspaceSvg.prototype.pasteBlock_=function(a){Blockly.Events.disable();try{var b=Blockly.Xml.domToBlock(a,this),c=this.getMarker(Blockly.navigation.MARKER_NAME).getCurNode();if(this.keyboardAccessibilityMode&&c&&c.isConnection()){var d=c.getLocation();Blockly.navigation.insertBlock(b,d);return}var e=parseInt(a.getAttribute(\"x\"),10),f=parseInt(a.getAttribute(\"y\"),10);if(!isNaN(e)&&!isNaN(f)){this.RTL&&(e=-e);do{a=!1;var g=this.getAllBlocks(!1);c=0;for(var h;h=g[c];c++){var k=h.getRelativeToSurfaceXY();\nif(1>=Math.abs(e-k.x)&&1>=Math.abs(f-k.y)){a=!0;break}}if(!a){var l=b.getConnections_(!1);c=0;for(var m;m=l[c];c++)if(m.closest(Blockly.SNAP_RADIUS,new Blockly.utils.Coordinate(e,f)).connection){a=!0;break}}a&&(e=this.RTL?e-Blockly.SNAP_RADIUS:e+Blockly.SNAP_RADIUS,f+=2*Blockly.SNAP_RADIUS)}while(a);b.moveBy(e,f)}}finally{Blockly.Events.enable()}Blockly.Events.isEnabled()&&!b.isShadow()&&Blockly.Events.fire(new Blockly.Events.BlockCreate(b));b.select()};\nBlockly.WorkspaceSvg.prototype.pasteWorkspaceComment_=function(a){Blockly.Events.disable();try{var b=Blockly.WorkspaceCommentSvg.fromXml(a,this),c=parseInt(a.getAttribute(\"x\"),10),d=parseInt(a.getAttribute(\"y\"),10);isNaN(c)||isNaN(d)||(this.RTL&&(c=-c),b.moveBy(c+50,d+50))}finally{Blockly.Events.enable()}Blockly.Events.isEnabled();b.select()};\nBlockly.WorkspaceSvg.prototype.refreshToolboxSelection=function(){var a=this.isFlyout?this.targetWorkspace:this;a&&!a.currentGesture_&&a.toolbox_&&a.toolbox_.getFlyout()&&a.toolbox_.refreshSelection()};Blockly.WorkspaceSvg.prototype.renameVariableById=function(a,b){Blockly.WorkspaceSvg.superClass_.renameVariableById.call(this,a,b);this.refreshToolboxSelection()};Blockly.WorkspaceSvg.prototype.deleteVariableById=function(a){Blockly.WorkspaceSvg.superClass_.deleteVariableById.call(this,a);this.refreshToolboxSelection()};\nBlockly.WorkspaceSvg.prototype.createVariable=function(a,b,c){a=Blockly.WorkspaceSvg.superClass_.createVariable.call(this,a,b,c);this.refreshToolboxSelection();return a};Blockly.WorkspaceSvg.prototype.recordDeleteAreas=function(){this.deleteAreaTrash_=this.trashcan&&this.svgGroup_.parentNode?this.trashcan.getClientRect():null;this.deleteAreaToolbox_=this.flyout_?this.flyout_.getClientRect():this.toolbox_?this.toolbox_.getClientRect():null};\nBlockly.WorkspaceSvg.prototype.isDeleteArea=function(a){return this.deleteAreaTrash_&&this.deleteAreaTrash_.contains(a.clientX,a.clientY)?Blockly.DELETE_AREA_TRASH:this.deleteAreaToolbox_&&this.deleteAreaToolbox_.contains(a.clientX,a.clientY)?Blockly.DELETE_AREA_TOOLBOX:Blockly.DELETE_AREA_NONE};Blockly.WorkspaceSvg.prototype.onMouseDown_=function(a){var b=this.getGesture(a);b&&b.handleWsStart(a,this)};\nBlockly.WorkspaceSvg.prototype.startDrag=function(a,b){a=Blockly.utils.mouseToSvg(a,this.getParentSvg(),this.getInverseScreenCTM());a.x/=this.scale;a.y/=this.scale;this.dragDeltaXY_=Blockly.utils.Coordinate.difference(b,a)};Blockly.WorkspaceSvg.prototype.moveDrag=function(a){a=Blockly.utils.mouseToSvg(a,this.getParentSvg(),this.getInverseScreenCTM());a.x/=this.scale;a.y/=this.scale;return Blockly.utils.Coordinate.sum(this.dragDeltaXY_,a)};\nBlockly.WorkspaceSvg.prototype.isDragging=function(){return null!=this.currentGesture_&&this.currentGesture_.isDragging()};Blockly.WorkspaceSvg.prototype.isDraggable=function(){return this.options.moveOptions&&this.options.moveOptions.drag};\nBlockly.WorkspaceSvg.prototype.isContentBounded=function(){return this.options.moveOptions&&this.options.moveOptions.scrollbars||this.options.moveOptions&&this.options.moveOptions.wheel||this.options.moveOptions&&this.options.moveOptions.drag||this.options.zoomOptions&&this.options.zoomOptions.controls||this.options.zoomOptions&&this.options.zoomOptions.wheel||this.options.zoomOptions&&this.options.zoomOptions.pinch};\nBlockly.WorkspaceSvg.prototype.isMovable=function(){return this.options.moveOptions&&this.options.moveOptions.scrollbars||this.options.moveOptions&&this.options.moveOptions.wheel||this.options.moveOptions&&this.options.moveOptions.drag||this.options.zoomOptions&&this.options.zoomOptions.wheel||this.options.zoomOptions&&this.options.zoomOptions.pinch};\nBlockly.WorkspaceSvg.prototype.onMouseWheel_=function(a){if(Blockly.Gesture.inProgress())a.preventDefault(),a.stopPropagation();else{var b=this.options.zoomOptions&&this.options.zoomOptions.wheel,c=this.options.moveOptions&&this.options.moveOptions.wheel;if(b||c){var d=Blockly.utils.getScrollDeltaPixels(a);!b||!a.ctrlKey&&c?(b=this.scrollX-d.x,c=this.scrollY-d.y,a.shiftKey&&!d.x&&(b=this.scrollX-d.y,c=this.scrollY),this.scroll(b,c)):(d=-d.y/50,b=Blockly.utils.mouseToSvg(a,this.getParentSvg(),this.getInverseScreenCTM()),\nthis.zoom(b.x,b.y,d));a.preventDefault()}}};Blockly.WorkspaceSvg.prototype.getBlocksBoundingBox=function(){var a=this.getTopBlocks(!1),b=this.getTopComments(!1);a=a.concat(b);if(!a.length)return new Blockly.utils.Rect(0,0,0,0);b=a[0].getBoundingRectangle();for(var c=1;c<a.length;c++){var d=a[c].getBoundingRectangle();d.top<b.top&&(b.top=d.top);d.bottom>b.bottom&&(b.bottom=d.bottom);d.left<b.left&&(b.left=d.left);d.right>b.right&&(b.right=d.right)}return b};\nBlockly.WorkspaceSvg.prototype.cleanUp=function(){this.setResizesEnabled(!1);Blockly.Events.setGroup(!0);for(var a=this.getTopBlocks(!0),b=0,c=0,d;d=a[c];c++)if(d.isMovable()){var e=d.getRelativeToSurfaceXY();d.moveBy(-e.x,b-e.y);d.snapToGrid();b=d.getRelativeToSurfaceXY().y+d.getHeightWidth().height+this.renderer_.getConstants().MIN_BLOCK_HEIGHT}Blockly.Events.setGroup(!1);this.setResizesEnabled(!0)};\nBlockly.WorkspaceSvg.prototype.showContextMenu=function(a){function b(a){if(a.isDeletable())p=p.concat(a.getDescendants(!1));else{a=a.getChildren(!1);for(var c=0;c<a.length;c++)b(a[c])}}function c(){Blockly.Events.setGroup(f);var a=p.shift();a&&(a.workspace?(a.dispose(!1,!0),setTimeout(c,10)):c());Blockly.Events.setGroup(!1)}if(!this.options.readOnly&&!this.isFlyout){var d=[],e=this.getTopBlocks(!0),f=Blockly.utils.genUid(),g=this,h={};h.text=Blockly.Msg.UNDO;h.enabled=0<this.undoStack_.length;h.callback=\nthis.undo.bind(this,!1);d.push(h);h={};h.text=Blockly.Msg.REDO;h.enabled=0<this.redoStack_.length;h.callback=this.undo.bind(this,!0);d.push(h);this.isMovable()&&(h={},h.text=Blockly.Msg.CLEAN_UP,h.enabled=1<e.length,h.callback=this.cleanUp.bind(this),d.push(h));if(this.options.collapse){for(var k=h=!1,l=0;l<e.length;l++)for(var m=e[l];m;)m.isCollapsed()?h=!0:k=!0,m=m.getNextBlock();var n=function(a){for(var b=0,c=0;c<e.length;c++)for(var d=e[c];d;)setTimeout(d.setCollapsed.bind(d,a),b),d=d.getNextBlock(),\nb+=10};k={enabled:k};k.text=Blockly.Msg.COLLAPSE_ALL;k.callback=function(){n(!0)};d.push(k);h={enabled:h};h.text=Blockly.Msg.EXPAND_ALL;h.callback=function(){n(!1)};d.push(h)}var p=[];for(l=0;l<e.length;l++)b(e[l]);h={text:1==p.length?Blockly.Msg.DELETE_BLOCK:Blockly.Msg.DELETE_X_BLOCKS.replace(\"%1\",String(p.length)),enabled:0<p.length,callback:function(){g.currentGesture_&&g.currentGesture_.cancel();2>p.length?c():Blockly.confirm(Blockly.Msg.DELETE_ALL_BLOCKS.replace(\"%1\",p.length),function(a){a&&\nc()})}};d.push(h);this.configureContextMenu&&this.configureContextMenu(d,a);Blockly.ContextMenu.show(a,d,this.RTL)}};\nBlockly.WorkspaceSvg.prototype.updateToolbox=function(a){if(a=Blockly.Options.parseToolboxTree(a)){if(!this.options.languageTree)throw Error(\"Existing toolbox is null.  Can't create new toolbox.\");if(a.getElementsByTagName(\"category\").length){if(!this.toolbox_)throw Error(\"Existing toolbox has no categories.  Can't change mode.\");this.options.languageTree=a;this.toolbox_.renderTree(a)}else{if(!this.flyout_)throw Error(\"Existing toolbox has categories.  Can't change mode.\");this.options.languageTree=\na;this.flyout_.show(a.childNodes)}}else if(this.options.languageTree)throw Error(\"Can't nullify an existing toolbox.\");};Blockly.WorkspaceSvg.prototype.markFocused=function(){this.options.parentWorkspace?this.options.parentWorkspace.markFocused():(Blockly.mainWorkspace=this,this.setBrowserFocus())};Blockly.WorkspaceSvg.prototype.setBrowserFocus=function(){document.activeElement&&document.activeElement.blur();try{this.getParentSvg().focus({preventScroll:!0})}catch(a){try{this.getParentSvg().parentNode.setActive()}catch(b){this.getParentSvg().parentNode.focus({preventScroll:!0})}}};\nBlockly.WorkspaceSvg.prototype.zoom=function(a,b,c){c=Math.pow(this.options.zoomOptions.scaleSpeed,c);var d=this.scale*c;if(this.scale!=d){d>this.options.zoomOptions.maxScale?c=this.options.zoomOptions.maxScale/this.scale:d<this.options.zoomOptions.minScale&&(c=this.options.zoomOptions.minScale/this.scale);var e=this.getCanvas().getCTM(),f=this.getParentSvg().createSVGPoint();f.x=a;f.y=b;f=f.matrixTransform(e.inverse());a=f.x;b=f.y;e=e.translate(a*(1-c),b*(1-c)).scale(c);this.scrollX=e.e;this.scrollY=\ne.f;this.setScale(d)}};Blockly.WorkspaceSvg.prototype.zoomCenter=function(a){var b=this.getMetrics();if(this.flyout_){var c=b.svgWidth/2;b=b.svgHeight/2}else c=b.viewWidth/2+b.absoluteLeft,b=b.viewHeight/2+b.absoluteTop;this.zoom(c,b,a)};\nBlockly.WorkspaceSvg.prototype.zoomToFit=function(){if(this.isMovable()){var a=this.getMetrics(),b=a.viewWidth;a=a.viewHeight;var c=this.getBlocksBoundingBox(),d=c.right-c.left;c=c.bottom-c.top;d&&(this.flyout_&&(this.horizontalLayout?(a+=this.flyout_.getHeight(),c+=this.flyout_.getHeight()/this.scale):(b+=this.flyout_.getWidth(),d+=this.flyout_.getWidth()/this.scale)),this.setScale(Math.min(b/d,a/c)),this.scrollCenter())}else console.warn(\"Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.\")};\nBlockly.WorkspaceSvg.prototype.beginCanvasTransition=function(){Blockly.utils.dom.addClass(this.svgBlockCanvas_,\"blocklyCanvasTransitioning\");Blockly.utils.dom.addClass(this.svgBubbleCanvas_,\"blocklyCanvasTransitioning\")};Blockly.WorkspaceSvg.prototype.endCanvasTransition=function(){Blockly.utils.dom.removeClass(this.svgBlockCanvas_,\"blocklyCanvasTransitioning\");Blockly.utils.dom.removeClass(this.svgBubbleCanvas_,\"blocklyCanvasTransitioning\")};\nBlockly.WorkspaceSvg.prototype.scrollCenter=function(){if(this.isMovable()){var a=this.getMetrics(),b=(a.contentWidth-a.viewWidth)/2,c=(a.contentHeight-a.viewHeight)/2;b=-b-a.contentLeft;c=-c-a.contentTop;this.scroll(b,c)}else console.warn(\"Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.\")};\nBlockly.WorkspaceSvg.prototype.centerOnBlock=function(a){if(this.isMovable()){if(a=a?this.getBlockById(a):null){var b=a.getRelativeToSurfaceXY(),c=a.getHeightWidth(),d=this.scale;a=(b.x+(this.RTL?-1:1)*c.width/2)*d;b=(b.y+c.height/2)*d;c=this.getMetrics();this.scroll(-(a-c.viewWidth/2),-(b-c.viewHeight/2))}}else console.warn(\"Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.\")};\nBlockly.WorkspaceSvg.prototype.setScale=function(a){this.options.zoomOptions.maxScale&&a>this.options.zoomOptions.maxScale?a=this.options.zoomOptions.maxScale:this.options.zoomOptions.minScale&&a<this.options.zoomOptions.minScale&&(a=this.options.zoomOptions.minScale);this.scale=a;Blockly.hideChaff(!1);this.flyout_&&(this.flyout_.reflow(),this.recordDeleteAreas());this.grid_&&this.grid_.update(this.scale);a=this.getMetrics();this.scrollX-=a.absoluteLeft;this.scrollY-=a.absoluteTop;a.viewLeft+=a.absoluteLeft;\na.viewTop+=a.absoluteTop;this.scroll(this.scrollX,this.scrollY);this.scrollbar&&(this.flyout_?(this.scrollbar.hScroll.resizeViewHorizontal(a),this.scrollbar.vScroll.resizeViewVertical(a)):(this.scrollbar.hScroll.resizeContentHorizontal(a),this.scrollbar.vScroll.resizeContentVertical(a)))};Blockly.WorkspaceSvg.prototype.getScale=function(){return this.options.parentWorkspace?this.options.parentWorkspace.getScale():this.scale};\nBlockly.WorkspaceSvg.prototype.scroll=function(a,b){Blockly.hideChaff(!0);var c=this.getMetrics(),d=c.contentWidth+c.contentLeft-c.viewWidth,e=c.contentHeight+c.contentTop-c.viewHeight;a=Math.min(a,-c.contentLeft);b=Math.min(b,-c.contentTop);a=Math.max(a,-d);b=Math.max(b,-e);this.scrollX=a;this.scrollY=b;this.scrollbar&&(this.scrollbar.hScroll.setHandlePosition(-(a+c.contentLeft)*this.scrollbar.hScroll.ratio_),this.scrollbar.vScroll.setHandlePosition(-(b+c.contentTop)*this.scrollbar.vScroll.ratio_));\na+=c.absoluteLeft;b+=c.absoluteTop;this.translate(a,b)};Blockly.WorkspaceSvg.getDimensionsPx_=function(a){var b=0,c=0;a&&(b=a.getWidth(),c=a.getHeight());return{width:b,height:c}};Blockly.WorkspaceSvg.getContentDimensions_=function(a,b){return a.isContentBounded()?Blockly.WorkspaceSvg.getContentDimensionsBounded_(a,b):Blockly.WorkspaceSvg.getContentDimensionsExact_(a)};\nBlockly.WorkspaceSvg.getContentDimensionsExact_=function(a){var b=a.getBlocksBoundingBox(),c=a.scale;a=b.top*c;var d=b.bottom*c,e=b.left*c;b=b.right*c;return{top:a,bottom:d,left:e,right:b,width:b-e,height:d-a}};\nBlockly.WorkspaceSvg.getContentDimensionsBounded_=function(a,b){a=Blockly.WorkspaceSvg.getContentDimensionsExact_(a);var c=b.width;b=b.height;var d=c/2,e=b/2,f=Math.min(a.left-d,a.right-c),g=Math.min(a.top-e,a.bottom-b);return{left:f,top:g,height:Math.max(a.bottom+e,a.top+b)-g,width:Math.max(a.right+d,a.left+c)-f}};\nBlockly.WorkspaceSvg.getTopLevelWorkspaceMetrics_=function(){var a=Blockly.WorkspaceSvg.getDimensionsPx_(this.toolbox_),b=Blockly.WorkspaceSvg.getDimensionsPx_(this.flyout_),c=Blockly.svgSize(this.getParentSvg()),d={height:c.height,width:c.width};if(this.toolbox_)if(this.toolboxPosition==Blockly.TOOLBOX_AT_TOP||this.toolboxPosition==Blockly.TOOLBOX_AT_BOTTOM)d.height-=a.height;else{if(this.toolboxPosition==Blockly.TOOLBOX_AT_LEFT||this.toolboxPosition==Blockly.TOOLBOX_AT_RIGHT)d.width-=a.width}else if(this.flyout_)if(this.toolboxPosition==\nBlockly.TOOLBOX_AT_TOP||this.toolboxPosition==Blockly.TOOLBOX_AT_BOTTOM)d.height-=b.height;else if(this.toolboxPosition==Blockly.TOOLBOX_AT_LEFT||this.toolboxPosition==Blockly.TOOLBOX_AT_RIGHT)d.width-=b.width;var e=Blockly.WorkspaceSvg.getContentDimensions_(this,d),f=0;this.toolbox_&&this.toolboxPosition==Blockly.TOOLBOX_AT_LEFT?f=a.width:this.flyout_&&this.toolboxPosition==Blockly.TOOLBOX_AT_LEFT&&(f=b.width);var g=0;this.toolbox_&&this.toolboxPosition==Blockly.TOOLBOX_AT_TOP?g=a.height:this.flyout_&&\nthis.toolboxPosition==Blockly.TOOLBOX_AT_TOP&&(g=b.height);return{contentHeight:e.height,contentWidth:e.width,contentTop:e.top,contentLeft:e.left,viewHeight:d.height,viewWidth:d.width,viewTop:-this.scrollY,viewLeft:-this.scrollX,absoluteTop:g,absoluteLeft:f,svgHeight:c.height,svgWidth:c.width,toolboxWidth:a.width,toolboxHeight:a.height,flyoutWidth:b.width,flyoutHeight:b.height,toolboxPosition:this.toolboxPosition}};\nBlockly.WorkspaceSvg.setTopLevelWorkspaceMetrics_=function(a){var b=this.getMetrics();\"number\"==typeof a.x&&(this.scrollX=-b.contentWidth*a.x-b.contentLeft);\"number\"==typeof a.y&&(this.scrollY=-b.contentHeight*a.y-b.contentTop);this.translate(this.scrollX+b.absoluteLeft,this.scrollY+b.absoluteTop)};Blockly.WorkspaceSvg.prototype.getBlockById=function(a){return Blockly.WorkspaceSvg.superClass_.getBlockById.call(this,a)};\nBlockly.WorkspaceSvg.prototype.getTopBlocks=function(a){return Blockly.WorkspaceSvg.superClass_.getTopBlocks.call(this,a)};Blockly.WorkspaceSvg.prototype.setResizesEnabled=function(a){var b=!this.resizesEnabled_&&a;this.resizesEnabled_=a;b&&this.resizeContents()};Blockly.WorkspaceSvg.prototype.clear=function(){this.setResizesEnabled(!1);Blockly.WorkspaceSvg.superClass_.clear.call(this);this.setResizesEnabled(!0)};\nBlockly.WorkspaceSvg.prototype.registerButtonCallback=function(a,b){if(\"function\"!=typeof b)throw TypeError(\"Button callbacks must be functions.\");this.flyoutButtonCallbacks_[a]=b};Blockly.WorkspaceSvg.prototype.getButtonCallback=function(a){return(a=this.flyoutButtonCallbacks_[a])?a:null};Blockly.WorkspaceSvg.prototype.removeButtonCallback=function(a){this.flyoutButtonCallbacks_[a]=null};\nBlockly.WorkspaceSvg.prototype.registerToolboxCategoryCallback=function(a,b){if(\"function\"!=typeof b)throw TypeError(\"Toolbox category callbacks must be functions.\");this.toolboxCategoryCallbacks_[a]=b};Blockly.WorkspaceSvg.prototype.getToolboxCategoryCallback=function(a){return this.toolboxCategoryCallbacks_[a]||null};Blockly.WorkspaceSvg.prototype.removeToolboxCategoryCallback=function(a){this.toolboxCategoryCallbacks_[a]=null};\nBlockly.WorkspaceSvg.prototype.getGesture=function(a){var b=\"mousedown\"==a.type||\"touchstart\"==a.type||\"pointerdown\"==a.type,c=this.currentGesture_;return c?b&&c.hasStarted()?(console.warn(\"Tried to start the same gesture twice.\"),c.cancel(),null):c:b?this.currentGesture_=new Blockly.TouchGesture(a,this):null};Blockly.WorkspaceSvg.prototype.clearGesture=function(){this.currentGesture_=null};Blockly.WorkspaceSvg.prototype.cancelCurrentGesture=function(){this.currentGesture_&&this.currentGesture_.cancel()};\nBlockly.WorkspaceSvg.prototype.getAudioManager=function(){return this.audioManager_};Blockly.WorkspaceSvg.prototype.getGrid=function(){return this.grid_};Blockly.inject=function(a,b){Blockly.checkBlockColourConstants();\"string\"==typeof a&&(a=document.getElementById(a)||document.querySelector(a));if(!a||!Blockly.utils.dom.containsNode(document,a))throw Error(\"Error: container is not in current document.\");b=new Blockly.Options(b||{});var c=document.createElement(\"div\");c.className=\"injectionDiv\";c.tabIndex=0;Blockly.utils.aria.setState(c,Blockly.utils.aria.State.LABEL,Blockly.Msg.WORKSPACE_ARIA_LABEL);a.appendChild(c);a=Blockly.createDom_(c,b);var d=\nnew Blockly.BlockDragSurfaceSvg(c),e=new Blockly.WorkspaceDragSurfaceSvg(c),f=Blockly.createMainWorkspace_(a,b,d,e);Blockly.user.keyMap.setKeyMap(b.keyMap);Blockly.init_(f);Blockly.mainWorkspace=f;Blockly.svgResize(f);c.addEventListener(\"focusin\",function(){Blockly.mainWorkspace=f});return f};\nBlockly.createDom_=function(a,b){a.setAttribute(\"dir\",\"LTR\");Blockly.Component.defaultRightToLeft=b.RTL;Blockly.Css.inject(b.hasCss,b.pathToMedia);a=Blockly.utils.dom.createSvgElement(\"svg\",{xmlns:Blockly.utils.dom.SVG_NS,\"xmlns:html\":Blockly.utils.dom.HTML_NS,\"xmlns:xlink\":Blockly.utils.dom.XLINK_NS,version:\"1.1\",\"class\":\"blocklySvg\",tabindex:\"0\"},a);var c=Blockly.utils.dom.createSvgElement(\"defs\",{},a),d=String(Math.random()).substring(2);b.gridPattern=Blockly.Grid.createDom(d,b.gridOptions,c);\nreturn a};\nBlockly.createMainWorkspace_=function(a,b,c,d){b.parentWorkspace=null;var e=new Blockly.WorkspaceSvg(b,c,d);b=e.options;e.scale=b.zoomOptions.startScale;a.appendChild(e.createDom(\"blocklyMainBackground\"));Blockly.utils.dom.addClass(e.getInjectionDiv(),e.getRenderer().getClassName());Blockly.utils.dom.addClass(e.getInjectionDiv(),e.getTheme().getClassName());!b.hasCategories&&b.languageTree&&(c=e.addFlyout(\"svg\"),Blockly.utils.dom.insertAfter(c,a));b.hasTrashcan&&e.addTrashcan();b.zoomOptions&&b.zoomOptions.controls&&\ne.addZoomControls();e.getThemeManager().subscribe(a,\"workspaceBackgroundColour\",\"background-color\");e.translate(0,0);b.readOnly||e.isMovable()||e.addChangeListener(function(a){if(!e.isDragging()&&!e.isMovable()&&-1!=Blockly.Events.BUMP_EVENTS.indexOf(a.type)){var b=Object.create(null),c=e.getMetrics(),d=e.scale;b.RTL=e.RTL;b.viewLeft=c.viewLeft/d;b.viewTop=c.viewTop/d;b.viewRight=(c.viewLeft+c.viewWidth)/d;b.viewBottom=(c.viewTop+c.viewHeight)/d;e.isContentBounded()?(c=e.getBlocksBoundingBox(),b.contentLeft=\nc.left,b.contentTop=c.top,b.contentRight=c.right,b.contentBottom=c.bottom):(b.contentLeft=c.contentLeft/d,b.contentTop=c.contentTop/d,b.contentRight=(c.contentLeft+c.contentWidth)/d,b.contentBottom=(c.contentTop+c.contentHeight)/d);if(b.contentTop<b.viewTop||b.contentBottom>b.viewBottom||b.contentLeft<b.viewLeft||b.contentRight>b.viewRight){c=null;a&&(c=Blockly.Events.getGroup(),Blockly.Events.setGroup(a.group));switch(a.type){case Blockly.Events.BLOCK_CREATE:case Blockly.Events.BLOCK_MOVE:var f=\ne.getBlockById(a.blockId);f&&(f=f.getRootBlock());break;case Blockly.Events.COMMENT_CREATE:case Blockly.Events.COMMENT_MOVE:f=e.getCommentById(a.commentId)}if(f){d=f.getBoundingRectangle();d.height=d.bottom-d.top;d.width=d.right-d.left;var m=b.viewTop,n=b.viewBottom-d.height;n=Math.max(m,n);m=Blockly.utils.math.clamp(m,d.top,n)-d.top;n=b.viewLeft;var p=b.viewRight-d.width;b.RTL?n=Math.min(p,n):p=Math.max(n,p);b=Blockly.utils.math.clamp(n,d.left,p)-d.left;f.moveBy(b,m)}a&&(!a.group&&f&&console.log(\"WARNING: Moved object in bounds but there was no event group. This may break undo.\"),\nnull!==c&&Blockly.Events.setGroup(c))}}});Blockly.svgResize(e);Blockly.WidgetDiv.createDom();Blockly.DropDownDiv.createDom();Blockly.Tooltip.createDom();return e};\nBlockly.init_=function(a){var b=a.options,c=a.getParentSvg();Blockly.bindEventWithChecks_(c.parentNode,\"contextmenu\",null,function(a){Blockly.utils.isTargetInput(a)||a.preventDefault()});c=Blockly.bindEventWithChecks_(window,\"resize\",null,function(){Blockly.hideChaff(!0);Blockly.svgResize(a)});a.setResizeHandlerWrapper(c);Blockly.inject.bindDocumentEvents_();if(b.languageTree){c=a.getToolbox();var d=a.getFlyout(!0);c?c.init():d&&(d.init(a),d.show(b.languageTree.childNodes),d.scrollToStart())}c=Blockly.Scrollbar.scrollbarThickness;\nb.hasTrashcan&&(c=a.trashcan.init(c));b.zoomOptions&&b.zoomOptions.controls&&a.zoomControls_.init(c);b.moveOptions&&b.moveOptions.scrollbars?(a.scrollbar=new Blockly.ScrollbarPair(a),a.scrollbar.resize()):a.setMetrics({x:.5,y:.5});b.hasSounds&&Blockly.inject.loadSounds_(b.pathToMedia,a)};\nBlockly.inject.bindDocumentEvents_=function(){Blockly.documentEventsBound_||(Blockly.bindEventWithChecks_(document,\"scroll\",null,function(){for(var a=Blockly.Workspace.getAll(),b=0,c;c=a[b];b++)c.updateInverseScreenCTM&&c.updateInverseScreenCTM()}),Blockly.bindEventWithChecks_(document,\"keydown\",null,Blockly.onKeyDown),Blockly.bindEvent_(document,\"touchend\",null,Blockly.longStop_),Blockly.bindEvent_(document,\"touchcancel\",null,Blockly.longStop_),Blockly.utils.userAgent.IPAD&&Blockly.bindEventWithChecks_(window,\n\"orientationchange\",document,function(){Blockly.svgResize(Blockly.getMainWorkspace())}));Blockly.documentEventsBound_=!0};\nBlockly.inject.loadSounds_=function(a,b){var c=b.getAudioManager();c.load([a+\"click.mp3\",a+\"click.wav\",a+\"click.ogg\"],\"click\");c.load([a+\"disconnect.wav\",a+\"disconnect.mp3\",a+\"disconnect.ogg\"],\"disconnect\");c.load([a+\"delete.mp3\",a+\"delete.ogg\",a+\"delete.wav\"],\"delete\");var d=[];a=function(){for(;d.length;)Blockly.unbindEvent_(d.pop());c.preload()};d.push(Blockly.bindEventWithChecks_(document,\"mousemove\",null,a,!0));d.push(Blockly.bindEventWithChecks_(document,\"touchstart\",null,a,!0))};Blockly.Names=function(a,b){this.variablePrefix_=b||\"\";this.reservedDict_=Object.create(null);if(a)for(a=a.split(\",\"),b=0;b<a.length;b++)this.reservedDict_[a[b]]=!0;this.reset()};Blockly.Names.DEVELOPER_VARIABLE_TYPE=\"DEVELOPER_VARIABLE\";Blockly.Names.prototype.reset=function(){this.db_=Object.create(null);this.dbReverse_=Object.create(null);this.variableMap_=null};Blockly.Names.prototype.setVariableMap=function(a){this.variableMap_=a};\nBlockly.Names.prototype.getNameForUserVariable_=function(a){return this.variableMap_?(a=this.variableMap_.getVariableById(a))?a.name:null:(console.log(\"Deprecated call to Blockly.Names.prototype.getName without defining a variable map. To fix, add the following code in your generator's init() function:\\nBlockly.YourGeneratorName.variableDB_.setVariableMap(workspace.getVariableMap());\"),null)};\nBlockly.Names.prototype.getName=function(a,b){if(b==Blockly.VARIABLE_CATEGORY_NAME){var c=this.getNameForUserVariable_(a);c&&(a=c)}c=a.toLowerCase()+\"_\"+b;var d=b==Blockly.VARIABLE_CATEGORY_NAME||b==Blockly.Names.DEVELOPER_VARIABLE_TYPE?this.variablePrefix_:\"\";if(c in this.db_)return d+this.db_[c];a=this.getDistinctName(a,b);this.db_[c]=a.substr(d.length);return a};\nBlockly.Names.prototype.getDistinctName=function(a,b){a=this.safeName_(a);for(var c=\"\";this.dbReverse_[a+c]||a+c in this.reservedDict_;)c=c?c+1:2;a+=c;this.dbReverse_[a]=!0;return(b==Blockly.VARIABLE_CATEGORY_NAME||b==Blockly.Names.DEVELOPER_VARIABLE_TYPE?this.variablePrefix_:\"\")+a};Blockly.Names.prototype.safeName_=function(a){a?(a=encodeURI(a.replace(/ /g,\"_\")).replace(/[^\\w]/g,\"_\"),-1!=\"0123456789\".indexOf(a[0])&&(a=\"my_\"+a)):a=Blockly.Msg.UNNAMED_KEY||\"unnamed\";return a};\nBlockly.Names.equals=function(a,b){return a.toLowerCase()==b.toLowerCase()};Blockly.Procedures={};Blockly.Procedures.NAME_TYPE=Blockly.PROCEDURE_CATEGORY_NAME;Blockly.Procedures.DEFAULT_ARG=\"x\";Blockly.Procedures.allProcedures=function(a){a=a.getAllBlocks(!1);for(var b=[],c=[],d=0;d<a.length;d++)if(a[d].getProcedureDef){var e=a[d].getProcedureDef();e&&(e[2]?b.push(e):c.push(e))}c.sort(Blockly.Procedures.procTupleComparator_);b.sort(Blockly.Procedures.procTupleComparator_);return[c,b]};Blockly.Procedures.procTupleComparator_=function(a,b){return a[0].toLowerCase().localeCompare(b[0].toLowerCase())};\nBlockly.Procedures.findLegalName=function(a,b){if(b.isInFlyout)return a;for(a=a||Blockly.Msg.UNNAMED_KEY||\"unnamed\";!Blockly.Procedures.isLegalName_(a,b.workspace,b);){var c=a.match(/^(.*?)(\\d+)$/);a=c?c[1]+(parseInt(c[2],10)+1):a+\"2\"}return a};Blockly.Procedures.isLegalName_=function(a,b,c){return!Blockly.Procedures.isNameUsed(a,b,c)};\nBlockly.Procedures.isNameUsed=function(a,b,c){b=b.getAllBlocks(!1);for(var d=0;d<b.length;d++)if(b[d]!=c&&b[d].getProcedureDef){var e=b[d].getProcedureDef();if(Blockly.Names.equals(e[0],a))return!0}return!1};Blockly.Procedures.rename=function(a){a=a.trim();var b=Blockly.Procedures.findLegalName(a,this.getSourceBlock()),c=this.getValue();if(c!=a&&c!=b){a=this.getSourceBlock().workspace.getAllBlocks(!1);for(var d=0;d<a.length;d++)a[d].renameProcedure&&a[d].renameProcedure(c,b)}return b};\nBlockly.Procedures.flyoutCategory=function(a){function b(a,b){for(var d=0;d<a.length;d++){var e=a[d][0],f=a[d][1],g=Blockly.utils.xml.createElement(\"block\");g.setAttribute(\"type\",b);g.setAttribute(\"gap\",16);var n=Blockly.utils.xml.createElement(\"mutation\");n.setAttribute(\"name\",e);g.appendChild(n);for(e=0;e<f.length;e++){var p=Blockly.utils.xml.createElement(\"arg\");p.setAttribute(\"name\",f[e]);n.appendChild(p)}c.push(g)}}var c=[];if(Blockly.Blocks.procedures_defnoreturn){var d=Blockly.utils.xml.createElement(\"block\");\nd.setAttribute(\"type\",\"procedures_defnoreturn\");d.setAttribute(\"gap\",16);var e=Blockly.utils.xml.createElement(\"field\");e.setAttribute(\"name\",\"NAME\");e.appendChild(Blockly.utils.xml.createTextNode(Blockly.Msg.PROCEDURES_DEFNORETURN_PROCEDURE));d.appendChild(e);c.push(d)}Blockly.Blocks.procedures_defreturn&&(d=Blockly.utils.xml.createElement(\"block\"),d.setAttribute(\"type\",\"procedures_defreturn\"),d.setAttribute(\"gap\",16),e=Blockly.utils.xml.createElement(\"field\"),e.setAttribute(\"name\",\"NAME\"),e.appendChild(Blockly.utils.xml.createTextNode(Blockly.Msg.PROCEDURES_DEFRETURN_PROCEDURE)),\nd.appendChild(e),c.push(d));Blockly.Blocks.procedures_ifreturn&&(d=Blockly.utils.xml.createElement(\"block\"),d.setAttribute(\"type\",\"procedures_ifreturn\"),d.setAttribute(\"gap\",16),c.push(d));c.length&&c[c.length-1].setAttribute(\"gap\",24);a=Blockly.Procedures.allProcedures(a);b(a[0],\"procedures_callnoreturn\");b(a[1],\"procedures_callreturn\");return c};\nBlockly.Procedures.updateMutatorFlyout_=function(a){for(var b=[],c=a.getBlocksByType(\"procedures_mutatorarg\",!1),d=0,e;e=c[d];d++)b.push(e.getFieldValue(\"NAME\"));c=Blockly.utils.xml.createElement(\"xml\");d=Blockly.utils.xml.createElement(\"block\");d.setAttribute(\"type\",\"procedures_mutatorarg\");e=Blockly.utils.xml.createElement(\"field\");e.setAttribute(\"name\",\"NAME\");b=Blockly.Variables.generateUniqueNameFromOptions(Blockly.Procedures.DEFAULT_ARG,b);b=Blockly.utils.xml.createTextNode(b);e.appendChild(b);\nd.appendChild(e);c.appendChild(d);a.updateToolbox(c)};Blockly.Procedures.mutatorOpenListener=function(a){if(a.type==Blockly.Events.UI&&\"mutatorOpen\"==a.element&&a.newValue){a=Blockly.Workspace.getById(a.workspaceId).getBlockById(a.blockId);var b=a.type;if(\"procedures_defnoreturn\"==b||\"procedures_defreturn\"==b)a=a.mutator.getWorkspace(),Blockly.Procedures.updateMutatorFlyout_(a),a.addChangeListener(Blockly.Procedures.mutatorChangeListener_)}};\nBlockly.Procedures.mutatorChangeListener_=function(a){if(a.type==Blockly.Events.BLOCK_CREATE||a.type==Blockly.Events.BLOCK_DELETE||a.type==Blockly.Events.BLOCK_CHANGE)a=Blockly.Workspace.getById(a.workspaceId),Blockly.Procedures.updateMutatorFlyout_(a)};Blockly.Procedures.getCallers=function(a,b){var c=[];b=b.getAllBlocks(!1);for(var d=0;d<b.length;d++)if(b[d].getProcedureCall){var e=b[d].getProcedureCall();e&&Blockly.Names.equals(e,a)&&c.push(b[d])}return c};\nBlockly.Procedures.mutateCallers=function(a){var b=Blockly.Events.recordUndo,c=a.getProcedureDef()[0],d=a.mutationToDom(!0);a=Blockly.Procedures.getCallers(c,a.workspace);c=0;for(var e;e=a[c];c++){var f=e.mutationToDom();f=f&&Blockly.Xml.domToText(f);e.domToMutation(d);var g=e.mutationToDom();g=g&&Blockly.Xml.domToText(g);f!=g&&(Blockly.Events.recordUndo=!1,Blockly.Events.fire(new Blockly.Events.BlockChange(e,\"mutation\",null,f,g)),Blockly.Events.recordUndo=b)}};\nBlockly.Procedures.getDefinition=function(a,b){b=b.getTopBlocks(!1);for(var c=0;c<b.length;c++)if(b[c].getProcedureDef){var d=b[c].getProcedureDef();if(d&&Blockly.Names.equals(d[0],a))return b[c]}return null};Blockly.VariableModel=function(a,b,c,d){this.workspace=a;this.name=b;this.type=c||\"\";this.id_=d||Blockly.utils.genUid();Blockly.Events.fire(new Blockly.Events.VarCreate(this))};Blockly.VariableModel.prototype.getId=function(){return this.id_};Blockly.VariableModel.compareByName=function(a,b){a=a.name.toLowerCase();b=b.name.toLowerCase();return a<b?-1:a==b?0:1};Blockly.Variables={};Blockly.Variables.NAME_TYPE=Blockly.VARIABLE_CATEGORY_NAME;Blockly.Variables.allUsedVarModels=function(a){var b=a.getAllBlocks(!1);a=Object.create(null);for(var c=0;c<b.length;c++){var d=b[c].getVarModels();if(d)for(var e=0;e<d.length;e++){var f=d[e],g=f.getId();g&&(a[g]=f)}}b=[];for(g in a)b.push(a[g]);return b};Blockly.Variables.allUsedVariables=function(){console.warn(\"Deprecated call to Blockly.Variables.allUsedVariables. Use Blockly.Variables.allUsedVarModels instead.\\nIf this is a major issue please file a bug on GitHub.\")};\nBlockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_={};\nBlockly.Variables.allDeveloperVariables=function(a){a=a.getAllBlocks(!1);for(var b=Object.create(null),c=0,d;d=a[c];c++){var e=d.getDeveloperVariables;!e&&d.getDeveloperVars&&(e=d.getDeveloperVars,Blockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_[d.type]||(console.warn(\"Function getDeveloperVars() deprecated. Use getDeveloperVariables() (block type '\"+d.type+\"')\"),Blockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_[d.type]=!0));if(e)for(d=e(),e=0;e<d.length;e++)b[d[e]]=!0}return Object.keys(b)};\nBlockly.Variables.flyoutCategory=function(a){var b=[],c=document.createElement(\"button\");c.setAttribute(\"text\",\"%{BKY_NEW_VARIABLE}\");c.setAttribute(\"callbackKey\",\"CREATE_VARIABLE\");a.registerButtonCallback(\"CREATE_VARIABLE\",function(a){Blockly.Variables.createVariableButtonHandler(a.getTargetWorkspace())});b.push(c);a=Blockly.Variables.flyoutCategoryBlocks(a);return b=b.concat(a)};\nBlockly.Variables.flyoutCategoryBlocks=function(a){a=a.getVariablesOfType(\"\");var b=[];if(0<a.length){var c=a[a.length-1];if(Blockly.Blocks.variables_set){var d=Blockly.utils.xml.createElement(\"block\");d.setAttribute(\"type\",\"variables_set\");d.setAttribute(\"gap\",Blockly.Blocks.math_change?8:24);d.appendChild(Blockly.Variables.generateVariableFieldDom(c));b.push(d)}Blockly.Blocks.math_change&&(d=Blockly.utils.xml.createElement(\"block\"),d.setAttribute(\"type\",\"math_change\"),d.setAttribute(\"gap\",Blockly.Blocks.variables_get?\n20:8),d.appendChild(Blockly.Variables.generateVariableFieldDom(c)),c=Blockly.Xml.textToDom('<value name=\"DELTA\"><shadow type=\"math_number\"><field name=\"NUM\">1</field></shadow></value>'),d.appendChild(c),b.push(d));if(Blockly.Blocks.variables_get){a.sort(Blockly.VariableModel.compareByName);c=0;for(var e;e=a[c];c++)d=Blockly.utils.xml.createElement(\"block\"),d.setAttribute(\"type\",\"variables_get\"),d.setAttribute(\"gap\",8),d.appendChild(Blockly.Variables.generateVariableFieldDom(e)),b.push(d)}}return b};\nBlockly.Variables.VAR_LETTER_OPTIONS=\"ijkmnopqrstuvwxyzabcdefgh\";Blockly.Variables.generateUniqueName=function(a){return Blockly.Variables.generateUniqueNameFromOptions(Blockly.Variables.VAR_LETTER_OPTIONS.charAt(0),a.getAllVariableNames())};\nBlockly.Variables.generateUniqueNameFromOptions=function(a,b){if(!b.length)return a;for(var c=Blockly.Variables.VAR_LETTER_OPTIONS,d=\"\",e=c.indexOf(a);;){for(var f=!1,g=0;g<b.length;g++)if(b[g].toLowerCase()==a){f=!0;break}if(!f)return a;e++;e==c.length&&(e=0,d=Number(d)+1);a=c.charAt(e)+d}};\nBlockly.Variables.createVariableButtonHandler=function(a,b,c){var d=c||\"\",e=function(c){Blockly.Variables.promptName(Blockly.Msg.NEW_VARIABLE_TITLE,c,function(c){if(c){var f=Blockly.Variables.nameUsedWithAnyType_(c,a);if(f){if(f.type==d)var g=Blockly.Msg.VARIABLE_ALREADY_EXISTS.replace(\"%1\",f.name);else g=Blockly.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,g=g.replace(\"%1\",f.name).replace(\"%2\",f.type);Blockly.alert(g,function(){e(c)})}else a.createVariable(c,d),b&&b(c)}else b&&b(null)})};e(\"\")};\nBlockly.Variables.createVariable=Blockly.Variables.createVariableButtonHandler;\nBlockly.Variables.renameVariable=function(a,b,c){var d=function(e){var f=Blockly.Msg.RENAME_VARIABLE_TITLE.replace(\"%1\",b.name);Blockly.Variables.promptName(f,e,function(e){if(e){var f=Blockly.Variables.nameUsedWithOtherType_(e,b.type,a);f?(f=Blockly.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace(\"%1\",f.name).replace(\"%2\",f.type),Blockly.alert(f,function(){d(e)})):(a.renameVariableById(b.getId(),e),c&&c(e))}else c&&c(null)})};d(\"\")};\nBlockly.Variables.promptName=function(a,b,c){Blockly.prompt(a,b,function(a){a&&(a=a.replace(/[\\s\\xa0]+/g,\" \").trim(),a==Blockly.Msg.RENAME_VARIABLE||a==Blockly.Msg.NEW_VARIABLE)&&(a=null);c(a)})};Blockly.Variables.nameUsedWithOtherType_=function(a,b,c){c=c.getVariableMap().getAllVariables();a=a.toLowerCase();for(var d=0,e;e=c[d];d++)if(e.name.toLowerCase()==a&&e.type!=b)return e;return null};\nBlockly.Variables.nameUsedWithAnyType_=function(a,b){b=b.getVariableMap().getAllVariables();a=a.toLowerCase();for(var c=0,d;d=b[c];c++)if(d.name.toLowerCase()==a)return d;return null};Blockly.Variables.generateVariableFieldDom=function(a){var b=Blockly.utils.xml.createElement(\"field\");b.setAttribute(\"name\",\"VAR\");b.setAttribute(\"id\",a.getId());b.setAttribute(\"variabletype\",a.type);a=Blockly.utils.xml.createTextNode(a.name);b.appendChild(a);return b};\nBlockly.Variables.getOrCreateVariablePackage=function(a,b,c,d){var e=Blockly.Variables.getVariable(a,b,c,d);e||(e=Blockly.Variables.createVariable_(a,b,c,d));return e};Blockly.Variables.getVariable=function(a,b,c,d){var e=a.getPotentialVariableMap(),f=null;if(b&&(f=a.getVariableById(b),!f&&e&&(f=e.getVariableById(b)),f))return f;if(c){if(void 0==d)throw Error(\"Tried to look up a variable by name without a type\");f=a.getVariable(c,d);!f&&e&&(f=e.getVariable(c,d))}return f};\nBlockly.Variables.createVariable_=function(a,b,c,d){var e=a.getPotentialVariableMap();c||(c=Blockly.Variables.generateUniqueName(a.isFlyout?a.targetWorkspace:a));return e?e.createVariable(c,d,b):a.createVariable(c,d,b)};Blockly.Variables.getAddedVariables=function(a,b){a=a.getAllVariables();var c=[];if(b.length!=a.length)for(var d=0;d<a.length;d++){var e=a[d];-1==b.indexOf(e)&&c.push(e)}return c};Blockly.WidgetDiv={};Blockly.WidgetDiv.owner_=null;Blockly.WidgetDiv.dispose_=null;Blockly.WidgetDiv.rendererClassName_=\"\";Blockly.WidgetDiv.themeClassName_=\"\";Blockly.WidgetDiv.createDom=function(){Blockly.WidgetDiv.DIV||(Blockly.WidgetDiv.DIV=document.createElement(\"div\"),Blockly.WidgetDiv.DIV.className=\"blocklyWidgetDiv\",(Blockly.parentContainer||document.body).appendChild(Blockly.WidgetDiv.DIV))};\nBlockly.WidgetDiv.show=function(a,b,c){Blockly.WidgetDiv.hide();Blockly.WidgetDiv.owner_=a;Blockly.WidgetDiv.dispose_=c;a=Blockly.WidgetDiv.DIV;a.style.direction=b?\"rtl\":\"ltr\";a.style.display=\"block\";Blockly.WidgetDiv.rendererClassName_=Blockly.getMainWorkspace().getRenderer().getClassName();Blockly.WidgetDiv.themeClassName_=Blockly.getMainWorkspace().getTheme().getClassName();Blockly.utils.dom.addClass(a,Blockly.WidgetDiv.rendererClassName_);Blockly.utils.dom.addClass(a,Blockly.WidgetDiv.themeClassName_)};\nBlockly.WidgetDiv.hide=function(){if(Blockly.WidgetDiv.isVisible()){Blockly.WidgetDiv.owner_=null;var a=Blockly.WidgetDiv.DIV;a.style.display=\"none\";a.style.left=\"\";a.style.top=\"\";Blockly.WidgetDiv.dispose_&&Blockly.WidgetDiv.dispose_();Blockly.WidgetDiv.dispose_=null;a.textContent=\"\";Blockly.WidgetDiv.rendererClassName_&&(Blockly.utils.dom.removeClass(a,Blockly.WidgetDiv.rendererClassName_),Blockly.WidgetDiv.rendererClassName_=\"\");Blockly.WidgetDiv.themeClassName_&&(Blockly.utils.dom.removeClass(a,\nBlockly.WidgetDiv.themeClassName_),Blockly.WidgetDiv.themeClassName_=\"\");Blockly.getMainWorkspace().markFocused()}};Blockly.WidgetDiv.isVisible=function(){return!!Blockly.WidgetDiv.owner_};Blockly.WidgetDiv.hideIfOwner=function(a){Blockly.WidgetDiv.owner_==a&&Blockly.WidgetDiv.hide()};Blockly.WidgetDiv.positionInternal_=function(a,b,c){Blockly.WidgetDiv.DIV.style.left=a+\"px\";Blockly.WidgetDiv.DIV.style.top=b+\"px\";Blockly.WidgetDiv.DIV.style.height=c+\"px\"};\nBlockly.WidgetDiv.positionWithAnchor=function(a,b,c,d){var e=Blockly.WidgetDiv.calculateY_(a,b,c);a=Blockly.WidgetDiv.calculateX_(a,b,c,d);0>e?Blockly.WidgetDiv.positionInternal_(a,0,c.height+e):Blockly.WidgetDiv.positionInternal_(a,e,c.height)};Blockly.WidgetDiv.calculateX_=function(a,b,c,d){if(d)return b=Math.max(b.right-c.width,a.left),Math.min(b,a.right-c.width);b=Math.min(b.left,a.right-c.width);return Math.max(b,a.left)};\nBlockly.WidgetDiv.calculateY_=function(a,b,c){return b.bottom+c.height>=a.bottom?b.top-c.height:b.bottom};Blockly.VERSION=\"3.20200402.1\";Blockly.mainWorkspace=null;Blockly.selected=null;Blockly.draggingConnections=[];Blockly.clipboardXml_=null;Blockly.clipboardSource_=null;Blockly.clipboardTypeCounts_=null;Blockly.cache3dSupported_=null;Blockly.parentContainer=null;Blockly.svgSize=function(a){return{width:a.cachedWidth_,height:a.cachedHeight_}};Blockly.resizeSvgContents=function(a){a.resizeContents()};\nBlockly.svgResize=function(a){for(;a.options.parentWorkspace;)a=a.options.parentWorkspace;var b=a.getParentSvg(),c=b.parentNode;if(c){var d=c.offsetWidth;c=c.offsetHeight;b.cachedWidth_!=d&&(b.setAttribute(\"width\",d+\"px\"),b.cachedWidth_=d);b.cachedHeight_!=c&&(b.setAttribute(\"height\",c+\"px\"),b.cachedHeight_=c);a.resize()}};\nBlockly.onKeyDown=function(a){var b=Blockly.mainWorkspace;if(b&&!(Blockly.utils.isTargetInput(a)||b.rendered&&!b.isVisible()))if(b.options.readOnly)Blockly.navigation.onKeyPress(a);else{var c=!1;if(a.keyCode==Blockly.utils.KeyCodes.ESC)Blockly.hideChaff(),Blockly.navigation.onBlocklyAction(Blockly.navigation.ACTION_EXIT);else{if(Blockly.navigation.onKeyPress(a))return;if(a.keyCode==Blockly.utils.KeyCodes.BACKSPACE||a.keyCode==Blockly.utils.KeyCodes.DELETE){a.preventDefault();if(Blockly.Gesture.inProgress())return;\nBlockly.selected&&Blockly.selected.isDeletable()&&(c=!0)}else if(a.altKey||a.ctrlKey||a.metaKey){if(Blockly.Gesture.inProgress())return;Blockly.selected&&Blockly.selected.isDeletable()&&Blockly.selected.isMovable()&&(a.keyCode==Blockly.utils.KeyCodes.C?(Blockly.hideChaff(),Blockly.copy_(Blockly.selected)):a.keyCode!=Blockly.utils.KeyCodes.X||Blockly.selected.workspace.isFlyout||(Blockly.copy_(Blockly.selected),c=!0));a.keyCode==Blockly.utils.KeyCodes.V?Blockly.clipboardXml_&&(a=Blockly.clipboardSource_,\na.isFlyout&&(a=a.targetWorkspace),Blockly.clipboardTypeCounts_&&a.isCapacityAvailable(Blockly.clipboardTypeCounts_)&&(Blockly.Events.setGroup(!0),a.paste(Blockly.clipboardXml_),Blockly.Events.setGroup(!1))):a.keyCode==Blockly.utils.KeyCodes.Z&&(Blockly.hideChaff(),b.undo(a.shiftKey))}}c&&!Blockly.selected.workspace.isFlyout&&(Blockly.Events.setGroup(!0),Blockly.hideChaff(),Blockly.selected.dispose(!0,!0),Blockly.Events.setGroup(!1))}};\nBlockly.copy_=function(a){if(a.isComment)var b=a.toXmlWithXY();else{b=Blockly.Xml.blockToDom(a,!0);Blockly.Xml.deleteNext(b);var c=a.getRelativeToSurfaceXY();b.setAttribute(\"x\",a.RTL?-c.x:c.x);b.setAttribute(\"y\",c.y)}Blockly.clipboardXml_=b;Blockly.clipboardSource_=a.workspace;Blockly.clipboardTypeCounts_=a.isComment?null:Blockly.utils.getBlockTypeCounts(a,!0)};\nBlockly.duplicate=function(a){var b=Blockly.clipboardXml_,c=Blockly.clipboardSource_;Blockly.copy_(a);a.workspace.paste(Blockly.clipboardXml_);Blockly.clipboardXml_=b;Blockly.clipboardSource_=c};Blockly.onContextMenu_=function(a){Blockly.utils.isTargetInput(a)||a.preventDefault()};\nBlockly.hideChaff=function(a){Blockly.Tooltip.hide();Blockly.WidgetDiv.hide();Blockly.DropDownDiv.hideWithoutAnimation();a||(a=Blockly.getMainWorkspace(),a.trashcan&&a.trashcan.flyout&&a.trashcan.flyout.hide(),(a=a.getToolbox())&&a.getFlyout()&&a.getFlyout().autoClose&&a.clearSelection())};Blockly.getMainWorkspace=function(){return Blockly.mainWorkspace};Blockly.alert=function(a,b){alert(a);b&&b()};Blockly.confirm=function(a,b){b(confirm(a))};Blockly.prompt=function(a,b,c){c(prompt(a,b))};\nBlockly.jsonInitFactory_=function(a){return function(){this.jsonInit(a)}};\nBlockly.defineBlocksWithJsonArray=function(a){for(var b=0;b<a.length;b++){var c=a[b];if(c){var d=c.type;null==d||\"\"===d?console.warn(\"Block definition #\"+b+\" in JSON array is missing a type attribute. Skipping.\"):(Blockly.Blocks[d]&&console.warn(\"Block definition #\"+b+' in JSON array overwrites prior definition of \"'+d+'\".'),Blockly.Blocks[d]={init:Blockly.jsonInitFactory_(c)})}else console.warn(\"Block definition #\"+b+\" in JSON array is \"+c+\". Skipping.\")}};\nBlockly.bindEventWithChecks_=function(a,b,c,d,e,f){var g=!1,h=function(a){var b=!e;a=Blockly.Touch.splitEventByTouches(a);for(var f=0,h;h=a[f];f++)if(!b||Blockly.Touch.shouldHandleEvent(h))Blockly.Touch.setClientFromTouch(h),c?d.call(c,h):d(h),g=!0},k=[];if(Blockly.utils.global.PointerEvent&&b in Blockly.Touch.TOUCH_MAP)for(var l=0,m;m=Blockly.Touch.TOUCH_MAP[b][l];l++)a.addEventListener(m,h,!1),k.push([a,m,h]);else if(a.addEventListener(b,h,!1),k.push([a,b,h]),b in Blockly.Touch.TOUCH_MAP){var n=\nfunction(a){h(a);var b=!f;g&&b&&a.preventDefault()};for(l=0;m=Blockly.Touch.TOUCH_MAP[b][l];l++)a.addEventListener(m,n,!1),k.push([a,m,n])}return k};\nBlockly.bindEvent_=function(a,b,c,d){var e=function(a){c?d.call(c,a):d(a)},f=[];if(Blockly.utils.global.PointerEvent&&b in Blockly.Touch.TOUCH_MAP)for(var g=0,h;h=Blockly.Touch.TOUCH_MAP[b][g];g++)a.addEventListener(h,e,!1),f.push([a,h,e]);else if(a.addEventListener(b,e,!1),f.push([a,b,e]),b in Blockly.Touch.TOUCH_MAP){var k=function(a){if(a.changedTouches&&1==a.changedTouches.length){var b=a.changedTouches[0];a.clientX=b.clientX;a.clientY=b.clientY}e(a);a.preventDefault()};for(g=0;h=Blockly.Touch.TOUCH_MAP[b][g];g++)a.addEventListener(h,\nk,!1),f.push([a,h,k])}return f};Blockly.unbindEvent_=function(a){for(;a.length;){var b=a.pop(),c=b[2];b[0].removeEventListener(b[1],c,!1)}return c};Blockly.isNumber=function(a){return/^\\s*-?\\d+(\\.\\d+)?\\s*$/.test(a)};Blockly.hueToHex=function(a){return Blockly.utils.colour.hsvToHex(a,Blockly.HSV_SATURATION,255*Blockly.HSV_VALUE)};\nBlockly.checkBlockColourConstants=function(){Blockly.checkBlockColourConstant_(\"LOGIC_HUE\",[\"Blocks\",\"logic\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"LOGIC_HUE\",[\"Constants\",\"Logic\",\"HUE\"],210);Blockly.checkBlockColourConstant_(\"LOOPS_HUE\",[\"Blocks\",\"loops\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"LOOPS_HUE\",[\"Constants\",\"Loops\",\"HUE\"],120);Blockly.checkBlockColourConstant_(\"MATH_HUE\",[\"Blocks\",\"math\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"MATH_HUE\",[\"Constants\",\"Math\",\n\"HUE\"],230);Blockly.checkBlockColourConstant_(\"TEXTS_HUE\",[\"Blocks\",\"texts\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"TEXTS_HUE\",[\"Constants\",\"Text\",\"HUE\"],160);Blockly.checkBlockColourConstant_(\"LISTS_HUE\",[\"Blocks\",\"lists\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"LISTS_HUE\",[\"Constants\",\"Lists\",\"HUE\"],260);Blockly.checkBlockColourConstant_(\"COLOUR_HUE\",[\"Blocks\",\"colour\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"COLOUR_HUE\",[\"Constants\",\"Colour\",\"HUE\"],20);Blockly.checkBlockColourConstant_(\"VARIABLES_HUE\",\n[\"Blocks\",\"variables\",\"HUE\"],void 0);Blockly.checkBlockColourConstant_(\"VARIABLES_HUE\",[\"Constants\",\"Variables\",\"HUE\"],330);Blockly.checkBlockColourConstant_(\"VARIABLES_DYNAMIC_HUE\",[\"Constants\",\"VariablesDynamic\",\"HUE\"],310);Blockly.checkBlockColourConstant_(\"PROCEDURES_HUE\",[\"Blocks\",\"procedures\",\"HUE\"],void 0)};\nBlockly.checkBlockColourConstant_=function(a,b,c){for(var d=\"Blockly\",e=Blockly,f=0;f<b.length;++f)d+=\".\"+b[f],e&&(e=e[b[f]]);e&&e!==c&&(a=(void 0===c?'%1 has been removed. Use Blockly.Msg[\"%2\"].':'%1 is deprecated and unused. Override Blockly.Msg[\"%2\"].').replace(\"%1\",d).replace(\"%2\",a),console.warn(a))};Blockly.setParentContainer=function(a){Blockly.parentContainer=a};Blockly.Icon=function(a){this.block_=a};Blockly.Icon.prototype.collapseHidden=!0;Blockly.Icon.prototype.SIZE=17;Blockly.Icon.prototype.bubble_=null;Blockly.Icon.prototype.iconXY_=null;\nBlockly.Icon.prototype.createIcon=function(){this.iconGroup_||(this.iconGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyIconGroup\"},null),this.block_.isInFlyout&&Blockly.utils.dom.addClass(this.iconGroup_,\"blocklyIconGroupReadonly\"),this.drawIcon_(this.iconGroup_),this.block_.getSvgRoot().appendChild(this.iconGroup_),Blockly.bindEventWithChecks_(this.iconGroup_,\"mouseup\",this,this.iconClick_),this.updateEditable())};\nBlockly.Icon.prototype.dispose=function(){Blockly.utils.dom.removeNode(this.iconGroup_);this.iconGroup_=null;this.setVisible(!1);this.block_=null};Blockly.Icon.prototype.updateEditable=function(){};Blockly.Icon.prototype.isVisible=function(){return!!this.bubble_};Blockly.Icon.prototype.iconClick_=function(a){this.block_.workspace.isDragging()||this.block_.isInFlyout||Blockly.utils.isRightButton(a)||this.setVisible(!this.isVisible())};\nBlockly.Icon.prototype.applyColour=function(){this.isVisible()&&this.bubble_.setColour(this.block_.style.colourPrimary)};Blockly.Icon.prototype.setIconLocation=function(a){this.iconXY_=a;this.isVisible()&&this.bubble_.setAnchorLocation(a)};\nBlockly.Icon.prototype.computeIconLocation=function(){var a=this.block_.getRelativeToSurfaceXY(),b=Blockly.utils.getRelativeXY(this.iconGroup_);a=new Blockly.utils.Coordinate(a.x+b.x+this.SIZE/2,a.y+b.y+this.SIZE/2);Blockly.utils.Coordinate.equals(this.getIconLocation(),a)||this.setIconLocation(a)};Blockly.Icon.prototype.getIconLocation=function(){return this.iconXY_};\nBlockly.Icon.prototype.getCorrectedSize=function(){return new Blockly.utils.Size(Blockly.Icon.prototype.SIZE,Blockly.Icon.prototype.SIZE-2)};Blockly.Warning=function(a){Blockly.Warning.superClass_.constructor.call(this,a);this.createIcon();this.text_={}};Blockly.utils.object.inherits(Blockly.Warning,Blockly.Icon);Blockly.Warning.prototype.collapseHidden=!1;\nBlockly.Warning.prototype.drawIcon_=function(a){Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyIconShape\",d:\"M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z\"},a);Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyIconSymbol\",d:\"m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z\"},a);Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyIconSymbol\",x:\"7\",y:\"11\",height:\"2\",width:\"2\"},a)};\nBlockly.Warning.textToDom_=function(a){var b=Blockly.utils.dom.createSvgElement(\"text\",{\"class\":\"blocklyText blocklyBubbleText blocklyNoPointerEvents\",y:Blockly.Bubble.BORDER_WIDTH},null);a=a.split(\"\\n\");for(var c=0;c<a.length;c++){var d=Blockly.utils.dom.createSvgElement(\"tspan\",{dy:\"1em\",x:Blockly.Bubble.BORDER_WIDTH},b),e=document.createTextNode(a[c]);d.appendChild(e)}return b};\nBlockly.Warning.prototype.setVisible=function(a){a!=this.isVisible()&&(Blockly.Events.fire(new Blockly.Events.Ui(this.block_,\"warningOpen\",!a,a)),a?this.createBubble():this.disposeBubble())};\nBlockly.Warning.prototype.createBubble=function(){this.paragraphElement_=Blockly.Warning.textToDom_(this.getText());this.bubble_=new Blockly.Bubble(this.block_.workspace,this.paragraphElement_,this.block_.pathObject.svgPath,this.iconXY_,null,null);this.bubble_.setSvgId(this.block_.id);if(this.block_.RTL)for(var a=this.paragraphElement_.getBBox().width,b=0,c;c=this.paragraphElement_.childNodes[b];b++)c.setAttribute(\"text-anchor\",\"end\"),c.setAttribute(\"x\",a+Blockly.Bubble.BORDER_WIDTH);this.applyColour()};\nBlockly.Warning.prototype.disposeBubble=function(){this.bubble_.dispose();this.paragraphElement_=this.body_=this.bubble_=null};Blockly.Warning.prototype.bodyFocus_=function(a){this.bubble_.promote()};Blockly.Warning.prototype.setText=function(a,b){this.text_[b]!=a&&(a?this.text_[b]=a:delete this.text_[b],this.isVisible()&&(this.setVisible(!1),this.setVisible(!0)))};Blockly.Warning.prototype.getText=function(){var a=[],b;for(b in this.text_)a.push(this.text_[b]);return a.join(\"\\n\")};\nBlockly.Warning.prototype.dispose=function(){this.block_.warning=null;Blockly.Icon.prototype.dispose.call(this)};Blockly.Comment=function(a){Blockly.Comment.superClass_.constructor.call(this,a);this.model_=a.commentModel;this.model_.text=this.model_.text||\"\";this.cachedText_=\"\";this.onInputWrapper_=this.onChangeWrapper_=this.onWheelWrapper_=this.onMouseUpWrapper_=null;this.createIcon()};Blockly.utils.object.inherits(Blockly.Comment,Blockly.Icon);\nBlockly.Comment.prototype.drawIcon_=function(a){Blockly.utils.dom.createSvgElement(\"circle\",{\"class\":\"blocklyIconShape\",r:\"8\",cx:\"8\",cy:\"8\"},a);Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyIconSymbol\",d:\"m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.4050.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25-1.201,0.998 -1.201,1.528 -1.204,2.19z\"},a);Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyIconSymbol\",x:\"6.8\",y:\"10.78\",height:\"2\",width:\"2\"},a)};\nBlockly.Comment.prototype.createEditor_=function(){this.foreignObject_=Blockly.utils.dom.createSvgElement(\"foreignObject\",{x:Blockly.Bubble.BORDER_WIDTH,y:Blockly.Bubble.BORDER_WIDTH},null);var a=document.createElementNS(Blockly.utils.dom.HTML_NS,\"body\");a.setAttribute(\"xmlns\",Blockly.utils.dom.HTML_NS);a.className=\"blocklyMinimalBody\";var b=this.textarea_=document.createElementNS(Blockly.utils.dom.HTML_NS,\"textarea\");b.className=\"blocklyCommentTextarea\";b.setAttribute(\"dir\",this.block_.RTL?\"RTL\":\n\"LTR\");b.value=this.model_.text;this.resizeTextarea_();a.appendChild(b);this.foreignObject_.appendChild(a);this.onMouseUpWrapper_=Blockly.bindEventWithChecks_(b,\"mouseup\",this,this.startEdit_,!0,!0);this.onWheelWrapper_=Blockly.bindEventWithChecks_(b,\"wheel\",this,function(a){a.stopPropagation()});this.onChangeWrapper_=Blockly.bindEventWithChecks_(b,\"change\",this,function(a){this.cachedText_!=this.model_.text&&Blockly.Events.fire(new Blockly.Events.BlockChange(this.block_,\"comment\",null,this.cachedText_,\nthis.model_.text))});this.onInputWrapper_=Blockly.bindEventWithChecks_(b,\"input\",this,function(a){this.model_.text=b.value});setTimeout(b.focus.bind(b),0);return this.foreignObject_};Blockly.Comment.prototype.updateEditable=function(){Blockly.Comment.superClass_.updateEditable.call(this);this.isVisible()&&(this.disposeBubble_(),this.createBubble_())};Blockly.Comment.prototype.onBubbleResize_=function(){this.isVisible()&&(this.model_.size=this.bubble_.getBubbleSize(),this.resizeTextarea_())};\nBlockly.Comment.prototype.resizeTextarea_=function(){var a=this.model_.size,b=2*Blockly.Bubble.BORDER_WIDTH,c=a.width-b;a=a.height-b;this.foreignObject_.setAttribute(\"width\",c);this.foreignObject_.setAttribute(\"height\",a);this.textarea_.style.width=c-4+\"px\";this.textarea_.style.height=a-4+\"px\"};Blockly.Comment.prototype.setVisible=function(a){a!=this.isVisible()&&(Blockly.Events.fire(new Blockly.Events.Ui(this.block_,\"commentOpen\",!a,a)),(this.model_.pinned=a)?this.createBubble_():this.disposeBubble_())};\nBlockly.Comment.prototype.createBubble_=function(){!this.block_.isEditable()||Blockly.utils.userAgent.IE?this.createNonEditableBubble_():this.createEditableBubble_()};Blockly.Comment.prototype.createEditableBubble_=function(){this.bubble_=new Blockly.Bubble(this.block_.workspace,this.createEditor_(),this.block_.pathObject.svgPath,this.iconXY_,this.model_.size.width,this.model_.size.height);this.bubble_.setSvgId(this.block_.id);this.bubble_.registerResizeEvent(this.onBubbleResize_.bind(this));this.applyColour()};\nBlockly.Comment.prototype.createNonEditableBubble_=function(){Blockly.Warning.prototype.createBubble.call(this)};\nBlockly.Comment.prototype.disposeBubble_=function(){this.paragraphElement_?Blockly.Warning.prototype.disposeBubble.call(this):(this.onMouseUpWrapper_&&(Blockly.unbindEvent_(this.onMouseUpWrapper_),this.onMouseUpWrapper_=null),this.onWheelWrapper_&&(Blockly.unbindEvent_(this.onWheelWrapper_),this.onWheelWrapper_=null),this.onChangeWrapper_&&(Blockly.unbindEvent_(this.onChangeWrapper_),this.onChangeWrapper_=null),this.onInputWrapper_&&(Blockly.unbindEvent_(this.onInputWrapper_),this.onInputWrapper_=\nnull),this.bubble_.dispose(),this.foreignObject_=this.textarea_=this.bubble_=null)};Blockly.Comment.prototype.startEdit_=function(a){this.bubble_.promote()&&this.textarea_.focus();this.cachedText_=this.model_.text};Blockly.Comment.prototype.getBubbleSize=function(){return this.model_.size};Blockly.Comment.prototype.setBubbleSize=function(a,b){this.bubble_?this.bubble_.setBubbleSize(a,b):(this.model_.size.width=a,this.model_.size.height=b)};\nBlockly.Comment.prototype.getText=function(){return this.model_.text||\"\"};Blockly.Comment.prototype.setText=function(a){this.model_.text!=a&&(this.model_.text=a,this.updateText())};Blockly.Comment.prototype.updateText=function(){this.textarea_?this.textarea_.value=this.model_.text:this.paragraphElement_&&(this.paragraphElement_.firstChild.textContent=this.model_.text)};Blockly.Comment.prototype.dispose=function(){this.block_.comment=null;Blockly.Icon.prototype.dispose.call(this)};Blockly.Css.register(\".blocklyCommentTextarea {,background-color: #fef49c;,border: 0;,outline: 0;,margin: 0;,padding: 3px;,resize: none;,display: block;,overflow: hidden;,}\".split(\",\"));Blockly.FlyoutCursor=function(){Blockly.FlyoutCursor.superClass_.constructor.call(this)};Blockly.utils.object.inherits(Blockly.FlyoutCursor,Blockly.Cursor);Blockly.FlyoutCursor.prototype.onBlocklyAction=function(a){switch(a.name){case Blockly.navigation.actionNames.PREVIOUS:return this.prev(),!0;case Blockly.navigation.actionNames.NEXT:return this.next(),!0;default:return!1}};\nBlockly.FlyoutCursor.prototype.next=function(){var a=this.getCurNode();if(!a)return null;(a=a.next())&&this.setCurNode(a);return a};Blockly.FlyoutCursor.prototype.in=function(){return null};Blockly.FlyoutCursor.prototype.prev=function(){var a=this.getCurNode();if(!a)return null;(a=a.prev())&&this.setCurNode(a);return a};Blockly.FlyoutCursor.prototype.out=function(){return null};Blockly.Flyout=function(a){a.getMetrics=this.getMetrics_.bind(this);a.setMetrics=this.setMetrics_.bind(this);this.workspace_=new Blockly.WorkspaceSvg(a);this.workspace_.isFlyout=!0;this.workspace_.setVisible(this.isVisible_);this.RTL=!!a.RTL;this.toolboxPosition_=a.toolboxPosition;this.eventWrappers_=[];this.mats_=[];this.buttons_=[];this.listeners_=[];this.permanentlyDisabled_=[];this.tabWidth_=this.workspace_.getRenderer().getConstants().TAB_WIDTH};Blockly.Flyout.prototype.autoClose=!0;\nBlockly.Flyout.prototype.isVisible_=!1;Blockly.Flyout.prototype.containerVisible_=!0;Blockly.Flyout.prototype.CORNER_RADIUS=8;Blockly.Flyout.prototype.MARGIN=Blockly.Flyout.prototype.CORNER_RADIUS;Blockly.Flyout.prototype.GAP_X=3*Blockly.Flyout.prototype.MARGIN;Blockly.Flyout.prototype.GAP_Y=3*Blockly.Flyout.prototype.MARGIN;Blockly.Flyout.prototype.SCROLLBAR_PADDING=2;Blockly.Flyout.prototype.width_=0;Blockly.Flyout.prototype.height_=0;Blockly.Flyout.prototype.dragAngleRange_=70;\nBlockly.Flyout.prototype.createDom=function(a){this.svgGroup_=Blockly.utils.dom.createSvgElement(a,{\"class\":\"blocklyFlyout\",style:\"display: none\"},null);this.svgBackground_=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyFlyoutBackground\"},this.svgGroup_);this.svgGroup_.appendChild(this.workspace_.createDom());this.workspace_.getThemeManager().subscribe(this.svgBackground_,\"flyoutBackgroundColour\",\"fill\");this.workspace_.getThemeManager().subscribe(this.svgBackground_,\"flyoutOpacity\",\"fill-opacity\");\nthis.workspace_.getMarkerManager().setCursor(new Blockly.FlyoutCursor);return this.svgGroup_};\nBlockly.Flyout.prototype.init=function(a){this.targetWorkspace_=a;this.workspace_.targetWorkspace=a;this.scrollbar_=new Blockly.Scrollbar(this.workspace_,this.horizontalLayout_,!1,\"blocklyFlyoutScrollbar\");this.hide();Array.prototype.push.apply(this.eventWrappers_,Blockly.bindEventWithChecks_(this.svgGroup_,\"wheel\",this,this.wheel_));this.autoClose||(this.filterWrapper_=this.filterForCapacity_.bind(this),this.targetWorkspace_.addChangeListener(this.filterWrapper_));Array.prototype.push.apply(this.eventWrappers_,\nBlockly.bindEventWithChecks_(this.svgBackground_,\"mousedown\",this,this.onMouseDown_));this.workspace_.getGesture=this.targetWorkspace_.getGesture.bind(this.targetWorkspace_);this.workspace_.setVariableMap(this.targetWorkspace_.getVariableMap());this.workspace_.createPotentialVariableMap()};\nBlockly.Flyout.prototype.dispose=function(){this.hide();Blockly.unbindEvent_(this.eventWrappers_);this.filterWrapper_&&(this.targetWorkspace_.removeChangeListener(this.filterWrapper_),this.filterWrapper_=null);this.scrollbar_&&(this.scrollbar_.dispose(),this.scrollbar_=null);this.workspace_&&(this.workspace_.getThemeManager().unsubscribe(this.svgBackground_),this.workspace_.targetWorkspace=null,this.workspace_.dispose(),this.workspace_=null);this.svgGroup_&&(Blockly.utils.dom.removeNode(this.svgGroup_),\nthis.svgGroup_=null);this.targetWorkspace_=this.svgBackground_=null};Blockly.Flyout.prototype.getWidth=function(){return this.width_};Blockly.Flyout.prototype.getHeight=function(){return this.height_};Blockly.Flyout.prototype.getWorkspace=function(){return this.workspace_};Blockly.Flyout.prototype.isVisible=function(){return this.isVisible_};Blockly.Flyout.prototype.setVisible=function(a){var b=a!=this.isVisible();this.isVisible_=a;b&&this.updateDisplay_()};\nBlockly.Flyout.prototype.setContainerVisible=function(a){var b=a!=this.containerVisible_;this.containerVisible_=a;b&&this.updateDisplay_()};Blockly.Flyout.prototype.updateDisplay_=function(){var a=this.containerVisible_?this.isVisible():!1;this.svgGroup_.style.display=a?\"block\":\"none\";this.scrollbar_.setContainerVisible(a)};\nBlockly.Flyout.prototype.positionAt_=function(a,b,c,d){this.svgGroup_.setAttribute(\"width\",a);this.svgGroup_.setAttribute(\"height\",b);\"svg\"==this.svgGroup_.tagName?Blockly.utils.dom.setCssTransform(this.svgGroup_,\"translate(\"+c+\"px,\"+d+\"px)\"):this.svgGroup_.setAttribute(\"transform\",\"translate(\"+c+\",\"+d+\")\");this.scrollbar_&&(this.scrollbar_.setOrigin(c,d),this.scrollbar_.resize(),this.scrollbar_.setPosition_(this.scrollbar_.position_.x,this.scrollbar_.position_.y))};\nBlockly.Flyout.prototype.hide=function(){if(this.isVisible()){this.setVisible(!1);for(var a=0,b;b=this.listeners_[a];a++)Blockly.unbindEvent_(b);this.listeners_.length=0;this.reflowWrapper_&&(this.workspace_.removeChangeListener(this.reflowWrapper_),this.reflowWrapper_=null)}};\nBlockly.Flyout.prototype.show=function(a){this.workspace_.setResizesEnabled(!1);this.hide();this.clearOldBlocks_();if(\"string\"==typeof a){a=this.workspace_.targetWorkspace.getToolboxCategoryCallback(a);if(\"function\"!=typeof a)throw TypeError(\"Couldn't find a callback function when opening a toolbox category.\");a=a(this.workspace_.targetWorkspace);if(!Array.isArray(a))throw TypeError(\"Result of toolbox category callback must be an array.\");}this.setVisible(!0);var b=[],c=[];this.permanentlyDisabled_.length=\n0;for(var d=this.horizontalLayout_?this.GAP_X:this.GAP_Y,e=0,f;f=a[e];e++)if(f.tagName)switch(f.tagName.toUpperCase()){case \"BLOCK\":var g=Blockly.Xml.domToBlock(f,this.workspace_);g.isEnabled()||this.permanentlyDisabled_.push(g);b.push({type:\"block\",block:g});f=parseInt(f.getAttribute(\"gap\"),10);c.push(isNaN(f)?d:f);break;case \"SEP\":f=parseInt(f.getAttribute(\"gap\"),10);!isNaN(f)&&0<c.length?c[c.length-1]=f:c.push(d);break;case \"LABEL\":case \"BUTTON\":g=\"LABEL\"==f.tagName.toUpperCase();if(!Blockly.FlyoutButton)throw Error(\"Missing require for Blockly.FlyoutButton\");\nf=new Blockly.FlyoutButton(this.workspace_,this.targetWorkspace_,f,g);b.push({type:\"button\",button:f});c.push(d)}this.layout_(b,c);this.listeners_.push(Blockly.bindEventWithChecks_(this.svgBackground_,\"mouseover\",this,function(){for(var a=this.workspace_.getTopBlocks(!1),b=0,c;c=a[b];b++)c.removeSelect()}));this.horizontalLayout_?this.height_=0:this.width_=0;this.workspace_.setResizesEnabled(!0);this.reflow();this.filterForCapacity_();this.position();this.reflowWrapper_=this.reflow.bind(this);this.workspace_.addChangeListener(this.reflowWrapper_)};\nBlockly.Flyout.prototype.clearOldBlocks_=function(){for(var a=this.workspace_.getTopBlocks(!1),b=0,c;c=a[b];b++)c.workspace==this.workspace_&&c.dispose(!1,!1);for(b=0;b<this.mats_.length;b++)if(a=this.mats_[b])Blockly.Tooltip.unbindMouseEvents(a),Blockly.utils.dom.removeNode(a);for(b=this.mats_.length=0;a=this.buttons_[b];b++)a.dispose();this.buttons_.length=0;this.workspace_.getPotentialVariableMap().clear()};\nBlockly.Flyout.prototype.addBlockListeners_=function(a,b,c){this.listeners_.push(Blockly.bindEventWithChecks_(a,\"mousedown\",null,this.blockMouseDown_(b)));this.listeners_.push(Blockly.bindEventWithChecks_(c,\"mousedown\",null,this.blockMouseDown_(b)));this.listeners_.push(Blockly.bindEvent_(a,\"mouseenter\",b,b.addSelect));this.listeners_.push(Blockly.bindEvent_(a,\"mouseleave\",b,b.removeSelect));this.listeners_.push(Blockly.bindEvent_(c,\"mouseenter\",b,b.addSelect));this.listeners_.push(Blockly.bindEvent_(c,\n\"mouseleave\",b,b.removeSelect))};Blockly.Flyout.prototype.blockMouseDown_=function(a){var b=this;return function(c){var d=b.targetWorkspace_.getGesture(c);d&&(d.setStartBlock(a),d.handleFlyoutStart(c,b))}};Blockly.Flyout.prototype.onMouseDown_=function(a){var b=this.targetWorkspace_.getGesture(a);b&&b.handleFlyoutStart(a,this)};Blockly.Flyout.prototype.isBlockCreatable_=function(a){return a.isEnabled()};\nBlockly.Flyout.prototype.createBlock=function(a){var b=null;Blockly.Events.disable();var c=this.targetWorkspace_.getAllVariables();this.targetWorkspace_.setResizesEnabled(!1);try{b=this.placeNewBlock_(a),Blockly.hideChaff()}finally{Blockly.Events.enable()}a=Blockly.Variables.getAddedVariables(this.targetWorkspace_,c);if(Blockly.Events.isEnabled())for(Blockly.Events.setGroup(!0),Blockly.Events.fire(new Blockly.Events.Create(b)),c=0;c<a.length;c++)Blockly.Events.fire(new Blockly.Events.VarCreate(a[c]));\nthis.autoClose?this.hide():this.filterForCapacity_();return b};Blockly.Flyout.prototype.initFlyoutButton_=function(a,b,c){var d=a.createDom();a.moveTo(b,c);a.show();this.listeners_.push(Blockly.bindEventWithChecks_(d,\"mousedown\",this,this.onMouseDown_));this.buttons_.push(a)};\nBlockly.Flyout.prototype.createRect_=function(a,b,c,d,e){b=Blockly.utils.dom.createSvgElement(\"rect\",{\"fill-opacity\":0,x:b,y:c,height:d.height,width:d.width},null);b.tooltip=a;Blockly.Tooltip.bindMouseEvents(b);this.workspace_.getCanvas().insertBefore(b,a.getSvgRoot());a.flyoutRect_=b;return this.mats_[e]=b};\nBlockly.Flyout.prototype.moveRectToBlock_=function(a,b){var c=b.getHeightWidth();a.setAttribute(\"width\",c.width);a.setAttribute(\"height\",c.height);b=b.getRelativeToSurfaceXY();a.setAttribute(\"y\",b.y);a.setAttribute(\"x\",this.RTL?b.x-c.width:b.x)};\nBlockly.Flyout.prototype.filterForCapacity_=function(){for(var a=this.workspace_.getTopBlocks(!1),b=0,c;c=a[b];b++)if(-1==this.permanentlyDisabled_.indexOf(c))for(var d=this.targetWorkspace_.isCapacityAvailable(Blockly.utils.getBlockTypeCounts(c));c;)c.setEnabled(d),c=c.getNextBlock()};Blockly.Flyout.prototype.reflow=function(){this.reflowWrapper_&&this.workspace_.removeChangeListener(this.reflowWrapper_);this.reflowInternal_();this.reflowWrapper_&&this.workspace_.addChangeListener(this.reflowWrapper_)};\nBlockly.Flyout.prototype.isScrollable=function(){return this.scrollbar_?this.scrollbar_.isVisible():!1};\nBlockly.Flyout.prototype.placeNewBlock_=function(a){var b=this.targetWorkspace_;if(!a.getSvgRoot())throw Error(\"oldBlock is not rendered.\");var c=Blockly.Xml.blockToDom(a,!0);b.setResizesEnabled(!1);c=Blockly.Xml.domToBlock(c,b);if(!c.getSvgRoot())throw Error(\"block is not rendered.\");var d=b.getOriginOffsetInPixels(),e=this.workspace_.getOriginOffsetInPixels();a=a.getRelativeToSurfaceXY();a.scale(this.workspace_.scale);a=Blockly.utils.Coordinate.sum(e,a);d=Blockly.utils.Coordinate.difference(a,d);\nd.scale(1/b.scale);c.moveBy(d.x,d.y);return c};Blockly.Flyout.prototype.onBlocklyAction=function(a){return this.workspace_.getCursor().onBlocklyAction(a)};Blockly.HorizontalFlyout=function(a){a.getMetrics=this.getMetrics_.bind(this);a.setMetrics=this.setMetrics_.bind(this);Blockly.HorizontalFlyout.superClass_.constructor.call(this,a);this.horizontalLayout_=!0};Blockly.utils.object.inherits(Blockly.HorizontalFlyout,Blockly.Flyout);\nBlockly.HorizontalFlyout.prototype.getMetrics_=function(){if(!this.isVisible())return null;try{var a=this.workspace_.getCanvas().getBBox()}catch(e){a={height:0,y:0,width:0,x:0}}var b=this.SCROLLBAR_PADDING,c=this.SCROLLBAR_PADDING;this.toolboxPosition_==Blockly.TOOLBOX_AT_BOTTOM&&(b=0);var d=this.height_;this.toolboxPosition_==Blockly.TOOLBOX_AT_TOP&&(d-=this.SCROLLBAR_PADDING);return{viewHeight:d,viewWidth:this.width_-2*this.SCROLLBAR_PADDING,contentHeight:(a.height+2*this.MARGIN)*this.workspace_.scale,\ncontentWidth:(a.width+2*this.MARGIN)*this.workspace_.scale,viewTop:-this.workspace_.scrollY,viewLeft:-this.workspace_.scrollX,contentTop:0,contentLeft:0,absoluteTop:b,absoluteLeft:c}};Blockly.HorizontalFlyout.prototype.setMetrics_=function(a){var b=this.getMetrics_();b&&(\"number\"==typeof a.x&&(this.workspace_.scrollX=-b.contentWidth*a.x),this.workspace_.translate(this.workspace_.scrollX+b.absoluteLeft,this.workspace_.scrollY+b.absoluteTop))};\nBlockly.HorizontalFlyout.prototype.position=function(){if(this.isVisible()){var a=this.targetWorkspace_.getMetrics();a&&(this.width_=a.viewWidth,this.setBackgroundPath_(a.viewWidth-2*this.CORNER_RADIUS,this.height_-this.CORNER_RADIUS),this.positionAt_(this.width_,this.height_,0,this.targetWorkspace_.toolboxPosition==this.toolboxPosition_?a.toolboxHeight?this.toolboxPosition_==Blockly.TOOLBOX_AT_TOP?a.toolboxHeight:a.viewHeight-this.height_:this.toolboxPosition_==Blockly.TOOLBOX_AT_TOP?0:a.viewHeight:\nthis.toolboxPosition_==Blockly.TOOLBOX_AT_TOP?0:a.viewHeight+a.absoluteTop-this.height_))}};\nBlockly.HorizontalFlyout.prototype.setBackgroundPath_=function(a,b){var c=this.toolboxPosition_==Blockly.TOOLBOX_AT_TOP,d=[\"M 0,\"+(c?0:this.CORNER_RADIUS)];c?(d.push(\"h\",a+2*this.CORNER_RADIUS),d.push(\"v\",b),d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,1,-this.CORNER_RADIUS,this.CORNER_RADIUS),d.push(\"h\",-a),d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,1,-this.CORNER_RADIUS,-this.CORNER_RADIUS)):(d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,1,this.CORNER_RADIUS,-this.CORNER_RADIUS),\nd.push(\"h\",a),d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,1,this.CORNER_RADIUS,this.CORNER_RADIUS),d.push(\"v\",b),d.push(\"h\",-a-2*this.CORNER_RADIUS));d.push(\"z\");this.svgBackground_.setAttribute(\"d\",d.join(\" \"))};Blockly.HorizontalFlyout.prototype.scrollToStart=function(){this.scrollbar_.set(this.RTL?Infinity:0)};\nBlockly.HorizontalFlyout.prototype.wheel_=function(a){var b=Blockly.utils.getScrollDeltaPixels(a),c=b.x||b.y;c&&(b=this.getMetrics_(),c=b.viewLeft+c,c=Math.min(c,b.contentWidth-b.viewWidth),c=Math.max(c,0),this.scrollbar_.set(c),Blockly.WidgetDiv.hide());a.preventDefault();a.stopPropagation()};\nBlockly.HorizontalFlyout.prototype.layout_=function(a,b){this.workspace_.scale=this.targetWorkspace_.scale;var c=this.MARGIN,d=c+this.tabWidth_;this.RTL&&(a=a.reverse());for(var e=0,f;f=a[e];e++)if(\"block\"==f.type){f=f.block;for(var g=f.getDescendants(!1),h=0,k;k=g[h];h++)k.isInFlyout=!0;f.render();g=f.getSvgRoot();h=f.getHeightWidth();k=f.outputConnection?this.tabWidth_:0;k=this.RTL?d+h.width:d-k;f.moveBy(k,c);k=this.createRect_(f,k,c,h,e);d+=h.width+b[e];this.addBlockListeners_(g,f,k)}else\"button\"==\nf.type&&(this.initFlyoutButton_(f.button,d,c),d+=f.button.width+b[e])};Blockly.HorizontalFlyout.prototype.isDragTowardWorkspace=function(a){a=Math.atan2(a.y,a.x)/Math.PI*180;var b=this.dragAngleRange_;return a<90+b&&a>90-b||a>-90-b&&a<-90+b?!0:!1};\nBlockly.HorizontalFlyout.prototype.getClientRect=function(){if(!this.svgGroup_)return null;var a=this.svgGroup_.getBoundingClientRect(),b=a.top;return this.toolboxPosition_==Blockly.TOOLBOX_AT_TOP?new Blockly.utils.Rect(-1E9,b+a.height,-1E9,1E9):new Blockly.utils.Rect(b,1E9,-1E9,1E9)};\nBlockly.HorizontalFlyout.prototype.reflowInternal_=function(){this.workspace_.scale=this.targetWorkspace_.scale;for(var a=0,b=this.workspace_.getTopBlocks(!1),c=0,d;d=b[c];c++)a=Math.max(a,d.getHeightWidth().height);a+=1.5*this.MARGIN;a*=this.workspace_.scale;a+=Blockly.Scrollbar.scrollbarThickness;if(this.height_!=a){for(c=0;d=b[c];c++)d.flyoutRect_&&this.moveRectToBlock_(d.flyoutRect_,d);this.height_=a;this.position()}};Blockly.VerticalFlyout=function(a){a.getMetrics=this.getMetrics_.bind(this);a.setMetrics=this.setMetrics_.bind(this);Blockly.VerticalFlyout.superClass_.constructor.call(this,a);this.horizontalLayout_=!1};Blockly.utils.object.inherits(Blockly.VerticalFlyout,Blockly.Flyout);\nBlockly.VerticalFlyout.prototype.getMetrics_=function(){if(!this.isVisible())return null;try{var a=this.workspace_.getCanvas().getBBox()}catch(e){a={height:0,y:0,width:0,x:0}}var b=this.SCROLLBAR_PADDING,c=this.height_-2*this.SCROLLBAR_PADDING,d=this.width_;this.RTL||(d-=this.SCROLLBAR_PADDING);return{viewHeight:c,viewWidth:d,contentHeight:a.height*this.workspace_.scale+2*this.MARGIN,contentWidth:a.width*this.workspace_.scale+2*this.MARGIN,viewTop:-this.workspace_.scrollY+a.y,viewLeft:-this.workspace_.scrollX,\ncontentTop:a.y,contentLeft:a.x,absoluteTop:b,absoluteLeft:0}};Blockly.VerticalFlyout.prototype.setMetrics_=function(a){var b=this.getMetrics_();b&&(\"number\"==typeof a.y&&(this.workspace_.scrollY=-b.contentHeight*a.y),this.workspace_.translate(this.workspace_.scrollX+b.absoluteLeft,this.workspace_.scrollY+b.absoluteTop))};\nBlockly.VerticalFlyout.prototype.position=function(){if(this.isVisible()){var a=this.targetWorkspace_.getMetrics();a&&(this.height_=a.viewHeight,this.setBackgroundPath_(this.width_-this.CORNER_RADIUS,a.viewHeight-2*this.CORNER_RADIUS),this.positionAt_(this.width_,this.height_,this.targetWorkspace_.toolboxPosition==this.toolboxPosition_?a.toolboxWidth?this.toolboxPosition_==Blockly.TOOLBOX_AT_LEFT?a.toolboxWidth:a.viewWidth-this.width_:this.toolboxPosition_==Blockly.TOOLBOX_AT_LEFT?0:a.viewWidth:this.toolboxPosition_==\nBlockly.TOOLBOX_AT_LEFT?0:a.viewWidth+a.absoluteLeft-this.width_,0))}};\nBlockly.VerticalFlyout.prototype.setBackgroundPath_=function(a,b){var c=this.toolboxPosition_==Blockly.TOOLBOX_AT_RIGHT,d=a+this.CORNER_RADIUS;d=[\"M \"+(c?d:0)+\",0\"];d.push(\"h\",c?-a:a);d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,c?0:1,c?-this.CORNER_RADIUS:this.CORNER_RADIUS,this.CORNER_RADIUS);d.push(\"v\",Math.max(0,b));d.push(\"a\",this.CORNER_RADIUS,this.CORNER_RADIUS,0,0,c?0:1,c?this.CORNER_RADIUS:-this.CORNER_RADIUS,this.CORNER_RADIUS);d.push(\"h\",c?a:-a);d.push(\"z\");this.svgBackground_.setAttribute(\"d\",\nd.join(\" \"))};Blockly.VerticalFlyout.prototype.scrollToStart=function(){this.scrollbar_.set(0)};Blockly.VerticalFlyout.prototype.wheel_=function(a){var b=Blockly.utils.getScrollDeltaPixels(a);if(b.y){var c=this.getMetrics_();b=c.viewTop-c.contentTop+b.y;b=Math.min(b,c.contentHeight-c.viewHeight);b=Math.max(b,0);this.scrollbar_.set(b);Blockly.WidgetDiv.hide()}a.preventDefault();a.stopPropagation()};\nBlockly.VerticalFlyout.prototype.layout_=function(a,b){this.workspace_.scale=this.targetWorkspace_.scale;for(var c=this.MARGIN,d=this.RTL?c:c+this.tabWidth_,e=0,f;f=a[e];e++)if(\"block\"==f.type){f=f.block;for(var g=f.getDescendants(!1),h=0,k;k=g[h];h++)k.isInFlyout=!0;f.render();g=f.getSvgRoot();h=f.getHeightWidth();k=f.outputConnection?d-this.tabWidth_:d;f.moveBy(k,c);k=this.createRect_(f,this.RTL?k-h.width:k,c,h,e);this.addBlockListeners_(g,f,k);c+=h.height+b[e]}else\"button\"==f.type&&(this.initFlyoutButton_(f.button,\nd,c),c+=f.button.height+b[e])};Blockly.VerticalFlyout.prototype.isDragTowardWorkspace=function(a){a=Math.atan2(a.y,a.x)/Math.PI*180;var b=this.dragAngleRange_;return a<b&&a>-b||a<-180+b||a>180-b?!0:!1};Blockly.VerticalFlyout.prototype.getClientRect=function(){if(!this.svgGroup_)return null;var a=this.svgGroup_.getBoundingClientRect(),b=a.left;return this.toolboxPosition_==Blockly.TOOLBOX_AT_LEFT?new Blockly.utils.Rect(-1E9,1E9,-1E9,b+a.width):new Blockly.utils.Rect(-1E9,1E9,b,1E9)};\nBlockly.VerticalFlyout.prototype.reflowInternal_=function(){this.workspace_.scale=this.targetWorkspace_.scale;for(var a=0,b=this.workspace_.getTopBlocks(!1),c=0,d;d=b[c];c++){var e=d.getHeightWidth().width;d.outputConnection&&(e-=this.tabWidth_);a=Math.max(a,e)}for(c=0;d=this.buttons_[c];c++)a=Math.max(a,d.width);a+=1.5*this.MARGIN+this.tabWidth_;a*=this.workspace_.scale;a+=Blockly.Scrollbar.scrollbarThickness;if(this.width_!=a){for(c=0;d=b[c];c++){if(this.RTL){e=d.getRelativeToSurfaceXY().x;var f=\na/this.workspace_.scale-this.MARGIN;d.outputConnection||(f-=this.tabWidth_);d.moveBy(f-e,0)}d.flyoutRect_&&this.moveRectToBlock_(d.flyoutRect_,d)}if(this.RTL)for(c=0;d=this.buttons_[c];c++)b=d.getPosition().y,d.moveTo(a/this.workspace_.scale-d.width-this.MARGIN-this.tabWidth_,b);this.width_=a;this.position()}};Blockly.FlyoutButton=function(a,b,c,d){this.workspace_=a;this.targetWorkspace_=b;this.text_=c.getAttribute(\"text\");this.position_=new Blockly.utils.Coordinate(0,0);this.isLabel_=d;this.callbackKey_=c.getAttribute(\"callbackKey\")||c.getAttribute(\"callbackkey\");this.cssClass_=c.getAttribute(\"web-class\")||null;this.onMouseUpWrapper_=null};Blockly.FlyoutButton.MARGIN_X=5;Blockly.FlyoutButton.MARGIN_Y=2;Blockly.FlyoutButton.prototype.width=0;Blockly.FlyoutButton.prototype.height=0;\nBlockly.FlyoutButton.prototype.createDom=function(){var a=this.isLabel_?\"blocklyFlyoutLabel\":\"blocklyFlyoutButton\";this.cssClass_&&(a+=\" \"+this.cssClass_);this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":a},this.workspace_.getCanvas());if(!this.isLabel_)var b=Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyFlyoutButtonShadow\",rx:4,ry:4,x:1,y:1},this.svgGroup_);a=Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":this.isLabel_?\"blocklyFlyoutLabelBackground\":\"blocklyFlyoutButtonBackground\",\nrx:4,ry:4},this.svgGroup_);var c=Blockly.utils.dom.createSvgElement(\"text\",{\"class\":this.isLabel_?\"blocklyFlyoutLabelText\":\"blocklyText\",x:0,y:0,\"text-anchor\":\"middle\"},this.svgGroup_),d=Blockly.utils.replaceMessageReferences(this.text_);this.workspace_.RTL&&(d+=\"\\u200f\");c.textContent=d;this.isLabel_&&(this.svgText_=c,this.workspace_.getThemeManager().subscribe(this.svgText_,\"flyoutForegroundColour\",\"fill\"));var e=Blockly.utils.style.getComputedStyle(c,\"fontSize\"),f=Blockly.utils.style.getComputedStyle(c,\n\"fontWeight\"),g=Blockly.utils.style.getComputedStyle(c,\"fontFamily\");this.width=Blockly.utils.dom.getFastTextWidthWithSizeString(c,e,f,g);d=Blockly.utils.dom.measureFontMetrics(d,e,f,g);this.height=d.height;this.isLabel_||(this.width+=2*Blockly.FlyoutButton.MARGIN_X,this.height+=2*Blockly.FlyoutButton.MARGIN_Y,b.setAttribute(\"width\",this.width),b.setAttribute(\"height\",this.height));a.setAttribute(\"width\",this.width);a.setAttribute(\"height\",this.height);c.setAttribute(\"x\",this.width/2);c.setAttribute(\"y\",\nthis.height/2-d.height/2+d.baseline);this.updateTransform_();this.onMouseUpWrapper_=Blockly.bindEventWithChecks_(this.svgGroup_,\"mouseup\",this,this.onMouseUp_);return this.svgGroup_};Blockly.FlyoutButton.prototype.show=function(){this.updateTransform_();this.svgGroup_.setAttribute(\"display\",\"block\")};Blockly.FlyoutButton.prototype.updateTransform_=function(){this.svgGroup_.setAttribute(\"transform\",\"translate(\"+this.position_.x+\",\"+this.position_.y+\")\")};\nBlockly.FlyoutButton.prototype.moveTo=function(a,b){this.position_.x=a;this.position_.y=b;this.updateTransform_()};Blockly.FlyoutButton.prototype.getPosition=function(){return this.position_};Blockly.FlyoutButton.prototype.getTargetWorkspace=function(){return this.targetWorkspace_};Blockly.FlyoutButton.prototype.dispose=function(){this.onMouseUpWrapper_&&Blockly.unbindEvent_(this.onMouseUpWrapper_);this.svgGroup_&&Blockly.utils.dom.removeNode(this.svgGroup_);this.svgText_&&this.workspace_.getThemeManager().unsubscribe(this.svgText_)};\nBlockly.FlyoutButton.prototype.onMouseUp_=function(a){(a=this.targetWorkspace_.getGesture(a))&&a.cancel();this.isLabel_&&this.callbackKey_?console.warn(\"Labels should not have callbacks. Label text: \"+this.text_):this.isLabel_||this.callbackKey_&&this.targetWorkspace_.getButtonCallback(this.callbackKey_)?this.isLabel_||this.targetWorkspace_.getButtonCallback(this.callbackKey_)(this):console.warn(\"Buttons should have callbacks. Button text: \"+this.text_)};Blockly.Css.register(\".blocklyFlyoutButton {,fill: #888;,cursor: default;,},.blocklyFlyoutButtonShadow {,fill: #666;,},.blocklyFlyoutButton:hover {,fill: #aaa;,},.blocklyFlyoutLabel {,cursor: default;,},.blocklyFlyoutLabelBackground {,opacity: 0;,}\".split(\",\"));Blockly.Generator=function(a){this.name_=a;this.FUNCTION_NAME_PLACEHOLDER_REGEXP_=new RegExp(this.FUNCTION_NAME_PLACEHOLDER_,\"g\")};Blockly.Generator.NAME_TYPE=\"generated_function\";Blockly.Generator.prototype.INFINITE_LOOP_TRAP=null;Blockly.Generator.prototype.STATEMENT_PREFIX=null;Blockly.Generator.prototype.STATEMENT_SUFFIX=null;Blockly.Generator.prototype.INDENT=\"  \";Blockly.Generator.prototype.COMMENT_WRAP=60;Blockly.Generator.prototype.ORDER_OVERRIDES=[];\nBlockly.Generator.prototype.workspaceToCode=function(a){a||(console.warn(\"No workspace specified in workspaceToCode call.  Guessing.\"),a=Blockly.getMainWorkspace());var b=[];this.init(a);a=a.getTopBlocks(!0);for(var c=0,d;d=a[c];c++){var e=this.blockToCode(d);Array.isArray(e)&&(e=e[0]);e&&(d.outputConnection&&(e=this.scrubNakedValue(e),this.STATEMENT_PREFIX&&!d.suppressPrefixSuffix&&(e=this.injectId(this.STATEMENT_PREFIX,d)+e),this.STATEMENT_SUFFIX&&!d.suppressPrefixSuffix&&(e+=this.injectId(this.STATEMENT_SUFFIX,\nd))),b.push(e))}b=b.join(\"\\n\");b=this.finish(b);b=b.replace(/^\\s+\\n/,\"\");b=b.replace(/\\n\\s+$/,\"\\n\");return b=b.replace(/[ \\t]+\\n/g,\"\\n\")};Blockly.Generator.prototype.prefixLines=function(a,b){return b+a.replace(/(?!\\n$)\\n/g,\"\\n\"+b)};Blockly.Generator.prototype.allNestedComments=function(a){var b=[];a=a.getDescendants(!0);for(var c=0;c<a.length;c++){var d=a[c].getCommentText();d&&b.push(d)}b.length&&b.push(\"\");return b.join(\"\\n\")};\nBlockly.Generator.prototype.blockToCode=function(a,b){if(!a)return\"\";if(!a.isEnabled())return b?\"\":this.blockToCode(a.getNextBlock());var c=this[a.type];if(\"function\"!=typeof c)throw Error('Language \"'+this.name_+'\" does not know how to generate  code for block type \"'+a.type+'\".');c=c.call(a,a);if(Array.isArray(c)){if(!a.outputConnection)throw TypeError(\"Expecting string from statement block: \"+a.type);return[this.scrub_(a,c[0],b),c[1]]}if(\"string\"==typeof c)return this.STATEMENT_PREFIX&&!a.suppressPrefixSuffix&&\n(c=this.injectId(this.STATEMENT_PREFIX,a)+c),this.STATEMENT_SUFFIX&&!a.suppressPrefixSuffix&&(c+=this.injectId(this.STATEMENT_SUFFIX,a)),this.scrub_(a,c,b);if(null===c)return\"\";throw SyntaxError(\"Invalid code generated: \"+c);};\nBlockly.Generator.prototype.valueToCode=function(a,b,c){if(isNaN(c))throw TypeError(\"Expecting valid order from block: \"+a.type);var d=a.getInputTargetBlock(b);if(!d)return\"\";b=this.blockToCode(d);if(\"\"===b)return\"\";if(!Array.isArray(b))throw TypeError(\"Expecting tuple from value block: \"+d.type);a=b[0];b=b[1];if(isNaN(b))throw TypeError(\"Expecting valid order from value block: \"+d.type);if(!a)return\"\";d=!1;var e=Math.floor(c),f=Math.floor(b);if(e<=f&&(e!=f||0!=e&&99!=e))for(d=!0,e=0;e<this.ORDER_OVERRIDES.length;e++)if(this.ORDER_OVERRIDES[e][0]==\nc&&this.ORDER_OVERRIDES[e][1]==b){d=!1;break}d&&(a=\"(\"+a+\")\");return a};Blockly.Generator.prototype.statementToCode=function(a,b){a=a.getInputTargetBlock(b);b=this.blockToCode(a);if(\"string\"!=typeof b)throw TypeError(\"Expecting code from statement block: \"+(a&&a.type));b&&(b=this.prefixLines(b,this.INDENT));return b};\nBlockly.Generator.prototype.addLoopTrap=function(a,b){this.INFINITE_LOOP_TRAP&&(a=this.prefixLines(this.injectId(this.INFINITE_LOOP_TRAP,b),this.INDENT)+a);this.STATEMENT_SUFFIX&&!b.suppressPrefixSuffix&&(a=this.prefixLines(this.injectId(this.STATEMENT_SUFFIX,b),this.INDENT)+a);this.STATEMENT_PREFIX&&!b.suppressPrefixSuffix&&(a+=this.prefixLines(this.injectId(this.STATEMENT_PREFIX,b),this.INDENT));return a};\nBlockly.Generator.prototype.injectId=function(a,b){b=b.id.replace(/\\$/g,\"$$$$\");return a.replace(/%1/g,\"'\"+b+\"'\")};Blockly.Generator.prototype.RESERVED_WORDS_=\"\";Blockly.Generator.prototype.addReservedWords=function(a){this.RESERVED_WORDS_+=a+\",\"};Blockly.Generator.prototype.FUNCTION_NAME_PLACEHOLDER_=\"{leCUI8hutHZI4480Dc}\";\nBlockly.Generator.prototype.provideFunction_=function(a,b){if(!this.definitions_[a]){var c=this.variableDB_.getDistinctName(a,Blockly.PROCEDURE_CATEGORY_NAME);this.functionNames_[a]=c;b=b.join(\"\\n\").replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_,c);for(var d;d!=b;)d=b,b=b.replace(/^(( {2})*) {2}/gm,\"$1\\x00\");b=b.replace(/\\0/g,this.INDENT);this.definitions_[a]=b}return this.functionNames_[a]};Blockly.Generator.prototype.init=function(a){};Blockly.Generator.prototype.scrub_=function(a,b,c){return b};\nBlockly.Generator.prototype.finish=function(a){return a};Blockly.Generator.prototype.scrubNakedValue=function(a){return a};Blockly.tree={};Blockly.tree.BaseNode=function(a,b){Blockly.Component.call(this);this.content=a;this.config_=b;this.expanded_=this.selected_=!1;this.isUserCollapsible_=!0;this.depth_=-1};Blockly.utils.object.inherits(Blockly.tree.BaseNode,Blockly.Component);Blockly.tree.BaseNode.allNodes={};Blockly.tree.BaseNode.prototype.disposeInternal=function(){Blockly.tree.BaseNode.superClass_.disposeInternal.call(this);this.tree&&(this.tree=null);this.setElementInternal(null)};\nBlockly.tree.BaseNode.prototype.initAccessibility=function(){var a=this.getElement();if(a){var b=this.getLabelElement();b&&!b.id&&(b.id=this.getId()+\".label\");Blockly.utils.aria.setRole(a,Blockly.utils.aria.Role.TREEITEM);Blockly.utils.aria.setState(a,Blockly.utils.aria.State.SELECTED,!1);Blockly.utils.aria.setState(a,Blockly.utils.aria.State.LEVEL,this.getDepth());b&&Blockly.utils.aria.setState(a,Blockly.utils.aria.State.LABELLEDBY,b.id);(b=this.getIconElement())&&Blockly.utils.aria.setRole(b,Blockly.utils.aria.Role.PRESENTATION);\nif(b=this.getChildrenElement())if(Blockly.utils.aria.setRole(b,Blockly.utils.aria.Role.GROUP),b.hasChildNodes())for(Blockly.utils.aria.setState(a,Blockly.utils.aria.State.EXPANDED,!1),a=this.getChildCount(),b=1;b<=a;b++){var c=this.getChildAt(b-1).getElement();Blockly.utils.aria.setState(c,Blockly.utils.aria.State.SETSIZE,a);Blockly.utils.aria.setState(c,Blockly.utils.aria.State.POSINSET,b)}}};\nBlockly.tree.BaseNode.prototype.createDom=function(){var a=document.createElement(\"div\");a.appendChild(this.toDom());this.setElementInternal(a)};Blockly.tree.BaseNode.prototype.enterDocument=function(){Blockly.tree.BaseNode.superClass_.enterDocument.call(this);Blockly.tree.BaseNode.allNodes[this.getId()]=this;this.initAccessibility()};Blockly.tree.BaseNode.prototype.exitDocument=function(){Blockly.tree.BaseNode.superClass_.exitDocument.call(this);delete Blockly.tree.BaseNode.allNodes[this.getId()]};\nBlockly.tree.BaseNode.prototype.addChildAt=function(a,b){var c=this.getChildAt(b-1),d=this.getChildAt(b);Blockly.tree.BaseNode.superClass_.addChildAt.call(this,a,b);a.previousSibling_=c;a.nextSibling_=d;c&&(c.nextSibling_=a);d&&(d.previousSibling_=a);(b=this.getTree())&&a.setTreeInternal(b);a.setDepth_(this.getDepth()+1);if(b=this.getElement())if(this.updateExpandIcon(),Blockly.utils.aria.setState(b,Blockly.utils.aria.State.EXPANDED,this.expanded_),this.expanded_){b=this.getChildrenElement();a.getElement()||\na.createDom();var e=a.getElement(),f=d&&d.getElement();b.insertBefore(e,f);this.isInDocument()&&a.enterDocument();d||(c?c.updateExpandIcon():(Blockly.utils.style.setElementShown(b,!0),this.setExpanded(this.expanded_)))}};Blockly.tree.BaseNode.prototype.add=function(a){if(a.getParent())throw Error(Blockly.Component.Error.PARENT_UNABLE_TO_BE_SET);this.addChildAt(a,this.getChildCount())};Blockly.tree.BaseNode.prototype.getTree=function(){return null};\nBlockly.tree.BaseNode.prototype.getDepth=function(){var a=this.depth_;0>a&&(a=(a=this.getParent())?a.getDepth()+1:0,this.setDepth_(a));return a};Blockly.tree.BaseNode.prototype.setDepth_=function(a){if(a!=this.depth_){this.depth_=a;var b=this.getRowElement();if(b){var c=this.getPixelIndent_()+\"px\";this.rightToLeft_?b.style.paddingRight=c:b.style.paddingLeft=c}this.forEachChild(function(b){b.setDepth_(a+1)})}};Blockly.tree.BaseNode.prototype.contains=function(a){for(;a;){if(a==this)return!0;a=a.getParent()}return!1};\nBlockly.tree.BaseNode.prototype.getChildren=function(){var a=[];this.forEachChild(function(b){a.push(b)});return a};Blockly.tree.BaseNode.prototype.getPreviousSibling=function(){return this.previousSibling_};Blockly.tree.BaseNode.prototype.getNextSibling=function(){return this.nextSibling_};Blockly.tree.BaseNode.prototype.isLastSibling=function(){return!this.nextSibling_};Blockly.tree.BaseNode.prototype.isSelected=function(){return this.selected_};\nBlockly.tree.BaseNode.prototype.select=function(){var a=this.getTree();a&&a.setSelectedItem(this)};Blockly.tree.BaseNode.prototype.setSelected=function(a){if(this.selected_!=a){this.selected_=a;this.updateRow();var b=this.getElement();b&&(Blockly.utils.aria.setState(b,Blockly.utils.aria.State.SELECTED,a),a&&(a=this.getTree().getElement(),Blockly.utils.aria.setState(a,Blockly.utils.aria.State.ACTIVEDESCENDANT,this.getId())))}};\nBlockly.tree.BaseNode.prototype.setExpanded=function(a){var b=a!=this.expanded_,c;this.expanded_=a;var d=this.getTree(),e=this.getElement();if(this.hasChildren()){if(!a&&d&&this.contains(d.getSelectedItem())&&this.select(),e){if(c=this.getChildrenElement())Blockly.utils.style.setElementShown(c,a),Blockly.utils.aria.setState(e,Blockly.utils.aria.State.EXPANDED,a),a&&this.isInDocument()&&!c.hasChildNodes()&&(this.forEachChild(function(a){c.appendChild(a.toDom())}),this.forEachChild(function(a){a.enterDocument()}));\nthis.updateExpandIcon()}}else(c=this.getChildrenElement())&&Blockly.utils.style.setElementShown(c,!1);e&&this.updateIcon_();b&&(a?this.doNodeExpanded():this.doNodeCollapsed())};Blockly.tree.BaseNode.prototype.doNodeExpanded=function(){};Blockly.tree.BaseNode.prototype.doNodeCollapsed=function(){};Blockly.tree.BaseNode.prototype.toggle=function(){this.setExpanded(!this.expanded_)};\nBlockly.tree.BaseNode.prototype.toDom=function(){var a=this.expanded_&&this.hasChildren(),b=document.createElement(\"div\");b.style.backgroundPosition=this.getBackgroundPosition();a||(b.style.display=\"none\");a&&this.forEachChild(function(a){b.appendChild(a.toDom())});a=document.createElement(\"div\");a.id=this.getId();a.appendChild(this.getRowDom());a.appendChild(b);return a};Blockly.tree.BaseNode.prototype.getPixelIndent_=function(){return Math.max(0,(this.getDepth()-1)*this.config_.indentWidth)};\nBlockly.tree.BaseNode.prototype.getRowDom=function(){var a=document.createElement(\"div\");a.className=this.getRowClassName();a.style[\"padding-\"+(this.rightToLeft_?\"right\":\"left\")]=this.getPixelIndent_()+\"px\";a.appendChild(this.getIconDom());a.appendChild(this.getLabelDom());return a};Blockly.tree.BaseNode.prototype.getRowClassName=function(){var a=\"\";this.isSelected()&&(a=\" \"+(this.config_.cssSelectedRow||\"\"));return this.config_.cssTreeRow+a};\nBlockly.tree.BaseNode.prototype.getLabelDom=function(){var a=document.createElement(\"span\");a.className=this.config_.cssItemLabel||\"\";a.textContent=this.content;return a};Blockly.tree.BaseNode.prototype.getIconDom=function(){var a=document.createElement(\"span\");a.style.display=\"inline-block\";a.className=this.getCalculatedIconClass();return a};Blockly.tree.BaseNode.prototype.getCalculatedIconClass=function(){throw Error(\"unimplemented abstract method\");};\nBlockly.tree.BaseNode.prototype.getBackgroundPosition=function(){return(this.isLastSibling()?\"-100\":(this.getDepth()-1)*this.config_.indentWidth)+\"px 0\"};Blockly.tree.BaseNode.prototype.getElement=function(){var a=Blockly.tree.BaseNode.superClass_.getElement.call(this);a||(a=document.getElementById(this.getId()),this.setElementInternal(a));return a};Blockly.tree.BaseNode.prototype.getRowElement=function(){var a=this.getElement();return a?a.firstChild:null};\nBlockly.tree.BaseNode.prototype.getIconElement=function(){var a=this.getRowElement();return a?a.firstChild:null};Blockly.tree.BaseNode.prototype.getLabelElement=function(){var a=this.getRowElement();return a&&a.lastChild?a.lastChild.previousSibling:null};Blockly.tree.BaseNode.prototype.getChildrenElement=function(){var a=this.getElement();return a?a.lastChild:null};Blockly.tree.BaseNode.prototype.updateRow=function(){var a=this.getRowElement();a&&(a.className=this.getRowClassName())};\nBlockly.tree.BaseNode.prototype.updateExpandIcon=function(){var a=this.getChildrenElement();a&&(a.style.backgroundPosition=this.getBackgroundPosition())};Blockly.tree.BaseNode.prototype.updateIcon_=function(){this.getIconElement().className=this.getCalculatedIconClass()};Blockly.tree.BaseNode.prototype.onMouseDown=function(a){\"expand\"==a.target.getAttribute(\"type\")&&this.hasChildren()?this.isUserCollapsible_&&this.toggle():(this.select(),this.updateRow())};\nBlockly.tree.BaseNode.prototype.onClick_=function(a){a.preventDefault()};Blockly.tree.BaseNode.prototype.onKeyDown=function(a){var b=!0;switch(a.keyCode){case Blockly.utils.KeyCodes.RIGHT:if(a.altKey)break;b=this.selectChild();break;case Blockly.utils.KeyCodes.LEFT:if(a.altKey)break;b=this.selectParent();break;case Blockly.utils.KeyCodes.DOWN:b=this.selectNext();break;case Blockly.utils.KeyCodes.UP:b=this.selectPrevious();break;default:b=!1}b&&a.preventDefault();return b};\nBlockly.tree.BaseNode.prototype.selectNext=function(){var a=this.getNextShownNode();a&&a.select();return!0};Blockly.tree.BaseNode.prototype.selectPrevious=function(){var a=this.getPreviousShownNode();a&&a.select();return!0};Blockly.tree.BaseNode.prototype.selectParent=function(){if(this.hasChildren()&&this.expanded_&&this.isUserCollapsible_)this.setExpanded(!1);else{var a=this.getParent(),b=this.getTree();a&&a!=b&&a.select()}return!0};\nBlockly.tree.BaseNode.prototype.selectChild=function(){return this.hasChildren()?(this.expanded_?this.getChildAt(0).select():this.setExpanded(!0),!0):!1};Blockly.tree.BaseNode.prototype.getLastShownDescendant=function(){return this.expanded_&&this.hasChildren()?this.getChildAt(this.getChildCount()-1).getLastShownDescendant():this};\nBlockly.tree.BaseNode.prototype.getNextShownNode=function(){if(this.hasChildren()&&this.expanded_)return this.getChildAt(0);for(var a=this,b;a!=this.getTree();){b=a.getNextSibling();if(null!=b)return b;a=a.getParent()}return null};Blockly.tree.BaseNode.prototype.getPreviousShownNode=function(){var a=this.getPreviousSibling();if(null!=a)return a.getLastShownDescendant();a=this.getParent();var b=this.getTree();return a==b||this==b?null:a};\nBlockly.tree.BaseNode.prototype.setTreeInternal=function(a){this.tree!=a&&(this.tree=a,this.forEachChild(function(b){b.setTreeInternal(a)}))};Blockly.tree.TreeNode=function(a,b,c){this.toolbox_=a;Blockly.tree.BaseNode.call(this,b,c)};Blockly.utils.object.inherits(Blockly.tree.TreeNode,Blockly.tree.BaseNode);Blockly.tree.TreeNode.prototype.getTree=function(){if(this.tree)return this.tree;var a=this.getParent();return a&&(a=a.getTree())?(this.setTreeInternal(a),a):null};\nBlockly.tree.TreeNode.prototype.getCalculatedIconClass=function(){var a=this.expanded_;if(a&&this.expandedIconClass)return this.expandedIconClass;var b=this.iconClass;if(!a&&b)return b;b=this.config_;if(this.hasChildren()){if(a&&b.cssExpandedFolderIcon)return b.cssTreeIcon+\" \"+b.cssExpandedFolderIcon;if(!a&&b.cssCollapsedFolderIcon)return b.cssTreeIcon+\" \"+b.cssCollapsedFolderIcon}else if(b.cssFileIcon)return b.cssTreeIcon+\" \"+b.cssFileIcon;return\"\"};\nBlockly.tree.TreeNode.prototype.onClick_=function(a){this.hasChildren()&&this.isUserCollapsible_?(this.toggle(),this.select()):this.isSelected()?this.getTree().setSelectedItem(null):this.select();this.updateRow()};Blockly.tree.TreeNode.prototype.onMouseDown=function(a){};\nBlockly.tree.TreeNode.prototype.onKeyDown=function(a){if(this.tree.toolbox_.horizontalLayout_){var b={},c=Blockly.utils.KeyCodes.DOWN,d=Blockly.utils.KeyCodes.UP;b[Blockly.utils.KeyCodes.RIGHT]=this.rightToLeft_?d:c;b[Blockly.utils.KeyCodes.LEFT]=this.rightToLeft_?c:d;b[Blockly.utils.KeyCodes.UP]=Blockly.utils.KeyCodes.LEFT;b[Blockly.utils.KeyCodes.DOWN]=Blockly.utils.KeyCodes.RIGHT;Object.defineProperties(a,{keyCode:{value:b[a.keyCode]||a.keyCode}})}return Blockly.tree.TreeNode.superClass_.onKeyDown.call(this,\na)};Blockly.tree.TreeNode.prototype.onSizeChanged=function(a){this.onSizeChanged_=a};Blockly.tree.TreeNode.prototype.resizeToolbox_=function(){this.onSizeChanged_&&this.onSizeChanged_.call(this.toolbox_)};Blockly.tree.TreeNode.prototype.doNodeExpanded=Blockly.tree.TreeNode.prototype.resizeToolbox_;Blockly.tree.TreeNode.prototype.doNodeCollapsed=Blockly.tree.TreeNode.prototype.resizeToolbox_;Blockly.tree.TreeControl=function(a,b){this.toolbox_=a;this.onKeydownWrapper_=this.onClickWrapper_=this.onBlurWrapper_=this.onFocusWrapper_=null;Blockly.tree.BaseNode.call(this,\"\",b);this.selected_=this.expanded_=!0;this.selectedItem_=this};Blockly.utils.object.inherits(Blockly.tree.TreeControl,Blockly.tree.BaseNode);Blockly.tree.TreeControl.prototype.getTree=function(){return this};Blockly.tree.TreeControl.prototype.getToolbox=function(){return this.toolbox_};\nBlockly.tree.TreeControl.prototype.getDepth=function(){return 0};Blockly.tree.TreeControl.prototype.handleFocus_=function(a){this.focused_=!0;a=this.getElement();Blockly.utils.dom.addClass(a,\"focused\");this.selectedItem_&&this.selectedItem_.select()};Blockly.tree.TreeControl.prototype.handleBlur_=function(a){this.focused_=!1;a=this.getElement();Blockly.utils.dom.removeClass(a,\"focused\")};Blockly.tree.TreeControl.prototype.hasFocus=function(){return this.focused_};\nBlockly.tree.TreeControl.prototype.setExpanded=function(a){this.expanded_=a};Blockly.tree.TreeControl.prototype.getIconElement=function(){var a=this.getRowElement();return a?a.firstChild:null};Blockly.tree.TreeControl.prototype.updateExpandIcon=function(){};Blockly.tree.TreeControl.prototype.getRowClassName=function(){return Blockly.tree.TreeControl.superClass_.getRowClassName.call(this)+\" \"+this.config_.cssHideRoot};\nBlockly.tree.TreeControl.prototype.getCalculatedIconClass=function(){var a=this.expanded_;if(a&&this.expandedIconClass)return this.expandedIconClass;var b=this.iconClass;return!a&&b?b:a&&this.config_.cssExpandedRootIcon?this.config_.cssTreeIcon+\" \"+this.config_.cssExpandedRootIcon:\"\"};\nBlockly.tree.TreeControl.prototype.setSelectedItem=function(a){if(a!=this.selectedItem_&&(!this.onBeforeSelected_||this.onBeforeSelected_.call(this.toolbox_,a))){var b=this.getSelectedItem();this.selectedItem_&&this.selectedItem_.setSelected(!1);(this.selectedItem_=a)&&a.setSelected(!0);this.onAfterSelected_&&this.onAfterSelected_.call(this.toolbox_,b,a)}};Blockly.tree.TreeControl.prototype.onBeforeSelected=function(a){this.onBeforeSelected_=a};\nBlockly.tree.TreeControl.prototype.onAfterSelected=function(a){this.onAfterSelected_=a};Blockly.tree.TreeControl.prototype.getSelectedItem=function(){return this.selectedItem_};Blockly.tree.TreeControl.prototype.initAccessibility=function(){Blockly.tree.TreeControl.superClass_.initAccessibility.call(this);var a=this.getElement();Blockly.utils.aria.setRole(a,Blockly.utils.aria.Role.TREE);Blockly.utils.aria.setState(a,Blockly.utils.aria.State.LABELLEDBY,this.getLabelElement().id)};\nBlockly.tree.TreeControl.prototype.enterDocument=function(){Blockly.tree.TreeControl.superClass_.enterDocument.call(this);var a=this.getElement();a.className=this.config_.cssRoot;a.setAttribute(\"hideFocus\",\"true\");this.attachEvents_();this.initAccessibility()};Blockly.tree.TreeControl.prototype.exitDocument=function(){Blockly.tree.TreeControl.superClass_.exitDocument.call(this);this.detachEvents_()};\nBlockly.tree.TreeControl.prototype.attachEvents_=function(){var a=this.getElement();a.tabIndex=0;this.onFocusWrapper_=Blockly.bindEvent_(a,\"focus\",this,this.handleFocus_);this.onBlurWrapper_=Blockly.bindEvent_(a,\"blur\",this,this.handleBlur_);this.onClickWrapper_=Blockly.bindEventWithChecks_(a,\"click\",this,this.handleMouseEvent_);this.onKeydownWrapper_=Blockly.bindEvent_(a,\"keydown\",this,this.handleKeyEvent_)};\nBlockly.tree.TreeControl.prototype.detachEvents_=function(){this.onFocusWrapper_&&(Blockly.unbindEvent_(this.onFocusWrapper_),this.onFocusWrapper_=null);this.onBlurWrapper_&&(Blockly.unbindEvent_(this.onBlurWrapper_),this.onBlurWrapper_=null);this.onClickWrapper_&&(Blockly.unbindEvent_(this.onClickWrapper_),this.onClickWrapper_=null);this.onKeydownWrapper_&&(Blockly.unbindEvent_(this.onKeydownWrapper_),this.onKeydownWrapper_=null)};\nBlockly.tree.TreeControl.prototype.handleMouseEvent_=function(a){var b=this.getNodeFromEvent_(a);if(b)switch(a.type){case \"mousedown\":b.onMouseDown(a);break;case \"click\":b.onClick_(a)}};Blockly.tree.TreeControl.prototype.handleKeyEvent_=function(a){var b=!1;if(b=this.selectedItem_&&this.selectedItem_.onKeyDown(a)||b)Blockly.utils.style.scrollIntoContainerView(this.selectedItem_.getElement(),this.getElement().parentNode),a.preventDefault();return b};\nBlockly.tree.TreeControl.prototype.getNodeFromEvent_=function(a){for(var b=a.target;null!=b;){if(a=Blockly.tree.BaseNode.allNodes[b.id])return a;if(b==this.getElement())break;if(b.getAttribute(\"role\")==Blockly.utils.aria.Role.GROUP)break;b=b.parentNode}return null};Blockly.tree.TreeControl.prototype.createNode=function(a){return new Blockly.tree.TreeNode(this.toolbox_,a||\"\",this.config_)};Blockly.Toolbox=function(a){this.workspace_=a;this.RTL=a.options.RTL;this.horizontalLayout_=a.options.horizontalLayout;this.toolboxPosition=a.options.toolboxPosition;this.config_={indentWidth:19,cssRoot:\"blocklyTreeRoot\",cssHideRoot:\"blocklyHidden\",cssTreeRow:\"blocklyTreeRow\",cssItemLabel:\"blocklyTreeLabel\",cssTreeIcon:\"blocklyTreeIcon\",cssExpandedFolderIcon:\"blocklyTreeIconOpen\",cssFileIcon:\"blocklyTreeIconNone\",cssSelectedRow:\"blocklyTreeSelected\"};this.treeSeparatorConfig_={cssTreeRow:\"blocklyTreeSeparator\"};\nthis.horizontalLayout_&&(this.config_.cssTreeRow+=a.RTL?\" blocklyHorizontalTreeRtl\":\" blocklyHorizontalTree\",this.treeSeparatorConfig_.cssTreeRow=\"blocklyTreeSeparatorHorizontal \"+(a.RTL?\"blocklyHorizontalTreeRtl\":\"blocklyHorizontalTree\"),this.config_.cssTreeIcon=\"\");this.flyout_=null};Blockly.Toolbox.prototype.width=0;Blockly.Toolbox.prototype.height=0;Blockly.Toolbox.prototype.selectedOption_=null;Blockly.Toolbox.prototype.lastCategory_=null;\nBlockly.Toolbox.prototype.init=function(){var a=this.workspace_,b=this.workspace_.getParentSvg();this.HtmlDiv=document.createElement(\"div\");this.HtmlDiv.className=\"blocklyToolboxDiv blocklyNonSelectable\";this.HtmlDiv.setAttribute(\"dir\",a.RTL?\"RTL\":\"LTR\");b.parentNode.insertBefore(this.HtmlDiv,b);var c=a.getThemeManager();c.subscribe(this.HtmlDiv,\"toolboxBackgroundColour\",\"background-color\");c.subscribe(this.HtmlDiv,\"toolboxForegroundColour\",\"color\");Blockly.bindEventWithChecks_(this.HtmlDiv,\"mousedown\",\nthis,function(a){Blockly.utils.isRightButton(a)||a.target==this.HtmlDiv?Blockly.hideChaff(!1):Blockly.hideChaff(!0);Blockly.Touch.clearTouchIdentifier()},!1,!0);c=new Blockly.Options({parentWorkspace:a,rtl:a.RTL,oneBasedIndex:a.options.oneBasedIndex,horizontalLayout:a.horizontalLayout,renderer:a.options.renderer,rendererOverrides:a.options.rendererOverrides});c.toolboxPosition=a.options.toolboxPosition;if(a.horizontalLayout){if(!Blockly.HorizontalFlyout)throw Error(\"Missing require for Blockly.HorizontalFlyout\");\nthis.flyout_=new Blockly.HorizontalFlyout(c)}else{if(!Blockly.VerticalFlyout)throw Error(\"Missing require for Blockly.VerticalFlyout\");this.flyout_=new Blockly.VerticalFlyout(c)}if(!this.flyout_)throw Error(\"One of Blockly.VerticalFlyout or Blockly.Horizontal must berequired.\");Blockly.utils.dom.insertAfter(this.flyout_.createDom(\"svg\"),b);this.flyout_.init(a);this.config_.cleardotPath=a.options.pathToMedia+\"1x1.gif\";this.config_.cssCollapsedFolderIcon=\"blocklyTreeIconClosed\"+(a.RTL?\"Rtl\":\"Ltr\");\nthis.renderTree(a.options.languageTree)};\nBlockly.Toolbox.prototype.renderTree=function(a){this.tree_&&(this.tree_.dispose(),this.lastCategory_=null);var b=new Blockly.tree.TreeControl(this,this.config_);this.tree_=b;b.setSelectedItem(null);b.onBeforeSelected(this.handleBeforeTreeSelected_);b.onAfterSelected(this.handleAfterTreeSelected_);var c=null;if(a){this.tree_.blocks=[];this.hasColours_=!1;c=this.syncTrees_(a,this.tree_,this.workspace_.options.pathToMedia);if(this.tree_.blocks.length)throw Error(\"Toolbox cannot have both blocks and categories in the root level.\");this.workspace_.resizeContents()}b.render(this.HtmlDiv);\nc&&b.setSelectedItem(c);this.addColour_();this.position();this.horizontalLayout_&&Blockly.utils.aria.setState(this.tree_.getElement(),Blockly.utils.aria.State.ORIENTATION,\"horizontal\")};Blockly.Toolbox.prototype.handleBeforeTreeSelected_=function(a){if(a==this.tree_)return!1;this.lastCategory_&&(this.lastCategory_.getRowElement().style.backgroundColor=\"\");if(a){var b=a.hexColour||\"#57e\";a.getRowElement().style.backgroundColor=b;this.addColour_(a)}return!0};\nBlockly.Toolbox.prototype.handleAfterTreeSelected_=function(a,b){b&&b.blocks&&b.blocks.length?(this.flyout_.show(b.blocks),this.lastCategory_!=b&&this.flyout_.scrollToStart(),this.workspace_.keyboardAccessibilityMode&&Blockly.navigation.setState(Blockly.navigation.STATE_TOOLBOX)):(this.flyout_.hide(),!this.workspace_.keyboardAccessibilityMode||b instanceof Blockly.Toolbox.TreeSeparator||Blockly.navigation.setState(Blockly.navigation.STATE_WS));a!=b&&a!=this&&(a=new Blockly.Events.Ui(null,\"category\",\na&&a.content,b&&b.content),a.workspaceId=this.workspace_.id,Blockly.Events.fire(a));b&&(this.lastCategory_=b)};Blockly.Toolbox.prototype.handleNodeSizeChanged_=function(){Blockly.svgResize(this.workspace_)};\nBlockly.Toolbox.prototype.onBlocklyAction=function(a){var b=this.tree_.getSelectedItem();if(!b)return!1;switch(a.name){case Blockly.navigation.actionNames.PREVIOUS:return b.selectPrevious();case Blockly.navigation.actionNames.OUT:return b.selectParent();case Blockly.navigation.actionNames.NEXT:return b.selectNext();case Blockly.navigation.actionNames.IN:return b.selectChild();default:return!1}};\nBlockly.Toolbox.prototype.dispose=function(){this.flyout_.dispose();this.tree_.dispose();this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv);Blockly.utils.dom.removeNode(this.HtmlDiv);this.lastCategory_=null};Blockly.Toolbox.prototype.getWidth=function(){return this.width};Blockly.Toolbox.prototype.getHeight=function(){return this.height};Blockly.Toolbox.prototype.getFlyout=function(){return this.flyout_};\nBlockly.Toolbox.prototype.position=function(){var a=this.HtmlDiv;if(a){var b=Blockly.svgSize(this.workspace_.getParentSvg());this.horizontalLayout_?(a.style.left=\"0\",a.style.height=\"auto\",a.style.width=b.width+\"px\",this.height=a.offsetHeight,this.toolboxPosition==Blockly.TOOLBOX_AT_TOP?a.style.top=\"0\":a.style.bottom=\"0\"):(this.toolboxPosition==Blockly.TOOLBOX_AT_RIGHT?a.style.right=\"0\":a.style.left=\"0\",a.style.height=b.height+\"px\",this.width=a.offsetWidth);this.flyout_.position()}};\nBlockly.Toolbox.prototype.syncTrees_=function(a,b,c){for(var d=null,e=null,f=0,g;g=a.childNodes[f];f++)if(g.tagName)switch(g.tagName.toUpperCase()){case \"CATEGORY\":e=Blockly.utils.replaceMessageReferences(g.getAttribute(\"name\"));var h=this.tree_.createNode(e);h.onSizeChanged(this.handleNodeSizeChanged_);h.blocks=[];b.add(h);var k=g.getAttribute(\"custom\");k?h.blocks=k:(k=this.syncTrees_(g,h,c))&&(d=k);k=g.getAttribute(\"categorystyle\");var l=g.getAttribute(\"colour\");l&&k?(h.hexColour=\"\",console.warn('Toolbox category \"'+\ne+'\" can not have both a style and a colour')):k?this.setColourFromStyle_(k,h,e):this.setColour_(l,h,e);\"true\"==g.getAttribute(\"expanded\")?(h.blocks.length&&(d=h),h.setExpanded(!0)):h.setExpanded(!1);e=g;break;case \"SEP\":if(e&&\"CATEGORY\"==e.tagName.toUpperCase()){b.add(new Blockly.Toolbox.TreeSeparator(this.treeSeparatorConfig_));break}case \"BLOCK\":case \"SHADOW\":case \"LABEL\":case \"BUTTON\":b.blocks.push(g),e=g}return d};\nBlockly.Toolbox.prototype.setColour_=function(a,b,c){a=Blockly.utils.replaceMessageReferences(a);if(null===a||\"\"===a)b.hexColour=\"\";else{var d=Number(a);isNaN(d)?(d=Blockly.utils.colour.parse(a))?(b.hexColour=d,this.hasColours_=!0):(b.hexColour=\"\",console.warn('Toolbox category \"'+c+'\" has unrecognized colour attribute: '+a)):(b.hexColour=Blockly.hueToHex(d),this.hasColours_=!0)}};\nBlockly.Toolbox.prototype.setColourFromStyle_=function(a,b,c){b.styleName=a;var d=this.workspace_.getTheme();a&&d&&((d=d.categoryStyles[a])&&d.colour?this.setColour_(d.colour,b,c):console.warn('Style \"'+a+'\" must exist and contain a colour value'))};Blockly.Toolbox.prototype.updateColourFromTheme_=function(a){if(a=a||this.tree_){a=a.getChildren(!1);for(var b=0,c;c=a[b];b++)c.styleName&&(this.setColourFromStyle_(c.styleName,c,\"\"),this.addColour_()),this.updateColourFromTheme_(c)}};\nBlockly.Toolbox.prototype.updateColourFromTheme=function(){var a=this.tree_;a&&(this.updateColourFromTheme_(a),this.updateSelectedItemColour_(a))};Blockly.Toolbox.prototype.updateSelectedItemColour_=function(a){if(a=a.getSelectedItem()){var b=a.hexColour||\"#57e\";a.getRowElement().style.backgroundColor=b;this.addColour_(a)}};\nBlockly.Toolbox.prototype.addColour_=function(a){a=(a||this.tree_).getChildren(!1);for(var b=0,c;c=a[b];b++){var d=c.getRowElement();if(d){var e=this.hasColours_?\"8px solid \"+(c.hexColour||\"#ddd\"):\"none\";this.workspace_.RTL?d.style.borderRight=e:d.style.borderLeft=e}this.addColour_(c)}};Blockly.Toolbox.prototype.clearSelection=function(){this.tree_.setSelectedItem(null)};Blockly.Toolbox.prototype.addStyle=function(a){Blockly.utils.dom.addClass(this.HtmlDiv,a)};\nBlockly.Toolbox.prototype.removeStyle=function(a){Blockly.utils.dom.removeClass(this.HtmlDiv,a)};\nBlockly.Toolbox.prototype.getClientRect=function(){if(!this.HtmlDiv)return null;var a=this.HtmlDiv.getBoundingClientRect(),b=a.top,c=b+a.height,d=a.left;a=d+a.width;return this.toolboxPosition==Blockly.TOOLBOX_AT_TOP?new Blockly.utils.Rect(-1E7,c,-1E7,1E7):this.toolboxPosition==Blockly.TOOLBOX_AT_BOTTOM?new Blockly.utils.Rect(b,1E7,-1E7,1E7):this.toolboxPosition==Blockly.TOOLBOX_AT_LEFT?new Blockly.utils.Rect(-1E7,1E7,-1E7,a):new Blockly.utils.Rect(-1E7,1E7,d,1E7)};\nBlockly.Toolbox.prototype.refreshSelection=function(){var a=this.tree_.getSelectedItem();a&&a.blocks&&this.flyout_.show(a.blocks)};Blockly.Toolbox.prototype.selectFirstCategory=function(){this.tree_.getSelectedItem()||this.tree_.selectChild()};Blockly.Toolbox.TreeSeparator=function(a){Blockly.tree.TreeNode.call(this,null,\"\",a)};Blockly.utils.object.inherits(Blockly.Toolbox.TreeSeparator,Blockly.tree.TreeNode);\nBlockly.Css.register([\".blocklyToolboxDelete {\",'cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;',\"}\",\".blocklyToolboxGrab {\",'cursor: url(\"<<<PATH>>>/handclosed.cur\"), auto;',\"cursor: grabbing;\",\"cursor: -webkit-grabbing;\",\"}\",\".blocklyToolboxDiv {\",\"background-color: #ddd;\",\"overflow-x: visible;\",\"overflow-y: auto;\",\"position: absolute;\",\"z-index: 70;\",\"-webkit-tap-highlight-color: transparent;\",\"}\",\".blocklyTreeRoot {\",\"padding: 4px 0;\",\"}\",\".blocklyTreeRoot:focus {\",\"outline: none;\",\"}\",\".blocklyTreeRow {\",\n\"height: 22px;\",\"line-height: 22px;\",\"margin-bottom: 3px;\",\"padding-right: 8px;\",\"white-space: nowrap;\",\"}\",\".blocklyHorizontalTree {\",\"float: left;\",\"margin: 1px 5px 8px 0;\",\"}\",\".blocklyHorizontalTreeRtl {\",\"float: right;\",\"margin: 1px 0 8px 5px;\",\"}\",'.blocklyToolboxDiv[dir=\"RTL\"] .blocklyTreeRow {',\"margin-left: 8px;\",\"}\",\".blocklyTreeRow:not(.blocklyTreeSelected):hover {\",\"background-color: rgba(255, 255, 255, 0.2);\",\"}\",\".blocklyTreeSeparator {\",\"border-bottom: solid #e5e5e5 1px;\",\"height: 0;\",\n\"margin: 5px 0;\",\"}\",\".blocklyTreeSeparatorHorizontal {\",\"border-right: solid #e5e5e5 1px;\",\"width: 0;\",\"padding: 5px 0;\",\"margin: 0 5px;\",\"}\",\".blocklyTreeIcon {\",\"background-image: url(<<<PATH>>>/sprites.png);\",\"height: 16px;\",\"vertical-align: middle;\",\"width: 16px;\",\"}\",\".blocklyTreeIconClosedLtr {\",\"background-position: -32px -1px;\",\"}\",\".blocklyTreeIconClosedRtl {\",\"background-position: 0 -1px;\",\"}\",\".blocklyTreeIconOpen {\",\"background-position: -16px -1px;\",\"}\",\".blocklyTreeSelected>.blocklyTreeIconClosedLtr {\",\n\"background-position: -32px -17px;\",\"}\",\".blocklyTreeSelected>.blocklyTreeIconClosedRtl {\",\"background-position: 0 -17px;\",\"}\",\".blocklyTreeSelected>.blocklyTreeIconOpen {\",\"background-position: -16px -17px;\",\"}\",\".blocklyTreeIconNone,\",\".blocklyTreeSelected>.blocklyTreeIconNone {\",\"background-position: -48px -1px;\",\"}\",\".blocklyTreeLabel {\",\"cursor: default;\",\"font-family: sans-serif;\",\"font-size: 16px;\",\"padding: 0 3px;\",\"vertical-align: middle;\",\"}\",\".blocklyToolboxDelete .blocklyTreeLabel {\",\n'cursor: url(\"<<<PATH>>>/handdelete.cur\"), auto;',\"}\",\".blocklyTreeSelected .blocklyTreeLabel {\",\"color: #fff;\",\"}\"]);Blockly.Trashcan=function(a){this.workspace_=a;this.contents_=[];this.flyout=null;if(!(0>=this.workspace_.options.maxTrashcanContents)){a=new Blockly.Options({scrollbars:!0,parentWorkspace:this.workspace_,rtl:this.workspace_.RTL,oneBasedIndex:this.workspace_.options.oneBasedIndex,renderer:this.workspace_.options.renderer,rendererOverrides:this.workspace_.options.rendererOverrides});if(this.workspace_.horizontalLayout){a.toolboxPosition=this.workspace_.toolboxPosition==Blockly.TOOLBOX_AT_TOP?Blockly.TOOLBOX_AT_BOTTOM:\nBlockly.TOOLBOX_AT_TOP;if(!Blockly.HorizontalFlyout)throw Error(\"Missing require for Blockly.HorizontalFlyout\");this.flyout=new Blockly.HorizontalFlyout(a)}else{a.toolboxPosition=this.workspace_.toolboxPosition==Blockly.TOOLBOX_AT_RIGHT?Blockly.TOOLBOX_AT_LEFT:Blockly.TOOLBOX_AT_RIGHT;if(!Blockly.VerticalFlyout)throw Error(\"Missing require for Blockly.VerticalFlyout\");this.flyout=new Blockly.VerticalFlyout(a)}this.workspace_.addChangeListener(this.onDelete_.bind(this))}};\nBlockly.Trashcan.prototype.WIDTH_=47;Blockly.Trashcan.prototype.BODY_HEIGHT_=44;Blockly.Trashcan.prototype.LID_HEIGHT_=16;Blockly.Trashcan.prototype.MARGIN_BOTTOM_=20;Blockly.Trashcan.prototype.MARGIN_SIDE_=20;Blockly.Trashcan.prototype.MARGIN_HOTSPOT_=10;Blockly.Trashcan.prototype.SPRITE_LEFT_=0;Blockly.Trashcan.prototype.SPRITE_TOP_=32;Blockly.Trashcan.prototype.HAS_BLOCKS_LID_ANGLE_=.1;Blockly.Trashcan.ANIMATION_LENGTH_=80;Blockly.Trashcan.ANIMATION_FRAMES_=4;Blockly.Trashcan.OPACITY_MIN_=.4;\nBlockly.Trashcan.OPACITY_MAX_=.8;Blockly.Trashcan.MAX_LID_ANGLE_=45;Blockly.Trashcan.prototype.isOpen=!1;Blockly.Trashcan.prototype.minOpenness_=0;Blockly.Trashcan.prototype.svgGroup_=null;Blockly.Trashcan.prototype.svgLid_=null;Blockly.Trashcan.prototype.lidTask_=0;Blockly.Trashcan.prototype.lidOpen_=0;Blockly.Trashcan.prototype.left_=0;Blockly.Trashcan.prototype.top_=0;\nBlockly.Trashcan.prototype.createDom=function(){this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyTrash\"},null);var a=String(Math.random()).substring(2);var b=Blockly.utils.dom.createSvgElement(\"clipPath\",{id:\"blocklyTrashBodyClipPath\"+a},this.svgGroup_);Blockly.utils.dom.createSvgElement(\"rect\",{width:this.WIDTH_,height:this.BODY_HEIGHT_,y:this.LID_HEIGHT_},b);var c=Blockly.utils.dom.createSvgElement(\"image\",{width:Blockly.SPRITE.width,x:-this.SPRITE_LEFT_,height:Blockly.SPRITE.height,\ny:-this.SPRITE_TOP_,\"clip-path\":\"url(#blocklyTrashBodyClipPath\"+a+\")\"},this.svgGroup_);c.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",this.workspace_.options.pathToMedia+Blockly.SPRITE.url);b=Blockly.utils.dom.createSvgElement(\"clipPath\",{id:\"blocklyTrashLidClipPath\"+a},this.svgGroup_);Blockly.utils.dom.createSvgElement(\"rect\",{width:this.WIDTH_,height:this.LID_HEIGHT_},b);this.svgLid_=Blockly.utils.dom.createSvgElement(\"image\",{width:Blockly.SPRITE.width,x:-this.SPRITE_LEFT_,height:Blockly.SPRITE.height,\ny:-this.SPRITE_TOP_,\"clip-path\":\"url(#blocklyTrashLidClipPath\"+a+\")\"},this.svgGroup_);this.svgLid_.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",this.workspace_.options.pathToMedia+Blockly.SPRITE.url);Blockly.bindEventWithChecks_(this.svgGroup_,\"mouseup\",this,this.click);Blockly.bindEvent_(c,\"mouseover\",this,this.mouseOver_);Blockly.bindEvent_(c,\"mouseout\",this,this.mouseOut_);this.animateLid_();return this.svgGroup_};\nBlockly.Trashcan.prototype.init=function(a){0<this.workspace_.options.maxTrashcanContents&&(Blockly.utils.dom.insertAfter(this.flyout.createDom(\"svg\"),this.workspace_.getParentSvg()),this.flyout.init(this.workspace_));this.verticalSpacing_=this.MARGIN_BOTTOM_+a;this.setOpen(!1);return this.verticalSpacing_+this.BODY_HEIGHT_+this.LID_HEIGHT_};\nBlockly.Trashcan.prototype.dispose=function(){this.svgGroup_&&(Blockly.utils.dom.removeNode(this.svgGroup_),this.svgGroup_=null);this.workspace_=this.svgLid_=null;clearTimeout(this.lidTask_)};Blockly.Trashcan.prototype.contentsIsOpen=function(){return this.flyout.isVisible()};Blockly.Trashcan.prototype.emptyContents=function(){this.contents_.length&&(this.contents_.length=0,this.setMinOpenness_(0),this.contentsIsOpen()&&this.flyout.hide())};\nBlockly.Trashcan.prototype.position=function(){if(this.verticalSpacing_){var a=this.workspace_.getMetrics();a&&(this.left_=a.toolboxPosition==Blockly.TOOLBOX_AT_LEFT||this.workspace_.horizontalLayout&&!this.workspace_.RTL?a.viewWidth+a.absoluteLeft-this.WIDTH_-this.MARGIN_SIDE_-Blockly.Scrollbar.scrollbarThickness:this.MARGIN_SIDE_+Blockly.Scrollbar.scrollbarThickness,this.top_=a.toolboxPosition==Blockly.TOOLBOX_AT_BOTTOM?this.verticalSpacing_:a.viewHeight+a.absoluteTop-(this.BODY_HEIGHT_+this.LID_HEIGHT_)-\nthis.verticalSpacing_,this.svgGroup_.setAttribute(\"transform\",\"translate(\"+this.left_+\",\"+this.top_+\")\"))}};Blockly.Trashcan.prototype.getClientRect=function(){if(!this.svgGroup_)return null;var a=this.svgGroup_.getBoundingClientRect(),b=a.top+this.SPRITE_TOP_-this.MARGIN_HOTSPOT_;a=a.left+this.SPRITE_LEFT_-this.MARGIN_HOTSPOT_;return new Blockly.utils.Rect(b,b+this.LID_HEIGHT_+this.BODY_HEIGHT_+2*this.MARGIN_HOTSPOT_,a,a+this.WIDTH_+2*this.MARGIN_HOTSPOT_)};\nBlockly.Trashcan.prototype.setOpen=function(a){this.isOpen!=a&&(clearTimeout(this.lidTask_),this.isOpen=a,this.animateLid_())};\nBlockly.Trashcan.prototype.animateLid_=function(){var a=Blockly.Trashcan.ANIMATION_FRAMES_,b=1/(a+1);this.lidOpen_+=this.isOpen?b:-b;this.lidOpen_=Math.min(Math.max(this.lidOpen_,this.minOpenness_),1);this.setLidAngle_(this.lidOpen_*Blockly.Trashcan.MAX_LID_ANGLE_);b=Blockly.Trashcan.OPACITY_MIN_;this.svgGroup_.style.opacity=b+this.lidOpen_*(Blockly.Trashcan.OPACITY_MAX_-b);this.lidOpen_>this.minOpenness_&&1>this.lidOpen_&&(this.lidTask_=setTimeout(this.animateLid_.bind(this),Blockly.Trashcan.ANIMATION_LENGTH_/\na))};Blockly.Trashcan.prototype.setLidAngle_=function(a){var b=this.workspace_.toolboxPosition==Blockly.TOOLBOX_AT_RIGHT||this.workspace_.horizontalLayout&&this.workspace_.RTL;this.svgLid_.setAttribute(\"transform\",\"rotate(\"+(b?-a:a)+\",\"+(b?4:this.WIDTH_-4)+\",\"+(this.LID_HEIGHT_-2)+\")\")};Blockly.Trashcan.prototype.setMinOpenness_=function(a){this.minOpenness_=a;this.isOpen||this.setLidAngle_(a*Blockly.Trashcan.MAX_LID_ANGLE_)};Blockly.Trashcan.prototype.close=function(){this.setOpen(!1)};\nBlockly.Trashcan.prototype.click=function(){if(this.contents_.length){for(var a=[],b=0,c;c=this.contents_[b];b++)a[b]=Blockly.Xml.textToDom(c);this.flyout.show(a)}};Blockly.Trashcan.prototype.mouseOver_=function(){this.contents_.length&&this.setOpen(!0)};Blockly.Trashcan.prototype.mouseOut_=function(){this.setOpen(!1)};\nBlockly.Trashcan.prototype.onDelete_=function(a){if(!(0>=this.workspace_.options.maxTrashcanContents)&&a.type==Blockly.Events.BLOCK_DELETE&&\"shadow\"!=a.oldXml.tagName.toLowerCase()&&(a=this.cleanBlockXML_(a.oldXml),-1==this.contents_.indexOf(a))){for(this.contents_.unshift(a);this.contents_.length>this.workspace_.options.maxTrashcanContents;)this.contents_.pop();this.setMinOpenness_(this.HAS_BLOCKS_LID_ANGLE_)}};\nBlockly.Trashcan.prototype.cleanBlockXML_=function(a){for(var b=a=a.cloneNode(!0);b;){b.removeAttribute&&(b.removeAttribute(\"x\"),b.removeAttribute(\"y\"),b.removeAttribute(\"id\"),b.removeAttribute(\"disabled\"),\"comment\"==b.nodeName&&(b.removeAttribute(\"h\"),b.removeAttribute(\"w\"),b.removeAttribute(\"pinned\")));var c=b.firstChild||b.nextSibling;if(!c)for(c=b.parentNode;c;){if(c.nextSibling){c=c.nextSibling;break}c=c.parentNode}b=c}return Blockly.Xml.domToText(a)};Blockly.VariablesDynamic={};Blockly.VariablesDynamic.onCreateVariableButtonClick_String=function(a){Blockly.Variables.createVariableButtonHandler(a.getTargetWorkspace(),void 0,\"String\")};Blockly.VariablesDynamic.onCreateVariableButtonClick_Number=function(a){Blockly.Variables.createVariableButtonHandler(a.getTargetWorkspace(),void 0,\"Number\")};Blockly.VariablesDynamic.onCreateVariableButtonClick_Colour=function(a){Blockly.Variables.createVariableButtonHandler(a.getTargetWorkspace(),void 0,\"Colour\")};\nBlockly.VariablesDynamic.flyoutCategory=function(a){var b=[],c=document.createElement(\"button\");c.setAttribute(\"text\",Blockly.Msg.NEW_STRING_VARIABLE);c.setAttribute(\"callbackKey\",\"CREATE_VARIABLE_STRING\");b.push(c);c=document.createElement(\"button\");c.setAttribute(\"text\",Blockly.Msg.NEW_NUMBER_VARIABLE);c.setAttribute(\"callbackKey\",\"CREATE_VARIABLE_NUMBER\");b.push(c);c=document.createElement(\"button\");c.setAttribute(\"text\",Blockly.Msg.NEW_COLOUR_VARIABLE);c.setAttribute(\"callbackKey\",\"CREATE_VARIABLE_COLOUR\");\nb.push(c);a.registerButtonCallback(\"CREATE_VARIABLE_STRING\",Blockly.VariablesDynamic.onCreateVariableButtonClick_String);a.registerButtonCallback(\"CREATE_VARIABLE_NUMBER\",Blockly.VariablesDynamic.onCreateVariableButtonClick_Number);a.registerButtonCallback(\"CREATE_VARIABLE_COLOUR\",Blockly.VariablesDynamic.onCreateVariableButtonClick_Colour);a=Blockly.VariablesDynamic.flyoutCategoryBlocks(a);return b=b.concat(a)};\nBlockly.VariablesDynamic.flyoutCategoryBlocks=function(a){a=a.getAllVariables();var b=[];if(0<a.length){if(Blockly.Blocks.variables_set_dynamic){var c=a[a.length-1],d=Blockly.utils.xml.createElement(\"block\");d.setAttribute(\"type\",\"variables_set_dynamic\");d.setAttribute(\"gap\",24);d.appendChild(Blockly.Variables.generateVariableFieldDom(c));b.push(d)}if(Blockly.Blocks.variables_get_dynamic){a.sort(Blockly.VariableModel.compareByName);c=0;for(var e;e=a[c];c++)d=Blockly.utils.xml.createElement(\"block\"),\nd.setAttribute(\"type\",\"variables_get_dynamic\"),d.setAttribute(\"gap\",8),d.appendChild(Blockly.Variables.generateVariableFieldDom(e)),b.push(d)}}return b};Blockly.ZoomControls=function(a){this.workspace_=a};Blockly.ZoomControls.prototype.WIDTH_=32;Blockly.ZoomControls.prototype.HEIGHT_=110;Blockly.ZoomControls.prototype.MARGIN_BOTTOM_=20;Blockly.ZoomControls.prototype.MARGIN_SIDE_=20;Blockly.ZoomControls.prototype.svgGroup_=null;Blockly.ZoomControls.prototype.left_=0;Blockly.ZoomControls.prototype.top_=0;\nBlockly.ZoomControls.prototype.createDom=function(){this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{},null);var a=String(Math.random()).substring(2);this.createZoomOutSvg_(a);this.createZoomInSvg_(a);this.workspace_.isMovable()&&this.createZoomResetSvg_(a);return this.svgGroup_};Blockly.ZoomControls.prototype.init=function(a){this.verticalSpacing_=this.MARGIN_BOTTOM_+a;return this.verticalSpacing_+this.HEIGHT_};Blockly.ZoomControls.prototype.dispose=function(){this.svgGroup_&&Blockly.utils.dom.removeNode(this.svgGroup_)};\nBlockly.ZoomControls.prototype.position=function(){if(this.verticalSpacing_){var a=this.workspace_.getMetrics();a&&(this.left_=a.toolboxPosition==Blockly.TOOLBOX_AT_LEFT||this.workspace_.horizontalLayout&&!this.workspace_.RTL?a.viewWidth+a.absoluteLeft-this.WIDTH_-this.MARGIN_SIDE_-Blockly.Scrollbar.scrollbarThickness:this.MARGIN_SIDE_+Blockly.Scrollbar.scrollbarThickness,a.toolboxPosition==Blockly.TOOLBOX_AT_BOTTOM?(this.top_=this.verticalSpacing_,this.zoomInGroup_.setAttribute(\"transform\",\"translate(0, 34)\"),\nthis.zoomResetGroup_&&this.zoomResetGroup_.setAttribute(\"transform\",\"translate(0, 77)\")):(this.top_=a.viewHeight+a.absoluteTop-this.HEIGHT_-this.verticalSpacing_,this.zoomInGroup_.setAttribute(\"transform\",\"translate(0, 43)\"),this.zoomOutGroup_.setAttribute(\"transform\",\"translate(0, 77)\")),this.svgGroup_.setAttribute(\"transform\",\"translate(\"+this.left_+\",\"+this.top_+\")\"))}};\nBlockly.ZoomControls.prototype.createZoomOutSvg_=function(a){var b=this.workspace_;this.zoomOutGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyZoom\"},this.svgGroup_);var c=Blockly.utils.dom.createSvgElement(\"clipPath\",{id:\"blocklyZoomoutClipPath\"+a},this.zoomOutGroup_);Blockly.utils.dom.createSvgElement(\"rect\",{width:32,height:32},c);a=Blockly.utils.dom.createSvgElement(\"image\",{width:Blockly.SPRITE.width,height:Blockly.SPRITE.height,x:-64,y:-92,\"clip-path\":\"url(#blocklyZoomoutClipPath\"+\na+\")\"},this.zoomOutGroup_);a.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",b.options.pathToMedia+Blockly.SPRITE.url);Blockly.bindEventWithChecks_(a,\"mousedown\",null,function(a){b.markFocused();b.zoomCenter(-1);Blockly.Touch.clearTouchIdentifier();a.stopPropagation();a.preventDefault()})};\nBlockly.ZoomControls.prototype.createZoomInSvg_=function(a){var b=this.workspace_;this.zoomInGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyZoom\"},this.svgGroup_);var c=Blockly.utils.dom.createSvgElement(\"clipPath\",{id:\"blocklyZoominClipPath\"+a},this.zoomInGroup_);Blockly.utils.dom.createSvgElement(\"rect\",{width:32,height:32},c);a=Blockly.utils.dom.createSvgElement(\"image\",{width:Blockly.SPRITE.width,height:Blockly.SPRITE.height,x:-32,y:-92,\"clip-path\":\"url(#blocklyZoominClipPath\"+\na+\")\"},this.zoomInGroup_);a.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",b.options.pathToMedia+Blockly.SPRITE.url);Blockly.bindEventWithChecks_(a,\"mousedown\",null,function(a){b.markFocused();b.zoomCenter(1);Blockly.Touch.clearTouchIdentifier();a.stopPropagation();a.preventDefault()})};\nBlockly.ZoomControls.prototype.createZoomResetSvg_=function(a){var b=this.workspace_;this.zoomResetGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyZoom\"},this.svgGroup_);var c=Blockly.utils.dom.createSvgElement(\"clipPath\",{id:\"blocklyZoomresetClipPath\"+a},this.zoomResetGroup_);Blockly.utils.dom.createSvgElement(\"rect\",{width:32,height:32},c);a=Blockly.utils.dom.createSvgElement(\"image\",{width:Blockly.SPRITE.width,height:Blockly.SPRITE.height,y:-92,\"clip-path\":\"url(#blocklyZoomresetClipPath\"+\na+\")\"},this.zoomResetGroup_);a.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",b.options.pathToMedia+Blockly.SPRITE.url);Blockly.bindEventWithChecks_(a,\"mousedown\",null,function(a){b.markFocused();b.setScale(b.options.zoomOptions.startScale);b.beginCanvasTransition();b.scrollCenter();setTimeout(b.endCanvasTransition.bind(b),500);Blockly.Touch.clearTouchIdentifier();a.stopPropagation();a.preventDefault()})};\nBlockly.Css.register([\".blocklyZoom>image, .blocklyZoom>svg>image {\",\"opacity: .4;\",\"}\",\".blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {\",\"opacity: .6;\",\"}\",\".blocklyZoom>image:active, .blocklyZoom>svg>image:active {\",\"opacity: .8;\",\"}\"]);Blockly.Mutator=function(a){Blockly.Mutator.superClass_.constructor.call(this,null);this.quarkNames_=a};Blockly.utils.object.inherits(Blockly.Mutator,Blockly.Icon);Blockly.Mutator.prototype.workspaceWidth_=0;Blockly.Mutator.prototype.workspaceHeight_=0;Blockly.Mutator.prototype.setBlock=function(a){this.block_=a};Blockly.Mutator.prototype.getWorkspace=function(){return this.workspace_};\nBlockly.Mutator.prototype.drawIcon_=function(a){Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyIconShape\",rx:\"4\",ry:\"4\",height:\"16\",width:\"16\"},a);Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyIconSymbol\",d:\"m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 -0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z\"},\na);Blockly.utils.dom.createSvgElement(\"circle\",{\"class\":\"blocklyIconShape\",r:\"2.7\",cx:\"8\",cy:\"8\"},a)};Blockly.Mutator.prototype.iconClick_=function(a){this.block_.isEditable()&&Blockly.Icon.prototype.iconClick_.call(this,a)};\nBlockly.Mutator.prototype.createEditor_=function(){this.svgDialog_=Blockly.utils.dom.createSvgElement(\"svg\",{x:Blockly.Bubble.BORDER_WIDTH,y:Blockly.Bubble.BORDER_WIDTH},null);if(this.quarkNames_.length)for(var a=Blockly.utils.xml.createElement(\"xml\"),b=0,c;c=this.quarkNames_[b];b++){var d=Blockly.utils.xml.createElement(\"block\");d.setAttribute(\"type\",c);a.appendChild(d)}else a=null;b=new Blockly.Options({disable:!1,parentWorkspace:this.block_.workspace,media:this.block_.workspace.options.pathToMedia,\nrtl:this.block_.RTL,horizontalLayout:!1,renderer:this.block_.workspace.options.renderer,rendererOverrides:this.block_.workspace.options.rendererOverrides});b.toolboxPosition=this.block_.RTL?Blockly.TOOLBOX_AT_RIGHT:Blockly.TOOLBOX_AT_LEFT;b.languageTree=a;b.getMetrics=this.getFlyoutMetrics_.bind(this);this.workspace_=new Blockly.WorkspaceSvg(b);this.workspace_.isMutator=!0;this.workspace_.addChangeListener(Blockly.Events.disableOrphans);a=this.workspace_.addFlyout(\"g\");b=this.workspace_.createDom(\"blocklyMutatorBackground\");\nb.insertBefore(a,this.workspace_.svgBlockCanvas_);this.svgDialog_.appendChild(b);return this.svgDialog_};Blockly.Mutator.prototype.updateEditable=function(){Blockly.Mutator.superClass_.updateEditable.call(this);this.block_.isInFlyout||(this.block_.isEditable()?this.iconGroup_&&Blockly.utils.dom.removeClass(this.iconGroup_,\"blocklyIconGroupReadonly\"):(this.setVisible(!1),this.iconGroup_&&Blockly.utils.dom.addClass(this.iconGroup_,\"blocklyIconGroupReadonly\")))};\nBlockly.Mutator.prototype.resizeBubble_=function(){var a=2*Blockly.Bubble.BORDER_WIDTH,b=this.workspace_.getCanvas().getBBox();var c=this.block_.RTL?-b.x:b.width+b.x;b=b.height+3*a;var d=this.workspace_.getFlyout();d&&(d=d.getMetrics_(),b=Math.max(b,d.contentHeight+20));c+=3*a;if(Math.abs(this.workspaceWidth_-c)>a||Math.abs(this.workspaceHeight_-b)>a)this.workspaceWidth_=c,this.workspaceHeight_=b,this.bubble_.setBubbleSize(c+a,b+a),this.svgDialog_.setAttribute(\"width\",this.workspaceWidth_),this.svgDialog_.setAttribute(\"height\",\nthis.workspaceHeight_);this.block_.RTL&&(a=\"translate(\"+this.workspaceWidth_+\",0)\",this.workspace_.getCanvas().setAttribute(\"transform\",a));this.workspace_.resize()};Blockly.Mutator.prototype.onBubbleMove_=function(){this.workspace_&&this.workspace_.recordDeleteAreas()};\nBlockly.Mutator.prototype.setVisible=function(a){if(a!=this.isVisible())if(Blockly.Events.fire(new Blockly.Events.Ui(this.block_,\"mutatorOpen\",!a,a)),a){this.bubble_=new Blockly.Bubble(this.block_.workspace,this.createEditor_(),this.block_.pathObject.svgPath,this.iconXY_,null,null);this.bubble_.setSvgId(this.block_.id);this.bubble_.registerMoveEvent(this.onBubbleMove_.bind(this));var b=this.workspace_.options.languageTree;a=this.workspace_.getFlyout();b&&(a.init(this.workspace_),a.show(b.childNodes));\nthis.rootBlock_=this.block_.decompose(this.workspace_);b=this.rootBlock_.getDescendants(!1);for(var c=0,d;d=b[c];c++)d.render();this.rootBlock_.setMovable(!1);this.rootBlock_.setDeletable(!1);a?(b=2*a.CORNER_RADIUS,a=a.getWidth()+b):a=b=16;this.block_.RTL&&(a=-a);this.rootBlock_.moveBy(a,b);if(this.block_.saveConnections){var e=this,f=this.block_;f.saveConnections(this.rootBlock_);this.sourceListener_=function(){f.saveConnections(e.rootBlock_)};this.block_.workspace.addChangeListener(this.sourceListener_)}this.resizeBubble_();\nthis.workspace_.addChangeListener(this.workspaceChanged_.bind(this));this.applyColour()}else this.svgDialog_=null,this.workspace_.dispose(),this.rootBlock_=this.workspace_=null,this.bubble_.dispose(),this.bubble_=null,this.workspaceHeight_=this.workspaceWidth_=0,this.sourceListener_&&(this.block_.workspace.removeChangeListener(this.sourceListener_),this.sourceListener_=null)};\nBlockly.Mutator.prototype.workspaceChanged_=function(a){if(a.type!=Blockly.Events.UI&&(a.type!=Blockly.Events.CHANGE||\"disabled\"!=a.element)){if(!this.workspace_.isDragging()){a=this.workspace_.getTopBlocks(!1);for(var b=0,c;c=a[b];b++){var d=c.getRelativeToSurfaceXY(),e=c.getHeightWidth();20>d.y+e.height&&c.moveBy(0,20-e.height-d.y)}}if(this.rootBlock_.workspace==this.workspace_){Blockly.Events.setGroup(!0);c=this.block_;a=(a=c.mutationToDom())&&Blockly.Xml.domToText(a);c.compose(this.rootBlock_);\nc.initSvg();c.render();Blockly.getMainWorkspace().keyboardAccessibilityMode&&Blockly.navigation.moveCursorOnBlockMutation(c);b=(b=c.mutationToDom())&&Blockly.Xml.domToText(b);if(a!=b){Blockly.Events.fire(new Blockly.Events.BlockChange(c,\"mutation\",null,a,b));var f=Blockly.Events.getGroup();setTimeout(function(){Blockly.Events.setGroup(f);c.bumpNeighbours();Blockly.Events.setGroup(!1)},Blockly.BUMP_DELAY)}this.workspace_.isDragging()||this.resizeBubble_();Blockly.Events.setGroup(!1)}}};\nBlockly.Mutator.prototype.getFlyoutMetrics_=function(){return{viewHeight:this.workspaceHeight_,viewWidth:this.workspaceWidth_-this.workspace_.getFlyout().getWidth(),absoluteTop:0,absoluteLeft:this.workspace_.RTL?0:this.workspace_.getFlyout().getWidth()}};Blockly.Mutator.prototype.dispose=function(){this.block_.mutator=null;Blockly.Icon.prototype.dispose.call(this)};\nBlockly.Mutator.prototype.updateBlockStyle=function(){var a=this.workspace_;if(a&&a.getAllBlocks(!1)){for(var b=a.getAllBlocks(!1),c=0;c<b.length;c++){var d=b[c];d.setStyle(d.getStyleName())}a=a.getFlyout().workspace_.getAllBlocks(!1);for(c=0;c<a.length;c++)d=a[c],d.setStyle(d.getStyleName())}};\nBlockly.Mutator.reconnect=function(a,b,c){if(!a||!a.getSourceBlock().workspace)return!1;c=b.getInput(c).connection;var d=a.targetBlock();return d&&d!=b||c.targetConnection==a?!1:(c.isConnected()&&c.disconnect(),c.connect(a),!0)};Blockly.Mutator.findParentWs=function(a){var b=null;if(a&&a.options){var c=a.options.parentWorkspace;a.isFlyout?c&&c.options&&(b=c.options.parentWorkspace):c&&(b=c)}return b};Blockly.FieldTextInput=function(a,b,c){this.spellcheck_=!0;null==a&&(a=\"\");Blockly.FieldTextInput.superClass_.constructor.call(this,a,b,c);this.onKeyInputWrapper_=this.onKeyDownWrapper_=this.htmlInput_=null;this.fullBlockClickTarget_=!1};Blockly.utils.object.inherits(Blockly.FieldTextInput,Blockly.Field);Blockly.FieldTextInput.fromJson=function(a){var b=Blockly.utils.replaceMessageReferences(a.text);return new Blockly.FieldTextInput(b,void 0,a)};Blockly.FieldTextInput.prototype.SERIALIZABLE=!0;\nBlockly.FieldTextInput.BORDERRADIUS=4;Blockly.FieldTextInput.prototype.CURSOR=\"text\";Blockly.FieldTextInput.prototype.configure_=function(a){Blockly.FieldTextInput.superClass_.configure_.call(this,a);\"boolean\"==typeof a.spellcheck&&(this.spellcheck_=a.spellcheck)};\nBlockly.FieldTextInput.prototype.initView=function(){if(this.getConstants().FULL_BLOCK_FIELDS){for(var a=0,b=0,c=0,d;d=this.sourceBlock_.inputList[c];c++){for(var e=0;d.fieldRow[e];e++)a++;d.connection&&b++}this.fullBlockClickTarget_=1>=a&&this.sourceBlock_.outputConnection&&!b}else this.fullBlockClickTarget_=!1;this.fullBlockClickTarget_?this.clickTarget_=this.sourceBlock_.getSvgRoot():this.createBorderRect_();this.createTextElement_()};\nBlockly.FieldTextInput.prototype.doClassValidation_=function(a){return null===a||void 0===a?null:String(a)};Blockly.FieldTextInput.prototype.doValueInvalid_=function(a){this.isBeingEdited_&&(this.isTextValid_=!1,a=this.value_,this.value_=this.htmlInput_.untypedDefaultValue_,this.sourceBlock_&&Blockly.Events.isEnabled()&&Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_,\"field\",this.name||null,a,this.value_)))};\nBlockly.FieldTextInput.prototype.doValueUpdate_=function(a){this.isTextValid_=!0;this.value_=a;this.isBeingEdited_||(this.isDirty_=!0)};Blockly.FieldTextInput.prototype.applyColour=function(){this.sourceBlock_&&this.getConstants().FULL_BLOCK_FIELDS&&(this.borderRect_?this.borderRect_.setAttribute(\"stroke\",this.sourceBlock_.style.colourTertiary):this.sourceBlock_.pathObject.svgPath.setAttribute(\"fill\",this.getConstants().FIELD_BORDER_RECT_COLOUR))};\nBlockly.FieldTextInput.prototype.render_=function(){Blockly.FieldTextInput.superClass_.render_.call(this);if(this.isBeingEdited_){this.resizeEditor_();var a=this.htmlInput_;this.isTextValid_?(Blockly.utils.dom.removeClass(a,\"blocklyInvalidInput\"),Blockly.utils.aria.setState(a,Blockly.utils.aria.State.INVALID,!1)):(Blockly.utils.dom.addClass(a,\"blocklyInvalidInput\"),Blockly.utils.aria.setState(a,Blockly.utils.aria.State.INVALID,!0))}};\nBlockly.FieldTextInput.prototype.setSpellcheck=function(a){a!=this.spellcheck_&&(this.spellcheck_=a,this.htmlInput_&&this.htmlInput_.setAttribute(\"spellcheck\",this.spellcheck_))};Blockly.FieldTextInput.prototype.showEditor_=function(a,b){this.workspace_=this.sourceBlock_.workspace;a=b||!1;!a&&(Blockly.utils.userAgent.MOBILE||Blockly.utils.userAgent.ANDROID||Blockly.utils.userAgent.IPAD)?this.showPromptEditor_():this.showInlineEditor_(a)};\nBlockly.FieldTextInput.prototype.showPromptEditor_=function(){var a=this;Blockly.prompt(Blockly.Msg.CHANGE_VALUE_TITLE,this.getText(),function(b){a.setValue(b)})};Blockly.FieldTextInput.prototype.showInlineEditor_=function(a){Blockly.WidgetDiv.show(this,this.sourceBlock_.RTL,this.widgetDispose_.bind(this));this.htmlInput_=this.widgetCreate_();this.isBeingEdited_=!0;a||(this.htmlInput_.focus({preventScroll:!0}),this.htmlInput_.select())};\nBlockly.FieldTextInput.prototype.widgetCreate_=function(){var a=Blockly.WidgetDiv.DIV;Blockly.utils.dom.addClass(this.getClickTarget_(),\"editing\");var b=document.createElement(\"input\");b.className=\"blocklyHtmlInput\";b.setAttribute(\"spellcheck\",this.spellcheck_);var c=this.workspace_.getScale(),d=this.getConstants().FIELD_TEXT_FONTSIZE*c+\"pt\";a.style.fontSize=d;b.style.fontSize=d;d=Blockly.FieldTextInput.BORDERRADIUS*c+\"px\";if(this.fullBlockClickTarget_){d=this.getScaledBBox();d=(d.bottom-d.top)/2+\n\"px\";var e=this.sourceBlock_.getParent()?this.sourceBlock_.getParent().style.colourTertiary:this.sourceBlock_.style.colourTertiary;b.style.border=1*c+\"px solid \"+e;a.style.borderRadius=d;a.style.transition=\"box-shadow 0.25s ease 0s\";this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW&&(a.style.boxShadow=\"rgba(255, 255, 255, 0.3) 0px 0px 0px \"+4*c+\"px\")}b.style.borderRadius=d;a.appendChild(b);b.value=b.defaultValue=this.getEditorText_(this.value_);b.untypedDefaultValue_=this.value_;b.oldValue_=null;this.resizeEditor_();\nthis.bindInputEvents_(b);return b};Blockly.FieldTextInput.prototype.widgetDispose_=function(){this.isBeingEdited_=!1;this.isTextValid_=!0;this.forceRerender();if(this.onFinishEditing_)this.onFinishEditing_(this.value_);this.unbindInputEvents_();var a=Blockly.WidgetDiv.DIV.style;a.width=\"auto\";a.height=\"auto\";a.fontSize=\"\";a.transition=\"\";a.boxShadow=\"\";this.htmlInput_=null;Blockly.utils.dom.removeClass(this.getClickTarget_(),\"editing\")};\nBlockly.FieldTextInput.prototype.bindInputEvents_=function(a){this.onKeyDownWrapper_=Blockly.bindEventWithChecks_(a,\"keydown\",this,this.onHtmlInputKeyDown_);this.onKeyInputWrapper_=Blockly.bindEventWithChecks_(a,\"input\",this,this.onHtmlInputChange_)};\nBlockly.FieldTextInput.prototype.unbindInputEvents_=function(){this.onKeyDownWrapper_&&(Blockly.unbindEvent_(this.onKeyDownWrapper_),this.onKeyDownWrapper_=null);this.onKeyInputWrapper_&&(Blockly.unbindEvent_(this.onKeyInputWrapper_),this.onKeyInputWrapper_=null)};\nBlockly.FieldTextInput.prototype.onHtmlInputKeyDown_=function(a){a.keyCode==Blockly.utils.KeyCodes.ENTER?(Blockly.WidgetDiv.hide(),Blockly.DropDownDiv.hideWithoutAnimation()):a.keyCode==Blockly.utils.KeyCodes.ESC?(this.htmlInput_.value=this.htmlInput_.defaultValue,Blockly.WidgetDiv.hide(),Blockly.DropDownDiv.hideWithoutAnimation()):a.keyCode==Blockly.utils.KeyCodes.TAB&&(Blockly.WidgetDiv.hide(),Blockly.DropDownDiv.hideWithoutAnimation(),this.sourceBlock_.tab(this,!a.shiftKey),a.preventDefault())};\nBlockly.FieldTextInput.prototype.onHtmlInputChange_=function(a){a=this.htmlInput_.value;a!==this.htmlInput_.oldValue_&&(this.htmlInput_.oldValue_=a,Blockly.Events.setGroup(!0),a=this.getValueFromEditorText_(a),this.setValue(a),this.forceRerender(),this.resizeEditor_(),Blockly.Events.setGroup(!1))};Blockly.FieldTextInput.prototype.setEditorValue_=function(a){this.isDirty_=!0;this.isBeingEdited_&&(this.htmlInput_.value=this.getEditorText_(a));this.setValue(a)};\nBlockly.FieldTextInput.prototype.resizeEditor_=function(){var a=Blockly.WidgetDiv.DIV,b=this.getScaledBBox();a.style.width=b.right-b.left+\"px\";a.style.height=b.bottom-b.top+\"px\";b=new Blockly.utils.Coordinate(this.sourceBlock_.RTL?b.right-a.offsetWidth:b.left,b.top);a.style.left=b.x+\"px\";a.style.top=b.y+\"px\"};\nBlockly.FieldTextInput.numberValidator=function(a){console.warn(\"Blockly.FieldTextInput.numberValidator is deprecated. Use Blockly.FieldNumber instead.\");if(null===a)return null;a=String(a);a=a.replace(/O/ig,\"0\");a=a.replace(/,/g,\"\");a=Number(a||0);return isNaN(a)?null:String(a)};Blockly.FieldTextInput.nonnegativeIntegerValidator=function(a){(a=Blockly.FieldTextInput.numberValidator(a))&&(a=String(Math.max(0,Math.floor(a))));return a};Blockly.FieldTextInput.prototype.isTabNavigable=function(){return!0};\nBlockly.FieldTextInput.prototype.getText_=function(){return this.isBeingEdited_&&this.htmlInput_?this.htmlInput_.value:null};Blockly.FieldTextInput.prototype.getEditorText_=function(a){return String(a)};Blockly.FieldTextInput.prototype.getValueFromEditorText_=function(a){return a};Blockly.fieldRegistry.register(\"field_input\",Blockly.FieldTextInput);Blockly.FieldAngle=function(a,b,c){this.clockwise_=Blockly.FieldAngle.CLOCKWISE;this.offset_=Blockly.FieldAngle.OFFSET;this.wrap_=Blockly.FieldAngle.WRAP;this.round_=Blockly.FieldAngle.ROUND;Blockly.FieldAngle.superClass_.constructor.call(this,a||0,b,c);this.moveSurfaceWrapper_=this.clickSurfaceWrapper_=this.clickWrapper_=this.line_=this.gauge_=null};Blockly.utils.object.inherits(Blockly.FieldAngle,Blockly.FieldTextInput);\nBlockly.FieldAngle.fromJson=function(a){return new Blockly.FieldAngle(a.angle,void 0,a)};Blockly.FieldAngle.prototype.SERIALIZABLE=!0;Blockly.FieldAngle.ROUND=15;Blockly.FieldAngle.HALF=50;Blockly.FieldAngle.CLOCKWISE=!1;Blockly.FieldAngle.OFFSET=0;Blockly.FieldAngle.WRAP=360;Blockly.FieldAngle.RADIUS=Blockly.FieldAngle.HALF-1;\nBlockly.FieldAngle.prototype.configure_=function(a){Blockly.FieldAngle.superClass_.configure_.call(this,a);switch(a.mode){case \"compass\":this.clockwise_=!0;this.offset_=90;break;case \"protractor\":this.clockwise_=!1,this.offset_=0}var b=a.clockwise;\"boolean\"==typeof b&&(this.clockwise_=b);b=a.offset;null!=b&&(b=Number(b),isNaN(b)||(this.offset_=b));b=a.wrap;null!=b&&(b=Number(b),isNaN(b)||(this.wrap_=b));a=a.round;null!=a&&(a=Number(a),isNaN(a)||(this.round_=a))};\nBlockly.FieldAngle.prototype.initView=function(){Blockly.FieldAngle.superClass_.initView.call(this);this.symbol_=Blockly.utils.dom.createSvgElement(\"tspan\",{},null);this.symbol_.appendChild(document.createTextNode(\"\\u00b0\"));this.textElement_.appendChild(this.symbol_)};Blockly.FieldAngle.prototype.render_=function(){Blockly.FieldAngle.superClass_.render_.call(this);this.updateGraph_()};\nBlockly.FieldAngle.prototype.showEditor_=function(a){Blockly.FieldAngle.superClass_.showEditor_.call(this,a,Blockly.utils.userAgent.MOBILE||Blockly.utils.userAgent.ANDROID||Blockly.utils.userAgent.IPAD);a=this.dropdownCreate_();Blockly.DropDownDiv.getContentDiv().appendChild(a);Blockly.DropDownDiv.setColour(this.sourceBlock_.style.colourPrimary,this.sourceBlock_.style.colourTertiary);Blockly.DropDownDiv.showPositionedByField(this,this.dropdownDispose_.bind(this));this.updateGraph_()};\nBlockly.FieldAngle.prototype.dropdownCreate_=function(){var a=Blockly.utils.dom.createSvgElement(\"svg\",{xmlns:Blockly.utils.dom.SVG_NS,\"xmlns:html\":Blockly.utils.dom.HTML_NS,\"xmlns:xlink\":Blockly.utils.dom.XLINK_NS,version:\"1.1\",height:2*Blockly.FieldAngle.HALF+\"px\",width:2*Blockly.FieldAngle.HALF+\"px\",style:\"touch-action: none\"},null),b=Blockly.utils.dom.createSvgElement(\"circle\",{cx:Blockly.FieldAngle.HALF,cy:Blockly.FieldAngle.HALF,r:Blockly.FieldAngle.RADIUS,\"class\":\"blocklyAngleCircle\"},a);this.gauge_=\nBlockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyAngleGauge\"},a);this.line_=Blockly.utils.dom.createSvgElement(\"line\",{x1:Blockly.FieldAngle.HALF,y1:Blockly.FieldAngle.HALF,\"class\":\"blocklyAngleLine\"},a);for(var c=0;360>c;c+=15)Blockly.utils.dom.createSvgElement(\"line\",{x1:Blockly.FieldAngle.HALF+Blockly.FieldAngle.RADIUS,y1:Blockly.FieldAngle.HALF,x2:Blockly.FieldAngle.HALF+Blockly.FieldAngle.RADIUS-(0==c%45?10:5),y2:Blockly.FieldAngle.HALF,\"class\":\"blocklyAngleMarks\",transform:\"rotate(\"+\nc+\",\"+Blockly.FieldAngle.HALF+\",\"+Blockly.FieldAngle.HALF+\")\"},a);this.clickWrapper_=Blockly.bindEventWithChecks_(a,\"click\",this,this.hide_);this.clickSurfaceWrapper_=Blockly.bindEventWithChecks_(b,\"click\",this,this.onMouseMove_,!0,!0);this.moveSurfaceWrapper_=Blockly.bindEventWithChecks_(b,\"mousemove\",this,this.onMouseMove_,!0,!0);return a};\nBlockly.FieldAngle.prototype.dropdownDispose_=function(){this.clickWrapper_&&(Blockly.unbindEvent_(this.clickWrapper_),this.clickWrapper_=null);this.clickSurfaceWrapper_&&(Blockly.unbindEvent_(this.clickSurfaceWrapper_),this.clickSurfaceWrapper_=null);this.moveSurfaceWrapper_&&(Blockly.unbindEvent_(this.moveSurfaceWrapper_),this.moveSurfaceWrapper_=null);this.line_=this.gauge_=null};Blockly.FieldAngle.prototype.hide_=function(){Blockly.DropDownDiv.hideIfOwner(this);Blockly.WidgetDiv.hide()};\nBlockly.FieldAngle.prototype.onMouseMove_=function(a){var b=this.gauge_.ownerSVGElement.getBoundingClientRect(),c=a.clientX-b.left-Blockly.FieldAngle.HALF;a=a.clientY-b.top-Blockly.FieldAngle.HALF;b=Math.atan(-a/c);isNaN(b)||(b=Blockly.utils.math.toDegrees(b),0>c?b+=180:0<a&&(b+=360),b=this.clockwise_?this.offset_+360-b:360-(this.offset_-b),this.displayMouseOrKeyboardValue_(b))};\nBlockly.FieldAngle.prototype.displayMouseOrKeyboardValue_=function(a){this.round_&&(a=Math.round(a/this.round_)*this.round_);a=this.wrapValue_(a);a!=this.value_&&this.setEditorValue_(a)};\nBlockly.FieldAngle.prototype.updateGraph_=function(){if(this.gauge_){var a=Number(this.getText())+this.offset_,b=Blockly.utils.math.toRadians(a%360);a=[\"M \",Blockly.FieldAngle.HALF,\",\",Blockly.FieldAngle.HALF];var c=Blockly.FieldAngle.HALF,d=Blockly.FieldAngle.HALF;if(!isNaN(b)){var e=Number(this.clockwise_),f=Blockly.utils.math.toRadians(this.offset_),g=Math.cos(f)*Blockly.FieldAngle.RADIUS,h=Math.sin(f)*-Blockly.FieldAngle.RADIUS;e&&(b=2*f-b);c+=Math.cos(b)*Blockly.FieldAngle.RADIUS;d-=Math.sin(b)*\nBlockly.FieldAngle.RADIUS;b=Math.abs(Math.floor((b-f)/Math.PI)%2);e&&(b=1-b);a.push(\" l \",g,\",\",h,\" A \",Blockly.FieldAngle.RADIUS,\",\",Blockly.FieldAngle.RADIUS,\" 0 \",b,\" \",e,\" \",c,\",\",d,\" z\")}this.gauge_.setAttribute(\"d\",a.join(\"\"));this.line_.setAttribute(\"x2\",c);this.line_.setAttribute(\"y2\",d)}};\nBlockly.FieldAngle.prototype.onHtmlInputKeyDown_=function(a){Blockly.FieldAngle.superClass_.onHtmlInputKeyDown_.call(this,a);var b;a.keyCode===Blockly.utils.KeyCodes.LEFT?b=this.sourceBlock_.RTL?1:-1:a.keyCode===Blockly.utils.KeyCodes.RIGHT?b=this.sourceBlock_.RTL?-1:1:a.keyCode===Blockly.utils.KeyCodes.DOWN?b=-1:a.keyCode===Blockly.utils.KeyCodes.UP&&(b=1);if(b){var c=this.getValue();this.displayMouseOrKeyboardValue_(c+b*this.round_);a.preventDefault();a.stopPropagation()}};\nBlockly.FieldAngle.prototype.doClassValidation_=function(a){a=Number(a);return isNaN(a)||!isFinite(a)?null:this.wrapValue_(a)};Blockly.FieldAngle.prototype.wrapValue_=function(a){a%=360;0>a&&(a+=360);a>this.wrap_&&(a-=360);return a};Blockly.Css.register(\".blocklyAngleCircle {,stroke: #444;,stroke-width: 1;,fill: #ddd;,fill-opacity: .8;,},.blocklyAngleMarks {,stroke: #444;,stroke-width: 1;,},.blocklyAngleGauge {,fill: #f88;,fill-opacity: .8;,pointer-events: none;,},.blocklyAngleLine {,stroke: #f00;,stroke-width: 2;,stroke-linecap: round;,pointer-events: none;,}\".split(\",\"));\nBlockly.fieldRegistry.register(\"field_angle\",Blockly.FieldAngle);Blockly.FieldCheckbox=function(a,b,c){this.checkChar_=null;null==a&&(a=\"FALSE\");Blockly.FieldCheckbox.superClass_.constructor.call(this,a,b,c)};Blockly.utils.object.inherits(Blockly.FieldCheckbox,Blockly.Field);Blockly.FieldCheckbox.fromJson=function(a){return new Blockly.FieldCheckbox(a.checked,void 0,a)};Blockly.FieldCheckbox.CHECK_CHAR=\"\\u2713\";Blockly.FieldCheckbox.prototype.SERIALIZABLE=!0;Blockly.FieldCheckbox.prototype.CURSOR=\"default\";\nBlockly.FieldCheckbox.prototype.configure_=function(a){Blockly.FieldCheckbox.superClass_.configure_.call(this,a);a.checkCharacter&&(this.checkChar_=a.checkCharacter)};Blockly.FieldCheckbox.prototype.initView=function(){Blockly.FieldCheckbox.superClass_.initView.call(this);Blockly.utils.dom.addClass(this.textElement_,\"blocklyCheckbox\");this.textElement_.style.display=this.value_?\"block\":\"none\"};\nBlockly.FieldCheckbox.prototype.render_=function(){this.textContent_&&(this.textContent_.nodeValue=this.getDisplayText_());this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET)};Blockly.FieldCheckbox.prototype.getDisplayText_=function(){return this.checkChar_||Blockly.FieldCheckbox.CHECK_CHAR};Blockly.FieldCheckbox.prototype.setCheckCharacter=function(a){this.checkChar_=a;this.forceRerender()};Blockly.FieldCheckbox.prototype.showEditor_=function(){this.setValue(!this.value_)};\nBlockly.FieldCheckbox.prototype.doClassValidation_=function(a){return!0===a||\"TRUE\"===a?\"TRUE\":!1===a||\"FALSE\"===a?\"FALSE\":null};Blockly.FieldCheckbox.prototype.doValueUpdate_=function(a){this.value_=this.convertValueToBool_(a);this.textElement_&&(this.textElement_.style.display=this.value_?\"block\":\"none\")};Blockly.FieldCheckbox.prototype.getValue=function(){return this.value_?\"TRUE\":\"FALSE\"};Blockly.FieldCheckbox.prototype.getValueBoolean=function(){return this.value_};\nBlockly.FieldCheckbox.prototype.getText=function(){return String(this.convertValueToBool_(this.value_))};Blockly.FieldCheckbox.prototype.convertValueToBool_=function(a){return\"string\"==typeof a?\"TRUE\"==a:!!a};Blockly.fieldRegistry.register(\"field_checkbox\",Blockly.FieldCheckbox);Blockly.FieldColour=function(a,b,c){Blockly.FieldColour.superClass_.constructor.call(this,a||Blockly.FieldColour.COLOURS[0],b,c);this.onKeyDownWrapper_=this.onMouseLeaveWrapper_=this.onMouseEnterWrapper_=this.onMouseMoveWrapper_=this.onClickWrapper_=this.highlightedIndex_=this.picker_=null};Blockly.utils.object.inherits(Blockly.FieldColour,Blockly.Field);Blockly.FieldColour.fromJson=function(a){return new Blockly.FieldColour(a.colour,void 0,a)};Blockly.FieldColour.prototype.SERIALIZABLE=!0;\nBlockly.FieldColour.prototype.CURSOR=\"default\";Blockly.FieldColour.prototype.isDirty_=!1;Blockly.FieldColour.prototype.colours_=null;Blockly.FieldColour.prototype.titles_=null;Blockly.FieldColour.prototype.columns_=0;Blockly.FieldColour.prototype.configure_=function(a){Blockly.FieldColour.superClass_.configure_.call(this,a);a.colourOptions&&(this.colours_=a.colourOptions,this.titles_=a.colourTitles);a.columns&&(this.columns_=a.columns)};\nBlockly.FieldColour.prototype.initView=function(){this.size_=new Blockly.utils.Size(this.getConstants().FIELD_COLOUR_DEFAULT_WIDTH,this.getConstants().FIELD_COLOUR_DEFAULT_HEIGHT);this.getConstants().FIELD_COLOUR_FULL_BLOCK?this.clickTarget_=this.sourceBlock_.getSvgRoot():(this.createBorderRect_(),this.borderRect_.style.fillOpacity=\"1\")};\nBlockly.FieldColour.prototype.applyColour=function(){this.getConstants().FIELD_COLOUR_FULL_BLOCK?(this.sourceBlock_.pathObject.svgPath.setAttribute(\"fill\",this.getValue()),this.sourceBlock_.pathObject.svgPath.setAttribute(\"stroke\",\"#fff\")):this.borderRect_&&(this.borderRect_.style.fill=this.getValue())};Blockly.FieldColour.prototype.doClassValidation_=function(a){return\"string\"!=typeof a?null:Blockly.utils.colour.parse(a)};\nBlockly.FieldColour.prototype.doValueUpdate_=function(a){this.value_=a;this.borderRect_?this.borderRect_.style.fill=a:this.sourceBlock_&&this.sourceBlock_.rendered&&(this.sourceBlock_.pathObject.svgPath.setAttribute(\"fill\",a),this.sourceBlock_.pathObject.svgPath.setAttribute(\"stroke\",\"#fff\"))};Blockly.FieldColour.prototype.getText=function(){var a=this.value_;/^#(.)\\1(.)\\2(.)\\3$/.test(a)&&(a=\"#\"+a[1]+a[3]+a[5]);return a};Blockly.FieldColour.COLOURS=\"#ffffff #cccccc #c0c0c0 #999999 #666666 #333333 #000000 #ffcccc #ff6666 #ff0000 #cc0000 #990000 #660000 #330000 #ffcc99 #ff9966 #ff9900 #ff6600 #cc6600 #993300 #663300 #ffff99 #ffff66 #ffcc66 #ffcc33 #cc9933 #996633 #663333 #ffffcc #ffff33 #ffff00 #ffcc00 #999900 #666600 #333300 #99ff99 #66ff99 #33ff33 #33cc00 #009900 #006600 #003300 #99ffff #33ffff #66cccc #00cccc #339999 #336666 #003333 #ccffff #66ffff #33ccff #3366ff #3333ff #000099 #000066 #ccccff #9999ff #6666cc #6633ff #6600cc #333399 #330099 #ffccff #ff99ff #cc66cc #cc33cc #993399 #663366 #330033\".split(\" \");\nBlockly.FieldColour.TITLES=[];Blockly.FieldColour.COLUMNS=7;Blockly.FieldColour.prototype.setColours=function(a,b){this.colours_=a;b&&(this.titles_=b);return this};Blockly.FieldColour.prototype.setColumns=function(a){this.columns_=a;return this};Blockly.FieldColour.prototype.showEditor_=function(){this.picker_=this.dropdownCreate_();Blockly.DropDownDiv.getContentDiv().appendChild(this.picker_);Blockly.DropDownDiv.showPositionedByField(this,this.dropdownDispose_.bind(this));this.picker_.focus({preventScroll:!0})};\nBlockly.FieldColour.prototype.onClick_=function(a){a=(a=a.target)&&a.label;null!==a&&(this.setValue(a),Blockly.DropDownDiv.hideIfOwner(this))};\nBlockly.FieldColour.prototype.onKeyDown_=function(a){var b=!1;if(a.keyCode===Blockly.utils.KeyCodes.UP)this.moveHighlightBy_(0,-1),b=!0;else if(a.keyCode===Blockly.utils.KeyCodes.DOWN)this.moveHighlightBy_(0,1),b=!0;else if(a.keyCode===Blockly.utils.KeyCodes.LEFT)this.moveHighlightBy_(-1,0),b=!0;else if(a.keyCode===Blockly.utils.KeyCodes.RIGHT)this.moveHighlightBy_(1,0),b=!0;else if(a.keyCode===Blockly.utils.KeyCodes.ENTER){if(b=this.getHighlighted_())b=b&&b.label,null!==b&&this.setValue(b);Blockly.DropDownDiv.hideWithoutAnimation();\nb=!0}b&&a.stopPropagation()};Blockly.FieldColour.prototype.onBlocklyAction=function(a){if(this.picker_){if(a===Blockly.navigation.ACTION_PREVIOUS)return this.moveHighlightBy_(0,-1),!0;if(a===Blockly.navigation.ACTION_NEXT)return this.moveHighlightBy_(0,1),!0;if(a===Blockly.navigation.ACTION_OUT)return this.moveHighlightBy_(-1,0),!0;if(a===Blockly.navigation.ACTION_IN)return this.moveHighlightBy_(1,0),!0}return Blockly.FieldColour.superClass_.onBlocklyAction.call(this,a)};\nBlockly.FieldColour.prototype.moveHighlightBy_=function(a,b){var c=this.colours_||Blockly.FieldColour.COLOURS,d=this.columns_||Blockly.FieldColour.COLUMNS,e=this.highlightedIndex_%d,f=Math.floor(this.highlightedIndex_/d);e+=a;f+=b;0>a?0>e&&0<f?(e=d-1,f--):0>e&&(e=0):0<a?e>d-1&&f<Math.floor(c.length/d)-1?(e=0,f++):e>d-1&&e--:0>b?0>f&&(f=0):0<b&&f>Math.floor(c.length/d)-1&&(f=Math.floor(c.length/d)-1);this.setHighlightedCell_(this.picker_.childNodes[f].childNodes[e],f*d+e)};\nBlockly.FieldColour.prototype.onMouseMove_=function(a){var b=(a=a.target)&&Number(a.getAttribute(\"data-index\"));null!==b&&b!==this.highlightedIndex_&&this.setHighlightedCell_(a,b)};Blockly.FieldColour.prototype.onMouseEnter_=function(){this.picker_.focus({preventScroll:!0})};Blockly.FieldColour.prototype.onMouseLeave_=function(){this.picker_.blur();var a=this.getHighlighted_();a&&Blockly.utils.dom.removeClass(a,\"blocklyColourHighlighted\")};\nBlockly.FieldColour.prototype.getHighlighted_=function(){var a=this.columns_||Blockly.FieldColour.COLUMNS,b=this.picker_.childNodes[Math.floor(this.highlightedIndex_/a)];return b?b.childNodes[this.highlightedIndex_%a]:null};\nBlockly.FieldColour.prototype.setHighlightedCell_=function(a,b){var c=this.getHighlighted_();c&&Blockly.utils.dom.removeClass(c,\"blocklyColourHighlighted\");Blockly.utils.dom.addClass(a,\"blocklyColourHighlighted\");this.highlightedIndex_=b;Blockly.utils.aria.setState(this.picker_,Blockly.utils.aria.State.ACTIVEDESCENDANT,a.getAttribute(\"id\"))};\nBlockly.FieldColour.prototype.dropdownCreate_=function(){var a=this.columns_||Blockly.FieldColour.COLUMNS,b=this.colours_||Blockly.FieldColour.COLOURS,c=this.titles_||Blockly.FieldColour.TITLES,d=this.getValue(),e=document.createElement(\"table\");e.className=\"blocklyColourTable\";e.tabIndex=0;e.dir=\"ltr\";Blockly.utils.aria.setRole(e,Blockly.utils.aria.Role.GRID);Blockly.utils.aria.setState(e,Blockly.utils.aria.State.EXPANDED,!0);Blockly.utils.aria.setState(e,Blockly.utils.aria.State.ROWCOUNT,Math.floor(b.length/\na));Blockly.utils.aria.setState(e,Blockly.utils.aria.State.COLCOUNT,a);for(var f,g=0;g<b.length;g++){0==g%a&&(f=document.createElement(\"tr\"),Blockly.utils.aria.setRole(f,Blockly.utils.aria.Role.ROW),e.appendChild(f));var h=document.createElement(\"td\");f.appendChild(h);h.label=b[g];h.title=c[g]||b[g];h.id=Blockly.utils.IdGenerator.getNextUniqueId();h.setAttribute(\"data-index\",g);Blockly.utils.aria.setRole(h,Blockly.utils.aria.Role.GRIDCELL);Blockly.utils.aria.setState(h,Blockly.utils.aria.State.LABEL,\nb[g]);Blockly.utils.aria.setState(h,Blockly.utils.aria.State.SELECTED,b[g]==d);h.style.backgroundColor=b[g];b[g]==d&&(h.className=\"blocklyColourSelected\",this.highlightedIndex_=g)}this.onClickWrapper_=Blockly.bindEventWithChecks_(e,\"click\",this,this.onClick_,!0);this.onMouseMoveWrapper_=Blockly.bindEventWithChecks_(e,\"mousemove\",this,this.onMouseMove_,!0);this.onMouseEnterWrapper_=Blockly.bindEventWithChecks_(e,\"mouseenter\",this,this.onMouseEnter_,!0);this.onMouseLeaveWrapper_=Blockly.bindEventWithChecks_(e,\n\"mouseleave\",this,this.onMouseLeave_,!0);this.onKeyDownWrapper_=Blockly.bindEventWithChecks_(e,\"keydown\",this,this.onKeyDown_);return e};\nBlockly.FieldColour.prototype.dropdownDispose_=function(){this.onClickWrapper_&&(Blockly.unbindEvent_(this.onClickWrapper_),this.onClickWrapper_=null);this.onMouseMoveWrapper_&&(Blockly.unbindEvent_(this.onMouseMoveWrapper_),this.onMouseMoveWrapper_=null);this.onMouseEnterWrapper_&&(Blockly.unbindEvent_(this.onMouseEnterWrapper_),this.onMouseEnterWrapper_=null);this.onMouseLeaveWrapper_&&(Blockly.unbindEvent_(this.onMouseLeaveWrapper_),this.onMouseLeaveWrapper_=null);this.onKeyDownWrapper_&&(Blockly.unbindEvent_(this.onKeyDownWrapper_),\nthis.onKeyDownWrapper_=null);this.highlightedIndex_=this.picker_=null};\nBlockly.Css.register([\".blocklyColourTable {\",\"border-collapse: collapse;\",\"display: block;\",\"outline: none;\",\"padding: 1px;\",\"}\",\".blocklyColourTable>tr>td {\",\"border: .5px solid #888;\",\"box-sizing: border-box;\",\"cursor: pointer;\",\"display: inline-block;\",\"height: 20px;\",\"padding: 0;\",\"width: 20px;\",\"}\",\".blocklyColourTable>tr>td.blocklyColourHighlighted {\",\"border-color: #eee;\",\"box-shadow: 2px 2px 7px 2px rgba(0,0,0,.3);\",\"position: relative;\",\"}\",\".blocklyColourSelected, .blocklyColourSelected:hover {\",\n\"border-color: #eee !important;\",\"outline: 1px solid #333;\",\"position: relative;\",\"}\"]);Blockly.fieldRegistry.register(\"field_colour\",Blockly.FieldColour);Blockly.FieldDropdown=function(a,b,c){\"function\"!=typeof a&&Blockly.FieldDropdown.validateOptions_(a);this.menuGenerator_=a;this.generatedOptions_=null;this.trimOptions_();this.selectedOption_=this.getOptions(!1)[0];Blockly.FieldDropdown.superClass_.constructor.call(this,this.selectedOption_[1],b,c);this.svgArrow_=this.arrow_=this.imageElement_=this.menu_=this.selectedMenuItem_=null};Blockly.utils.object.inherits(Blockly.FieldDropdown,Blockly.Field);\nBlockly.FieldDropdown.fromJson=function(a){return new Blockly.FieldDropdown(a.options,void 0,a)};Blockly.FieldDropdown.prototype.SERIALIZABLE=!0;Blockly.FieldDropdown.CHECKMARK_OVERHANG=25;Blockly.FieldDropdown.MAX_MENU_HEIGHT_VH=.45;Blockly.FieldDropdown.IMAGE_Y_OFFSET=5;Blockly.FieldDropdown.IMAGE_Y_PADDING=2*Blockly.FieldDropdown.IMAGE_Y_OFFSET;Blockly.FieldDropdown.ARROW_CHAR=Blockly.utils.userAgent.ANDROID?\"\\u25bc\":\"\\u25be\";Blockly.FieldDropdown.prototype.CURSOR=\"default\";\nBlockly.FieldDropdown.prototype.initView=function(){this.shouldAddBorderRect_()?this.createBorderRect_():this.clickTarget_=this.sourceBlock_.getSvgRoot();this.createTextElement_();this.imageElement_=Blockly.utils.dom.createSvgElement(\"image\",{},this.fieldGroup_);this.getConstants().FIELD_DROPDOWN_SVG_ARROW?this.createSVGArrow_():this.createTextArrow_();this.borderRect_&&Blockly.utils.dom.addClass(this.borderRect_,\"blocklyDropdownRect\")};\nBlockly.FieldDropdown.prototype.shouldAddBorderRect_=function(){return!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW||this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW&&!this.sourceBlock_.isShadow()};\nBlockly.FieldDropdown.prototype.createTextArrow_=function(){this.arrow_=Blockly.utils.dom.createSvgElement(\"tspan\",{},this.textElement_);this.arrow_.appendChild(document.createTextNode(this.sourceBlock_.RTL?Blockly.FieldDropdown.ARROW_CHAR+\" \":\" \"+Blockly.FieldDropdown.ARROW_CHAR));this.sourceBlock_.RTL?this.textElement_.insertBefore(this.arrow_,this.textContent_):this.textElement_.appendChild(this.arrow_)};\nBlockly.FieldDropdown.prototype.createSVGArrow_=function(){this.svgArrow_=Blockly.utils.dom.createSvgElement(\"image\",{height:this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE+\"px\",width:this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE+\"px\"},this.fieldGroup_);this.svgArrow_.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI)};\nBlockly.FieldDropdown.prototype.showEditor_=function(a){this.menu_=this.dropdownCreate_();this.menu_.openingCoords=a&&\"number\"===typeof a.clientX?new Blockly.utils.Coordinate(a.clientX,a.clientY):null;this.menu_.render(Blockly.DropDownDiv.getContentDiv());Blockly.utils.dom.addClass(this.menu_.getElement(),\"blocklyDropdownMenu\");if(this.getConstants().FIELD_DROPDOWN_COLOURED_DIV){a=this.sourceBlock_.isShadow()?this.sourceBlock_.getParent().getColour():this.sourceBlock_.getColour();var b=this.sourceBlock_.isShadow()?\nthis.sourceBlock_.getParent().style.colourTertiary:this.sourceBlock_.style.colourTertiary;Blockly.DropDownDiv.setColour(a,b)}Blockly.DropDownDiv.showPositionedByField(this,this.dropdownDispose_.bind(this));this.menu_.focus();this.selectedMenuItem_&&Blockly.utils.style.scrollIntoContainerView(this.selectedMenuItem_.getElement(),this.menu_.getElement());this.applyColour()};\nBlockly.FieldDropdown.prototype.dropdownCreate_=function(){var a=new Blockly.Menu;a.setRightToLeft(this.sourceBlock_.RTL);a.setRole(Blockly.utils.aria.Role.LISTBOX);var b=this.getOptions(!1);this.selectedMenuItem_=null;for(var c=0;c<b.length;c++){var d=b[c][0],e=b[c][1];if(\"object\"==typeof d){var f=new Image(d.width,d.height);f.src=d.src;f.alt=d.alt||\"\";d=f}d=new Blockly.MenuItem(d);d.setRole(Blockly.utils.aria.Role.OPTION);d.setRightToLeft(this.sourceBlock_.RTL);d.setValue(e);d.setCheckable(!0);\na.addChild(d,!0);d.setChecked(e==this.value_);e==this.value_&&(this.selectedMenuItem_=d);d.onAction(this.handleMenuActionEvent_,this)}Blockly.utils.aria.setState(a.getElement(),Blockly.utils.aria.State.ACTIVEDESCENDANT,this.selectedMenuItem_?this.selectedMenuItem_.getId():\"\");return a};Blockly.FieldDropdown.prototype.dropdownDispose_=function(){this.menu_&&this.menu_.dispose();this.selectedMenuItem_=this.menu_=null;this.applyColour()};\nBlockly.FieldDropdown.prototype.handleMenuActionEvent_=function(a){Blockly.DropDownDiv.hideIfOwner(this,!0);this.onItemSelected_(this.menu_,a)};Blockly.FieldDropdown.prototype.onItemSelected_=function(a,b){this.setValue(b.getValue())};\nBlockly.FieldDropdown.prototype.trimOptions_=function(){this.suffixField=this.prefixField=null;var a=this.menuGenerator_;if(Array.isArray(a)){for(var b=!1,c=0;c<a.length;c++){var d=a[c][0];\"string\"==typeof d?a[c][0]=Blockly.utils.replaceMessageReferences(d):(null!=d.alt&&(a[c][0].alt=Blockly.utils.replaceMessageReferences(d.alt)),b=!0)}if(!(b||2>a.length)){b=[];for(c=0;c<a.length;c++)b.push(a[c][0]);c=Blockly.utils.string.shortestStringLength(b);d=Blockly.utils.string.commonWordPrefix(b,c);var e=\nBlockly.utils.string.commonWordSuffix(b,c);!d&&!e||c<=d+e||(d&&(this.prefixField=b[0].substring(0,d-1)),e&&(this.suffixField=b[0].substr(1-e)),this.menuGenerator_=Blockly.FieldDropdown.applyTrim_(a,d,e))}}};Blockly.FieldDropdown.applyTrim_=function(a,b,c){for(var d=[],e=0;e<a.length;e++){var f=a[e][0],g=a[e][1];f=f.substring(b,f.length-c);d[e]=[f,g]}return d};Blockly.FieldDropdown.prototype.isOptionListDynamic=function(){return\"function\"==typeof this.menuGenerator_};\nBlockly.FieldDropdown.prototype.getOptions=function(a){return this.isOptionListDynamic()?(this.generatedOptions_&&a||(this.generatedOptions_=this.menuGenerator_.call(this),Blockly.FieldDropdown.validateOptions_(this.generatedOptions_)),this.generatedOptions_):this.menuGenerator_};\nBlockly.FieldDropdown.prototype.doClassValidation_=function(a){for(var b=!1,c=this.getOptions(!0),d=0,e;e=c[d];d++)if(e[1]==a){b=!0;break}return b?a:(this.sourceBlock_&&console.warn(\"Cannot set the dropdown's value to an unavailable option. Block type: \"+this.sourceBlock_.type+\", Field name: \"+this.name+\", Value: \"+a),null)};\nBlockly.FieldDropdown.prototype.doValueUpdate_=function(a){Blockly.FieldDropdown.superClass_.doValueUpdate_.call(this,a);a=this.getOptions(!0);for(var b=0,c;c=a[b];b++)c[1]==this.value_&&(this.selectedOption_=c)};\nBlockly.FieldDropdown.prototype.applyColour=function(){this.borderRect_&&(this.borderRect_.setAttribute(\"stroke\",this.sourceBlock_.style.colourTertiary),this.menu_?this.borderRect_.setAttribute(\"fill\",this.sourceBlock_.style.colourTertiary):this.borderRect_.setAttribute(\"fill\",\"transparent\"));this.sourceBlock_&&this.arrow_&&(this.sourceBlock_.isShadow()?this.arrow_.style.fill=this.sourceBlock_.style.colourSecondary:this.arrow_.style.fill=this.sourceBlock_.style.colourPrimary)};\nBlockly.FieldDropdown.prototype.render_=function(){this.textContent_.nodeValue=\"\";this.imageElement_.style.display=\"none\";var a=this.selectedOption_&&this.selectedOption_[0];a&&\"object\"==typeof a?this.renderSelectedImage_(a):this.renderSelectedText_();this.positionBorderRect_()};\nBlockly.FieldDropdown.prototype.renderSelectedImage_=function(a){this.imageElement_.style.display=\"\";this.imageElement_.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",a.src);this.imageElement_.setAttribute(\"height\",a.height);this.imageElement_.setAttribute(\"width\",a.width);var b=Number(a.height);a=Number(a.width);var c=!!this.borderRect_,d=Math.max(c?this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT:0,b+Blockly.FieldDropdown.IMAGE_Y_PADDING);c=c?this.getConstants().FIELD_BORDER_RECT_X_PADDING:\n0;var e=this.svgArrow_?this.positionSVGArrow_(a+c,d/2-this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE/2):Blockly.utils.dom.getFastTextWidth(this.arrow_,this.getConstants().FIELD_TEXT_FONTSIZE,this.getConstants().FIELD_TEXT_FONTWEIGHT,this.getConstants().FIELD_TEXT_FONTFAMILY);this.size_.width=a+e+2*c;this.size_.height=d;var f=0;this.sourceBlock_.RTL?this.imageElement_.setAttribute(\"x\",c+e):(f=a+e,this.textElement_.setAttribute(\"text-anchor\",\"end\"),this.imageElement_.setAttribute(\"x\",c));this.imageElement_.setAttribute(\"y\",\nd/2-b/2);this.positionTextElement_(f+c,a+e)};\nBlockly.FieldDropdown.prototype.renderSelectedText_=function(){this.textContent_.nodeValue=this.getDisplayText_();Blockly.utils.dom.addClass(this.textElement_,\"blocklyDropdownText\");this.textElement_.setAttribute(\"text-anchor\",\"start\");var a=!!this.borderRect_,b=Math.max(a?this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT:0,this.getConstants().FIELD_TEXT_HEIGHT),c=Blockly.utils.dom.getFastTextWidth(this.textElement_,this.getConstants().FIELD_TEXT_FONTSIZE,this.getConstants().FIELD_TEXT_FONTWEIGHT,\nthis.getConstants().FIELD_TEXT_FONTFAMILY);a=a?this.getConstants().FIELD_BORDER_RECT_X_PADDING:0;var d=0;this.svgArrow_&&(d=this.positionSVGArrow_(c+a,b/2-this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE/2));this.size_.width=c+d+2*a;this.size_.height=b;this.positionTextElement_(a,c)};\nBlockly.FieldDropdown.prototype.positionSVGArrow_=function(a,b){if(!this.svgArrow_)return 0;var c=this.borderRect_?this.getConstants().FIELD_BORDER_RECT_X_PADDING:0,d=this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING,e=this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;this.svgArrow_.setAttribute(\"transform\",\"translate(\"+(this.sourceBlock_.RTL?c:a+d)+\",\"+b+\")\");return e+d};\nBlockly.FieldDropdown.prototype.getText_=function(){if(!this.selectedOption_)return null;var a=this.selectedOption_[0];return\"object\"==typeof a?a.alt:a};\nBlockly.FieldDropdown.validateOptions_=function(a){if(!Array.isArray(a))throw TypeError(\"FieldDropdown options must be an array.\");if(!a.length)throw TypeError(\"FieldDropdown options must not be an empty array.\");for(var b=!1,c=0;c<a.length;++c){var d=a[c];Array.isArray(d)?\"string\"!=typeof d[1]?(b=!0,console.error(\"Invalid option[\"+c+\"]: Each FieldDropdown option id must be a string. Found \"+d[1]+\" in: \",d)):d[0]&&\"string\"!=typeof d[0]&&\"string\"!=typeof d[0].src&&(b=!0,console.error(\"Invalid option[\"+\nc+\"]: Each FieldDropdown option must have a string label or image description. Found\"+d[0]+\" in: \",d)):(b=!0,console.error(\"Invalid option[\"+c+\"]: Each FieldDropdown option must be an array. Found: \",d))}if(b)throw TypeError(\"Found invalid FieldDropdown options.\");};\nBlockly.FieldDropdown.prototype.onBlocklyAction=function(a){if(this.menu_){if(a===Blockly.navigation.ACTION_PREVIOUS)return this.menu_.highlightPrevious(),!0;if(a===Blockly.navigation.ACTION_NEXT)return this.menu_.highlightNext(),!0}return Blockly.FieldDropdown.superClass_.onBlocklyAction.call(this,a)};Blockly.fieldRegistry.register(\"field_dropdown\",Blockly.FieldDropdown);Blockly.FieldLabelSerializable=function(a,b,c){Blockly.FieldLabelSerializable.superClass_.constructor.call(this,a,b,c)};Blockly.utils.object.inherits(Blockly.FieldLabelSerializable,Blockly.FieldLabel);Blockly.FieldLabelSerializable.fromJson=function(a){var b=Blockly.utils.replaceMessageReferences(a.text);return new Blockly.FieldLabelSerializable(b,void 0,a)};Blockly.FieldLabelSerializable.prototype.EDITABLE=!1;Blockly.FieldLabelSerializable.prototype.SERIALIZABLE=!0;\nBlockly.fieldRegistry.register(\"field_label_serializable\",Blockly.FieldLabelSerializable);Blockly.FieldImage=function(a,b,c,d,e,f,g){if(!a)throw Error(\"Src value of an image field is required\");a=Blockly.utils.replaceMessageReferences(a);c=Number(Blockly.utils.replaceMessageReferences(c));b=Number(Blockly.utils.replaceMessageReferences(b));if(isNaN(c)||isNaN(b))throw Error(\"Height and width values of an image field must cast to numbers.\");if(0>=c||0>=b)throw Error(\"Height and width values of an image field must be greater than 0.\");this.flipRtl_=!1;this.altText_=\"\";Blockly.FieldImage.superClass_.constructor.call(this,\na||\"\",null,g);g||(this.flipRtl_=!!f,this.altText_=Blockly.utils.replaceMessageReferences(d)||\"\");this.size_=new Blockly.utils.Size(b,c+Blockly.FieldImage.Y_PADDING);this.imageHeight_=c;this.clickHandler_=null;\"function\"==typeof e&&(this.clickHandler_=e);this.imageElement_=null};Blockly.utils.object.inherits(Blockly.FieldImage,Blockly.Field);Blockly.FieldImage.fromJson=function(a){return new Blockly.FieldImage(a.src,a.width,a.height,void 0,void 0,void 0,a)};Blockly.FieldImage.Y_PADDING=1;\nBlockly.FieldImage.prototype.EDITABLE=!1;Blockly.FieldImage.prototype.isDirty_=!1;Blockly.FieldImage.prototype.configure_=function(a){Blockly.FieldImage.superClass_.configure_.call(this,a);this.flipRtl_=!!a.flipRtl;this.altText_=Blockly.utils.replaceMessageReferences(a.alt)||\"\"};\nBlockly.FieldImage.prototype.initView=function(){this.imageElement_=Blockly.utils.dom.createSvgElement(\"image\",{height:this.imageHeight_+\"px\",width:this.size_.width+\"px\",alt:this.altText_},this.fieldGroup_);this.imageElement_.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",this.value_);this.clickHandler_&&(this.imageElement_.style.cursor=\"pointer\")};Blockly.FieldImage.prototype.updateSize_=function(){};\nBlockly.FieldImage.prototype.doClassValidation_=function(a){return\"string\"!=typeof a?null:a};Blockly.FieldImage.prototype.doValueUpdate_=function(a){this.value_=a;this.imageElement_&&this.imageElement_.setAttributeNS(Blockly.utils.dom.XLINK_NS,\"xlink:href\",String(this.value_))};Blockly.FieldImage.prototype.getFlipRtl=function(){return this.flipRtl_};Blockly.FieldImage.prototype.setAlt=function(a){a!=this.altText_&&(this.altText_=a||\"\",this.imageElement_&&this.imageElement_.setAttribute(\"alt\",this.altText_))};\nBlockly.FieldImage.prototype.showEditor_=function(){this.clickHandler_&&this.clickHandler_(this)};Blockly.FieldImage.prototype.setOnClickHandler=function(a){this.clickHandler_=a};Blockly.FieldImage.prototype.getText_=function(){return this.altText_};Blockly.fieldRegistry.register(\"field_image\",Blockly.FieldImage);Blockly.FieldMultilineInput=function(a,b,c){null==a&&(a=\"\");Blockly.FieldMultilineInput.superClass_.constructor.call(this,a,b,c);this.textGroup_=null};Blockly.utils.object.inherits(Blockly.FieldMultilineInput,Blockly.FieldTextInput);Blockly.FieldMultilineInput.fromJson=function(a){var b=Blockly.utils.replaceMessageReferences(a.text);return new Blockly.FieldMultilineInput(b,void 0,a)};\nBlockly.FieldMultilineInput.prototype.initView=function(){this.createBorderRect_();this.textGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":\"blocklyEditableText\"},this.fieldGroup_)};\nBlockly.FieldMultilineInput.prototype.getDisplayText_=function(){var a=this.value_;if(!a)return Blockly.Field.NBSP;var b=a.split(\"\\n\");a=\"\";for(var c=0;c<b.length;c++){var d=b[c];d.length>this.maxDisplayLength&&(d=d.substring(0,this.maxDisplayLength-4)+\"...\");d=d.replace(/\\s/g,Blockly.Field.NBSP);a+=d;c!==b.length-1&&(a+=\"\\n\")}this.sourceBlock_.RTL&&(a+=\"\\u200f\");return a};\nBlockly.FieldMultilineInput.prototype.render_=function(){for(var a;a=this.textGroup_.firstChild;)this.textGroup_.removeChild(a);a=this.getDisplayText_().split(\"\\n\");for(var b=0,c=0;c<a.length;c++){var d=this.getConstants().FIELD_TEXT_HEIGHT+this.getConstants().FIELD_BORDER_RECT_Y_PADDING;Blockly.utils.dom.createSvgElement(\"text\",{\"class\":\"blocklyText blocklyMultilineText\",x:this.getConstants().FIELD_BORDER_RECT_X_PADDING,y:b+this.getConstants().FIELD_BORDER_RECT_Y_PADDING,dy:this.getConstants().FIELD_TEXT_BASELINE},\nthis.textGroup_).appendChild(document.createTextNode(a[c]));b+=d}this.updateSize_();this.isBeingEdited_&&(this.sourceBlock_.RTL?setTimeout(this.resizeEditor_.bind(this),0):this.resizeEditor_(),a=this.htmlInput_,this.isTextValid_?(Blockly.utils.dom.removeClass(a,\"blocklyInvalidInput\"),Blockly.utils.aria.setState(a,Blockly.utils.aria.State.INVALID,!1)):(Blockly.utils.dom.addClass(a,\"blocklyInvalidInput\"),Blockly.utils.aria.setState(a,Blockly.utils.aria.State.INVALID,!0)))};\nBlockly.FieldMultilineInput.prototype.updateSize_=function(){for(var a=this.textGroup_.childNodes,b=0,c=0,d=0;d<a.length;d++){var e=Blockly.utils.dom.getTextWidth(a[d]);e>b&&(b=e);c+=this.getConstants().FIELD_TEXT_HEIGHT+(0<d?this.getConstants().FIELD_BORDER_RECT_Y_PADDING:0)}this.borderRect_&&(c+=2*this.getConstants().FIELD_BORDER_RECT_Y_PADDING,b+=2*this.getConstants().FIELD_BORDER_RECT_X_PADDING,this.borderRect_.setAttribute(\"width\",b),this.borderRect_.setAttribute(\"height\",c));this.size_.width=\nb;this.size_.height=c;this.positionBorderRect_()};\nBlockly.FieldMultilineInput.prototype.widgetCreate_=function(){var a=Blockly.WidgetDiv.DIV,b=this.workspace_.getScale(),c=document.createElement(\"textarea\");c.className=\"blocklyHtmlInput blocklyHtmlTextAreaInput\";c.setAttribute(\"spellcheck\",this.spellcheck_);var d=this.getConstants().FIELD_TEXT_FONTSIZE*b+\"pt\";a.style.fontSize=d;c.style.fontSize=d;c.style.borderRadius=Blockly.FieldTextInput.BORDERRADIUS*b+\"px\";d=this.getConstants().FIELD_BORDER_RECT_X_PADDING*b;var e=this.getConstants().FIELD_BORDER_RECT_Y_PADDING*\nb/2;c.style.padding=e+\"px \"+d+\"px \"+e+\"px \"+d+\"px\";d=this.getConstants().FIELD_TEXT_HEIGHT+this.getConstants().FIELD_BORDER_RECT_Y_PADDING;c.style.lineHeight=d*b+\"px\";a.appendChild(c);c.value=c.defaultValue=this.getEditorText_(this.value_);c.untypedDefaultValue_=this.value_;c.oldValue_=null;Blockly.utils.userAgent.GECKO?setTimeout(this.resizeEditor_.bind(this),0):this.resizeEditor_();this.bindInputEvents_(c);return c};\nBlockly.FieldMultilineInput.prototype.onHtmlInputKeyDown_=function(a){a.keyCode!==Blockly.utils.KeyCodes.ENTER&&Blockly.FieldMultilineInput.superClass_.onHtmlInputKeyDown_.call(this,a)};Blockly.Css.register(\".blocklyHtmlTextAreaInput {,font-family: monospace;,resize: none;,overflow: hidden;,height: 100%;,text-align: left;,}\".split(\",\"));Blockly.fieldRegistry.register(\"field_multilinetext\",Blockly.FieldMultilineInput);Blockly.FieldNumber=function(a,b,c,d,e,f){this.min_=-Infinity;this.max_=Infinity;this.precision_=0;this.decimalPlaces_=null;Blockly.FieldNumber.superClass_.constructor.call(this,a||0,e,f);f||this.setConstraints(b,c,d)};Blockly.utils.object.inherits(Blockly.FieldNumber,Blockly.FieldTextInput);Blockly.FieldNumber.fromJson=function(a){return new Blockly.FieldNumber(a.value,void 0,void 0,void 0,void 0,a)};Blockly.FieldNumber.prototype.SERIALIZABLE=!0;\nBlockly.FieldNumber.prototype.configure_=function(a){Blockly.FieldNumber.superClass_.configure_.call(this,a);this.setMinInternal_(a.min);this.setMaxInternal_(a.max);this.setPrecisionInternal_(a.precision)};Blockly.FieldNumber.prototype.setConstraints=function(a,b,c){this.setMinInternal_(a);this.setMaxInternal_(b);this.setPrecisionInternal_(c);this.setValue(this.getValue())};Blockly.FieldNumber.prototype.setMin=function(a){this.setMinInternal_(a);this.setValue(this.getValue())};\nBlockly.FieldNumber.prototype.setMinInternal_=function(a){null==a?this.min_=-Infinity:(a=Number(a),isNaN(a)||(this.min_=a))};Blockly.FieldNumber.prototype.getMin=function(){return this.min_};Blockly.FieldNumber.prototype.setMax=function(a){this.setMaxInternal_(a);this.setValue(this.getValue())};Blockly.FieldNumber.prototype.setMaxInternal_=function(a){null==a?this.max_=Infinity:(a=Number(a),isNaN(a)||(this.max_=a))};Blockly.FieldNumber.prototype.getMax=function(){return this.max_};\nBlockly.FieldNumber.prototype.setPrecision=function(a){this.setPrecisionInternal_(a);this.setValue(this.getValue())};Blockly.FieldNumber.prototype.setPrecisionInternal_=function(a){null==a?this.precision_=0:(a=Number(a),isNaN(a)||(this.precision_=a));var b=this.precision_.toString(),c=b.indexOf(\".\");this.decimalPlaces_=-1==c?a?0:null:b.length-c-1};Blockly.FieldNumber.prototype.getPrecision=function(){return this.precision_};\nBlockly.FieldNumber.prototype.doClassValidation_=function(a){if(null===a)return null;a=String(a);a=a.replace(/O/ig,\"0\");a=a.replace(/,/g,\"\");a=a.replace(/infinity/i,\"Infinity\");a=Number(a||0);if(isNaN(a))return null;a=Math.min(Math.max(a,this.min_),this.max_);this.precision_&&isFinite(a)&&(a=Math.round(a/this.precision_)*this.precision_);null!=this.decimalPlaces_&&(a=Number(a.toFixed(this.decimalPlaces_)));return a};\nBlockly.FieldNumber.prototype.widgetCreate_=function(){var a=Blockly.FieldNumber.superClass_.widgetCreate_.call(this);-Infinity<this.min_&&Blockly.utils.aria.setState(a,Blockly.utils.aria.State.VALUEMIN,this.min_);Infinity>this.max_&&Blockly.utils.aria.setState(a,Blockly.utils.aria.State.VALUEMAX,this.max_);return a};Blockly.fieldRegistry.register(\"field_number\",Blockly.FieldNumber);Blockly.FieldVariable=function(a,b,c,d,e){this.menuGenerator_=Blockly.FieldVariable.dropdownCreate;this.defaultVariableName=a||\"\";this.size_=new Blockly.utils.Size(0,0);e&&this.configure_(e);b&&this.setValidator(b);e||this.setTypes_(c,d)};Blockly.utils.object.inherits(Blockly.FieldVariable,Blockly.FieldDropdown);Blockly.FieldVariable.fromJson=function(a){var b=Blockly.utils.replaceMessageReferences(a.variable);return new Blockly.FieldVariable(b,void 0,void 0,void 0,a)};\nBlockly.FieldVariable.prototype.workspace_=null;Blockly.FieldVariable.prototype.SERIALIZABLE=!0;Blockly.FieldVariable.prototype.configure_=function(a){Blockly.FieldVariable.superClass_.configure_.call(this,a);this.setTypes_(a.variableTypes,a.defaultType)};Blockly.FieldVariable.prototype.initModel=function(){if(!this.variable_){var a=Blockly.Variables.getOrCreateVariablePackage(this.sourceBlock_.workspace,null,this.defaultVariableName,this.defaultType_);this.doValueUpdate_(a.getId())}};\nBlockly.FieldVariable.prototype.shouldAddBorderRect_=function(){return Blockly.FieldVariable.superClass_.shouldAddBorderRect_.call(this)&&(!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW||\"variables_get\"!=this.sourceBlock_.type)};\nBlockly.FieldVariable.prototype.fromXml=function(a){var b=a.getAttribute(\"id\"),c=a.textContent,d=a.getAttribute(\"variabletype\")||a.getAttribute(\"variableType\")||\"\";b=Blockly.Variables.getOrCreateVariablePackage(this.sourceBlock_.workspace,b,c,d);if(null!=d&&d!==b.type)throw Error(\"Serialized variable type with id '\"+b.getId()+\"' had type \"+b.type+\", and does not match variable field that references it: \"+Blockly.Xml.domToText(a)+\".\");this.setValue(b.getId())};\nBlockly.FieldVariable.prototype.toXml=function(a){this.initModel();a.id=this.variable_.getId();a.textContent=this.variable_.name;this.variable_.type&&a.setAttribute(\"variabletype\",this.variable_.type);return a};Blockly.FieldVariable.prototype.setSourceBlock=function(a){if(a.isShadow())throw Error(\"Variable fields are not allowed to exist on shadow blocks.\");Blockly.FieldVariable.superClass_.setSourceBlock.call(this,a)};\nBlockly.FieldVariable.prototype.getValue=function(){return this.variable_?this.variable_.getId():null};Blockly.FieldVariable.prototype.getText=function(){return this.variable_?this.variable_.name:\"\"};Blockly.FieldVariable.prototype.getVariable=function(){return this.variable_};Blockly.FieldVariable.prototype.getValidator=function(){return this.variable_?this.validator_:null};\nBlockly.FieldVariable.prototype.doClassValidation_=function(a){if(null===a)return null;var b=Blockly.Variables.getVariable(this.sourceBlock_.workspace,a);if(!b)return console.warn(\"Variable id doesn't point to a real variable! ID was \"+a),null;b=b.type;return this.typeIsAllowed_(b)?a:(console.warn(\"Variable type doesn't match this field!  Type was \"+b),null)};\nBlockly.FieldVariable.prototype.doValueUpdate_=function(a){this.variable_=Blockly.Variables.getVariable(this.sourceBlock_.workspace,a);Blockly.FieldVariable.superClass_.doValueUpdate_.call(this,a)};Blockly.FieldVariable.prototype.typeIsAllowed_=function(a){var b=this.getVariableTypes_();if(!b)return!0;for(var c=0;c<b.length;c++)if(a==b[c])return!0;return!1};\nBlockly.FieldVariable.prototype.getVariableTypes_=function(){var a=this.variableTypes;if(null===a&&this.sourceBlock_&&this.sourceBlock_.workspace)return this.sourceBlock_.workspace.getVariableTypes();a=a||[\"\"];if(0==a.length)throw a=this.getText(),Error(\"'variableTypes' of field variable \"+a+\" was an empty list\");return a};\nBlockly.FieldVariable.prototype.setTypes_=function(a,b){b=b||\"\";if(null==a||void 0==a)a=null;else if(Array.isArray(a)){for(var c=!1,d=0;d<a.length;d++)a[d]==b&&(c=!0);if(!c)throw Error(\"Invalid default type '\"+b+\"' in the definition of a FieldVariable\");}else throw Error(\"'variableTypes' was not an array in the definition of a FieldVariable\");this.defaultType_=b;this.variableTypes=a};Blockly.FieldVariable.prototype.refreshVariableName=function(){this.forceRerender()};\nBlockly.FieldVariable.dropdownCreate=function(){if(!this.variable_)throw Error(\"Tried to call dropdownCreate on a variable field with no variable selected.\");var a=this.getText(),b=[];if(this.sourceBlock_&&this.sourceBlock_.workspace)for(var c=this.getVariableTypes_(),d=0;d<c.length;d++){var e=this.sourceBlock_.workspace.getVariablesOfType(c[d]);b=b.concat(e)}b.sort(Blockly.VariableModel.compareByName);c=[];for(d=0;d<b.length;d++)c[d]=[b[d].name,b[d].getId()];c.push([Blockly.Msg.RENAME_VARIABLE,Blockly.RENAME_VARIABLE_ID]);\nBlockly.Msg.DELETE_VARIABLE&&c.push([Blockly.Msg.DELETE_VARIABLE.replace(\"%1\",a),Blockly.DELETE_VARIABLE_ID]);return c};Blockly.FieldVariable.prototype.onItemSelected_=function(a,b){a=b.getValue();if(this.sourceBlock_&&this.sourceBlock_.workspace){if(a==Blockly.RENAME_VARIABLE_ID){Blockly.Variables.renameVariable(this.sourceBlock_.workspace,this.variable_);return}if(a==Blockly.DELETE_VARIABLE_ID){this.sourceBlock_.workspace.deleteVariableById(this.variable_.getId());return}}this.setValue(a)};\nBlockly.FieldVariable.prototype.referencesVariables=function(){return!0};Blockly.fieldRegistry.register(\"field_variable\",Blockly.FieldVariable);Blockly.utils.svgPaths={};Blockly.utils.svgPaths.point=function(a,b){return\" \"+a+\",\"+b+\" \"};Blockly.utils.svgPaths.curve=function(a,b){return\" \"+a+b.join(\"\")};Blockly.utils.svgPaths.moveTo=function(a,b){return\" M \"+a+\",\"+b+\" \"};Blockly.utils.svgPaths.moveBy=function(a,b){return\" m \"+a+\",\"+b+\" \"};Blockly.utils.svgPaths.lineTo=function(a,b){return\" l \"+a+\",\"+b+\" \"};Blockly.utils.svgPaths.line=function(a){return\" l\"+a.join(\"\")};Blockly.utils.svgPaths.lineOnAxis=function(a,b){return\" \"+a+\" \"+b+\" \"};\nBlockly.utils.svgPaths.arc=function(a,b,c,d){return a+\" \"+c+\" \"+c+\" \"+b+d};Blockly.blockRendering.ConstantProvider=function(){this.NO_PADDING=0;this.SMALL_PADDING=3;this.MEDIUM_PADDING=5;this.MEDIUM_LARGE_PADDING=8;this.LARGE_PADDING=10;this.TALL_INPUT_FIELD_OFFSET_Y=this.MEDIUM_PADDING;this.TAB_HEIGHT=15;this.TAB_OFFSET_FROM_TOP=5;this.TAB_VERTICAL_OVERLAP=2.5;this.TAB_WIDTH=8;this.NOTCH_WIDTH=15;this.NOTCH_HEIGHT=4;this.MIN_BLOCK_WIDTH=12;this.EMPTY_BLOCK_SPACER_HEIGHT=16;this.DUMMY_INPUT_SHADOW_MIN_HEIGHT=this.DUMMY_INPUT_MIN_HEIGHT=this.TAB_HEIGHT;this.CORNER_RADIUS=\n8;this.STATEMENT_INPUT_NOTCH_OFFSET=this.NOTCH_OFFSET_LEFT=15;this.STATEMENT_BOTTOM_SPACER=0;this.STATEMENT_INPUT_PADDING_LEFT=20;this.BETWEEN_STATEMENT_PADDING_Y=4;this.TOP_ROW_MIN_HEIGHT=this.MEDIUM_PADDING;this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT=this.LARGE_PADDING;this.BOTTOM_ROW_MIN_HEIGHT=this.MEDIUM_PADDING;this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT=this.LARGE_PADDING;this.ADD_START_HATS=!1;this.START_HAT_HEIGHT=15;this.START_HAT_WIDTH=100;this.SPACER_DEFAULT_HEIGHT=15;this.MIN_BLOCK_HEIGHT=\n24;this.EMPTY_INLINE_INPUT_PADDING=14.5;this.EMPTY_INLINE_INPUT_HEIGHT=this.TAB_HEIGHT+11;this.EXTERNAL_VALUE_INPUT_PADDING=2;this.EMPTY_STATEMENT_INPUT_HEIGHT=this.MIN_BLOCK_HEIGHT;this.START_POINT=Blockly.utils.svgPaths.moveBy(0,0);this.JAGGED_TEETH_HEIGHT=12;this.JAGGED_TEETH_WIDTH=6;this.FIELD_TEXT_FONTSIZE=11;this.FIELD_TEXT_FONTWEIGHT=\"normal\";this.FIELD_TEXT_FONTFAMILY=\"sans-serif\";this.FIELD_TEXT_BASELINE=this.FIELD_TEXT_HEIGHT=-1;this.FIELD_BORDER_RECT_RADIUS=4;this.FIELD_BORDER_RECT_HEIGHT=\n16;this.FIELD_BORDER_RECT_X_PADDING=5;this.FIELD_BORDER_RECT_Y_PADDING=3;this.FIELD_BORDER_RECT_COLOUR=\"#fff\";this.FIELD_TEXT_BASELINE_CENTER=!Blockly.utils.userAgent.IE&&!Blockly.utils.userAgent.EDGE;this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT=this.FIELD_BORDER_RECT_HEIGHT;this.FIELD_DROPDOWN_SVG_ARROW=this.FIELD_DROPDOWN_COLOURED_DIV=this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW=!1;this.FIELD_DROPDOWN_SVG_ARROW_PADDING=this.FIELD_BORDER_RECT_X_PADDING;this.FIELD_DROPDOWN_SVG_ARROW_SIZE=12;this.FIELD_DROPDOWN_SVG_ARROW_DATAURI=\n\"data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=\";\nthis.FIELD_COLOUR_FULL_BLOCK=this.FIELD_TEXTINPUT_BOX_SHADOW=!1;this.FIELD_COLOUR_DEFAULT_WIDTH=26;this.FIELD_COLOUR_DEFAULT_HEIGHT=this.FIELD_BORDER_RECT_HEIGHT;this.FIELD_CHECKBOX_X_OFFSET=this.FIELD_BORDER_RECT_X_PADDING-3;this.randomIdentifier=String(Math.random()).substring(2);this.embossFilterId=\"\";this.embossFilter_=null;this.disabledPatternId=\"\";this.disabledPattern_=null;this.debugFilterId=\"\";this.cssNode_=this.debugFilter_=null;this.CURSOR_COLOUR=\"#cc0a0a\";this.MARKER_COLOUR=\"#4286f4\";this.CURSOR_WS_WIDTH=\n100;this.WS_CURSOR_HEIGHT=5;this.CURSOR_STACK_PADDING=10;this.CURSOR_BLOCK_PADDING=2;this.CURSOR_STROKE_WIDTH=4;this.FULL_BLOCK_FIELDS=!1;this.INSERTION_MARKER_COLOUR=\"#000000\";this.INSERTION_MARKER_OPACITY=.2;this.SHAPES={PUZZLE:1,NOTCH:2}};\nBlockly.blockRendering.ConstantProvider.prototype.init=function(){this.JAGGED_TEETH=this.makeJaggedTeeth();this.NOTCH=this.makeNotch();this.START_HAT=this.makeStartHat();this.PUZZLE_TAB=this.makePuzzleTab();this.INSIDE_CORNERS=this.makeInsideCorners();this.OUTSIDE_CORNERS=this.makeOutsideCorners()};Blockly.blockRendering.ConstantProvider.prototype.setTheme=function(a){this.blockStyles={};var b=a.blockStyles,c;for(c in b)this.blockStyles[c]=this.validatedBlockStyle_(b[c]);this.setDynamicProperties_(a)};\nBlockly.blockRendering.ConstantProvider.prototype.setDynamicProperties_=function(a){this.setFontConstants_(a);this.setComponentConstants_(a);this.ADD_START_HATS=null!=a.startHats?a.startHats:this.ADD_START_HATS};\nBlockly.blockRendering.ConstantProvider.prototype.setFontConstants_=function(a){this.FIELD_TEXT_FONTFAMILY=a.fontStyle&&void 0!=a.fontStyle.family?a.fontStyle.family:this.FIELD_TEXT_FONTFAMILY;this.FIELD_TEXT_FONTWEIGHT=a.fontStyle&&void 0!=a.fontStyle.weight?a.fontStyle.weight:this.FIELD_TEXT_FONTWEIGHT;this.FIELD_TEXT_FONTSIZE=a.fontStyle&&void 0!=a.fontStyle.size?a.fontStyle.size:this.FIELD_TEXT_FONTSIZE;a=Blockly.utils.dom.measureFontMetrics(\"Hg\",this.FIELD_TEXT_FONTSIZE+\"pt\",this.FIELD_TEXT_FONTWEIGHT,\nthis.FIELD_TEXT_FONTFAMILY);this.FIELD_TEXT_HEIGHT=a.height;this.FIELD_TEXT_BASELINE=a.baseline};\nBlockly.blockRendering.ConstantProvider.prototype.setComponentConstants_=function(a){this.CURSOR_COLOUR=a.getComponentStyle(\"cursorColour\")||this.CURSOR_COLOUR;this.MARKER_COLOUR=a.getComponentStyle(\"markerColour\")||this.MARKER_COLOUR;this.INSERTION_MARKER_COLOUR=a.getComponentStyle(\"insertionMarkerColour\")||this.INSERTION_MARKER_COLOUR;this.INSERTION_MARKER_OPACITY=Number(a.getComponentStyle(\"insertionMarkerOpacity\"))||this.INSERTION_MARKER_OPACITY};\nBlockly.blockRendering.ConstantProvider.prototype.getBlockStyleForColour=function(a){var b=\"auto_\"+a;this.blockStyles[b]||(this.blockStyles[b]=this.createBlockStyle_(a));return{style:this.blockStyles[b],name:b}};Blockly.blockRendering.ConstantProvider.prototype.getBlockStyle=function(a){return this.blockStyles[a||\"\"]||(a&&0==a.indexOf(\"auto_\")?this.getBlockStyleForColour(a.substring(5)).style:this.createBlockStyle_(\"#000000\"))};Blockly.blockRendering.ConstantProvider.prototype.createBlockStyle_=function(a){return this.validatedBlockStyle_({colourPrimary:a})};\nBlockly.blockRendering.ConstantProvider.prototype.validatedBlockStyle_=function(a){var b={};a&&Blockly.utils.object.mixin(b,a);a=Blockly.utils.parseBlockColour(b.colourPrimary||\"#000\");b.colourPrimary=a.hex;b.colourSecondary=b.colourSecondary?Blockly.utils.parseBlockColour(b.colourSecondary).hex:this.generateSecondaryColour_(b.colourPrimary);b.colourTertiary=b.colourTertiary?Blockly.utils.parseBlockColour(b.colourTertiary).hex:this.generateTertiaryColour_(b.colourPrimary);b.hat=b.hat||\"\";return b};\nBlockly.blockRendering.ConstantProvider.prototype.generateSecondaryColour_=function(a){return Blockly.utils.colour.blend(\"#fff\",a,.6)||a};Blockly.blockRendering.ConstantProvider.prototype.generateTertiaryColour_=function(a){return Blockly.utils.colour.blend(\"#fff\",a,.3)||a};\nBlockly.blockRendering.ConstantProvider.prototype.dispose=function(){this.embossFilter_&&Blockly.utils.dom.removeNode(this.embossFilter_);this.disabledPattern_&&Blockly.utils.dom.removeNode(this.disabledPattern_);this.debugFilter_&&Blockly.utils.dom.removeNode(this.debugFilter_);this.cssNode_=null};\nBlockly.blockRendering.ConstantProvider.prototype.makeJaggedTeeth=function(){var a=this.JAGGED_TEETH_HEIGHT,b=this.JAGGED_TEETH_WIDTH,c=Blockly.utils.svgPaths.line([Blockly.utils.svgPaths.point(b,a/4),Blockly.utils.svgPaths.point(2*-b,a/2),Blockly.utils.svgPaths.point(b,a/4)]);return{height:a,width:b,path:c}};\nBlockly.blockRendering.ConstantProvider.prototype.makeStartHat=function(){var a=this.START_HAT_HEIGHT,b=this.START_HAT_WIDTH,c=Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(30,-a),Blockly.utils.svgPaths.point(70,-a),Blockly.utils.svgPaths.point(b,0)]);return{height:a,width:b,path:c}};\nBlockly.blockRendering.ConstantProvider.prototype.makePuzzleTab=function(){function a(a){a=a?-1:1;var d=-a,e=c/2,f=e+2.5,l=e+.5,m=Blockly.utils.svgPaths.point(-b,a*e);e=Blockly.utils.svgPaths.point(b,a*e);return Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(0,a*f),Blockly.utils.svgPaths.point(-b,d*l),m])+Blockly.utils.svgPaths.curve(\"s\",[Blockly.utils.svgPaths.point(b,2.5*d),e])}var b=this.TAB_WIDTH,c=this.TAB_HEIGHT,d=a(!0),e=a(!1);return{type:this.SHAPES.PUZZLE,width:b,height:c,\npathDown:e,pathUp:d}};Blockly.blockRendering.ConstantProvider.prototype.makeNotch=function(){function a(a){return Blockly.utils.svgPaths.line([Blockly.utils.svgPaths.point(a*d,c),Blockly.utils.svgPaths.point(3*a,0),Blockly.utils.svgPaths.point(a*d,-c)])}var b=this.NOTCH_WIDTH,c=this.NOTCH_HEIGHT,d=(b-3)/2,e=a(1),f=a(-1);return{type:this.SHAPES.NOTCH,width:b,height:c,pathLeft:e,pathRight:f}};\nBlockly.blockRendering.ConstantProvider.prototype.makeInsideCorners=function(){var a=this.CORNER_RADIUS,b=Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a,Blockly.utils.svgPaths.point(-a,a)),c=Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a,Blockly.utils.svgPaths.point(a,a));return{width:a,height:a,pathTop:b,pathBottom:c}};\nBlockly.blockRendering.ConstantProvider.prototype.makeOutsideCorners=function(){var a=this.CORNER_RADIUS,b=Blockly.utils.svgPaths.moveBy(0,a)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(a,-a)),c=Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(a,a)),d=Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(-a,-a)),e=Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(-a,a));return{topLeft:b,topRight:c,bottomRight:e,bottomLeft:d,\nrightHeight:a}};Blockly.blockRendering.ConstantProvider.prototype.shapeFor=function(a){switch(a.type){case Blockly.INPUT_VALUE:case Blockly.OUTPUT_VALUE:return this.PUZZLE_TAB;case Blockly.PREVIOUS_STATEMENT:case Blockly.NEXT_STATEMENT:return this.NOTCH;default:throw Error(\"Unknown connection type\");}};\nBlockly.blockRendering.ConstantProvider.prototype.createDom=function(a,b,c){this.injectCSS_(b,c);a=Blockly.utils.dom.createSvgElement(\"defs\",{},a);b=Blockly.utils.dom.createSvgElement(\"filter\",{id:\"blocklyEmbossFilter\"+this.randomIdentifier},a);Blockly.utils.dom.createSvgElement(\"feGaussianBlur\",{\"in\":\"SourceAlpha\",stdDeviation:1,result:\"blur\"},b);c=Blockly.utils.dom.createSvgElement(\"feSpecularLighting\",{\"in\":\"blur\",surfaceScale:1,specularConstant:.5,specularExponent:10,\"lighting-color\":\"white\",\nresult:\"specOut\"},b);Blockly.utils.dom.createSvgElement(\"fePointLight\",{x:-5E3,y:-1E4,z:2E4},c);Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"specOut\",in2:\"SourceAlpha\",operator:\"in\",result:\"specOut\"},b);Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"SourceGraphic\",in2:\"specOut\",operator:\"arithmetic\",k1:0,k2:1,k3:1,k4:0},b);this.embossFilterId=b.id;this.embossFilter_=b;b=Blockly.utils.dom.createSvgElement(\"pattern\",{id:\"blocklyDisabledPattern\"+this.randomIdentifier,patternUnits:\"userSpaceOnUse\",\nwidth:10,height:10},a);Blockly.utils.dom.createSvgElement(\"rect\",{width:10,height:10,fill:\"#aaa\"},b);Blockly.utils.dom.createSvgElement(\"path\",{d:\"M 0 0 L 10 10 M 10 0 L 0 10\",stroke:\"#cc0\"},b);this.disabledPatternId=b.id;this.disabledPattern_=b;Blockly.blockRendering.Debug&&(a=Blockly.utils.dom.createSvgElement(\"filter\",{id:\"blocklyDebugFilter\"+this.randomIdentifier,height:\"160%\",width:\"180%\",y:\"-30%\",x:\"-40%\"},a),b=Blockly.utils.dom.createSvgElement(\"feComponentTransfer\",{result:\"outBlur\"},a),Blockly.utils.dom.createSvgElement(\"feFuncA\",\n{type:\"table\",tableValues:\"0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\"},b),Blockly.utils.dom.createSvgElement(\"feFlood\",{\"flood-color\":\"#ff0000\",\"flood-opacity\":.5,result:\"outColor\"},a),Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"outColor\",in2:\"outBlur\",operator:\"in\",result:\"outGlow\"},a),this.debugFilterId=a.id,this.debugFilter_=a)};\nBlockly.blockRendering.ConstantProvider.prototype.injectCSS_=function(a,b){b=this.getCSS_(b);a=\"blockly-renderer-style-\"+a;this.cssNode_=document.getElementById(a);var c=b.join(\"\\n\");this.cssNode_?this.cssNode_.firstChild.textContent=c:(b=document.createElement(\"style\"),b.id=a,a=document.createTextNode(c),b.appendChild(a),document.head.insertBefore(b,document.head.firstChild),this.cssNode_=b)};\nBlockly.blockRendering.ConstantProvider.prototype.getCSS_=function(a){return[a+\" .blocklyText, \",a+\" .blocklyFlyoutLabelText {\",\"font-family: \"+this.FIELD_TEXT_FONTFAMILY+\";\",\"font-size: \"+this.FIELD_TEXT_FONTSIZE+\"pt;\",\"font-weight: \"+this.FIELD_TEXT_FONTWEIGHT+\";\",\"}\",a+\" .blocklyText {\",\"fill: #fff;\",\"}\",a+\" .blocklyNonEditableText>rect,\",a+\" .blocklyEditableText>rect {\",\"fill: \"+this.FIELD_BORDER_RECT_COLOUR+\";\",\"fill-opacity: .6;\",\"stroke: none;\",\"}\",a+\" .blocklyNonEditableText>text,\",a+\" .blocklyEditableText>text {\",\n\"fill: #000;\",\"}\",a+\" .blocklyFlyoutLabelText {\",\"fill: #000;\",\"}\",a+\" .blocklyText.blocklyBubbleText {\",\"fill: #000;\",\"}\",a+\" .blocklyEditableText:not(.editing):hover>rect {\",\"stroke: #fff;\",\"stroke-width: 2;\",\"}\",a+\" .blocklyHtmlInput {\",\"font-family: \"+this.FIELD_TEXT_FONTFAMILY+\";\",\"font-weight: \"+this.FIELD_TEXT_FONTWEIGHT+\";\",\"}\",a+\" .blocklySelected>.blocklyPath {\",\"stroke: #fc3;\",\"stroke-width: 3px;\",\"}\",a+\" .blocklyHighlightedConnectionPath {\",\"stroke: #fc3;\",\"}\",a+\" .blocklyReplaceable .blocklyPath {\",\n\"fill-opacity: .5;\",\"}\",a+\" .blocklyReplaceable .blocklyPathLight,\",a+\" .blocklyReplaceable .blocklyPathDark {\",\"display: none;\",\"}\",a+\" .blocklyInsertionMarker>.blocklyPath {\",\"fill-opacity: \"+this.INSERTION_MARKER_OPACITY+\";\",\"stroke: none\",\"}\"]};Blockly.blockRendering.MarkerSvg=function(a,b,c){this.workspace_=a;this.marker_=c;this.parent_=null;this.constants_=b;this.currentMarkerSvg=null;a=this.isCursor()?this.constants_.CURSOR_COLOUR:this.constants_.MARKER_COLOUR;this.colour_=c.colour||a};Blockly.blockRendering.MarkerSvg.CURSOR_CLASS=\"blocklyCursor\";Blockly.blockRendering.MarkerSvg.MARKER_CLASS=\"blocklyMarker\";Blockly.blockRendering.MarkerSvg.HEIGHT_MULTIPLIER=.75;Blockly.blockRendering.MarkerSvg.prototype.getSvgRoot=function(){return this.svgGroup_};\nBlockly.blockRendering.MarkerSvg.prototype.isCursor=function(){return\"cursor\"==this.marker_.type};Blockly.blockRendering.MarkerSvg.prototype.createDom=function(){var a=this.isCursor()?Blockly.blockRendering.MarkerSvg.CURSOR_CLASS:Blockly.blockRendering.MarkerSvg.MARKER_CLASS;this.svgGroup_=Blockly.utils.dom.createSvgElement(\"g\",{\"class\":a},null);this.createDomInternal_();this.applyColour_();return this.svgGroup_};\nBlockly.blockRendering.MarkerSvg.prototype.setParent_=function(a){this.isCursor()?(this.parent_&&this.parent_.setCursorSvg(null),a.setCursorSvg(this.getSvgRoot())):(this.parent_&&this.parent_.setMarkerSvg(null),a.setMarkerSvg(this.getSvgRoot()));this.parent_=a};\nBlockly.blockRendering.MarkerSvg.prototype.showWithBlockPrevOutput_=function(a){if(a){var b=a.width,c=a.height,d=c*Blockly.blockRendering.MarkerSvg.HEIGHT_MULTIPLIER,e=this.constants_.CURSOR_BLOCK_PADDING;if(a.previousConnection){var f=this.constants_.shapeFor(a.previousConnection);this.positionPrevious_(b,e,d,f)}else a.outputConnection?(f=this.constants_.shapeFor(a.outputConnection),this.positionOutput_(b,c,f)):this.positionBlock_(b,e,d);this.setParent_(a);this.showCurrent_()}};\nBlockly.blockRendering.MarkerSvg.prototype.showWithCoordinates_=function(a){var b=a.getWsCoordinate();a=b.x;b=b.y;this.workspace_.RTL&&(a-=this.constants_.CURSOR_WS_WIDTH);this.positionLine_(a,b,this.constants_.CURSOR_WS_WIDTH);this.setParent_(this.workspace_);this.showCurrent_()};Blockly.blockRendering.MarkerSvg.prototype.showWithField_=function(a){a=a.getLocation();var b=a.getSize().width,c=a.getSize().height;this.positionRect_(0,0,b,c);this.setParent_(a);this.showCurrent_()};\nBlockly.blockRendering.MarkerSvg.prototype.showWithInput_=function(a){a=a.getLocation();var b=a.getSourceBlock();this.positionInput_(a);this.setParent_(b);this.showCurrent_()};Blockly.blockRendering.MarkerSvg.prototype.showWithNext_=function(a){var b=a.getLocation();a=b.getSourceBlock();var c=0;b=b.getOffsetInBlock().y;var d=a.getHeightWidth().width;this.workspace_.RTL&&(c=-d);this.positionLine_(c,b,d);this.setParent_(a);this.showCurrent_()};\nBlockly.blockRendering.MarkerSvg.prototype.showWithStack_=function(a){a=a.getLocation();var b=a.getHeightWidth(),c=b.width+this.constants_.CURSOR_STACK_PADDING;b=b.height+this.constants_.CURSOR_STACK_PADDING;var d=-this.constants_.CURSOR_STACK_PADDING/2,e=-this.constants_.CURSOR_STACK_PADDING/2,f=d;this.workspace_.RTL&&(f=-(c+d));this.positionRect_(f,e,c,b);this.setParent_(a);this.showCurrent_()};\nBlockly.blockRendering.MarkerSvg.prototype.showCurrent_=function(){this.hide();this.currentMarkerSvg.style.display=\"\"};Blockly.blockRendering.MarkerSvg.prototype.positionBlock_=function(a,b,c){a=Blockly.utils.svgPaths.moveBy(-b,c)+Blockly.utils.svgPaths.lineOnAxis(\"V\",-b)+Blockly.utils.svgPaths.lineOnAxis(\"H\",a+2*b)+Blockly.utils.svgPaths.lineOnAxis(\"V\",c);this.markerBlock_.setAttribute(\"d\",a);this.workspace_.RTL&&this.flipRtl_(this.markerBlock_);this.currentMarkerSvg=this.markerBlock_};\nBlockly.blockRendering.MarkerSvg.prototype.positionInput_=function(a){var b=a.getOffsetInBlock().x,c=a.getOffsetInBlock().y;a=Blockly.utils.svgPaths.moveTo(0,0)+this.constants_.shapeFor(a).pathDown;this.markerInput_.setAttribute(\"d\",a);this.markerInput_.setAttribute(\"transform\",\"translate(\"+b+\",\"+c+\")\"+(this.workspace_.RTL?\" scale(-1 1)\":\"\"));this.currentMarkerSvg=this.markerInput_};\nBlockly.blockRendering.MarkerSvg.prototype.positionLine_=function(a,b,c){this.markerSvgLine_.setAttribute(\"x\",a);this.markerSvgLine_.setAttribute(\"y\",b);this.markerSvgLine_.setAttribute(\"width\",c);this.currentMarkerSvg=this.markerSvgLine_};\nBlockly.blockRendering.MarkerSvg.prototype.positionOutput_=function(a,b,c){a=Blockly.utils.svgPaths.moveBy(a,0)+Blockly.utils.svgPaths.lineOnAxis(\"h\",-(a-c.width))+Blockly.utils.svgPaths.lineOnAxis(\"v\",this.constants_.TAB_OFFSET_FROM_TOP)+c.pathDown+Blockly.utils.svgPaths.lineOnAxis(\"V\",b)+Blockly.utils.svgPaths.lineOnAxis(\"H\",a);this.markerBlock_.setAttribute(\"d\",a);this.workspace_.RTL&&this.flipRtl_(this.markerBlock_);this.currentMarkerSvg=this.markerBlock_};\nBlockly.blockRendering.MarkerSvg.prototype.positionPrevious_=function(a,b,c,d){a=Blockly.utils.svgPaths.moveBy(-b,c)+Blockly.utils.svgPaths.lineOnAxis(\"V\",-b)+Blockly.utils.svgPaths.lineOnAxis(\"H\",this.constants_.NOTCH_OFFSET_LEFT)+d.pathLeft+Blockly.utils.svgPaths.lineOnAxis(\"H\",a+2*b)+Blockly.utils.svgPaths.lineOnAxis(\"V\",c);this.markerBlock_.setAttribute(\"d\",a);this.workspace_.RTL&&this.flipRtl_(this.markerBlock_);this.currentMarkerSvg=this.markerBlock_};\nBlockly.blockRendering.MarkerSvg.prototype.positionRect_=function(a,b,c,d){this.markerSvgRect_.setAttribute(\"x\",a);this.markerSvgRect_.setAttribute(\"y\",b);this.markerSvgRect_.setAttribute(\"width\",c);this.markerSvgRect_.setAttribute(\"height\",d);this.currentMarkerSvg=this.markerSvgRect_};Blockly.blockRendering.MarkerSvg.prototype.flipRtl_=function(a){a.setAttribute(\"transform\",\"scale(-1 1)\")};\nBlockly.blockRendering.MarkerSvg.prototype.hide=function(){this.markerSvgLine_.style.display=\"none\";this.markerSvgRect_.style.display=\"none\";this.markerInput_.style.display=\"none\";this.markerBlock_.style.display=\"none\"};\nBlockly.blockRendering.MarkerSvg.prototype.draw=function(a,b){if(b){this.constants_=this.workspace_.getRenderer().getConstants();var c=this.isCursor()?this.constants_.CURSOR_COLOUR:this.constants_.MARKER_COLOUR;this.colour_=this.marker_.colour||c;this.applyColour_();this.showAtLocation_(b);this.firemarkerEvent_(a,b);a=this.currentMarkerSvg.childNodes[0];void 0!==a&&a.beginElement&&a.beginElement()}else this.hide()};\nBlockly.blockRendering.MarkerSvg.prototype.showAtLocation_=function(a){a.getType()==Blockly.ASTNode.types.BLOCK?(a=a.getLocation(),this.showWithBlockPrevOutput_(a)):a.getType()==Blockly.ASTNode.types.OUTPUT?(a=a.getLocation().getSourceBlock(),this.showWithBlockPrevOutput_(a)):a.getLocation().type==Blockly.INPUT_VALUE?this.showWithInput_(a):a.getLocation().type==Blockly.NEXT_STATEMENT?this.showWithNext_(a):a.getType()==Blockly.ASTNode.types.PREVIOUS?(a=a.getLocation().getSourceBlock(),this.showWithBlockPrevOutput_(a)):\na.getType()==Blockly.ASTNode.types.FIELD?this.showWithField_(a):a.getType()==Blockly.ASTNode.types.WORKSPACE?this.showWithCoordinates_(a):a.getType()==Blockly.ASTNode.types.STACK&&this.showWithStack_(a)};Blockly.blockRendering.MarkerSvg.prototype.firemarkerEvent_=function(a,b){var c=b.getSourceBlock(),d=this.isCursor()?\"cursorMove\":\"markerMove\";a=new Blockly.Events.Ui(c,d,a,b);b.getType()==Blockly.ASTNode.types.WORKSPACE&&(a.workspaceId=b.getLocation().id);Blockly.Events.fire(a)};\nBlockly.blockRendering.MarkerSvg.prototype.getBlinkProperties_=function(){return{attributeType:\"XML\",attributeName:\"fill\",dur:\"1s\",values:this.colour_+\";transparent;transparent;\",repeatCount:\"indefinite\"}};\nBlockly.blockRendering.MarkerSvg.prototype.createDomInternal_=function(){this.markerSvg_=Blockly.utils.dom.createSvgElement(\"g\",{width:this.constants_.CURSOR_WS_WIDTH,height:this.constants_.WS_CURSOR_HEIGHT},this.svgGroup_);this.markerSvgLine_=Blockly.utils.dom.createSvgElement(\"rect\",{width:this.constants_.CURSOR_WS_WIDTH,height:this.constants_.WS_CURSOR_HEIGHT,style:\"display: none\"},this.markerSvg_);this.markerSvgRect_=Blockly.utils.dom.createSvgElement(\"rect\",{\"class\":\"blocklyVerticalMarker\",rx:10,\nry:10,style:\"display: none\"},this.markerSvg_);this.markerInput_=Blockly.utils.dom.createSvgElement(\"path\",{transform:\"\",style:\"display: none\"},this.markerSvg_);this.markerBlock_=Blockly.utils.dom.createSvgElement(\"path\",{transform:\"\",style:\"display: none\",fill:\"none\",\"stroke-width\":this.constants_.CURSOR_STROKE_WIDTH},this.markerSvg_);if(this.isCursor()){var a=this.getBlinkProperties_();Blockly.utils.dom.createSvgElement(\"animate\",a,this.markerSvgLine_);Blockly.utils.dom.createSvgElement(\"animate\",\na,this.markerInput_);a.attributeName=\"stroke\";Blockly.utils.dom.createSvgElement(\"animate\",a,this.markerBlock_)}return this.markerSvg_};\nBlockly.blockRendering.MarkerSvg.prototype.applyColour_=function(){this.markerSvgLine_.setAttribute(\"fill\",this.colour_);this.markerSvgRect_.setAttribute(\"stroke\",this.colour_);this.markerInput_.setAttribute(\"fill\",this.colour_);this.markerBlock_.setAttribute(\"stroke\",this.colour_);if(this.isCursor()){var a=this.colour_+\";transparent;transparent;\";this.markerSvgLine_.firstChild.setAttribute(\"values\",a);this.markerInput_.firstChild.setAttribute(\"values\",a);this.markerBlock_.firstChild.setAttribute(\"values\",\na)}};Blockly.blockRendering.MarkerSvg.prototype.dispose=function(){this.svgGroup_&&Blockly.utils.dom.removeNode(this.svgGroup_)};Blockly.blockRendering.Types={NONE:0,FIELD:1,HAT:2,ICON:4,SPACER:8,BETWEEN_ROW_SPACER:16,IN_ROW_SPACER:32,EXTERNAL_VALUE_INPUT:64,INPUT:128,INLINE_INPUT:256,STATEMENT_INPUT:512,CONNECTION:1024,PREVIOUS_CONNECTION:2048,NEXT_CONNECTION:4096,OUTPUT_CONNECTION:8192,CORNER:16384,LEFT_SQUARE_CORNER:32768,LEFT_ROUND_CORNER:65536,RIGHT_SQUARE_CORNER:131072,RIGHT_ROUND_CORNER:262144,JAGGED_EDGE:524288,ROW:1048576,TOP_ROW:2097152,BOTTOM_ROW:4194304,INPUT_ROW:8388608};\nBlockly.blockRendering.Types.LEFT_CORNER=Blockly.blockRendering.Types.LEFT_SQUARE_CORNER|Blockly.blockRendering.Types.LEFT_ROUND_CORNER;Blockly.blockRendering.Types.RIGHT_CORNER=Blockly.blockRendering.Types.RIGHT_SQUARE_CORNER|Blockly.blockRendering.Types.RIGHT_ROUND_CORNER;Blockly.blockRendering.Types.nextTypeValue_=16777216;\nBlockly.blockRendering.Types.getType=function(a){Blockly.blockRendering.Types.hasOwnProperty(a)||(Blockly.blockRendering.Types[a]=Blockly.blockRendering.Types.nextTypeValue_,Blockly.blockRendering.Types.nextTypeValue_<<=1);return Blockly.blockRendering.Types[a]};Blockly.blockRendering.Types.isField=function(a){return a.type&Blockly.blockRendering.Types.FIELD};Blockly.blockRendering.Types.isHat=function(a){return a.type&Blockly.blockRendering.Types.HAT};\nBlockly.blockRendering.Types.isIcon=function(a){return a.type&Blockly.blockRendering.Types.ICON};Blockly.blockRendering.Types.isSpacer=function(a){return a.type&Blockly.blockRendering.Types.SPACER};Blockly.blockRendering.Types.isInRowSpacer=function(a){return a.type&Blockly.blockRendering.Types.IN_ROW_SPACER};Blockly.blockRendering.Types.isInput=function(a){return a.type&Blockly.blockRendering.Types.INPUT};Blockly.blockRendering.Types.isExternalInput=function(a){return a.type&Blockly.blockRendering.Types.EXTERNAL_VALUE_INPUT};\nBlockly.blockRendering.Types.isInlineInput=function(a){return a.type&Blockly.blockRendering.Types.INLINE_INPUT};Blockly.blockRendering.Types.isStatementInput=function(a){return a.type&Blockly.blockRendering.Types.STATEMENT_INPUT};Blockly.blockRendering.Types.isPreviousConnection=function(a){return a.type&Blockly.blockRendering.Types.PREVIOUS_CONNECTION};Blockly.blockRendering.Types.isNextConnection=function(a){return a.type&Blockly.blockRendering.Types.NEXT_CONNECTION};\nBlockly.blockRendering.Types.isPreviousOrNextConnection=function(a){return a.type&(Blockly.blockRendering.Types.PREVIOUS_CONNECTION|Blockly.blockRendering.Types.NEXT_CONNECTION)};Blockly.blockRendering.Types.isLeftRoundedCorner=function(a){return a.type&Blockly.blockRendering.Types.LEFT_ROUND_CORNER};Blockly.blockRendering.Types.isRightRoundedCorner=function(a){return a.type&Blockly.blockRendering.Types.RIGHT_ROUND_CORNER};\nBlockly.blockRendering.Types.isLeftSquareCorner=function(a){return a.type&Blockly.blockRendering.Types.LEFT_SQUARE_CORNER};Blockly.blockRendering.Types.isRightSquareCorner=function(a){return a.type&Blockly.blockRendering.Types.RIGHT_SQUARE_CORNER};Blockly.blockRendering.Types.isCorner=function(a){return a.type&Blockly.blockRendering.Types.CORNER};Blockly.blockRendering.Types.isJaggedEdge=function(a){return a.type&Blockly.blockRendering.Types.JAGGED_EDGE};\nBlockly.blockRendering.Types.isRow=function(a){return a.type&Blockly.blockRendering.Types.ROW};Blockly.blockRendering.Types.isBetweenRowSpacer=function(a){return a.type&Blockly.blockRendering.Types.BETWEEN_ROW_SPACER};Blockly.blockRendering.Types.isTopRow=function(a){return a.type&Blockly.blockRendering.Types.TOP_ROW};Blockly.blockRendering.Types.isBottomRow=function(a){return a.type&Blockly.blockRendering.Types.BOTTOM_ROW};\nBlockly.blockRendering.Types.isTopOrBottomRow=function(a){return a.type&(Blockly.blockRendering.Types.TOP_ROW|Blockly.blockRendering.Types.BOTTOM_ROW)};Blockly.blockRendering.Types.isInputRow=function(a){return a.type&Blockly.blockRendering.Types.INPUT_ROW};Blockly.blockRendering.Measurable=function(a){this.height=this.width=0;this.type=Blockly.blockRendering.Types.NONE;this.centerline=this.xPos=0;this.constants_=a;this.notchOffset=this.constants_.NOTCH_OFFSET_LEFT};Blockly.blockRendering.Connection=function(a,b){Blockly.blockRendering.Connection.superClass_.constructor.call(this,a);this.connectionModel=b;this.shape=this.constants_.shapeFor(b);this.isDynamicShape=!!this.shape.isDynamic;this.type|=Blockly.blockRendering.Types.CONNECTION};Blockly.utils.object.inherits(Blockly.blockRendering.Connection,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.OutputConnection=function(a,b){Blockly.blockRendering.OutputConnection.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.OUTPUT_CONNECTION;this.height=this.isDynamicShape?0:this.shape.height;this.startX=this.width=this.isDynamicShape?0:this.shape.width;this.connectionOffsetY=this.constants_.TAB_OFFSET_FROM_TOP;this.connectionOffsetX=0};Blockly.utils.object.inherits(Blockly.blockRendering.OutputConnection,Blockly.blockRendering.Connection);\nBlockly.blockRendering.PreviousConnection=function(a,b){Blockly.blockRendering.PreviousConnection.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.PREVIOUS_CONNECTION;this.height=this.shape.height;this.width=this.shape.width};Blockly.utils.object.inherits(Blockly.blockRendering.PreviousConnection,Blockly.blockRendering.Connection);\nBlockly.blockRendering.NextConnection=function(a,b){Blockly.blockRendering.NextConnection.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.NEXT_CONNECTION;this.height=this.shape.height;this.width=this.shape.width};Blockly.utils.object.inherits(Blockly.blockRendering.NextConnection,Blockly.blockRendering.Connection);Blockly.blockRendering.InputConnection=function(a,b){Blockly.blockRendering.InputConnection.superClass_.constructor.call(this,a,b.connection);this.type|=Blockly.blockRendering.Types.INPUT;this.input=b;this.align=b.align;(this.connectedBlock=b.connection&&b.connection.targetBlock()?b.connection.targetBlock():null)?(a=this.connectedBlock.getHeightWidth(),this.connectedBlockWidth=a.width,this.connectedBlockHeight=a.height):this.connectedBlockHeight=this.connectedBlockWidth=0;this.connectionOffsetY=this.connectionOffsetX=\n0};Blockly.utils.object.inherits(Blockly.blockRendering.InputConnection,Blockly.blockRendering.Connection);\nBlockly.blockRendering.InlineInput=function(a,b){Blockly.blockRendering.InlineInput.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.INLINE_INPUT;this.connectedBlock?(this.width=this.connectedBlockWidth,this.height=this.connectedBlockHeight):(this.height=this.constants_.EMPTY_INLINE_INPUT_HEIGHT,this.width=this.constants_.EMPTY_INLINE_INPUT_PADDING);this.connectionHeight=this.isDynamicShape?this.shape.height(this.height):this.shape.height;this.connectionWidth=this.isDynamicShape?\nthis.shape.width(this.height):this.shape.width;this.connectedBlock||(this.width+=this.connectionWidth*(this.isDynamicShape?2:1));this.connectionOffsetY=this.isDynamicShape?this.shape.connectionOffsetY(this.connectionHeight):this.constants_.TAB_OFFSET_FROM_TOP;this.connectionOffsetX=this.isDynamicShape?this.shape.connectionOffsetX(this.connectionWidth):0};Blockly.utils.object.inherits(Blockly.blockRendering.InlineInput,Blockly.blockRendering.InputConnection);\nBlockly.blockRendering.StatementInput=function(a,b){Blockly.blockRendering.StatementInput.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.STATEMENT_INPUT;this.height=this.connectedBlock?this.connectedBlockHeight+this.constants_.STATEMENT_BOTTOM_SPACER:this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT;this.width=this.constants_.STATEMENT_INPUT_NOTCH_OFFSET+this.shape.width};Blockly.utils.object.inherits(Blockly.blockRendering.StatementInput,Blockly.blockRendering.InputConnection);\nBlockly.blockRendering.ExternalValueInput=function(a,b){Blockly.blockRendering.ExternalValueInput.superClass_.constructor.call(this,a,b);this.type|=Blockly.blockRendering.Types.EXTERNAL_VALUE_INPUT;this.height=this.connectedBlock?this.connectedBlockHeight-this.constants_.TAB_OFFSET_FROM_TOP-this.constants_.MEDIUM_PADDING:this.shape.height;this.width=this.shape.width+this.constants_.EXTERNAL_VALUE_INPUT_PADDING;this.connectionOffsetY=this.constants_.TAB_OFFSET_FROM_TOP;this.connectionHeight=this.shape.height;\nthis.connectionWidth=this.shape.width};Blockly.utils.object.inherits(Blockly.blockRendering.ExternalValueInput,Blockly.blockRendering.InputConnection);Blockly.blockRendering.Icon=function(a,b){Blockly.blockRendering.Icon.superClass_.constructor.call(this,a);this.icon=b;this.isVisible=b.isVisible();this.type|=Blockly.blockRendering.Types.ICON;a=b.getCorrectedSize();this.height=a.height;this.width=a.width};Blockly.utils.object.inherits(Blockly.blockRendering.Icon,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.JaggedEdge=function(a){Blockly.blockRendering.JaggedEdge.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.JAGGED_EDGE;this.height=this.constants_.JAGGED_TEETH.height;this.width=this.constants_.JAGGED_TEETH.width};Blockly.utils.object.inherits(Blockly.blockRendering.JaggedEdge,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.Field=function(a,b,c){Blockly.blockRendering.Field.superClass_.constructor.call(this,a);this.field=b;this.isEditable=b.EDITABLE;this.flipRtl=b.getFlipRtl();this.type|=Blockly.blockRendering.Types.FIELD;a=this.field.getSize();this.height=a.height;this.width=a.width;this.parentInput=c};Blockly.utils.object.inherits(Blockly.blockRendering.Field,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.Hat=function(a){Blockly.blockRendering.Hat.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.HAT;this.height=this.constants_.START_HAT.height;this.width=this.constants_.START_HAT.width;this.ascenderHeight=this.height};Blockly.utils.object.inherits(Blockly.blockRendering.Hat,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.SquareCorner=function(a,b){Blockly.blockRendering.SquareCorner.superClass_.constructor.call(this,a);this.type=(b&&\"left\"!=b?Blockly.blockRendering.Types.RIGHT_SQUARE_CORNER:Blockly.blockRendering.Types.LEFT_SQUARE_CORNER)|Blockly.blockRendering.Types.CORNER;this.width=this.height=this.constants_.NO_PADDING};Blockly.utils.object.inherits(Blockly.blockRendering.SquareCorner,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.RoundCorner=function(a,b){Blockly.blockRendering.RoundCorner.superClass_.constructor.call(this,a);this.type=(b&&\"left\"!=b?Blockly.blockRendering.Types.RIGHT_ROUND_CORNER:Blockly.blockRendering.Types.LEFT_ROUND_CORNER)|Blockly.blockRendering.Types.CORNER;this.width=this.constants_.CORNER_RADIUS;this.height=this.constants_.CORNER_RADIUS/2};Blockly.utils.object.inherits(Blockly.blockRendering.RoundCorner,Blockly.blockRendering.Measurable);\nBlockly.blockRendering.InRowSpacer=function(a,b){Blockly.blockRendering.InRowSpacer.superClass_.constructor.call(this,a);this.type=this.type|Blockly.blockRendering.Types.SPACER|Blockly.blockRendering.Types.IN_ROW_SPACER;this.width=b;this.height=this.constants_.SPACER_DEFAULT_HEIGHT};Blockly.utils.object.inherits(Blockly.blockRendering.InRowSpacer,Blockly.blockRendering.Measurable);Blockly.blockRendering.Row=function(a){this.type=Blockly.blockRendering.Types.ROW;this.elements=[];this.xPos=this.yPos=this.widthWithConnectedBlocks=this.minWidth=this.minHeight=this.width=this.height=0;this.hasJaggedEdge=this.hasDummyInput=this.hasInlineInput=this.hasStatement=this.hasExternalInput=!1;this.constants_=a;this.notchOffset=this.constants_.NOTCH_OFFSET_LEFT;this.align=null};\nBlockly.blockRendering.Row.prototype.measure=function(){throw Error(\"Unexpected attempt to measure a base Row.\");};Blockly.blockRendering.Row.prototype.getLastInput=function(){for(var a=this.elements.length-1,b;b=this.elements[a];a--)if(Blockly.blockRendering.Types.isInput(b))return b;return null};Blockly.blockRendering.Row.prototype.startsWithElemSpacer=function(){return!0};Blockly.blockRendering.Row.prototype.endsWithElemSpacer=function(){return!0};\nBlockly.blockRendering.Row.prototype.getFirstSpacer=function(){for(var a=0,b;b=this.elements[a];a++)if(Blockly.blockRendering.Types.isSpacer(b))return b;return null};Blockly.blockRendering.Row.prototype.getLastSpacer=function(){for(var a=this.elements.length-1,b;b=this.elements[a];a--)if(Blockly.blockRendering.Types.isSpacer(b))return b;return null};\nBlockly.blockRendering.TopRow=function(a){Blockly.blockRendering.TopRow.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.TOP_ROW;this.ascenderHeight=this.capline=0;this.hasPreviousConnection=!1;this.connection=null};Blockly.utils.object.inherits(Blockly.blockRendering.TopRow,Blockly.blockRendering.Row);\nBlockly.blockRendering.TopRow.prototype.hasLeftSquareCorner=function(a){var b=(a.hat?\"cap\"===a.hat:this.constants_.ADD_START_HATS)&&!a.outputConnection&&!a.previousConnection,c=a.getPreviousBlock();return!!a.outputConnection||b||(c?c.getNextBlock()==a:!1)};Blockly.blockRendering.TopRow.prototype.hasRightSquareCorner=function(a){return!0};\nBlockly.blockRendering.TopRow.prototype.measure=function(){for(var a=0,b=0,c=0,d=0,e;e=this.elements[d];d++)b+=e.width,Blockly.blockRendering.Types.isSpacer(e)||(Blockly.blockRendering.Types.isHat(e)?c=Math.max(c,e.ascenderHeight):a=Math.max(a,e.height));this.width=Math.max(this.minWidth,b);this.height=Math.max(this.minHeight,a)+c;this.capline=this.ascenderHeight=c;this.widthWithConnectedBlocks=this.width};Blockly.blockRendering.TopRow.prototype.startsWithElemSpacer=function(){return!1};\nBlockly.blockRendering.TopRow.prototype.endsWithElemSpacer=function(){return!1};Blockly.blockRendering.BottomRow=function(a){Blockly.blockRendering.BottomRow.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.BOTTOM_ROW;this.hasNextConnection=!1;this.connection=null;this.baseline=this.descenderHeight=0};Blockly.utils.object.inherits(Blockly.blockRendering.BottomRow,Blockly.blockRendering.Row);\nBlockly.blockRendering.BottomRow.prototype.hasLeftSquareCorner=function(a){return!!a.outputConnection||!!a.getNextBlock()};Blockly.blockRendering.BottomRow.prototype.hasRightSquareCorner=function(a){return!0};\nBlockly.blockRendering.BottomRow.prototype.measure=function(){for(var a=0,b=0,c=0,d=0,e;e=this.elements[d];d++)b+=e.width,Blockly.blockRendering.Types.isSpacer(e)||(Blockly.blockRendering.Types.isNextConnection(e)?c=Math.max(c,e.height):a=Math.max(a,e.height));this.width=Math.max(this.minWidth,b);this.height=Math.max(this.minHeight,a)+c;this.descenderHeight=c;this.widthWithConnectedBlocks=this.width};Blockly.blockRendering.BottomRow.prototype.startsWithElemSpacer=function(){return!1};\nBlockly.blockRendering.BottomRow.prototype.endsWithElemSpacer=function(){return!1};Blockly.blockRendering.SpacerRow=function(a,b,c){Blockly.blockRendering.SpacerRow.superClass_.constructor.call(this,a);this.type=this.type|Blockly.blockRendering.Types.SPACER|Blockly.blockRendering.Types.BETWEEN_ROW_SPACER;this.width=c;this.height=b;this.followsStatement=!1;this.widthWithConnectedBlocks=0;this.elements=[new Blockly.blockRendering.InRowSpacer(this.constants_,c)]};\nBlockly.utils.object.inherits(Blockly.blockRendering.SpacerRow,Blockly.blockRendering.Row);Blockly.blockRendering.SpacerRow.prototype.measure=function(){};Blockly.blockRendering.InputRow=function(a){Blockly.blockRendering.InputRow.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.INPUT_ROW;this.connectedBlockWidths=0};Blockly.utils.object.inherits(Blockly.blockRendering.InputRow,Blockly.blockRendering.Row);\nBlockly.blockRendering.InputRow.prototype.measure=function(){this.width=this.minWidth;this.height=this.minHeight;for(var a=0,b=0,c;c=this.elements[b];b++)this.width+=c.width,Blockly.blockRendering.Types.isInput(c)&&(Blockly.blockRendering.Types.isStatementInput(c)?a+=c.connectedBlockWidth:Blockly.blockRendering.Types.isExternalInput(c)&&0!=c.connectedBlockWidth&&(a+=c.connectedBlockWidth-c.connectionWidth)),Blockly.blockRendering.Types.isSpacer(c)||(this.height=Math.max(this.height,c.height));this.connectedBlockWidths=\na;this.widthWithConnectedBlocks=this.width+a};Blockly.blockRendering.InputRow.prototype.endsWithElemSpacer=function(){return!this.hasExternalInput&&!this.hasStatement};Blockly.blockRendering.RenderInfo=function(a,b){this.block_=b;this.renderer_=a;this.constants_=this.renderer_.getConstants();this.outputConnection=b.outputConnection?new Blockly.blockRendering.OutputConnection(this.constants_,b.outputConnection):null;this.isInline=b.getInputsInline()&&!b.isCollapsed();this.isCollapsed=b.isCollapsed();this.isInsertionMarker=b.isInsertionMarker();this.RTL=b.RTL;this.statementEdge=this.width=this.widthWithChildren=this.height=0;this.rows=[];this.inputRows=[];this.hiddenIcons=\n[];this.topRow=new Blockly.blockRendering.TopRow(this.constants_);this.bottomRow=new Blockly.blockRendering.BottomRow(this.constants_);this.startY=this.startX=0};Blockly.blockRendering.RenderInfo.prototype.getRenderer=function(){return this.renderer_};Blockly.blockRendering.RenderInfo.prototype.measure=function(){this.createRows_();this.addElemSpacing_();this.addRowSpacing_();this.computeBounds_();this.alignRowElements_();this.finalize_()};\nBlockly.blockRendering.RenderInfo.prototype.createRows_=function(){this.populateTopRow_();this.rows.push(this.topRow);var a=new Blockly.blockRendering.InputRow(this.constants_);this.inputRows.push(a);var b=this.block_.getIcons();if(b.length)for(var c=0,d;d=b[c];c++){var e=new Blockly.blockRendering.Icon(this.constants_,d);this.isCollapsed&&d.collapseHidden?this.hiddenIcons.push(e):a.elements.push(e)}d=null;for(c=0;b=this.block_.inputList[c];c++)if(b.isVisible()){this.shouldStartNewRow_(b,d)&&(this.rows.push(a),\na=new Blockly.blockRendering.InputRow(this.constants_),this.inputRows.push(a));for(d=0;e=b.fieldRow[d];d++)a.elements.push(new Blockly.blockRendering.Field(this.constants_,e,b));this.addInput_(b,a);d=b}this.isCollapsed&&(a.hasJaggedEdge=!0,a.elements.push(new Blockly.blockRendering.JaggedEdge(this.constants_)));(a.elements.length||a.hasDummyInput)&&this.rows.push(a);this.populateBottomRow_();this.rows.push(this.bottomRow)};\nBlockly.blockRendering.RenderInfo.prototype.populateTopRow_=function(){var a=!!this.block_.previousConnection,b=(this.block_.hat?\"cap\"===this.block_.hat:this.constants_.ADD_START_HATS)&&!this.outputConnection&&!a;this.topRow.hasLeftSquareCorner(this.block_)?this.topRow.elements.push(new Blockly.blockRendering.SquareCorner(this.constants_)):this.topRow.elements.push(new Blockly.blockRendering.RoundCorner(this.constants_));b?(a=new Blockly.blockRendering.Hat(this.constants_),this.topRow.elements.push(a),\nthis.topRow.capline=a.ascenderHeight):a&&(this.topRow.hasPreviousConnection=!0,this.topRow.connection=new Blockly.blockRendering.PreviousConnection(this.constants_,this.block_.previousConnection),this.topRow.elements.push(this.topRow.connection));this.block_.inputList.length&&this.block_.inputList[0].type==Blockly.NEXT_STATEMENT&&!this.block_.isCollapsed()?this.topRow.minHeight=this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT:this.topRow.minHeight=this.constants_.TOP_ROW_MIN_HEIGHT;this.topRow.hasRightSquareCorner(this.block_)?\nthis.topRow.elements.push(new Blockly.blockRendering.SquareCorner(this.constants_,\"right\")):this.topRow.elements.push(new Blockly.blockRendering.RoundCorner(this.constants_,\"right\"))};\nBlockly.blockRendering.RenderInfo.prototype.populateBottomRow_=function(){this.bottomRow.hasNextConnection=!!this.block_.nextConnection;this.bottomRow.minHeight=this.block_.inputList.length&&this.block_.inputList[this.block_.inputList.length-1].type==Blockly.NEXT_STATEMENT?this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT:this.constants_.BOTTOM_ROW_MIN_HEIGHT;this.bottomRow.hasLeftSquareCorner(this.block_)?this.bottomRow.elements.push(new Blockly.blockRendering.SquareCorner(this.constants_)):\nthis.bottomRow.elements.push(new Blockly.blockRendering.RoundCorner(this.constants_));this.bottomRow.hasNextConnection&&(this.bottomRow.connection=new Blockly.blockRendering.NextConnection(this.constants_,this.block_.nextConnection),this.bottomRow.elements.push(this.bottomRow.connection));this.bottomRow.hasRightSquareCorner(this.block_)?this.bottomRow.elements.push(new Blockly.blockRendering.SquareCorner(this.constants_,\"right\")):this.bottomRow.elements.push(new Blockly.blockRendering.RoundCorner(this.constants_,\n\"right\"))};\nBlockly.blockRendering.RenderInfo.prototype.addInput_=function(a,b){this.isInline&&a.type==Blockly.INPUT_VALUE?(b.elements.push(new Blockly.blockRendering.InlineInput(this.constants_,a)),b.hasInlineInput=!0):a.type==Blockly.NEXT_STATEMENT?(b.elements.push(new Blockly.blockRendering.StatementInput(this.constants_,a)),b.hasStatement=!0):a.type==Blockly.INPUT_VALUE?(b.elements.push(new Blockly.blockRendering.ExternalValueInput(this.constants_,a)),b.hasExternalInput=!0):a.type==Blockly.DUMMY_INPUT&&(b.minHeight=\nMath.max(b.minHeight,a.getSourceBlock()&&a.getSourceBlock().isShadow()?this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT:this.constants_.DUMMY_INPUT_MIN_HEIGHT),b.hasDummyInput=!0);null==b.align&&(b.align=a.align)};Blockly.blockRendering.RenderInfo.prototype.shouldStartNewRow_=function(a,b){return b?a.type==Blockly.NEXT_STATEMENT||b.type==Blockly.NEXT_STATEMENT?!0:a.type==Blockly.INPUT_VALUE||a.type==Blockly.DUMMY_INPUT?!this.isInline:!1:!1};\nBlockly.blockRendering.RenderInfo.prototype.addElemSpacing_=function(){for(var a=0,b;b=this.rows[a];a++){var c=b.elements;b.elements=[];b.startsWithElemSpacer()&&b.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,this.getInRowSpacing_(null,c[0])));if(c.length){for(var d=0;d<c.length-1;d++){b.elements.push(c[d]);var e=this.getInRowSpacing_(c[d],c[d+1]);b.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,e))}b.elements.push(c[c.length-1]);b.endsWithElemSpacer()&&\nb.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,this.getInRowSpacing_(c[c.length-1],null)))}}};\nBlockly.blockRendering.RenderInfo.prototype.getInRowSpacing_=function(a,b){if(!a&&b&&Blockly.blockRendering.Types.isStatementInput(b))return this.constants_.STATEMENT_INPUT_PADDING_LEFT;if(a&&Blockly.blockRendering.Types.isInput(a)&&!b){if(Blockly.blockRendering.Types.isExternalInput(a))return this.constants_.NO_PADDING;if(Blockly.blockRendering.Types.isInlineInput(a))return this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isStatementInput(a))return this.constants_.NO_PADDING}return a&&\nBlockly.blockRendering.Types.isLeftSquareCorner(a)&&b&&(Blockly.blockRendering.Types.isPreviousConnection(b)||Blockly.blockRendering.Types.isNextConnection(b))?b.notchOffset:a&&Blockly.blockRendering.Types.isLeftRoundedCorner(a)&&b&&(Blockly.blockRendering.Types.isPreviousConnection(b)||Blockly.blockRendering.Types.isNextConnection(b))?b.notchOffset-this.constants_.CORNER_RADIUS:this.constants_.MEDIUM_PADDING};\nBlockly.blockRendering.RenderInfo.prototype.computeBounds_=function(){for(var a=0,b=0,c=0,d=0,e;e=this.rows[d];d++){e.measure();b=Math.max(b,e.width);if(e.hasStatement){var f=e.getLastInput();a=Math.max(a,e.width-f.width)}c=Math.max(c,e.widthWithConnectedBlocks)}this.statementEdge=a;this.width=b;for(d=0;e=this.rows[d];d++)e.hasStatement&&(e.statementEdge=this.statementEdge);this.widthWithChildren=Math.max(b,c);this.outputConnection&&(this.startX=this.outputConnection.width,this.width+=this.outputConnection.width,\nthis.widthWithChildren+=this.outputConnection.width)};Blockly.blockRendering.RenderInfo.prototype.alignRowElements_=function(){for(var a=0,b;b=this.rows[a];a++)if(b.hasStatement)this.alignStatementRow_(b);else{var c=b.width;c=this.getDesiredRowWidth_(b)-c;0<c&&this.addAlignmentPadding_(b,c);Blockly.blockRendering.Types.isTopOrBottomRow(b)&&(b.widthWithConnectedBlocks=b.width)}};Blockly.blockRendering.RenderInfo.prototype.getDesiredRowWidth_=function(a){return this.width-this.startX};\nBlockly.blockRendering.RenderInfo.prototype.addAlignmentPadding_=function(a,b){var c=a.getFirstSpacer(),d=a.getLastSpacer();if(a.hasExternalInput||a.hasStatement)a.widthWithConnectedBlocks+=b;a.align==Blockly.ALIGN_LEFT?d.width+=b:a.align==Blockly.ALIGN_CENTRE?(c.width+=b/2,d.width+=b/2):a.align==Blockly.ALIGN_RIGHT?c.width+=b:d.width+=b;a.width+=b};\nBlockly.blockRendering.RenderInfo.prototype.alignStatementRow_=function(a){var b=a.getLastInput(),c=a.width-b.width,d=this.statementEdge;c=d-c;0<c&&this.addAlignmentPadding_(a,c);c=a.width;d=this.getDesiredRowWidth_(a);b.width+=d-c;b.height=Math.max(b.height,a.height);a.width+=d-c;a.widthWithConnectedBlocks=Math.max(a.width,this.statementEdge+a.connectedBlockWidths)};\nBlockly.blockRendering.RenderInfo.prototype.addRowSpacing_=function(){var a=this.rows;this.rows=[];for(var b=0;b<a.length;b++)this.rows.push(a[b]),b!=a.length-1&&this.rows.push(this.makeSpacerRow_(a[b],a[b+1]))};Blockly.blockRendering.RenderInfo.prototype.makeSpacerRow_=function(a,b){var c=this.getSpacerRowHeight_(a,b),d=this.getSpacerRowWidth_(a,b);c=new Blockly.blockRendering.SpacerRow(this.constants_,c,d);a.hasStatement&&(c.followsStatement=!0);b.hasStatement&&(c.precedesStatement=!0);return c};\nBlockly.blockRendering.RenderInfo.prototype.getSpacerRowWidth_=function(a,b){return this.width-this.startX};Blockly.blockRendering.RenderInfo.prototype.getSpacerRowHeight_=function(a,b){return this.constants_.MEDIUM_PADDING};\nBlockly.blockRendering.RenderInfo.prototype.getElemCenterline_=function(a,b){return Blockly.blockRendering.Types.isSpacer(b)?a.yPos+b.height/2:Blockly.blockRendering.Types.isBottomRow(a)?(a=a.yPos+a.height-a.descenderHeight,Blockly.blockRendering.Types.isNextConnection(b)?a+b.height/2:a-b.height/2):Blockly.blockRendering.Types.isTopRow(a)?Blockly.blockRendering.Types.isHat(b)?a.capline-b.height/2:a.capline+b.height/2:a.yPos+a.height/2};\nBlockly.blockRendering.RenderInfo.prototype.recordElemPositions_=function(a){for(var b=a.xPos,c=0,d;d=a.elements[c];c++)Blockly.blockRendering.Types.isSpacer(d)&&(d.height=a.height),d.xPos=b,d.centerline=this.getElemCenterline_(a,d),b+=d.width};\nBlockly.blockRendering.RenderInfo.prototype.finalize_=function(){for(var a=0,b=0,c=0,d;d=this.rows[c];c++)d.yPos=b,d.xPos=this.startX,b+=d.height,a=Math.max(a,d.widthWithConnectedBlocks),this.recordElemPositions_(d);this.outputConnection&&this.block_.nextConnection&&this.block_.nextConnection.isConnected()&&(a=Math.max(a,this.block_.nextConnection.targetBlock().getHeightWidth().width));this.widthWithChildren=a+this.startX;this.height=b;this.startY=this.topRow.capline;this.bottomRow.baseline=b-this.bottomRow.descenderHeight};Blockly.blockRendering.Drawer=function(a,b){this.block_=a;this.info_=b;this.topLeft_=a.getRelativeToSurfaceXY();this.inlinePath_=this.outlinePath_=\"\";this.constants_=b.getRenderer().getConstants()};\nBlockly.blockRendering.Drawer.prototype.draw=function(){this.hideHiddenIcons_();this.drawOutline_();this.drawInternals_();this.block_.pathObject.setPath(this.outlinePath_+\"\\n\"+this.inlinePath_);this.info_.RTL&&this.block_.pathObject.flipRTL();Blockly.blockRendering.useDebugger&&this.block_.renderingDebugger.drawDebug(this.block_,this.info_);this.recordSizeOnBlock_()};Blockly.blockRendering.Drawer.prototype.recordSizeOnBlock_=function(){this.block_.height=this.info_.height;this.block_.width=this.info_.widthWithChildren};\nBlockly.blockRendering.Drawer.prototype.hideHiddenIcons_=function(){for(var a=0,b;b=this.info_.hiddenIcons[a];a++)b.icon.iconGroup_.setAttribute(\"display\",\"none\")};Blockly.blockRendering.Drawer.prototype.drawOutline_=function(){this.drawTop_();for(var a=1;a<this.info_.rows.length-1;a++){var b=this.info_.rows[a];b.hasJaggedEdge?this.drawJaggedEdge_(b):b.hasStatement?this.drawStatementInput_(b):b.hasExternalInput?this.drawValueInput_(b):this.drawRightSideRow_(b)}this.drawBottom_();this.drawLeft_()};\nBlockly.blockRendering.Drawer.prototype.drawTop_=function(){var a=this.info_.topRow,b=a.elements;this.positionPreviousConnection_();this.outlinePath_+=Blockly.utils.svgPaths.moveBy(a.xPos,this.info_.startY);for(var c=0,d;d=b[c];c++)Blockly.blockRendering.Types.isLeftRoundedCorner(d)?this.outlinePath_+=this.constants_.OUTSIDE_CORNERS.topLeft:Blockly.blockRendering.Types.isRightRoundedCorner(d)?this.outlinePath_+=this.constants_.OUTSIDE_CORNERS.topRight:Blockly.blockRendering.Types.isPreviousConnection(d)?\nthis.outlinePath_+=d.shape.pathLeft:Blockly.blockRendering.Types.isHat(d)?this.outlinePath_+=this.constants_.START_HAT.path:Blockly.blockRendering.Types.isSpacer(d)&&(this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"h\",d.width));this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"v\",a.height)};Blockly.blockRendering.Drawer.prototype.drawJaggedEdge_=function(a){this.outlinePath_+=this.constants_.JAGGED_TEETH.path+Blockly.utils.svgPaths.lineOnAxis(\"v\",a.height-this.constants_.JAGGED_TEETH.height)};\nBlockly.blockRendering.Drawer.prototype.drawValueInput_=function(a){var b=a.getLastInput();this.positionExternalValueConnection_(a);var c=\"function\"==typeof b.shape.pathDown?b.shape.pathDown(b.height):b.shape.pathDown;this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",b.xPos+b.width)+c+Blockly.utils.svgPaths.lineOnAxis(\"v\",a.height-b.connectionHeight)};\nBlockly.blockRendering.Drawer.prototype.drawStatementInput_=function(a){var b=a.getLastInput(),c=b.xPos+b.notchOffset+b.shape.width;b=b.shape.pathRight+Blockly.utils.svgPaths.lineOnAxis(\"h\",-(b.notchOffset-this.constants_.INSIDE_CORNERS.width))+this.constants_.INSIDE_CORNERS.pathTop;var d=a.height-2*this.constants_.INSIDE_CORNERS.height;this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",c)+b+Blockly.utils.svgPaths.lineOnAxis(\"v\",d)+this.constants_.INSIDE_CORNERS.pathBottom+Blockly.utils.svgPaths.lineOnAxis(\"H\",\na.xPos+a.width);this.positionStatementInputConnection_(a)};Blockly.blockRendering.Drawer.prototype.drawRightSideRow_=function(a){this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.yPos+a.height)};\nBlockly.blockRendering.Drawer.prototype.drawBottom_=function(){var a=this.info_.bottomRow,b=a.elements;this.positionNextConnection_();for(var c=0,d=\"\",e=b.length-1,f;f=b[e];e--)Blockly.blockRendering.Types.isNextConnection(f)?d+=f.shape.pathRight:Blockly.blockRendering.Types.isLeftSquareCorner(f)?d+=Blockly.utils.svgPaths.lineOnAxis(\"H\",a.xPos):Blockly.blockRendering.Types.isLeftRoundedCorner(f)?d+=this.constants_.OUTSIDE_CORNERS.bottomLeft:Blockly.blockRendering.Types.isRightRoundedCorner(f)?(d+=\nthis.constants_.OUTSIDE_CORNERS.bottomRight,c=this.constants_.OUTSIDE_CORNERS.rightHeight):Blockly.blockRendering.Types.isSpacer(f)&&(d+=Blockly.utils.svgPaths.lineOnAxis(\"h\",-1*f.width));this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.baseline-c);this.outlinePath_+=d};\nBlockly.blockRendering.Drawer.prototype.drawLeft_=function(){var a=this.info_.outputConnection;this.positionOutputConnection_();if(a){var b=a.connectionOffsetY+a.height;a=\"function\"==typeof a.shape.pathUp?a.shape.pathUp(a.height):a.shape.pathUp;this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",b)+a}this.outlinePath_+=\"z\"};\nBlockly.blockRendering.Drawer.prototype.drawInternals_=function(){for(var a=0,b;b=this.info_.rows[a];a++)for(var c=0,d;d=b.elements[c];c++)Blockly.blockRendering.Types.isInlineInput(d)?this.drawInlineInput_(d):(Blockly.blockRendering.Types.isIcon(d)||Blockly.blockRendering.Types.isField(d))&&this.layoutField_(d)};\nBlockly.blockRendering.Drawer.prototype.layoutField_=function(a){if(Blockly.blockRendering.Types.isField(a))var b=a.field.getSvgRoot();else Blockly.blockRendering.Types.isIcon(a)&&(b=a.icon.iconGroup_);var c=a.centerline-a.height/2,d=a.xPos,e=\"\";this.info_.RTL&&(d=-(d+a.width),a.flipRtl&&(d+=a.width,e=\"scale(-1 1)\"));Blockly.blockRendering.Types.isIcon(a)?(b.setAttribute(\"display\",\"block\"),b.setAttribute(\"transform\",\"translate(\"+d+\",\"+c+\")\"),a.icon.computeIconLocation()):b.setAttribute(\"transform\",\n\"translate(\"+d+\",\"+c+\")\"+e);this.info_.isInsertionMarker&&b.setAttribute(\"display\",\"none\")};\nBlockly.blockRendering.Drawer.prototype.drawInlineInput_=function(a){var b=a.width,c=a.height,d=a.connectionOffsetY,e=a.connectionHeight+d;this.inlinePath_+=Blockly.utils.svgPaths.moveTo(a.xPos+a.connectionWidth,a.centerline-c/2)+Blockly.utils.svgPaths.lineOnAxis(\"v\",d)+a.shape.pathDown+Blockly.utils.svgPaths.lineOnAxis(\"v\",c-e)+Blockly.utils.svgPaths.lineOnAxis(\"h\",b-a.connectionWidth)+Blockly.utils.svgPaths.lineOnAxis(\"v\",-c)+\"z\";this.positionInlineInputConnection_(a)};\nBlockly.blockRendering.Drawer.prototype.positionInlineInputConnection_=function(a){var b=a.centerline-a.height/2;if(a.connectionModel){var c=a.xPos+a.connectionWidth+a.connectionOffsetX;this.info_.RTL&&(c*=-1);a.connectionModel.setOffsetInBlock(c,b+a.connectionOffsetY)}};\nBlockly.blockRendering.Drawer.prototype.positionStatementInputConnection_=function(a){var b=a.getLastInput();if(b.connectionModel){var c=a.xPos+a.statementEdge+b.notchOffset;this.info_.RTL&&(c*=-1);b.connectionModel.setOffsetInBlock(c,a.yPos)}};Blockly.blockRendering.Drawer.prototype.positionExternalValueConnection_=function(a){var b=a.getLastInput();if(b.connectionModel){var c=a.xPos+a.width;this.info_.RTL&&(c*=-1);b.connectionModel.setOffsetInBlock(c,a.yPos)}};\nBlockly.blockRendering.Drawer.prototype.positionPreviousConnection_=function(){var a=this.info_.topRow;if(a.connection){var b=a.xPos+a.notchOffset;a.connection.connectionModel.setOffsetInBlock(this.info_.RTL?-b:b,0)}};Blockly.blockRendering.Drawer.prototype.positionNextConnection_=function(){var a=this.info_.bottomRow;if(a.connection){var b=a.connection,c=b.xPos;b.connectionModel.setOffsetInBlock(this.info_.RTL?-c:c,a.baseline)}};\nBlockly.blockRendering.Drawer.prototype.positionOutputConnection_=function(){if(this.info_.outputConnection){var a=this.info_.startX+this.info_.outputConnection.connectionOffsetX;this.block_.outputConnection.setOffsetInBlock(this.info_.RTL?-a:a,this.info_.outputConnection.connectionOffsetY)}};Blockly.blockRendering.PathObject=function(a,b,c){this.constants=c;this.svgRoot=a;this.svgPath=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyPath\"},this.svgRoot);this.style=b;this.markerSvg=this.cursorSvg=null};Blockly.blockRendering.PathObject.prototype.setPath=function(a){this.svgPath.setAttribute(\"d\",a)};Blockly.blockRendering.PathObject.prototype.flipRTL=function(){this.svgPath.setAttribute(\"transform\",\"scale(-1 1)\")};\nBlockly.blockRendering.PathObject.prototype.setCursorSvg=function(a){a?(this.svgRoot.appendChild(a),this.cursorSvg=a):this.cursorSvg=null};Blockly.blockRendering.PathObject.prototype.setMarkerSvg=function(a){a?(this.cursorSvg?this.svgRoot.insertBefore(a,this.cursorSvg):this.svgRoot.appendChild(a),this.markerSvg=a):this.markerSvg=null};\nBlockly.blockRendering.PathObject.prototype.applyColour=function(a){this.svgPath.setAttribute(\"stroke\",this.style.colourTertiary);this.svgPath.setAttribute(\"fill\",this.style.colourPrimary);this.updateShadow_(a.isShadow());this.updateDisabled_(!a.isEnabled()||a.getInheritedDisabled())};Blockly.blockRendering.PathObject.prototype.setStyle=function(a){this.style=a};\nBlockly.blockRendering.PathObject.prototype.setClass_=function(a,b){b?Blockly.utils.dom.addClass(this.svgRoot,a):Blockly.utils.dom.removeClass(this.svgRoot,a)};Blockly.blockRendering.PathObject.prototype.updateHighlighted=function(a){a?this.svgPath.setAttribute(\"filter\",\"url(#\"+this.constants.embossFilterId+\")\"):this.svgPath.setAttribute(\"filter\",\"none\")};\nBlockly.blockRendering.PathObject.prototype.updateShadow_=function(a){a&&(this.svgPath.setAttribute(\"stroke\",\"none\"),this.svgPath.setAttribute(\"fill\",this.style.colourSecondary))};Blockly.blockRendering.PathObject.prototype.updateDisabled_=function(a){this.setClass_(\"blocklyDisabled\",a);a&&this.svgPath.setAttribute(\"fill\",\"url(#\"+this.constants.disabledPatternId+\")\")};Blockly.blockRendering.PathObject.prototype.updateSelected=function(a){this.setClass_(\"blocklySelected\",a)};\nBlockly.blockRendering.PathObject.prototype.updateDraggingDelete=function(a){this.setClass_(\"blocklyDraggingDelete\",a)};Blockly.blockRendering.PathObject.prototype.updateInsertionMarker=function(a){this.setClass_(\"blocklyInsertionMarker\",a)};Blockly.blockRendering.PathObject.prototype.updateMovable=function(a){this.setClass_(\"blocklyDraggable\",a)};Blockly.blockRendering.PathObject.prototype.updateReplacementFade=function(a){this.setClass_(\"blocklyReplaceable\",a)};\nBlockly.blockRendering.PathObject.prototype.updateShapeForInputHighlight=function(a,b){};Blockly.blockRendering.Renderer=function(a){this.name=a;this.overrides=this.constants_=null};Blockly.blockRendering.Renderer.prototype.getClassName=function(){return this.name+\"-renderer\"};Blockly.blockRendering.Renderer.prototype.init=function(a,b){this.constants_=this.makeConstants_();b&&(this.overrides=b,Blockly.utils.object.mixin(this.constants_,b));this.constants_.setTheme(a);this.constants_.init()};\nBlockly.blockRendering.Renderer.prototype.createDom=function(a,b){this.constants_.createDom(a,this.name+\"-\"+b.name,\".\"+this.getClassName()+\".\"+b.getClassName())};Blockly.blockRendering.Renderer.prototype.refreshDom=function(a,b){var c=this.getConstants();c.dispose();this.constants_=this.makeConstants_();this.overrides&&Blockly.utils.object.mixin(this.constants_,this.overrides);this.constants_.randomIdentifier=c.randomIdentifier;this.constants_.setTheme(b);this.constants_.init();this.createDom(a,b)};\nBlockly.blockRendering.Renderer.prototype.dispose=function(){this.constants_&&this.constants_.dispose()};Blockly.blockRendering.Renderer.prototype.makeConstants_=function(){return new Blockly.blockRendering.ConstantProvider};Blockly.blockRendering.Renderer.prototype.makeRenderInfo_=function(a){return new Blockly.blockRendering.RenderInfo(this,a)};Blockly.blockRendering.Renderer.prototype.makeDrawer_=function(a,b){return new Blockly.blockRendering.Drawer(a,b)};\nBlockly.blockRendering.Renderer.prototype.makeDebugger_=function(){if(!Blockly.blockRendering.Debug)throw Error(\"Missing require for Blockly.blockRendering.Debug\");return new Blockly.blockRendering.Debug(this.getConstants())};Blockly.blockRendering.Renderer.prototype.makeMarkerDrawer=function(a,b){return new Blockly.blockRendering.MarkerSvg(a,this.getConstants(),b)};Blockly.blockRendering.Renderer.prototype.makePathObject=function(a,b){return new Blockly.blockRendering.PathObject(a,b,this.constants_)};\nBlockly.blockRendering.Renderer.prototype.getConstants=function(){return this.constants_};Blockly.blockRendering.Renderer.prototype.shouldHighlightConnection=function(a){return!0};Blockly.blockRendering.Renderer.prototype.orphanCanConnectAtEnd=function(a,b,c){c==Blockly.OUTPUT_VALUE?(c=b.outputConnection,a=Blockly.Connection.lastConnectionInRow(a,b)):(c=b.previousConnection,a=a.lastConnectionInStack());return a?c.checkType(a):!1};\nBlockly.blockRendering.Renderer.prototype.getConnectionPreviewMethod=function(a,b,c){return b.type==Blockly.OUTPUT_VALUE||b.type==Blockly.PREVIOUS_STATEMENT?!a.isConnected()||this.orphanCanConnectAtEnd(c,a.targetBlock(),b.type)?Blockly.InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER:Blockly.InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE:Blockly.InsertionMarkerManager.PREVIEW_TYPE.INSERTION_MARKER};\nBlockly.blockRendering.Renderer.prototype.render=function(a){Blockly.blockRendering.useDebugger&&!a.renderingDebugger&&(a.renderingDebugger=this.makeDebugger_());var b=this.makeRenderInfo_(a);b.measure();this.makeDrawer_(a,b).draw()};Blockly.geras={};Blockly.geras.ConstantProvider=function(){Blockly.geras.ConstantProvider.superClass_.constructor.call(this);this.FIELD_TEXT_BASELINE_CENTER=!1;this.DARK_PATH_OFFSET=1;this.MAX_BOTTOM_WIDTH=30};Blockly.utils.object.inherits(Blockly.geras.ConstantProvider,Blockly.blockRendering.ConstantProvider);\nBlockly.geras.ConstantProvider.prototype.getCSS_=function(a){return Blockly.geras.ConstantProvider.superClass_.getCSS_.call(this,a).concat([a+\" .blocklyInsertionMarker>.blocklyPathLight,\",a+\" .blocklyInsertionMarker>.blocklyPathDark {\",\"fill-opacity: \"+this.INSERTION_MARKER_OPACITY+\";\",\"stroke: none\",\"}\"])};Blockly.geras.Highlighter=function(a){this.info_=a;this.inlineSteps_=this.steps_=\"\";this.RTL_=this.info_.RTL;a=a.getRenderer();this.constants_=a.getConstants();this.highlightConstants_=a.getHighlightConstants();this.highlightOffset_=this.highlightConstants_.OFFSET;this.outsideCornerPaths_=this.highlightConstants_.OUTSIDE_CORNER;this.insideCornerPaths_=this.highlightConstants_.INSIDE_CORNER;this.puzzleTabPaths_=this.highlightConstants_.PUZZLE_TAB;this.notchPaths_=this.highlightConstants_.NOTCH;this.startPaths_=\nthis.highlightConstants_.START_HAT;this.jaggedTeethPaths_=this.highlightConstants_.JAGGED_TEETH};Blockly.geras.Highlighter.prototype.getPath=function(){return this.steps_+\"\\n\"+this.inlineSteps_};\nBlockly.geras.Highlighter.prototype.drawTopCorner=function(a){this.steps_+=Blockly.utils.svgPaths.moveBy(a.xPos,this.info_.startY);for(var b=0,c;c=a.elements[b];b++)Blockly.blockRendering.Types.isLeftSquareCorner(c)?this.steps_+=this.highlightConstants_.START_POINT:Blockly.blockRendering.Types.isLeftRoundedCorner(c)?this.steps_+=this.outsideCornerPaths_.topLeft(this.RTL_):Blockly.blockRendering.Types.isPreviousConnection(c)?this.steps_+=this.notchPaths_.pathLeft:Blockly.blockRendering.Types.isHat(c)?\nthis.steps_+=this.startPaths_.path(this.RTL_):Blockly.blockRendering.Types.isSpacer(c)&&0!=c.width&&(this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",c.xPos+c.width-this.highlightOffset_));this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",a.xPos+a.width-this.highlightOffset_)};Blockly.geras.Highlighter.prototype.drawJaggedEdge_=function(a){this.info_.RTL&&(this.steps_+=this.jaggedTeethPaths_.pathLeft+Blockly.utils.svgPaths.lineOnAxis(\"v\",a.height-this.jaggedTeethPaths_.height-this.highlightOffset_))};\nBlockly.geras.Highlighter.prototype.drawValueInput=function(a){var b=a.getLastInput();if(this.RTL_){var c=a.height-b.connectionHeight;this.steps_+=Blockly.utils.svgPaths.moveTo(b.xPos+b.width-this.highlightOffset_,a.yPos)+this.puzzleTabPaths_.pathDown(this.RTL_)+Blockly.utils.svgPaths.lineOnAxis(\"v\",c)}else this.steps_+=Blockly.utils.svgPaths.moveTo(b.xPos+b.width,a.yPos)+this.puzzleTabPaths_.pathDown(this.RTL_)};\nBlockly.geras.Highlighter.prototype.drawStatementInput=function(a){var b=a.getLastInput();if(this.RTL_){var c=a.height-2*this.insideCornerPaths_.height;this.steps_+=Blockly.utils.svgPaths.moveTo(b.xPos,a.yPos)+this.insideCornerPaths_.pathTop(this.RTL_)+Blockly.utils.svgPaths.lineOnAxis(\"v\",c)+this.insideCornerPaths_.pathBottom(this.RTL_)+Blockly.utils.svgPaths.lineTo(a.width-b.xPos-this.insideCornerPaths_.width,0)}else this.steps_+=Blockly.utils.svgPaths.moveTo(b.xPos,a.yPos+a.height)+this.insideCornerPaths_.pathBottom(this.RTL_)+\nBlockly.utils.svgPaths.lineTo(a.width-b.xPos-this.insideCornerPaths_.width,0)};Blockly.geras.Highlighter.prototype.drawRightSideRow=function(a){var b=a.xPos+a.width-this.highlightOffset_;a.followsStatement&&(this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",b));this.RTL_&&(this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",b),a.height>this.highlightOffset_&&(this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.yPos+a.height-this.highlightOffset_)))};\nBlockly.geras.Highlighter.prototype.drawBottomRow=function(a){if(this.RTL_)this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.baseline-this.highlightOffset_);else{var b=this.info_.bottomRow.elements[0];Blockly.blockRendering.Types.isLeftSquareCorner(b)?this.steps_+=Blockly.utils.svgPaths.moveTo(a.xPos+this.highlightOffset_,a.baseline-this.highlightOffset_):Blockly.blockRendering.Types.isLeftRoundedCorner(b)&&(this.steps_+=Blockly.utils.svgPaths.moveTo(a.xPos,a.baseline),this.steps_+=this.outsideCornerPaths_.bottomLeft())}};\nBlockly.geras.Highlighter.prototype.drawLeft=function(){var a=this.info_.outputConnection;a&&(a=a.connectionOffsetY+a.height,this.RTL_?this.steps_+=Blockly.utils.svgPaths.moveTo(this.info_.startX,a):(this.steps_+=Blockly.utils.svgPaths.moveTo(this.info_.startX+this.highlightOffset_,this.info_.bottomRow.baseline-this.highlightOffset_),this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a)),this.steps_+=this.puzzleTabPaths_.pathUp(this.RTL_));this.RTL_||(a=this.info_.topRow,Blockly.blockRendering.Types.isLeftRoundedCorner(a.elements[0])?\nthis.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",this.outsideCornerPaths_.height):this.steps_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.capline+this.highlightOffset_))};\nBlockly.geras.Highlighter.prototype.drawInlineInput=function(a){var b=this.highlightOffset_,c=a.xPos+a.connectionWidth,d=a.centerline-a.height/2,e=a.width-a.connectionWidth,f=d+b;this.RTL_?(d=a.connectionOffsetY-b,a=a.height-(a.connectionOffsetY+a.connectionHeight)+b,this.inlineSteps_+=Blockly.utils.svgPaths.moveTo(c-b,f)+Blockly.utils.svgPaths.lineOnAxis(\"v\",d)+this.puzzleTabPaths_.pathDown(this.RTL_)+Blockly.utils.svgPaths.lineOnAxis(\"v\",a)+Blockly.utils.svgPaths.lineOnAxis(\"h\",e)):this.inlineSteps_+=\nBlockly.utils.svgPaths.moveTo(a.xPos+a.width+b,f)+Blockly.utils.svgPaths.lineOnAxis(\"v\",a.height)+Blockly.utils.svgPaths.lineOnAxis(\"h\",-e)+Blockly.utils.svgPaths.moveTo(c,d+a.connectionOffsetY)+this.puzzleTabPaths_.pathDown(this.RTL_)};Blockly.geras.InlineInput=function(a,b){Blockly.geras.InlineInput.superClass_.constructor.call(this,a,b);this.connectedBlock&&(this.width+=this.constants_.DARK_PATH_OFFSET,this.height+=this.constants_.DARK_PATH_OFFSET)};Blockly.utils.object.inherits(Blockly.geras.InlineInput,Blockly.blockRendering.InlineInput);Blockly.geras.StatementInput=function(a,b){Blockly.geras.StatementInput.superClass_.constructor.call(this,a,b);this.connectedBlock&&(this.height+=this.constants_.DARK_PATH_OFFSET)};\nBlockly.utils.object.inherits(Blockly.geras.StatementInput,Blockly.blockRendering.StatementInput);Blockly.geras.RenderInfo=function(a,b){Blockly.geras.RenderInfo.superClass_.constructor.call(this,a,b)};Blockly.utils.object.inherits(Blockly.geras.RenderInfo,Blockly.blockRendering.RenderInfo);Blockly.geras.RenderInfo.prototype.getRenderer=function(){return this.renderer_};\nBlockly.geras.RenderInfo.prototype.populateBottomRow_=function(){Blockly.geras.RenderInfo.superClass_.populateBottomRow_.call(this);this.block_.inputList.length&&this.block_.inputList[this.block_.inputList.length-1].type==Blockly.NEXT_STATEMENT||(this.bottomRow.minHeight=this.constants_.MEDIUM_PADDING-this.constants_.DARK_PATH_OFFSET)};\nBlockly.geras.RenderInfo.prototype.addInput_=function(a,b){this.isInline&&a.type==Blockly.INPUT_VALUE?(b.elements.push(new Blockly.geras.InlineInput(this.constants_,a)),b.hasInlineInput=!0):a.type==Blockly.NEXT_STATEMENT?(b.elements.push(new Blockly.geras.StatementInput(this.constants_,a)),b.hasStatement=!0):a.type==Blockly.INPUT_VALUE?(b.elements.push(new Blockly.blockRendering.ExternalValueInput(this.constants_,a)),b.hasExternalInput=!0):a.type==Blockly.DUMMY_INPUT&&(b.minHeight=Math.max(b.minHeight,\nthis.constants_.DUMMY_INPUT_MIN_HEIGHT),b.hasDummyInput=!0);this.isInline||null!=b.align||(b.align=a.align)};\nBlockly.geras.RenderInfo.prototype.addElemSpacing_=function(){for(var a=!1,b=0,c;c=this.rows[b];b++)c.hasExternalInput&&(a=!0);for(b=0;c=this.rows[b];b++){var d=c.elements;c.elements=[];c.startsWithElemSpacer()&&c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,this.getInRowSpacing_(null,d[0])));if(d.length){for(var e=0;e<d.length-1;e++){c.elements.push(d[e]);var f=this.getInRowSpacing_(d[e],d[e+1]);c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,f))}c.elements.push(d[d.length-\n1]);c.endsWithElemSpacer()&&(f=this.getInRowSpacing_(d[d.length-1],null),a&&c.hasDummyInput&&(f+=this.constants_.TAB_WIDTH),c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,f)))}}};\nBlockly.geras.RenderInfo.prototype.getInRowSpacing_=function(a,b){if(!a)return b&&Blockly.blockRendering.Types.isField(b)&&b.isEditable?this.constants_.MEDIUM_PADDING:b&&Blockly.blockRendering.Types.isInlineInput(b)?this.constants_.MEDIUM_LARGE_PADDING:b&&Blockly.blockRendering.Types.isStatementInput(b)?this.constants_.STATEMENT_INPUT_PADDING_LEFT:this.constants_.LARGE_PADDING;if(!Blockly.blockRendering.Types.isInput(a)&&(!b||Blockly.blockRendering.Types.isStatementInput(b)))return Blockly.blockRendering.Types.isField(a)&&\na.isEditable?this.constants_.MEDIUM_PADDING:Blockly.blockRendering.Types.isIcon(a)?2*this.constants_.LARGE_PADDING+1:Blockly.blockRendering.Types.isHat(a)?this.constants_.NO_PADDING:Blockly.blockRendering.Types.isPreviousOrNextConnection(a)?this.constants_.LARGE_PADDING:Blockly.blockRendering.Types.isLeftRoundedCorner(a)?this.constants_.MIN_BLOCK_WIDTH:Blockly.blockRendering.Types.isJaggedEdge(a)?this.constants_.NO_PADDING:this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isInput(a)&&\n!b){if(Blockly.blockRendering.Types.isExternalInput(a))return this.constants_.NO_PADDING;if(Blockly.blockRendering.Types.isInlineInput(a))return this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isStatementInput(a))return this.constants_.NO_PADDING}if(!Blockly.blockRendering.Types.isInput(a)&&b&&Blockly.blockRendering.Types.isInput(b)){if(Blockly.blockRendering.Types.isField(a)&&a.isEditable){if(Blockly.blockRendering.Types.isInlineInput(b)||Blockly.blockRendering.Types.isExternalInput(b))return this.constants_.SMALL_PADDING}else{if(Blockly.blockRendering.Types.isInlineInput(b)||\nBlockly.blockRendering.Types.isExternalInput(b))return this.constants_.MEDIUM_LARGE_PADDING;if(Blockly.blockRendering.Types.isStatementInput(b))return this.constants_.LARGE_PADDING}return this.constants_.LARGE_PADDING-1}if(Blockly.blockRendering.Types.isIcon(a)&&b&&!Blockly.blockRendering.Types.isInput(b))return this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isInlineInput(a)&&b&&Blockly.blockRendering.Types.isField(b))return b.isEditable?this.constants_.MEDIUM_PADDING:this.constants_.LARGE_PADDING;\nif(Blockly.blockRendering.Types.isLeftSquareCorner(a)&&b){if(Blockly.blockRendering.Types.isHat(b))return this.constants_.NO_PADDING;if(Blockly.blockRendering.Types.isPreviousConnection(b))return b.notchOffset;if(Blockly.blockRendering.Types.isNextConnection(b))return a=(this.RTL?1:-1)*this.constants_.DARK_PATH_OFFSET/2,b.notchOffset+a}if(Blockly.blockRendering.Types.isLeftRoundedCorner(a)&&b){if(Blockly.blockRendering.Types.isPreviousConnection(b))return b.notchOffset-this.constants_.CORNER_RADIUS;\nif(Blockly.blockRendering.Types.isNextConnection(b))return a=(this.RTL?1:-1)*this.constants_.DARK_PATH_OFFSET/2,b.notchOffset-this.constants_.CORNER_RADIUS+a}return Blockly.blockRendering.Types.isField(a)&&b&&Blockly.blockRendering.Types.isField(b)&&a.isEditable==b.isEditable||b&&Blockly.blockRendering.Types.isJaggedEdge(b)?this.constants_.LARGE_PADDING:this.constants_.MEDIUM_PADDING};\nBlockly.geras.RenderInfo.prototype.getSpacerRowHeight_=function(a,b){return Blockly.blockRendering.Types.isTopRow(a)&&Blockly.blockRendering.Types.isBottomRow(b)?this.constants_.EMPTY_BLOCK_SPACER_HEIGHT:Blockly.blockRendering.Types.isTopRow(a)||Blockly.blockRendering.Types.isBottomRow(b)?this.constants_.NO_PADDING:a.hasExternalInput&&b.hasExternalInput?this.constants_.LARGE_PADDING:!a.hasStatement&&b.hasStatement?this.constants_.BETWEEN_STATEMENT_PADDING_Y:a.hasStatement&&b.hasStatement||!a.hasStatement&&\nb.hasDummyInput||a.hasDummyInput?this.constants_.LARGE_PADDING:this.constants_.MEDIUM_PADDING};\nBlockly.geras.RenderInfo.prototype.getElemCenterline_=function(a,b){if(Blockly.blockRendering.Types.isSpacer(b))return a.yPos+b.height/2;if(Blockly.blockRendering.Types.isBottomRow(a))return a=a.yPos+a.height-a.descenderHeight,Blockly.blockRendering.Types.isNextConnection(b)?a+b.height/2:a-b.height/2;if(Blockly.blockRendering.Types.isTopRow(a))return Blockly.blockRendering.Types.isHat(b)?a.capline-b.height/2:a.capline+b.height/2;var c=a.yPos;Blockly.blockRendering.Types.isField(b)||Blockly.blockRendering.Types.isIcon(b)?\n(c+=b.height/2,(a.hasInlineInput||a.hasStatement)&&b.height+this.constants_.TALL_INPUT_FIELD_OFFSET_Y<=a.height&&(c+=this.constants_.TALL_INPUT_FIELD_OFFSET_Y)):c=Blockly.blockRendering.Types.isInlineInput(b)?c+b.height/2:c+a.height/2;return c};\nBlockly.geras.RenderInfo.prototype.alignRowElements_=function(){if(this.isInline){for(var a=0,b=null,c=this.rows.length-1,d;d=this.rows[c];c--)d.nextRightEdge=a,Blockly.blockRendering.Types.isInputRow(d)&&(d.hasStatement&&this.alignStatementRow_(d),b&&b.hasStatement&&d.width<b.width?d.nextRightEdge=b.width:a=d.width,b=d);for(c=a=0;d=this.rows[c];c++)d.hasStatement?a=this.getDesiredRowWidth_(d):Blockly.blockRendering.Types.isSpacer(d)?d.width=Math.max(a,d.nextRightEdge):(a=Math.max(a,d.nextRightEdge)-\nd.width,0<a&&this.addAlignmentPadding_(d,a),a=d.width)}else Blockly.geras.RenderInfo.superClass_.alignRowElements_.call(this)};Blockly.geras.RenderInfo.prototype.getDesiredRowWidth_=function(a){return this.isInline&&a.hasStatement?this.statementEdge+this.constants_.MAX_BOTTOM_WIDTH+this.startX:Blockly.geras.RenderInfo.superClass_.getDesiredRowWidth_.call(this,a)};\nBlockly.geras.RenderInfo.prototype.finalize_=function(){for(var a=0,b=0,c=0,d;d=this.rows[c];c++){d.yPos=b;d.xPos=this.startX;b+=d.height;a=Math.max(a,d.widthWithConnectedBlocks);var e=b-this.topRow.ascenderHeight;d==this.bottomRow&&e<this.constants_.MIN_BLOCK_HEIGHT&&(e=this.constants_.MIN_BLOCK_HEIGHT-e,this.bottomRow.height+=e,b+=e);this.recordElemPositions_(d)}this.outputConnection&&this.block_.nextConnection&&this.block_.nextConnection.isConnected()&&(a=Math.max(a,this.block_.nextConnection.targetBlock().getHeightWidth().width-\nthis.constants_.DARK_PATH_OFFSET));this.bottomRow.baseline=b-this.bottomRow.descenderHeight;this.widthWithChildren=a+this.startX+this.constants_.DARK_PATH_OFFSET;this.width+=this.constants_.DARK_PATH_OFFSET;this.height=b+this.constants_.DARK_PATH_OFFSET;this.startY=this.topRow.capline};Blockly.geras.Drawer=function(a,b){Blockly.geras.Drawer.superClass_.constructor.call(this,a,b);this.highlighter_=new Blockly.geras.Highlighter(b)};Blockly.utils.object.inherits(Blockly.geras.Drawer,Blockly.blockRendering.Drawer);\nBlockly.geras.Drawer.prototype.draw=function(){this.hideHiddenIcons_();this.drawOutline_();this.drawInternals_();var a=this.block_.pathObject;a.setPath(this.outlinePath_+\"\\n\"+this.inlinePath_);a.setHighlightPath(this.highlighter_.getPath());this.info_.RTL&&a.flipRTL();Blockly.blockRendering.useDebugger&&this.block_.renderingDebugger.drawDebug(this.block_,this.info_);this.recordSizeOnBlock_()};\nBlockly.geras.Drawer.prototype.drawTop_=function(){this.highlighter_.drawTopCorner(this.info_.topRow);this.highlighter_.drawRightSideRow(this.info_.topRow);Blockly.geras.Drawer.superClass_.drawTop_.call(this)};Blockly.geras.Drawer.prototype.drawJaggedEdge_=function(a){this.highlighter_.drawJaggedEdge_(a);Blockly.geras.Drawer.superClass_.drawJaggedEdge_.call(this,a)};\nBlockly.geras.Drawer.prototype.drawValueInput_=function(a){this.highlighter_.drawValueInput(a);Blockly.geras.Drawer.superClass_.drawValueInput_.call(this,a)};Blockly.geras.Drawer.prototype.drawStatementInput_=function(a){this.highlighter_.drawStatementInput(a);Blockly.geras.Drawer.superClass_.drawStatementInput_.call(this,a)};\nBlockly.geras.Drawer.prototype.drawRightSideRow_=function(a){this.highlighter_.drawRightSideRow(a);this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",a.xPos+a.width)+Blockly.utils.svgPaths.lineOnAxis(\"V\",a.yPos+a.height)};Blockly.geras.Drawer.prototype.drawBottom_=function(){this.highlighter_.drawBottomRow(this.info_.bottomRow);Blockly.geras.Drawer.superClass_.drawBottom_.call(this)};Blockly.geras.Drawer.prototype.drawLeft_=function(){this.highlighter_.drawLeft();Blockly.geras.Drawer.superClass_.drawLeft_.call(this)};\nBlockly.geras.Drawer.prototype.drawInlineInput_=function(a){this.highlighter_.drawInlineInput(a);Blockly.geras.Drawer.superClass_.drawInlineInput_.call(this,a)};Blockly.geras.Drawer.prototype.positionInlineInputConnection_=function(a){var b=a.centerline-a.height/2;if(a.connectionModel){var c=a.xPos+a.connectionWidth+this.constants_.DARK_PATH_OFFSET;this.info_.RTL&&(c*=-1);a.connectionModel.setOffsetInBlock(c,b+a.connectionOffsetY+this.constants_.DARK_PATH_OFFSET)}};\nBlockly.geras.Drawer.prototype.positionStatementInputConnection_=function(a){var b=a.getLastInput();if(b.connectionModel){var c=a.xPos+a.statementEdge+b.notchOffset;c=this.info_.RTL?-1*c:c+this.constants_.DARK_PATH_OFFSET;b.connectionModel.setOffsetInBlock(c,a.yPos+this.constants_.DARK_PATH_OFFSET)}};\nBlockly.geras.Drawer.prototype.positionExternalValueConnection_=function(a){var b=a.getLastInput();if(b.connectionModel){var c=a.xPos+a.width+this.constants_.DARK_PATH_OFFSET;this.info_.RTL&&(c*=-1);b.connectionModel.setOffsetInBlock(c,a.yPos)}};Blockly.geras.Drawer.prototype.positionNextConnection_=function(){var a=this.info_.bottomRow;if(a.connection){var b=a.connection,c=b.xPos;b.connectionModel.setOffsetInBlock((this.info_.RTL?-c:c)+this.constants_.DARK_PATH_OFFSET/2,a.baseline+this.constants_.DARK_PATH_OFFSET)}};Blockly.geras.HighlightConstantProvider=function(a){this.constantProvider=a;this.OFFSET=.5;this.START_POINT=Blockly.utils.svgPaths.moveBy(this.OFFSET,this.OFFSET)};Blockly.geras.HighlightConstantProvider.prototype.init=function(){this.INSIDE_CORNER=this.makeInsideCorner();this.OUTSIDE_CORNER=this.makeOutsideCorner();this.PUZZLE_TAB=this.makePuzzleTab();this.NOTCH=this.makeNotch();this.JAGGED_TEETH=this.makeJaggedTeeth();this.START_HAT=this.makeStartHat()};\nBlockly.geras.HighlightConstantProvider.prototype.makeInsideCorner=function(){var a=this.constantProvider.CORNER_RADIUS,b=this.OFFSET,c=(1-Math.SQRT1_2)*(a+b)-b,d=Blockly.utils.svgPaths.moveBy(c,c)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a,Blockly.utils.svgPaths.point(-c-b,a-c)),e=Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a+b,Blockly.utils.svgPaths.point(a+b,a+b)),f=Blockly.utils.svgPaths.moveBy(c,-c)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a+b,Blockly.utils.svgPaths.point(a-c,c+b));return{width:a+b,height:a,\npathTop:function(a){return a?d:\"\"},pathBottom:function(a){return a?e:f}}};\nBlockly.geras.HighlightConstantProvider.prototype.makeOutsideCorner=function(){var a=this.constantProvider.CORNER_RADIUS,b=this.OFFSET,c=(1-Math.SQRT1_2)*(a-b)+b,d=Blockly.utils.svgPaths.moveBy(c,c)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a-b,Blockly.utils.svgPaths.point(a-c,-c+b)),e=Blockly.utils.svgPaths.moveBy(b,a)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a-b,Blockly.utils.svgPaths.point(a,-a+b)),f=-c,g=Blockly.utils.svgPaths.moveBy(c,f)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a-b,Blockly.utils.svgPaths.point(-c+\nb,-f-a));return{height:a,topLeft:function(a){return a?d:e},bottomLeft:function(){return g}}};\nBlockly.geras.HighlightConstantProvider.prototype.makePuzzleTab=function(){var a=this.constantProvider.TAB_WIDTH,b=this.constantProvider.TAB_HEIGHT,c=Blockly.utils.svgPaths.moveBy(-2,-b+3.4)+Blockly.utils.svgPaths.lineTo(-.45*a,-2.1),d=Blockly.utils.svgPaths.lineOnAxis(\"v\",2.5)+Blockly.utils.svgPaths.moveBy(.97*-a,2.5)+Blockly.utils.svgPaths.curve(\"q\",[Blockly.utils.svgPaths.point(.05*-a,10),Blockly.utils.svgPaths.point(.3*a,9.5)])+Blockly.utils.svgPaths.moveBy(.67*a,-1.9)+Blockly.utils.svgPaths.lineOnAxis(\"v\",\n2.5),e=Blockly.utils.svgPaths.lineOnAxis(\"v\",-1.5)+Blockly.utils.svgPaths.moveBy(-.92*a,-.5)+Blockly.utils.svgPaths.curve(\"q\",[Blockly.utils.svgPaths.point(-.19*a,-5.5),Blockly.utils.svgPaths.point(0,-11)])+Blockly.utils.svgPaths.moveBy(.92*a,1),f=Blockly.utils.svgPaths.moveBy(-5,b-.7)+Blockly.utils.svgPaths.lineTo(.46*a,-2.1);return{width:a,height:b,pathUp:function(a){return a?c:e},pathDown:function(a){return a?d:f}}};\nBlockly.geras.HighlightConstantProvider.prototype.makeNotch=function(){return{pathLeft:Blockly.utils.svgPaths.lineOnAxis(\"h\",this.OFFSET)+this.constantProvider.NOTCH.pathLeft}};Blockly.geras.HighlightConstantProvider.prototype.makeJaggedTeeth=function(){return{pathLeft:Blockly.utils.svgPaths.lineTo(5.1,2.6)+Blockly.utils.svgPaths.moveBy(-10.2,6.8)+Blockly.utils.svgPaths.lineTo(5.1,2.6),height:12,width:10.2}};\nBlockly.geras.HighlightConstantProvider.prototype.makeStartHat=function(){var a=this.constantProvider.START_HAT.height,b=Blockly.utils.svgPaths.moveBy(25,-8.7)+Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(29.7,-6.2),Blockly.utils.svgPaths.point(57.2,-.5),Blockly.utils.svgPaths.point(75,8.7)]),c=Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(17.8,-9.2),Blockly.utils.svgPaths.point(45.3,-14.9),Blockly.utils.svgPaths.point(75,-8.7)])+Blockly.utils.svgPaths.moveTo(100.5,\na+.5);return{path:function(a){return a?b:c}}};Blockly.geras.PathObject=function(a,b,c){this.constants=c;this.svgRoot=a;this.svgPathDark=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyPathDark\",transform:\"translate(1,1)\"},this.svgRoot);this.svgPath=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyPath\"},this.svgRoot);this.svgPathLight=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyPathLight\"},this.svgRoot);this.colourDark=\"#000000\";this.style=b};Blockly.utils.object.inherits(Blockly.geras.PathObject,Blockly.blockRendering.PathObject);\nBlockly.geras.PathObject.prototype.setPath=function(a){this.svgPath.setAttribute(\"d\",a);this.svgPathDark.setAttribute(\"d\",a)};Blockly.geras.PathObject.prototype.setHighlightPath=function(a){this.svgPathLight.setAttribute(\"d\",a)};Blockly.geras.PathObject.prototype.flipRTL=function(){this.svgPath.setAttribute(\"transform\",\"scale(-1 1)\");this.svgPathLight.setAttribute(\"transform\",\"scale(-1 1)\");this.svgPathDark.setAttribute(\"transform\",\"translate(1,1) scale(-1 1)\")};\nBlockly.geras.PathObject.prototype.applyColour=function(a){this.svgPathLight.style.display=\"\";this.svgPathDark.style.display=\"\";this.svgPathLight.setAttribute(\"stroke\",this.style.colourTertiary);this.svgPathDark.setAttribute(\"fill\",this.colourDark);Blockly.geras.PathObject.superClass_.applyColour.call(this,a);this.svgPath.setAttribute(\"stroke\",\"none\")};\nBlockly.geras.PathObject.prototype.setStyle=function(a){this.style=a;this.colourDark=Blockly.utils.colour.blend(\"#000\",this.style.colourPrimary,.2)||this.colourDark};Blockly.geras.PathObject.prototype.updateHighlighted=function(a){a?(this.svgPath.setAttribute(\"filter\",\"url(#\"+this.constants.embossFilterId+\")\"),this.svgPathLight.style.display=\"none\"):(this.svgPath.setAttribute(\"filter\",\"none\"),this.svgPathLight.style.display=\"inline\")};\nBlockly.geras.PathObject.prototype.updateShadow_=function(a){a&&(this.svgPathLight.style.display=\"none\",this.svgPathDark.setAttribute(\"fill\",this.style.colourSecondary),this.svgPath.setAttribute(\"stroke\",\"none\"),this.svgPath.setAttribute(\"fill\",this.style.colourSecondary))};Blockly.geras.PathObject.prototype.updateDisabled_=function(a){Blockly.geras.PathObject.superClass_.updateDisabled_.call(this,a);a&&this.svgPath.setAttribute(\"stroke\",\"none\")};Blockly.geras.Renderer=function(a){Blockly.geras.Renderer.superClass_.constructor.call(this,a);this.highlightConstants_=null};Blockly.utils.object.inherits(Blockly.geras.Renderer,Blockly.blockRendering.Renderer);Blockly.geras.Renderer.prototype.init=function(a,b){Blockly.geras.Renderer.superClass_.init.call(this,a,b);this.highlightConstants_=this.makeHighlightConstants_();this.highlightConstants_.init()};\nBlockly.geras.Renderer.prototype.refreshDom=function(a,b){Blockly.geras.Renderer.superClass_.refreshDom.call(this,a,b);this.getHighlightConstants().init()};Blockly.geras.Renderer.prototype.makeConstants_=function(){return new Blockly.geras.ConstantProvider};Blockly.geras.Renderer.prototype.makeRenderInfo_=function(a){return new Blockly.geras.RenderInfo(this,a)};Blockly.geras.Renderer.prototype.makeDrawer_=function(a,b){return new Blockly.geras.Drawer(a,b)};\nBlockly.geras.Renderer.prototype.makePathObject=function(a,b){return new Blockly.geras.PathObject(a,b,this.getConstants())};Blockly.geras.Renderer.prototype.makeHighlightConstants_=function(){return new Blockly.geras.HighlightConstantProvider(this.getConstants())};Blockly.geras.Renderer.prototype.getHighlightConstants=function(){return this.highlightConstants_};Blockly.blockRendering.register(\"geras\",Blockly.geras.Renderer);Blockly.thrasos={};Blockly.thrasos.RenderInfo=function(a,b){Blockly.thrasos.RenderInfo.superClass_.constructor.call(this,a,b)};Blockly.utils.object.inherits(Blockly.thrasos.RenderInfo,Blockly.blockRendering.RenderInfo);Blockly.thrasos.RenderInfo.prototype.getRenderer=function(){return this.renderer_};\nBlockly.thrasos.RenderInfo.prototype.addElemSpacing_=function(){for(var a=!1,b=0,c;c=this.rows[b];b++)c.hasExternalInput&&(a=!0);for(b=0;c=this.rows[b];b++){var d=c.elements;c.elements=[];c.startsWithElemSpacer()&&c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,this.getInRowSpacing_(null,d[0])));for(var e=0;e<d.length-1;e++){c.elements.push(d[e]);var f=this.getInRowSpacing_(d[e],d[e+1]);c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,f))}c.elements.push(d[d.length-\n1]);c.endsWithElemSpacer()&&(f=this.getInRowSpacing_(d[d.length-1],null),a&&c.hasDummyInput&&(f+=this.constants_.TAB_WIDTH),c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,f)))}};\nBlockly.thrasos.RenderInfo.prototype.getInRowSpacing_=function(a,b){if(!a)return b&&Blockly.blockRendering.Types.isField(b)&&b.isEditable?this.constants_.MEDIUM_PADDING:b&&Blockly.blockRendering.Types.isInlineInput(b)?this.constants_.MEDIUM_LARGE_PADDING:b&&Blockly.blockRendering.Types.isStatementInput(b)?this.constants_.STATEMENT_INPUT_PADDING_LEFT:this.constants_.LARGE_PADDING;if(!Blockly.blockRendering.Types.isInput(a)&&!b)return Blockly.blockRendering.Types.isField(a)&&a.isEditable?this.constants_.MEDIUM_PADDING:\nBlockly.blockRendering.Types.isIcon(a)?2*this.constants_.LARGE_PADDING+1:Blockly.blockRendering.Types.isHat(a)?this.constants_.NO_PADDING:Blockly.blockRendering.Types.isPreviousOrNextConnection(a)?this.constants_.LARGE_PADDING:Blockly.blockRendering.Types.isLeftRoundedCorner(a)?this.constants_.MIN_BLOCK_WIDTH:Blockly.blockRendering.Types.isJaggedEdge(a)?this.constants_.NO_PADDING:this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isInput(a)&&!b){if(Blockly.blockRendering.Types.isExternalInput(a))return this.constants_.NO_PADDING;\nif(Blockly.blockRendering.Types.isInlineInput(a))return this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isStatementInput(a))return this.constants_.NO_PADDING}if(!Blockly.blockRendering.Types.isInput(a)&&b&&Blockly.blockRendering.Types.isInput(b)){if(Blockly.blockRendering.Types.isField(a)&&a.isEditable){if(Blockly.blockRendering.Types.isInlineInput(b)||Blockly.blockRendering.Types.isExternalInput(b))return this.constants_.SMALL_PADDING}else{if(Blockly.blockRendering.Types.isInlineInput(b)||\nBlockly.blockRendering.Types.isExternalInput(b))return this.constants_.MEDIUM_LARGE_PADDING;if(Blockly.blockRendering.Types.isStatementInput(b))return this.constants_.LARGE_PADDING}return this.constants_.LARGE_PADDING-1}if(Blockly.blockRendering.Types.isIcon(a)&&b&&!Blockly.blockRendering.Types.isInput(b))return this.constants_.LARGE_PADDING;if(Blockly.blockRendering.Types.isInlineInput(a)&&b&&Blockly.blockRendering.Types.isField(b))return b.isEditable?this.constants_.MEDIUM_PADDING:this.constants_.LARGE_PADDING;\nif(Blockly.blockRendering.Types.isLeftSquareCorner(a)&&b){if(Blockly.blockRendering.Types.isHat(b))return this.constants_.NO_PADDING;if(Blockly.blockRendering.Types.isPreviousConnection(b)||Blockly.blockRendering.Types.isNextConnection(b))return b.notchOffset}return Blockly.blockRendering.Types.isLeftRoundedCorner(a)&&b?b.notchOffset-this.constants_.CORNER_RADIUS:Blockly.blockRendering.Types.isField(a)&&b&&Blockly.blockRendering.Types.isField(b)&&a.isEditable==b.isEditable||b&&Blockly.blockRendering.Types.isJaggedEdge(b)?\nthis.constants_.LARGE_PADDING:this.constants_.MEDIUM_PADDING};\nBlockly.thrasos.RenderInfo.prototype.getSpacerRowHeight_=function(a,b){return Blockly.blockRendering.Types.isTopRow(a)&&Blockly.blockRendering.Types.isBottomRow(b)?this.constants_.EMPTY_BLOCK_SPACER_HEIGHT:Blockly.blockRendering.Types.isTopRow(a)||Blockly.blockRendering.Types.isBottomRow(b)?this.constants_.NO_PADDING:a.hasExternalInput&&b.hasExternalInput?this.constants_.LARGE_PADDING:!a.hasStatement&&b.hasStatement?this.constants_.BETWEEN_STATEMENT_PADDING_Y:a.hasStatement&&b.hasStatement||a.hasDummyInput||\nb.hasDummyInput?this.constants_.LARGE_PADDING:this.constants_.MEDIUM_PADDING};\nBlockly.thrasos.RenderInfo.prototype.getElemCenterline_=function(a,b){if(Blockly.blockRendering.Types.isSpacer(b))return a.yPos+b.height/2;if(Blockly.blockRendering.Types.isBottomRow(a))return a=a.yPos+a.height-a.descenderHeight,Blockly.blockRendering.Types.isNextConnection(b)?a+b.height/2:a-b.height/2;if(Blockly.blockRendering.Types.isTopRow(a))return Blockly.blockRendering.Types.isHat(b)?a.capline-b.height/2:a.capline+b.height/2;var c=a.yPos;return c=Blockly.blockRendering.Types.isField(b)&&a.hasStatement?\nc+(this.constants_.TALL_INPUT_FIELD_OFFSET_Y+b.height/2):c+a.height/2};\nBlockly.thrasos.RenderInfo.prototype.finalize_=function(){for(var a=0,b=0,c=0,d;d=this.rows[c];c++){d.yPos=b;d.xPos=this.startX;b+=d.height;a=Math.max(a,d.widthWithConnectedBlocks);var e=b-this.topRow.ascenderHeight;d==this.bottomRow&&e<this.constants_.MIN_BLOCK_HEIGHT&&(e=this.constants_.MIN_BLOCK_HEIGHT-e,this.bottomRow.height+=e,b+=e);this.recordElemPositions_(d)}this.outputConnection&&this.block_.nextConnection&&this.block_.nextConnection.isConnected()&&(a=Math.max(a,this.block_.nextConnection.targetBlock().getHeightWidth().width));\nthis.bottomRow.baseline=b-this.bottomRow.descenderHeight;this.widthWithChildren=a+this.startX;this.height=b;this.startY=this.topRow.capline};Blockly.thrasos.Renderer=function(a){Blockly.thrasos.Renderer.superClass_.constructor.call(this,a)};Blockly.utils.object.inherits(Blockly.thrasos.Renderer,Blockly.blockRendering.Renderer);Blockly.thrasos.Renderer.prototype.makeRenderInfo_=function(a){return new Blockly.thrasos.RenderInfo(this,a)};Blockly.blockRendering.register(\"thrasos\",Blockly.thrasos.Renderer);Blockly.zelos={};\nBlockly.zelos.ConstantProvider=function(){Blockly.zelos.ConstantProvider.superClass_.constructor.call(this);this.SMALL_PADDING=this.GRID_UNIT=4;this.MEDIUM_PADDING=2*this.GRID_UNIT;this.MEDIUM_LARGE_PADDING=3*this.GRID_UNIT;this.LARGE_PADDING=4*this.GRID_UNIT;this.CORNER_RADIUS=1*this.GRID_UNIT;this.NOTCH_WIDTH=9*this.GRID_UNIT;this.NOTCH_HEIGHT=2*this.GRID_UNIT;this.STATEMENT_INPUT_NOTCH_OFFSET=this.NOTCH_OFFSET_LEFT=3*this.GRID_UNIT;this.MIN_BLOCK_WIDTH=2*this.GRID_UNIT;this.MIN_BLOCK_HEIGHT=12*\nthis.GRID_UNIT;this.EMPTY_STATEMENT_INPUT_HEIGHT=6*this.GRID_UNIT;this.TAB_OFFSET_FROM_TOP=0;this.TOP_ROW_MIN_HEIGHT=this.CORNER_RADIUS;this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT=this.LARGE_PADDING;this.BOTTOM_ROW_MIN_HEIGHT=this.CORNER_RADIUS;this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT=6*this.GRID_UNIT;this.STATEMENT_BOTTOM_SPACER=-this.NOTCH_HEIGHT;this.STATEMENT_INPUT_SPACER_MIN_WIDTH=40*this.GRID_UNIT;this.STATEMENT_INPUT_PADDING_LEFT=4*this.GRID_UNIT;this.EMPTY_INLINE_INPUT_PADDING=4*this.GRID_UNIT;\nthis.EMPTY_INLINE_INPUT_HEIGHT=8*this.GRID_UNIT;this.DUMMY_INPUT_MIN_HEIGHT=8*this.GRID_UNIT;this.DUMMY_INPUT_SHADOW_MIN_HEIGHT=6*this.GRID_UNIT;this.CURSOR_WS_WIDTH=20*this.GRID_UNIT;this.CURSOR_COLOUR=\"#ffa200\";this.CURSOR_RADIUS=5;this.JAGGED_TEETH_WIDTH=this.JAGGED_TEETH_HEIGHT=0;this.START_HAT_HEIGHT=22;this.START_HAT_WIDTH=96;this.SHAPES={HEXAGONAL:1,ROUND:2,SQUARE:3,PUZZLE:4,NOTCH:5};this.SHAPE_IN_SHAPE_PADDING={1:{0:5*this.GRID_UNIT,1:2*this.GRID_UNIT,2:5*this.GRID_UNIT,3:5*this.GRID_UNIT},\n2:{0:3*this.GRID_UNIT,1:3*this.GRID_UNIT,2:1*this.GRID_UNIT,3:2*this.GRID_UNIT},3:{0:2*this.GRID_UNIT,1:2*this.GRID_UNIT,2:2*this.GRID_UNIT,3:2*this.GRID_UNIT}};this.FULL_BLOCK_FIELDS=!0;this.FIELD_TEXT_FONTSIZE=3*this.GRID_UNIT;this.FIELD_TEXT_FONTWEIGHT=\"bold\";this.FIELD_TEXT_FONTFAMILY='\"Helvetica Neue\", \"Segoe UI\", Helvetica, sans-serif';this.FIELD_BORDER_RECT_RADIUS=this.CORNER_RADIUS;this.FIELD_BORDER_RECT_X_PADDING=2*this.GRID_UNIT;this.FIELD_BORDER_RECT_Y_PADDING=1.625*this.GRID_UNIT;this.FIELD_BORDER_RECT_HEIGHT=\n8*this.GRID_UNIT;this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT=8*this.GRID_UNIT;this.FIELD_DROPDOWN_SVG_ARROW=this.FIELD_DROPDOWN_COLOURED_DIV=this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW=!0;this.FIELD_DROPDOWN_SVG_ARROW_PADDING=this.FIELD_BORDER_RECT_X_PADDING;this.FIELD_COLOUR_FULL_BLOCK=this.FIELD_TEXTINPUT_BOX_SHADOW=!0;this.FIELD_COLOUR_DEFAULT_WIDTH=2*this.GRID_UNIT;this.FIELD_COLOUR_DEFAULT_HEIGHT=4*this.GRID_UNIT;this.FIELD_CHECKBOX_X_OFFSET=1*this.GRID_UNIT;this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH=\n12*this.GRID_UNIT;this.SELECTED_GLOW_COLOUR=\"#fff200\";this.SELECTED_GLOW_SIZE=.5;this.REPLACEMENT_GLOW_COLOUR=\"#fff200\";this.REPLACEMENT_GLOW_SIZE=2;this.selectedGlowFilterId=\"\";this.selectedGlowFilter_=null;this.replacementGlowFilterId=\"\";this.replacementGlowFilter_=null};Blockly.utils.object.inherits(Blockly.zelos.ConstantProvider,Blockly.blockRendering.ConstantProvider);\nBlockly.zelos.ConstantProvider.prototype.setFontConstants_=function(a){Blockly.zelos.ConstantProvider.superClass_.setFontConstants_.call(this,a);this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT=this.FIELD_BORDER_RECT_HEIGHT=this.FIELD_TEXT_HEIGHT+2*this.FIELD_BORDER_RECT_Y_PADDING};\nBlockly.zelos.ConstantProvider.prototype.init=function(){Blockly.zelos.ConstantProvider.superClass_.init.call(this);this.HEXAGONAL=this.makeHexagonal();this.ROUNDED=this.makeRounded();this.SQUARED=this.makeSquared();this.STATEMENT_INPUT_NOTCH_OFFSET=this.NOTCH_OFFSET_LEFT+this.INSIDE_CORNERS.rightWidth};\nBlockly.zelos.ConstantProvider.prototype.setDynamicProperties_=function(a){Blockly.zelos.ConstantProvider.superClass_.setDynamicProperties_.call(this,a);this.SELECTED_GLOW_COLOUR=a.getComponentStyle(\"selectedGlowColour\")||this.SELECTED_GLOW_COLOUR;var b=Number(a.getComponentStyle(\"selectedGlowSize\"));this.SELECTED_GLOW_SIZE=b&&!isNaN(b)?b:this.SELECTED_GLOW_SIZE;this.REPLACEMENT_GLOW_COLOUR=a.getComponentStyle(\"replacementGlowColour\")||this.REPLACEMENT_GLOW_COLOUR;this.REPLACEMENT_GLOW_SIZE=(a=Number(a.getComponentStyle(\"replacementGlowSize\")))&&\n!isNaN(a)?a:this.REPLACEMENT_GLOW_SIZE};Blockly.zelos.ConstantProvider.prototype.dispose=function(){Blockly.zelos.ConstantProvider.superClass_.dispose.call(this);this.selectedGlowFilter_&&Blockly.utils.dom.removeNode(this.selectedGlowFilter_);this.replacementGlowFilter_&&Blockly.utils.dom.removeNode(this.replacementGlowFilter_)};\nBlockly.zelos.ConstantProvider.prototype.makeStartHat=function(){var a=this.START_HAT_HEIGHT,b=this.START_HAT_WIDTH,c=Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(25,-a),Blockly.utils.svgPaths.point(71,-a),Blockly.utils.svgPaths.point(b,0)]);return{height:a,width:b,path:c}};\nBlockly.zelos.ConstantProvider.prototype.makeHexagonal=function(){function a(a,d,e){var c=a/2;c=c>b?b:c;e=e?-1:1;a=(d?-1:1)*a/2;return Blockly.utils.svgPaths.lineTo(-e*c,a)+Blockly.utils.svgPaths.lineTo(e*c,a)}var b=this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;return{type:this.SHAPES.HEXAGONAL,isDynamic:!0,width:function(a){a/=2;return a>b?b:a},height:function(a){return a},connectionOffsetY:function(a){return a/2},connectionOffsetX:function(a){return-a},pathDown:function(b){return a(b,!1,!1)},pathUp:function(b){return a(b,\n!0,!1)},pathRightDown:function(b){return a(b,!1,!0)},pathRightUp:function(b){return a(b,!1,!0)}}};\nBlockly.zelos.ConstantProvider.prototype.makeRounded=function(){function a(a,b,f){var d=a>c?a-c:0;a=(a>c?c:a)/2;return Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point((b?-1:1)*a,(b?-1:1)*a))+Blockly.utils.svgPaths.lineOnAxis(\"v\",(f?1:-1)*d)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point((b?1:-1)*a,(b?-1:1)*a))}var b=this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH,c=2*b;return{type:this.SHAPES.ROUND,isDynamic:!0,width:function(a){a/=2;return a>b?b:a},height:function(a){return a},\nconnectionOffsetY:function(a){return a/2},connectionOffsetX:function(a){return-a},pathDown:function(b){return a(b,!1,!1)},pathUp:function(b){return a(b,!0,!1)},pathRightDown:function(b){return a(b,!1,!0)},pathRightUp:function(b){return a(b,!1,!0)}}};\nBlockly.zelos.ConstantProvider.prototype.makeSquared=function(){function a(a,d,e){a-=2*b;return Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",b,Blockly.utils.svgPaths.point((d?-1:1)*b,(d?-1:1)*b))+Blockly.utils.svgPaths.lineOnAxis(\"v\",(e?1:-1)*a)+Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",b,Blockly.utils.svgPaths.point((d?1:-1)*b,(d?-1:1)*b))}var b=this.CORNER_RADIUS;return{type:this.SHAPES.SQUARE,isDynamic:!0,width:function(a){return b},height:function(a){return a},connectionOffsetY:function(a){return a/2},\nconnectionOffsetX:function(a){return-a},pathDown:function(b){return a(b,!1,!1)},pathUp:function(b){return a(b,!0,!1)},pathRightDown:function(b){return a(b,!1,!0)},pathRightUp:function(b){return a(b,!1,!0)}}};\nBlockly.zelos.ConstantProvider.prototype.shapeFor=function(a){var b=a.getCheck();!b&&a.targetConnection&&(b=a.targetConnection.getCheck());switch(a.type){case Blockly.INPUT_VALUE:case Blockly.OUTPUT_VALUE:a=a.getSourceBlock().getOutputShape();if(null!=a)switch(a){case this.SHAPES.HEXAGONAL:return this.HEXAGONAL;case this.SHAPES.ROUND:return this.ROUNDED;case this.SHAPES.SQUARE:return this.SQUARED}if(b&&-1!=b.indexOf(\"Boolean\"))return this.HEXAGONAL;if(b&&-1!=b.indexOf(\"Number\"))return this.ROUNDED;\nb&&b.indexOf(\"String\");return this.ROUNDED;case Blockly.PREVIOUS_STATEMENT:case Blockly.NEXT_STATEMENT:return this.NOTCH;default:throw Error(\"Unknown type\");}};\nBlockly.zelos.ConstantProvider.prototype.makeNotch=function(){function a(a){return Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(a*e/2,0),Blockly.utils.svgPaths.point(a*e*3/4,g/2),Blockly.utils.svgPaths.point(a*e,g)])+Blockly.utils.svgPaths.line([Blockly.utils.svgPaths.point(a*e,f)])+Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(a*e/4,g/2),Blockly.utils.svgPaths.point(a*e/2,g),Blockly.utils.svgPaths.point(a*e,g)])+Blockly.utils.svgPaths.lineOnAxis(\"h\",a*d)+Blockly.utils.svgPaths.curve(\"c\",\n[Blockly.utils.svgPaths.point(a*e/2,0),Blockly.utils.svgPaths.point(a*e*3/4,-(g/2)),Blockly.utils.svgPaths.point(a*e,-g)])+Blockly.utils.svgPaths.line([Blockly.utils.svgPaths.point(a*e,-f)])+Blockly.utils.svgPaths.curve(\"c\",[Blockly.utils.svgPaths.point(a*e/4,-(g/2)),Blockly.utils.svgPaths.point(a*e/2,-g),Blockly.utils.svgPaths.point(a*e,-g)])}var b=this.NOTCH_WIDTH,c=this.NOTCH_HEIGHT,d=b/3,e=d/3,f=c/2,g=f/2,h=a(1),k=a(-1);return{type:this.SHAPES.NOTCH,width:b,height:c,pathLeft:h,pathRight:k}};\nBlockly.zelos.ConstantProvider.prototype.makeInsideCorners=function(){var a=this.CORNER_RADIUS,b=Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a,Blockly.utils.svgPaths.point(-a,a)),c=Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(-a,a)),d=Blockly.utils.svgPaths.arc(\"a\",\"0 0,0\",a,Blockly.utils.svgPaths.point(a,a)),e=Blockly.utils.svgPaths.arc(\"a\",\"0 0,1\",a,Blockly.utils.svgPaths.point(a,a));return{width:a,height:a,pathTop:b,pathBottom:d,rightWidth:a,rightHeight:a,pathTopRight:c,pathBottomRight:e}};\nBlockly.zelos.ConstantProvider.prototype.generateSecondaryColour_=function(a){return Blockly.utils.colour.blend(\"#000\",a,.15)||a};Blockly.zelos.ConstantProvider.prototype.generateTertiaryColour_=function(a){return Blockly.utils.colour.blend(\"#000\",a,.25)||a};\nBlockly.zelos.ConstantProvider.prototype.createDom=function(a,b,c){Blockly.zelos.ConstantProvider.superClass_.createDom.call(this,a,b,c);a=Blockly.utils.dom.createSvgElement(\"defs\",{},a);b=Blockly.utils.dom.createSvgElement(\"filter\",{id:\"blocklySelectedGlowFilter\"+this.randomIdentifier,height:\"160%\",width:\"180%\",y:\"-30%\",x:\"-40%\"},a);Blockly.utils.dom.createSvgElement(\"feGaussianBlur\",{\"in\":\"SourceGraphic\",stdDeviation:this.SELECTED_GLOW_SIZE},b);c=Blockly.utils.dom.createSvgElement(\"feComponentTransfer\",\n{result:\"outBlur\"},b);Blockly.utils.dom.createSvgElement(\"feFuncA\",{type:\"table\",tableValues:\"0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\"},c);Blockly.utils.dom.createSvgElement(\"feFlood\",{\"flood-color\":this.SELECTED_GLOW_COLOUR,\"flood-opacity\":1,result:\"outColor\"},b);Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"outColor\",in2:\"outBlur\",operator:\"in\",result:\"outGlow\"},b);this.selectedGlowFilterId=b.id;this.selectedGlowFilter_=b;a=Blockly.utils.dom.createSvgElement(\"filter\",{id:\"blocklyReplacementGlowFilter\"+\nthis.randomIdentifier,height:\"160%\",width:\"180%\",y:\"-30%\",x:\"-40%\"},a);Blockly.utils.dom.createSvgElement(\"feGaussianBlur\",{\"in\":\"SourceGraphic\",stdDeviation:this.REPLACEMENT_GLOW_SIZE},a);b=Blockly.utils.dom.createSvgElement(\"feComponentTransfer\",{result:\"outBlur\"},a);Blockly.utils.dom.createSvgElement(\"feFuncA\",{type:\"table\",tableValues:\"0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\"},b);Blockly.utils.dom.createSvgElement(\"feFlood\",{\"flood-color\":this.REPLACEMENT_GLOW_COLOUR,\"flood-opacity\":1,result:\"outColor\"},\na);Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"outColor\",in2:\"outBlur\",operator:\"in\",result:\"outGlow\"},a);Blockly.utils.dom.createSvgElement(\"feComposite\",{\"in\":\"SourceGraphic\",in2:\"outGlow\",operator:\"over\"},a);this.replacementGlowFilterId=a.id;this.replacementGlowFilter_=a};\nBlockly.zelos.ConstantProvider.prototype.getCSS_=function(a){return[a+\" .blocklyText, \",a+\" .blocklyFlyoutLabelText {\",\"font-family: \"+this.FIELD_TEXT_FONTFAMILY+\";\",\"font-size: \"+this.FIELD_TEXT_FONTSIZE+\"pt;\",\"font-weight: \"+this.FIELD_TEXT_FONTWEIGHT+\";\",\"}\",a+\" .blocklyText {\",\"fill: #fff;\",\"}\",a+\" .blocklyNonEditableText>rect:not(.blocklyDropdownRect),\",a+\" .blocklyEditableText>rect:not(.blocklyDropdownRect) {\",\"fill: \"+this.FIELD_BORDER_RECT_COLOUR+\";\",\"}\",a+\" .blocklyNonEditableText>text,\",\na+\" .blocklyEditableText>text,\",a+\" .blocklyNonEditableText>g>text,\",a+\" .blocklyEditableText>g>text {\",\"fill: #575E75;\",\"}\",a+\" .blocklyFlyoutLabelText {\",\"fill: #575E75;\",\"}\",a+\" .blocklyText.blocklyBubbleText {\",\"fill: #575E75;\",\"}\",a+\" .blocklyDraggable:not(.blocklyDisabled)\",\" .blocklyEditableText:not(.editing):hover>rect ,\",a+\" .blocklyDraggable:not(.blocklyDisabled)\",\" .blocklyEditableText:not(.editing):hover>.blocklyPath {\",\"stroke: #fff;\",\"stroke-width: 2;\",\"}\",a+\" .blocklyHtmlInput {\",\"font-family: \"+\nthis.FIELD_TEXT_FONTFAMILY+\";\",\"font-weight: \"+this.FIELD_TEXT_FONTWEIGHT+\";\",\"color: #575E75;\",\"}\",a+\" .blocklyDropdownText {\",\"fill: #fff !important;\",\"}\",a+\".blocklyWidgetDiv .goog-menuitem,\",a+\".blocklyDropDownDiv .goog-menuitem {\",\"font-family: \"+this.FIELD_TEXT_FONTFAMILY+\";\",\"}\",a+\".blocklyDropDownDiv .goog-menuitem-content {\",\"color: #fff;\",\"}\",a+\" .blocklyHighlightedConnectionPath {\",\"stroke: \"+this.SELECTED_GLOW_COLOUR+\";\",\"}\",a+\" .blocklyDisabled > .blocklyOutlinePath {\",\"fill: url(#blocklyDisabledPattern\"+\nthis.randomIdentifier+\")\",\"}\",a+\" .blocklyInsertionMarker>.blocklyPath {\",\"fill-opacity: \"+this.INSERTION_MARKER_OPACITY+\";\",\"stroke: none\",\"}\"]};Blockly.zelos.TopRow=function(a){Blockly.zelos.TopRow.superClass_.constructor.call(this,a)};Blockly.utils.object.inherits(Blockly.zelos.TopRow,Blockly.blockRendering.TopRow);Blockly.zelos.TopRow.prototype.endsWithElemSpacer=function(){return!1};Blockly.zelos.TopRow.prototype.hasLeftSquareCorner=function(a){var b=(a.hat?\"cap\"===a.hat:this.constants_.ADD_START_HATS)&&!a.outputConnection&&!a.previousConnection;return!!a.outputConnection||b};\nBlockly.zelos.TopRow.prototype.hasRightSquareCorner=function(a){return!!a.outputConnection&&!a.statementInputCount&&!a.nextConnection};Blockly.zelos.BottomRow=function(a){Blockly.zelos.BottomRow.superClass_.constructor.call(this,a)};Blockly.utils.object.inherits(Blockly.zelos.BottomRow,Blockly.blockRendering.BottomRow);Blockly.zelos.BottomRow.prototype.endsWithElemSpacer=function(){return!1};Blockly.zelos.BottomRow.prototype.hasLeftSquareCorner=function(a){return!!a.outputConnection};\nBlockly.zelos.BottomRow.prototype.hasRightSquareCorner=function(a){return!!a.outputConnection&&!a.statementInputCount&&!a.nextConnection};Blockly.zelos.RightConnectionShape=function(a){Blockly.zelos.RightConnectionShape.superClass_.constructor.call(this,a);this.type|=Blockly.blockRendering.Types.getType(\"RIGHT_CONNECTION\");this.width=this.height=0};Blockly.utils.object.inherits(Blockly.zelos.RightConnectionShape,Blockly.blockRendering.Measurable);Blockly.zelos.StatementInput=function(a,b){Blockly.zelos.StatementInput.superClass_.constructor.call(this,a,b);if(this.connectedBlock){for(a=this.connectedBlock;a.getNextBlock();)a=a.getNextBlock();a.nextConnection||(this.height=this.connectedBlockHeight,this.connectedBottomNextConnection=!0)}};Blockly.utils.object.inherits(Blockly.zelos.StatementInput,Blockly.blockRendering.StatementInput);Blockly.zelos.RenderInfo=function(a,b){Blockly.zelos.RenderInfo.superClass_.constructor.call(this,a,b);this.topRow=new Blockly.zelos.TopRow(this.constants_);this.bottomRow=new Blockly.zelos.BottomRow(this.constants_);this.isInline=!0;this.isMultiRow=!b.getInputsInline()||b.isCollapsed();this.hasStatementInput=0<b.statementInputCount;this.rightSide=this.outputConnection?new Blockly.zelos.RightConnectionShape(this.constants_):null};Blockly.utils.object.inherits(Blockly.zelos.RenderInfo,Blockly.blockRendering.RenderInfo);\nBlockly.zelos.RenderInfo.prototype.getRenderer=function(){return this.renderer_};Blockly.zelos.RenderInfo.prototype.measure=function(){this.createRows_();this.addElemSpacing_();this.addRowSpacing_();this.adjustXPosition_();this.computeBounds_();this.alignRowElements_();this.finalize_()};\nBlockly.zelos.RenderInfo.prototype.shouldStartNewRow_=function(a,b){return b?a.type==Blockly.NEXT_STATEMENT||b.type==Blockly.NEXT_STATEMENT?!0:a.type==Blockly.INPUT_VALUE||a.type==Blockly.DUMMY_INPUT?!this.isInline||this.isMultiRow:!1:!1};Blockly.zelos.RenderInfo.prototype.getDesiredRowWidth_=function(a){return a.hasStatement?this.width-this.startX-(this.constants_.INSIDE_CORNERS.rightWidth||0):Blockly.zelos.RenderInfo.superClass_.getDesiredRowWidth_.call(this,a)};\nBlockly.zelos.RenderInfo.prototype.getInRowSpacing_=function(a,b){return a&&b||!this.outputConnection||!this.outputConnection.isDynamicShape||this.hasStatementInput||this.bottomRow.hasNextConnection?!a&&b&&Blockly.blockRendering.Types.isStatementInput(b)?this.constants_.STATEMENT_INPUT_PADDING_LEFT:a&&Blockly.blockRendering.Types.isLeftRoundedCorner(a)&&b&&(Blockly.blockRendering.Types.isPreviousConnection(b)||Blockly.blockRendering.Types.isNextConnection(b))?b.notchOffset-this.constants_.CORNER_RADIUS:\na&&Blockly.blockRendering.Types.isLeftSquareCorner(a)&&b&&Blockly.blockRendering.Types.isHat(b)?this.constants_.NO_PADDING:this.constants_.MEDIUM_PADDING:this.constants_.NO_PADDING};\nBlockly.zelos.RenderInfo.prototype.getSpacerRowHeight_=function(a,b){if(Blockly.blockRendering.Types.isTopRow(a)&&Blockly.blockRendering.Types.isBottomRow(b))return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;var c=Blockly.blockRendering.Types.isInputRow(a)&&a.hasStatement,d=Blockly.blockRendering.Types.isInputRow(b)&&b.hasStatement;return d||c?(a=Math.max(this.constants_.NOTCH_HEIGHT,this.constants_.INSIDE_CORNERS.rightHeight||0),d&&c?Math.max(a,this.constants_.DUMMY_INPUT_MIN_HEIGHT):a):Blockly.blockRendering.Types.isTopRow(a)?\na.hasPreviousConnection||this.outputConnection&&!this.hasStatementInput?this.constants_.NO_PADDING:Math.abs(this.constants_.NOTCH_HEIGHT-this.constants_.CORNER_RADIUS):Blockly.blockRendering.Types.isBottomRow(b)?this.outputConnection?!b.hasNextConnection&&this.hasStatementInput?Math.abs(this.constants_.NOTCH_HEIGHT-this.constants_.CORNER_RADIUS):this.constants_.NO_PADDING:Math.max(this.topRow.minHeight,Math.max(this.constants_.NOTCH_HEIGHT,this.constants_.CORNER_RADIUS))-this.constants_.CORNER_RADIUS:\nthis.constants_.MEDIUM_PADDING};Blockly.zelos.RenderInfo.prototype.getSpacerRowWidth_=function(a,b){var c=this.width-this.startX;return Blockly.blockRendering.Types.isInputRow(a)&&a.hasStatement||Blockly.blockRendering.Types.isInputRow(b)&&b.hasStatement?Math.max(c,this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH):c};\nBlockly.zelos.RenderInfo.prototype.getElemCenterline_=function(a,b){if(a.hasStatement&&!Blockly.blockRendering.Types.isSpacer(b)&&!Blockly.blockRendering.Types.isStatementInput(b))return a.yPos+this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT/2;if(Blockly.blockRendering.Types.isInlineInput(b)){var c=b.connectedBlock;if(c&&c.outputConnection&&c.nextConnection)return a.yPos+c.height/2}return Blockly.zelos.RenderInfo.superClass_.getElemCenterline_.call(this,a,b)};\nBlockly.zelos.RenderInfo.prototype.addInput_=function(a,b){a.type==Blockly.DUMMY_INPUT&&b.hasDummyInput&&b.align==Blockly.ALIGN_LEFT&&a.align==Blockly.ALIGN_RIGHT&&(b.rightAlignedDummyInput=a);Blockly.zelos.RenderInfo.superClass_.addInput_.call(this,a,b)};\nBlockly.zelos.RenderInfo.prototype.addAlignmentPadding_=function(a,b){if(a.rightAlignedDummyInput){for(var c,d=0,e;(e=a.elements[d])&&(Blockly.blockRendering.Types.isSpacer(e)&&(c=e),!Blockly.blockRendering.Types.isField(e)||e.parentInput!=a.rightAlignedDummyInput);d++);if(c){c.width+=b;a.width+=b;return}}Blockly.zelos.RenderInfo.superClass_.addAlignmentPadding_.call(this,a,b)};\nBlockly.zelos.RenderInfo.prototype.adjustXPosition_=function(){for(var a=this.constants_.NOTCH_OFFSET_LEFT+this.constants_.NOTCH_WIDTH,b=a,c=2;c<this.rows.length-1;c+=2){var d=this.rows[c-1],e=this.rows[c],f=this.rows[c+1];d=2==c?!!this.topRow.hasPreviousConnection:!!d.followsStatement;f=c+2>=this.rows.length-1?!!this.bottomRow.hasNextConnection:!!f.precedesStatement;if(Blockly.blockRendering.Types.isInputRow(e)&&e.hasStatement)e.measure(),b=e.width-e.getLastInput().width+a;else if(d&&(2==c||f)&&\nBlockly.blockRendering.Types.isInputRow(e)&&!e.hasStatement){f=e.xPos;d=null;for(var g=0,h;h=e.elements[g];g++)Blockly.blockRendering.Types.isSpacer(h)&&(d=h),!(d&&(Blockly.blockRendering.Types.isField(h)||Blockly.blockRendering.Types.isInput(h))&&f<b)||Blockly.blockRendering.Types.isField(h)&&(h.field instanceof Blockly.FieldLabel||h.field instanceof Blockly.FieldImage)||(d.width+=b-f),f+=h.width}}};\nBlockly.zelos.RenderInfo.prototype.finalizeOutputConnection_=function(){if(this.outputConnection&&this.outputConnection.isDynamicShape){for(var a=0,b=0,c;c=this.rows[b];b++)c.yPos=a,a+=c.height;this.height=a;b=this.bottomRow.hasNextConnection?this.height-this.bottomRow.descenderHeight:this.height;a=this.outputConnection.shape.height(b);b=this.outputConnection.shape.width(b);this.outputConnection.height=a;this.outputConnection.width=b;this.outputConnection.startX=b;this.outputConnection.connectionOffsetY=\nthis.outputConnection.shape.connectionOffsetY(a);this.outputConnection.connectionOffsetX=this.outputConnection.shape.connectionOffsetX(b);c=0;this.hasStatementInput||this.bottomRow.hasNextConnection||(c=b,this.rightSide.height=a,this.rightSide.width=c,this.rightSide.centerline=a/2,this.rightSide.xPos=this.width+c);this.startX=b;this.width+=b+c;this.widthWithChildren+=b+c}};\nBlockly.zelos.RenderInfo.prototype.finalizeHorizontalAlignment_=function(){if(this.outputConnection&&!this.hasStatementInput&&!this.bottomRow.hasNextConnection){for(var a=0,b=0,c;c=this.rows[b];b++)if(Blockly.blockRendering.Types.isInputRow(c)){a=c.elements[c.elements.length-2];var d=this.getNegativeSpacing_(c.elements[1]),e=this.getNegativeSpacing_(a);a=d+e;var f=this.constants_.MIN_BLOCK_WIDTH+2*this.outputConnection.width;this.width-a<f&&(a=this.width-f,d=a/2,e=a/2);c.elements.unshift(new Blockly.blockRendering.InRowSpacer(this.constants_,\n-d));c.elements.push(new Blockly.blockRendering.InRowSpacer(this.constants_,-e))}if(a)for(this.width-=a,this.widthWithChildren-=a,this.rightSide.xPos-=a,b=0;c=this.rows[b];b++)Blockly.blockRendering.Types.isTopOrBottomRow(c)&&(c.elements[1].width-=a,c.elements[1].widthWithConnectedBlocks-=a),c.width-=a,c.widthWithConnectedBlocks-=a}};\nBlockly.zelos.RenderInfo.prototype.getNegativeSpacing_=function(a){if(!a)return 0;var b=this.outputConnection.width,c=this.outputConnection.shape.type,d=this.constants_;if(this.isMultiRow&&1<this.inputRows.length)switch(c){case d.SHAPES.ROUND:return c=this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH,c=this.height/2>c?c:this.height/2,b-c*(1-Math.sin(Math.acos((c-this.constants_.SMALL_PADDING)/c)));default:return 0}if(Blockly.blockRendering.Types.isInlineInput(a)){var e=a.connectedBlock;a=e?e.pathObject.outputShapeType:\na.shape.type;return e&&e.outputConnection&&(e.statementInputCount||e.nextConnection)||c==d.SHAPES.HEXAGONAL&&c!=a?0:b-this.constants_.SHAPE_IN_SHAPE_PADDING[c][a]}return Blockly.blockRendering.Types.isField(a)?c==d.SHAPES.ROUND&&a.field instanceof Blockly.FieldTextInput?b-2.75*d.GRID_UNIT:b-this.constants_.SHAPE_IN_SHAPE_PADDING[c][0]:Blockly.blockRendering.Types.isIcon(a)?this.constants_.SMALL_PADDING:0};\nBlockly.zelos.RenderInfo.prototype.finalizeVerticalAlignment_=function(){if(!this.outputConnection)for(var a=2;a<this.rows.length-1;a+=2){var b=this.rows[a-1],c=this.rows[a],d=this.rows[a+1],e=2==a,f=a+2>=this.rows.length-1?!!this.bottomRow.hasNextConnection:!!d.precedesStatement;if(e?this.topRow.hasPreviousConnection:b.followsStatement){var g=3==c.elements.length&&(c.elements[1].field instanceof Blockly.FieldLabel||c.elements[1].field instanceof Blockly.FieldImage);if(!e&&g)b.height-=this.constants_.SMALL_PADDING,\nd.height-=this.constants_.SMALL_PADDING,c.height-=this.constants_.MEDIUM_PADDING;else if(!e&&!f)b.height+=this.constants_.SMALL_PADDING;else if(f){e=!1;for(f=0;g=c.elements[f];f++)if(Blockly.blockRendering.Types.isInlineInput(g)&&g.connectedBlock&&!g.connectedBlock.isShadow()&&40<=g.connectedBlock.getHeightWidth().height){e=!0;break}e&&(b.height-=this.constants_.SMALL_PADDING,d.height-=this.constants_.SMALL_PADDING)}}}};\nBlockly.zelos.RenderInfo.prototype.finalize_=function(){this.finalizeOutputConnection_();this.finalizeHorizontalAlignment_();this.finalizeVerticalAlignment_();Blockly.zelos.RenderInfo.superClass_.finalize_.call(this);this.rightSide&&(this.widthWithChildren+=this.rightSide.width)};Blockly.zelos.Drawer=function(a,b){Blockly.zelos.Drawer.superClass_.constructor.call(this,a,b)};Blockly.utils.object.inherits(Blockly.zelos.Drawer,Blockly.blockRendering.Drawer);\nBlockly.zelos.Drawer.prototype.draw=function(){var a=this.block_.pathObject;a.beginDrawing();this.hideHiddenIcons_();this.drawOutline_();this.drawInternals_();a.setPath(this.outlinePath_+\"\\n\"+this.inlinePath_);this.info_.RTL&&a.flipRTL();Blockly.blockRendering.useDebugger&&this.block_.renderingDebugger.drawDebug(this.block_,this.info_);this.recordSizeOnBlock_();this.info_.outputConnection&&(a.outputShapeType=this.info_.outputConnection.shape.type);a.endDrawing()};\nBlockly.zelos.Drawer.prototype.drawOutline_=function(){this.info_.outputConnection&&this.info_.outputConnection.isDynamicShape&&!this.info_.hasStatementInput&&!this.info_.bottomRow.hasNextConnection?(this.drawFlatTop_(),this.drawRightDynamicConnection_(),this.drawFlatBottom_(),this.drawLeftDynamicConnection_()):Blockly.zelos.Drawer.superClass_.drawOutline_.call(this)};\nBlockly.zelos.Drawer.prototype.drawLeft_=function(){this.info_.outputConnection&&this.info_.outputConnection.isDynamicShape?this.drawLeftDynamicConnection_():Blockly.zelos.Drawer.superClass_.drawLeft_.call(this)};\nBlockly.zelos.Drawer.prototype.drawRightSideRow_=function(a){if(!(0>=a.height))if(a.precedesStatement||a.followsStatement){var b=this.constants_.INSIDE_CORNERS.rightHeight;b=a.height-(a.precedesStatement?b:0);this.outlinePath_+=(a.followsStatement?this.constants_.INSIDE_CORNERS.pathBottomRight:\"\")+(0<b?Blockly.utils.svgPaths.lineOnAxis(\"V\",a.yPos+b):\"\")+(a.precedesStatement?this.constants_.INSIDE_CORNERS.pathTopRight:\"\")}else this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.yPos+a.height)};\nBlockly.zelos.Drawer.prototype.drawRightDynamicConnection_=function(){this.outlinePath_+=this.info_.outputConnection.shape.pathRightDown(this.info_.outputConnection.height)};Blockly.zelos.Drawer.prototype.drawLeftDynamicConnection_=function(){this.positionOutputConnection_();this.outlinePath_+=this.info_.outputConnection.shape.pathUp(this.info_.outputConnection.height);this.outlinePath_+=\"z\"};\nBlockly.zelos.Drawer.prototype.drawFlatTop_=function(){var a=this.info_.topRow;this.positionPreviousConnection_();this.outlinePath_+=Blockly.utils.svgPaths.moveBy(a.xPos,this.info_.startY);this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"h\",a.width)};Blockly.zelos.Drawer.prototype.drawFlatBottom_=function(){var a=this.info_.bottomRow;this.positionNextConnection_();this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"V\",a.baseline);this.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"h\",-a.width)};\nBlockly.zelos.Drawer.prototype.drawInlineInput_=function(a){this.positionInlineInputConnection_(a);var b=a.input.name;if(!a.connectedBlock&&!this.info_.isInsertionMarker){var c=a.width-2*a.connectionWidth;a=Blockly.utils.svgPaths.moveTo(a.xPos+a.connectionWidth,a.centerline-a.height/2)+Blockly.utils.svgPaths.lineOnAxis(\"h\",c)+a.shape.pathRightDown(a.height)+Blockly.utils.svgPaths.lineOnAxis(\"h\",-c)+a.shape.pathUp(a.height)+\"z\";this.block_.pathObject.setOutlinePath(b,a)}};\nBlockly.zelos.Drawer.prototype.drawStatementInput_=function(a){var b=a.getLastInput(),c=b.xPos+b.notchOffset+b.shape.width,d=b.shape.pathRight+Blockly.utils.svgPaths.lineOnAxis(\"h\",-(b.notchOffset-this.constants_.INSIDE_CORNERS.width))+this.constants_.INSIDE_CORNERS.pathTop,e=a.height-2*this.constants_.INSIDE_CORNERS.height;b=this.constants_.INSIDE_CORNERS.pathBottom+Blockly.utils.svgPaths.lineOnAxis(\"h\",b.notchOffset-this.constants_.INSIDE_CORNERS.width)+(b.connectedBottomNextConnection?\"\":b.shape.pathLeft);\nthis.outlinePath_+=Blockly.utils.svgPaths.lineOnAxis(\"H\",c)+d+Blockly.utils.svgPaths.lineOnAxis(\"v\",e)+b+Blockly.utils.svgPaths.lineOnAxis(\"H\",a.xPos+a.width);this.positionStatementInputConnection_(a)};Blockly.zelos.PathObject=function(a,b,c){Blockly.zelos.PathObject.superClass_.constructor.call(this,a,b,c);this.constants=c;this.svgPathSelected_=null;this.outlines_={};this.outputShapeType=this.remainingOutlines_=null};Blockly.utils.object.inherits(Blockly.zelos.PathObject,Blockly.blockRendering.PathObject);Blockly.zelos.PathObject.prototype.setPath=function(a){Blockly.zelos.PathObject.superClass_.setPath.call(this,a);this.svgPathSelected_&&this.svgPathSelected_.setAttribute(\"d\",a)};\nBlockly.zelos.PathObject.prototype.applyColour=function(a){Blockly.zelos.PathObject.superClass_.applyColour.call(this,a);a.isShadow()&&a.getParent()&&this.svgPath.setAttribute(\"stroke\",a.getParent().style.colourTertiary);a=0;for(var b=Object.keys(this.outlines_),c;c=b[a];a++)this.outlines_[c].setAttribute(\"fill\",this.style.colourTertiary)};\nBlockly.zelos.PathObject.prototype.flipRTL=function(){Blockly.zelos.PathObject.superClass_.flipRTL.call(this);for(var a=0,b=Object.keys(this.outlines_),c;c=b[a];a++)this.outlines_[c].setAttribute(\"transform\",\"scale(-1 1)\")};\nBlockly.zelos.PathObject.prototype.updateSelected=function(a){this.setClass_(\"blocklySelected\",a);a?this.svgPathSelected_||(this.svgPathSelected_=this.svgPath.cloneNode(!0),this.svgPathSelected_.setAttribute(\"fill\",\"none\"),this.svgPathSelected_.setAttribute(\"filter\",\"url(#\"+this.constants.selectedGlowFilterId+\")\"),this.svgRoot.appendChild(this.svgPathSelected_)):this.svgPathSelected_&&(this.svgRoot.removeChild(this.svgPathSelected_),this.svgPathSelected_=null)};\nBlockly.zelos.PathObject.prototype.updateReplacementFade=function(a){this.setClass_(\"blocklyReplaceable\",a);a?this.svgPath.setAttribute(\"filter\",\"url(#\"+this.constants.replacementGlowFilterId+\")\"):this.svgPath.removeAttribute(\"filter\")};Blockly.zelos.PathObject.prototype.updateShapeForInputHighlight=function(a,b){a=a.getParentInput().name;(a=this.getOutlinePath_(a))&&(b?a.setAttribute(\"filter\",\"url(#\"+this.constants.replacementGlowFilterId+\")\"):a.removeAttribute(\"filter\"))};\nBlockly.zelos.PathObject.prototype.beginDrawing=function(){this.remainingOutlines_={};for(var a=0,b=Object.keys(this.outlines_),c;c=b[a];a++)this.remainingOutlines_[c]=1};Blockly.zelos.PathObject.prototype.endDrawing=function(){if(this.remainingOutlines_)for(var a=0,b=Object.keys(this.remainingOutlines_),c;c=b[a];a++)this.removeOutlinePath_(c);this.remainingOutlines_=null};\nBlockly.zelos.PathObject.prototype.setOutlinePath=function(a,b){a=this.getOutlinePath_(a);a.setAttribute(\"d\",b);a.setAttribute(\"fill\",this.style.colourTertiary)};Blockly.zelos.PathObject.prototype.getOutlinePath_=function(a){this.outlines_[a]||(this.outlines_[a]=Blockly.utils.dom.createSvgElement(\"path\",{\"class\":\"blocklyOutlinePath\",d:\"\"},this.svgRoot));this.remainingOutlines_&&delete this.remainingOutlines_[a];return this.outlines_[a]};\nBlockly.zelos.PathObject.prototype.removeOutlinePath_=function(a){this.outlines_[a].parentNode.removeChild(this.outlines_[a]);delete this.outlines_[a]};Blockly.zelos.MarkerSvg=function(a,b,c){Blockly.zelos.MarkerSvg.superClass_.constructor.call(this,a,b,c)};Blockly.utils.object.inherits(Blockly.zelos.MarkerSvg,Blockly.blockRendering.MarkerSvg);Blockly.zelos.MarkerSvg.prototype.showWithInput_=function(a){var b=a.getSourceBlock();a=a.getLocation().getOffsetInBlock();this.positionCircle_(a.x,a.y);this.setParent_(b);this.showCurrent_()};\nBlockly.zelos.MarkerSvg.prototype.showWithBlock_=function(a){a=a.getLocation();var b=a.getHeightWidth();this.positionRect_(0,0,b.width,b.height);this.setParent_(a);this.showCurrent_()};Blockly.zelos.MarkerSvg.prototype.positionCircle_=function(a,b){this.markerCircle_.setAttribute(\"cx\",a);this.markerCircle_.setAttribute(\"cy\",b);this.currentMarkerSvg=this.markerCircle_};\nBlockly.zelos.MarkerSvg.prototype.showAtLocation_=function(a){var b=!1;a.getType()==Blockly.ASTNode.types.OUTPUT?(this.showWithInput_(a),b=!0):a.getType()==Blockly.ASTNode.types.BLOCK&&(this.showWithBlock_(a),b=!0);b||Blockly.zelos.MarkerSvg.superClass_.showAtLocation_.call(this,a)};Blockly.zelos.MarkerSvg.prototype.hide=function(){Blockly.zelos.MarkerSvg.superClass_.hide.call(this);this.markerCircle_.style.display=\"none\"};\nBlockly.zelos.MarkerSvg.prototype.createDomInternal_=function(){Blockly.zelos.MarkerSvg.superClass_.createDomInternal_.call(this);this.markerCircle_=Blockly.utils.dom.createSvgElement(\"circle\",{r:this.constants_.CURSOR_RADIUS,style:\"display: none\",\"stroke-width\":this.constants_.CURSOR_STROKE_WIDTH},this.markerSvg_);if(this.isCursor()){var a=this.getBlinkProperties_();Blockly.utils.dom.createSvgElement(\"animate\",a,this.markerCircle_)}return this.markerSvg_};\nBlockly.zelos.MarkerSvg.prototype.applyColour_=function(){Blockly.zelos.MarkerSvg.superClass_.applyColour_.call(this);this.markerCircle_.setAttribute(\"fill\",this.colour_);this.markerCircle_.setAttribute(\"stroke\",this.colour_);this.isCursor()&&this.markerCircle_.firstChild.setAttribute(\"values\",this.colour_+\";transparent;transparent;\")};Blockly.zelos.Renderer=function(a){Blockly.zelos.Renderer.superClass_.constructor.call(this,a)};Blockly.utils.object.inherits(Blockly.zelos.Renderer,Blockly.blockRendering.Renderer);Blockly.zelos.Renderer.prototype.makeConstants_=function(){return new Blockly.zelos.ConstantProvider};Blockly.zelos.Renderer.prototype.makeRenderInfo_=function(a){return new Blockly.zelos.RenderInfo(this,a)};Blockly.zelos.Renderer.prototype.makeDrawer_=function(a,b){return new Blockly.zelos.Drawer(a,b)};\nBlockly.zelos.Renderer.prototype.makeMarkerDrawer=function(a,b){return new Blockly.zelos.MarkerSvg(a,this.getConstants(),b)};Blockly.zelos.Renderer.prototype.makePathObject=function(a,b){return new Blockly.zelos.PathObject(a,b,this.getConstants())};Blockly.zelos.Renderer.prototype.shouldHighlightConnection=function(a){return a.type!=Blockly.INPUT_VALUE&&a.type!==Blockly.OUTPUT_VALUE};\nBlockly.zelos.Renderer.prototype.getConnectionPreviewMethod=function(a,b,c){return b.type==Blockly.OUTPUT_VALUE?a.isConnected()?Blockly.InsertionMarkerManager.PREVIEW_TYPE.REPLACEMENT_FADE:Blockly.InsertionMarkerManager.PREVIEW_TYPE.INPUT_OUTLINE:Blockly.zelos.Renderer.superClass_.getConnectionPreviewMethod(a,b,c)};Blockly.blockRendering.register(\"zelos\",Blockly.zelos.Renderer);Blockly.Themes.Dark=Blockly.Theme.defineTheme(\"dark\",{base:Blockly.Themes.Classic,componentStyles:{workspaceBackgroundColour:\"#1e1e1e\",toolboxBackgroundColour:\"#333\",toolboxForegroundColour:\"#fff\",flyoutBackgroundColour:\"#252526\",flyoutForegroundColour:\"#ccc\",flyoutOpacity:1,scrollbarColour:\"#797979\",insertionMarkerColour:\"#fff\",insertionMarkerOpacity:.3,scrollbarOpacity:.4,cursorColour:\"#d0d0d0\"}});Blockly.Themes.Deuteranopia={};\nBlockly.Themes.Deuteranopia.defaultBlockStyles={colour_blocks:{colourPrimary:\"#f2a72c\",colourSecondary:\"#f1c172\",colourTertiary:\"#da921c\"},list_blocks:{colourPrimary:\"#7d65ab\",colourSecondary:\"#a88be0\",colourTertiary:\"#66518e\"},logic_blocks:{colourPrimary:\"#9fd2f1\",colourSecondary:\"#c0e0f4\",colourTertiary:\"#74bae5\"},loop_blocks:{colourPrimary:\"#795a07\",colourSecondary:\"#ac8726\",colourTertiary:\"#c4a03f\"},math_blocks:{colourPrimary:\"#e6da39\",colourSecondary:\"#f3ec8e\",colourTertiary:\"#f2eeb7\"},procedure_blocks:{colourPrimary:\"#590721\",\ncolourSecondary:\"#8c475d\",colourTertiary:\"#885464\"},text_blocks:{colourPrimary:\"#058863\",colourSecondary:\"#5ecfaf\",colourTertiary:\"#04684c\"},variable_blocks:{colourPrimary:\"#47025a\",colourSecondary:\"#820fa1\",colourTertiary:\"#8e579d\"},variable_dynamic_blocks:{colourPrimary:\"#47025a\",colourSecondary:\"#820fa1\",colourTertiary:\"#8e579d\"}};\nBlockly.Themes.Deuteranopia.categoryStyles={colour_category:{colour:\"#f2a72c\"},list_category:{colour:\"#7d65ab\"},logic_category:{colour:\"#9fd2f1\"},loop_category:{colour:\"#795a07\"},math_category:{colour:\"#e6da39\"},procedure_category:{colour:\"#590721\"},text_category:{colour:\"#058863\"},variable_category:{colour:\"#47025a\"},variable_dynamic_category:{colour:\"#47025a\"}};Blockly.Themes.Deuteranopia=new Blockly.Theme(\"deuteranopia\",Blockly.Themes.Deuteranopia.defaultBlockStyles,Blockly.Themes.Deuteranopia.categoryStyles);Blockly.Themes.HighContrast={};\nBlockly.Themes.HighContrast.defaultBlockStyles={colour_blocks:{colourPrimary:\"#a52714\",colourSecondary:\"#FB9B8C\",colourTertiary:\"#FBE1DD\"},list_blocks:{colourPrimary:\"#4a148c\",colourSecondary:\"#AD7BE9\",colourTertiary:\"#CDB6E9\"},logic_blocks:{colourPrimary:\"#01579b\",colourSecondary:\"#64C7FF\",colourTertiary:\"#C5EAFF\"},loop_blocks:{colourPrimary:\"#33691e\",colourSecondary:\"#9AFF78\",colourTertiary:\"#E1FFD7\"},math_blocks:{colourPrimary:\"#1a237e\",colourSecondary:\"#8A9EFF\",colourTertiary:\"#DCE2FF\"},procedure_blocks:{colourPrimary:\"#006064\",\ncolourSecondary:\"#77E6EE\",colourTertiary:\"#CFECEE\"},text_blocks:{colourPrimary:\"#004d40\",colourSecondary:\"#5ae27c\",colourTertiary:\"#D2FFDD\"},variable_blocks:{colourPrimary:\"#880e4f\",colourSecondary:\"#FF73BE\",colourTertiary:\"#FFD4EB\"},variable_dynamic_blocks:{colourPrimary:\"#880e4f\",colourSecondary:\"#FF73BE\",colourTertiary:\"#FFD4EB\"},hat_blocks:{colourPrimary:\"#880e4f\",colourSecondary:\"#FF73BE\",colourTertiary:\"#FFD4EB\",hat:\"cap\"}};\nBlockly.Themes.HighContrast.categoryStyles={colour_category:{colour:\"#a52714\"},list_category:{colour:\"#4a148c\"},logic_category:{colour:\"#01579b\"},loop_category:{colour:\"#33691e\"},math_category:{colour:\"#1a237e\"},procedure_category:{colour:\"#006064\"},text_category:{colour:\"#004d40\"},variable_category:{colour:\"#880e4f\"},variable_dynamic_category:{colour:\"#880e4f\"}};Blockly.Themes.HighContrast=new Blockly.Theme(\"highcontrast\",Blockly.Themes.HighContrast.defaultBlockStyles,Blockly.Themes.HighContrast.categoryStyles);\nBlockly.Themes.HighContrast.setComponentStyle(\"selectedGlowColour\",\"#000000\");Blockly.Themes.HighContrast.setComponentStyle(\"selectedGlowSize\",1);Blockly.Themes.HighContrast.setComponentStyle(\"replacementGlowColour\",\"#000000\");Blockly.Themes.HighContrast.setFontStyle({family:null,weight:null,size:16});Blockly.Themes.Tritanopia={};\nBlockly.Themes.Tritanopia.defaultBlockStyles={colour_blocks:{colourPrimary:\"#05427f\",colourSecondary:\"#2974c0\",colourTertiary:\"#2d74bb\"},list_blocks:{colourPrimary:\"#b69ce8\",colourSecondary:\"#ccbaef\",colourTertiary:\"#9176c5\"},logic_blocks:{colourPrimary:\"#9fd2f1\",colourSecondary:\"#c0e0f4\",colourTertiary:\"#74bae5\"},loop_blocks:{colourPrimary:\"#aa1846\",colourSecondary:\"#d36185\",colourTertiary:\"#7c1636\"},math_blocks:{colourPrimary:\"#e6da39\",colourSecondary:\"#f3ec8e\",colourTertiary:\"#f2eeb7\"},procedure_blocks:{colourPrimary:\"#590721\",\ncolourSecondary:\"#8c475d\",colourTertiary:\"#885464\"},text_blocks:{colourPrimary:\"#058863\",colourSecondary:\"#5ecfaf\",colourTertiary:\"#04684c\"},variable_blocks:{colourPrimary:\"#4b2d84\",colourSecondary:\"#816ea7\",colourTertiary:\"#83759e\"},variable_dynamic_blocks:{colourPrimary:\"#4b2d84\",colourSecondary:\"#816ea7\",colourTertiary:\"#83759e\"}};\nBlockly.Themes.Tritanopia.categoryStyles={colour_category:{colour:\"#05427f\"},list_category:{colour:\"#b69ce8\"},logic_category:{colour:\"#9fd2f1\"},loop_category:{colour:\"#aa1846\"},math_category:{colour:\"#e6da39\"},procedure_category:{colour:\"#590721\"},text_category:{colour:\"#058863\"},variable_category:{colour:\"#4b2d84\"},variable_dynamic_category:{colour:\"#4b2d84\"}};Blockly.Themes.Tritanopia=new Blockly.Theme(\"tritanopia\",Blockly.Themes.Tritanopia.defaultBlockStyles,Blockly.Themes.Tritanopia.categoryStyles);Blockly.requires={};\n\nreturn Blockly;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['./core'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('./core'));\n  } else { // Browser\n    root.Blockly.Blocks = factory(root.Blockly);\n  }\n}(this, function(Blockly) {\n\n    Blockly.Blocks={};// Do not edit this file; automatically generated by gulp.\n'use strict';\n\n\nBlockly.Blocks.colour={};Blockly.Constants={};Blockly.Constants.Colour={};Blockly.Constants.Colour.HUE=20;\nBlockly.defineBlocksWithJsonArray([{type:\"colour_picker\",message0:\"%1\",args0:[{type:\"field_colour\",name:\"COLOUR\",colour:\"#ff0000\"}],output:\"Colour\",helpUrl:\"%{BKY_COLOUR_PICKER_HELPURL}\",style:\"colour_blocks\",tooltip:\"%{BKY_COLOUR_PICKER_TOOLTIP}\",extensions:[\"parent_tooltip_when_inline\"]},{type:\"colour_random\",message0:\"%{BKY_COLOUR_RANDOM_TITLE}\",output:\"Colour\",helpUrl:\"%{BKY_COLOUR_RANDOM_HELPURL}\",style:\"colour_blocks\",tooltip:\"%{BKY_COLOUR_RANDOM_TOOLTIP}\"},{type:\"colour_rgb\",message0:\"%{BKY_COLOUR_RGB_TITLE} %{BKY_COLOUR_RGB_RED} %1 %{BKY_COLOUR_RGB_GREEN} %2 %{BKY_COLOUR_RGB_BLUE} %3\",\nargs0:[{type:\"input_value\",name:\"RED\",check:\"Number\",align:\"RIGHT\"},{type:\"input_value\",name:\"GREEN\",check:\"Number\",align:\"RIGHT\"},{type:\"input_value\",name:\"BLUE\",check:\"Number\",align:\"RIGHT\"}],output:\"Colour\",helpUrl:\"%{BKY_COLOUR_RGB_HELPURL}\",style:\"colour_blocks\",tooltip:\"%{BKY_COLOUR_RGB_TOOLTIP}\"},{type:\"colour_blend\",message0:\"%{BKY_COLOUR_BLEND_TITLE} %{BKY_COLOUR_BLEND_COLOUR1} %1 %{BKY_COLOUR_BLEND_COLOUR2} %2 %{BKY_COLOUR_BLEND_RATIO} %3\",args0:[{type:\"input_value\",name:\"COLOUR1\",check:\"Colour\",\nalign:\"RIGHT\"},{type:\"input_value\",name:\"COLOUR2\",check:\"Colour\",align:\"RIGHT\"},{type:\"input_value\",name:\"RATIO\",check:\"Number\",align:\"RIGHT\"}],output:\"Colour\",helpUrl:\"%{BKY_COLOUR_BLEND_HELPURL}\",style:\"colour_blocks\",tooltip:\"%{BKY_COLOUR_BLEND_TOOLTIP}\"}]);Blockly.Blocks.lists={};Blockly.Constants.Lists={};Blockly.Constants.Lists.HUE=260;\nBlockly.defineBlocksWithJsonArray([{type:\"lists_create_empty\",message0:\"%{BKY_LISTS_CREATE_EMPTY_TITLE}\",output:\"Array\",style:\"list_blocks\",tooltip:\"%{BKY_LISTS_CREATE_EMPTY_TOOLTIP}\",helpUrl:\"%{BKY_LISTS_CREATE_EMPTY_HELPURL}\"},{type:\"lists_repeat\",message0:\"%{BKY_LISTS_REPEAT_TITLE}\",args0:[{type:\"input_value\",name:\"ITEM\"},{type:\"input_value\",name:\"NUM\",check:\"Number\"}],output:\"Array\",style:\"list_blocks\",tooltip:\"%{BKY_LISTS_REPEAT_TOOLTIP}\",helpUrl:\"%{BKY_LISTS_REPEAT_HELPURL}\"},{type:\"lists_reverse\",\nmessage0:\"%{BKY_LISTS_REVERSE_MESSAGE0}\",args0:[{type:\"input_value\",name:\"LIST\",check:\"Array\"}],output:\"Array\",inputsInline:!0,style:\"list_blocks\",tooltip:\"%{BKY_LISTS_REVERSE_TOOLTIP}\",helpUrl:\"%{BKY_LISTS_REVERSE_HELPURL}\"},{type:\"lists_isEmpty\",message0:\"%{BKY_LISTS_ISEMPTY_TITLE}\",args0:[{type:\"input_value\",name:\"VALUE\",check:[\"String\",\"Array\"]}],output:\"Boolean\",style:\"list_blocks\",tooltip:\"%{BKY_LISTS_ISEMPTY_TOOLTIP}\",helpUrl:\"%{BKY_LISTS_ISEMPTY_HELPURL}\"},{type:\"lists_length\",message0:\"%{BKY_LISTS_LENGTH_TITLE}\",\nargs0:[{type:\"input_value\",name:\"VALUE\",check:[\"String\",\"Array\"]}],output:\"Number\",style:\"list_blocks\",tooltip:\"%{BKY_LISTS_LENGTH_TOOLTIP}\",helpUrl:\"%{BKY_LISTS_LENGTH_HELPURL}\"}]);\nBlockly.Blocks.lists_create_with={init:function(){this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_HELPURL);this.setStyle(\"list_blocks\");this.itemCount_=3;this.updateShape_();this.setOutput(!0,\"Array\");this.setMutator(new Blockly.Mutator([\"lists_create_with_item\"]));this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_TOOLTIP)},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"items\",this.itemCount_);return a},domToMutation:function(a){this.itemCount_=parseInt(a.getAttribute(\"items\"),\n10);this.updateShape_()},decompose:function(a){var b=a.newBlock(\"lists_create_with_container\");b.initSvg();for(var c=b.getInput(\"STACK\").connection,d=0;d<this.itemCount_;d++){var e=a.newBlock(\"lists_create_with_item\");e.initSvg();c.connect(e.previousConnection);c=e.nextConnection}return b},compose:function(a){var b=a.getInputTargetBlock(\"STACK\");for(a=[];b;)a.push(b.valueConnection_),b=b.nextConnection&&b.nextConnection.targetBlock();for(b=0;b<this.itemCount_;b++){var c=this.getInput(\"ADD\"+b).connection.targetConnection;\nc&&-1==a.indexOf(c)&&c.disconnect()}this.itemCount_=a.length;this.updateShape_();for(b=0;b<this.itemCount_;b++)Blockly.Mutator.reconnect(a[b],this,\"ADD\"+b)},saveConnections:function(a){a=a.getInputTargetBlock(\"STACK\");for(var b=0;a;){var c=this.getInput(\"ADD\"+b);a.valueConnection_=c&&c.connection.targetConnection;b++;a=a.nextConnection&&a.nextConnection.targetBlock()}},updateShape_:function(){this.itemCount_&&this.getInput(\"EMPTY\")?this.removeInput(\"EMPTY\"):this.itemCount_||this.getInput(\"EMPTY\")||\nthis.appendDummyInput(\"EMPTY\").appendField(Blockly.Msg.LISTS_CREATE_EMPTY_TITLE);for(var a=0;a<this.itemCount_;a++)if(!this.getInput(\"ADD\"+a)){var b=this.appendValueInput(\"ADD\"+a).setAlign(Blockly.ALIGN_RIGHT);0==a&&b.appendField(Blockly.Msg.LISTS_CREATE_WITH_INPUT_WITH)}for(;this.getInput(\"ADD\"+a);)this.removeInput(\"ADD\"+a),a++}};\nBlockly.Blocks.lists_create_with_container={init:function(){this.setStyle(\"list_blocks\");this.appendDummyInput().appendField(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD);this.appendStatementInput(\"STACK\");this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP);this.contextMenu=!1}};\nBlockly.Blocks.lists_create_with_item={init:function(){this.setStyle(\"list_blocks\");this.appendDummyInput().appendField(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TITLE);this.setPreviousStatement(!0);this.setNextStatement(!0);this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP);this.contextMenu=!1}};\nBlockly.Blocks.lists_indexOf={init:function(){var a=[[Blockly.Msg.LISTS_INDEX_OF_FIRST,\"FIRST\"],[Blockly.Msg.LISTS_INDEX_OF_LAST,\"LAST\"]];this.setHelpUrl(Blockly.Msg.LISTS_INDEX_OF_HELPURL);this.setStyle(\"list_blocks\");this.setOutput(!0,\"Number\");this.appendValueInput(\"VALUE\").setCheck(\"Array\").appendField(Blockly.Msg.LISTS_INDEX_OF_INPUT_IN_LIST);this.appendValueInput(\"FIND\").appendField(new Blockly.FieldDropdown(a),\"END\");this.setInputsInline(!0);var b=this;this.setTooltip(function(){return Blockly.Msg.LISTS_INDEX_OF_TOOLTIP.replace(\"%1\",\nb.workspace.options.oneBasedIndex?\"0\":\"-1\")})}};\nBlockly.Blocks.lists_getIndex={init:function(){var a=[[Blockly.Msg.LISTS_GET_INDEX_GET,\"GET\"],[Blockly.Msg.LISTS_GET_INDEX_GET_REMOVE,\"GET_REMOVE\"],[Blockly.Msg.LISTS_GET_INDEX_REMOVE,\"REMOVE\"]];this.WHERE_OPTIONS=[[Blockly.Msg.LISTS_GET_INDEX_FROM_START,\"FROM_START\"],[Blockly.Msg.LISTS_GET_INDEX_FROM_END,\"FROM_END\"],[Blockly.Msg.LISTS_GET_INDEX_FIRST,\"FIRST\"],[Blockly.Msg.LISTS_GET_INDEX_LAST,\"LAST\"],[Blockly.Msg.LISTS_GET_INDEX_RANDOM,\"RANDOM\"]];this.setHelpUrl(Blockly.Msg.LISTS_GET_INDEX_HELPURL);this.setStyle(\"list_blocks\");\na=new Blockly.FieldDropdown(a,function(a){a=\"REMOVE\"==a;this.getSourceBlock().updateStatement_(a)});this.appendValueInput(\"VALUE\").setCheck(\"Array\").appendField(Blockly.Msg.LISTS_GET_INDEX_INPUT_IN_LIST);this.appendDummyInput().appendField(a,\"MODE\").appendField(\"\",\"SPACE\");this.appendDummyInput(\"AT\");Blockly.Msg.LISTS_GET_INDEX_TAIL&&this.appendDummyInput(\"TAIL\").appendField(Blockly.Msg.LISTS_GET_INDEX_TAIL);this.setInputsInline(!0);this.setOutput(!0);this.updateAt_(!0);var b=this;this.setTooltip(function(){var a=\nb.getFieldValue(\"MODE\"),d=b.getFieldValue(\"WHERE\"),e=\"\";switch(a+\" \"+d){case \"GET FROM_START\":case \"GET FROM_END\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM;break;case \"GET FIRST\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST;break;case \"GET LAST\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST;break;case \"GET RANDOM\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM;break;case \"GET_REMOVE FROM_START\":case \"GET_REMOVE FROM_END\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM;break;case \"GET_REMOVE FIRST\":e=\nBlockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST;break;case \"GET_REMOVE LAST\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST;break;case \"GET_REMOVE RANDOM\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM;break;case \"REMOVE FROM_START\":case \"REMOVE FROM_END\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM;break;case \"REMOVE FIRST\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST;break;case \"REMOVE LAST\":e=Blockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST;break;case \"REMOVE RANDOM\":e=\nBlockly.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM}if(\"FROM_START\"==d||\"FROM_END\"==d)e+=\"  \"+(\"FROM_START\"==d?Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP:Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP).replace(\"%1\",b.workspace.options.oneBasedIndex?\"#1\":\"#0\");return e})},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"statement\",!this.outputConnection);var b=this.getInput(\"AT\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at\",b);return a},domToMutation:function(a){var b=\n\"true\"==a.getAttribute(\"statement\");this.updateStatement_(b);a=\"false\"!=a.getAttribute(\"at\");this.updateAt_(a)},updateStatement_:function(a){a!=!this.outputConnection&&(this.unplug(!0,!0),a?(this.setOutput(!1),this.setPreviousStatement(!0),this.setNextStatement(!0)):(this.setPreviousStatement(!1),this.setNextStatement(!1),this.setOutput(!0)))},updateAt_:function(a){this.removeInput(\"AT\");this.removeInput(\"ORDINAL\",!0);a?(this.appendValueInput(\"AT\").setCheck(\"Number\"),Blockly.Msg.ORDINAL_NUMBER_SUFFIX&&\nthis.appendDummyInput(\"ORDINAL\").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)):this.appendDummyInput(\"AT\");var b=new Blockly.FieldDropdown(this.WHERE_OPTIONS,function(b){var c=\"FROM_START\"==b||\"FROM_END\"==b;if(c!=a){var e=this.getSourceBlock();e.updateAt_(c);e.setFieldValue(b,\"WHERE\");return null}});this.getInput(\"AT\").appendField(b,\"WHERE\");Blockly.Msg.LISTS_GET_INDEX_TAIL&&this.moveInputBefore(\"TAIL\",null)}};\nBlockly.Blocks.lists_setIndex={init:function(){var a=[[Blockly.Msg.LISTS_SET_INDEX_SET,\"SET\"],[Blockly.Msg.LISTS_SET_INDEX_INSERT,\"INSERT\"]];this.WHERE_OPTIONS=[[Blockly.Msg.LISTS_GET_INDEX_FROM_START,\"FROM_START\"],[Blockly.Msg.LISTS_GET_INDEX_FROM_END,\"FROM_END\"],[Blockly.Msg.LISTS_GET_INDEX_FIRST,\"FIRST\"],[Blockly.Msg.LISTS_GET_INDEX_LAST,\"LAST\"],[Blockly.Msg.LISTS_GET_INDEX_RANDOM,\"RANDOM\"]];this.setHelpUrl(Blockly.Msg.LISTS_SET_INDEX_HELPURL);this.setStyle(\"list_blocks\");this.appendValueInput(\"LIST\").setCheck(\"Array\").appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_IN_LIST);\nthis.appendDummyInput().appendField(new Blockly.FieldDropdown(a),\"MODE\").appendField(\"\",\"SPACE\");this.appendDummyInput(\"AT\");this.appendValueInput(\"TO\").appendField(Blockly.Msg.LISTS_SET_INDEX_INPUT_TO);this.setInputsInline(!0);this.setPreviousStatement(!0);this.setNextStatement(!0);this.setTooltip(Blockly.Msg.LISTS_SET_INDEX_TOOLTIP);this.updateAt_(!0);var b=this;this.setTooltip(function(){var a=b.getFieldValue(\"MODE\"),d=b.getFieldValue(\"WHERE\"),e=\"\";switch(a+\" \"+d){case \"SET FROM_START\":case \"SET FROM_END\":e=\nBlockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM;break;case \"SET FIRST\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST;break;case \"SET LAST\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST;break;case \"SET RANDOM\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM;break;case \"INSERT FROM_START\":case \"INSERT FROM_END\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM;break;case \"INSERT FIRST\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST;break;case \"INSERT LAST\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST;\nbreak;case \"INSERT RANDOM\":e=Blockly.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM}if(\"FROM_START\"==d||\"FROM_END\"==d)e+=\"  \"+Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP.replace(\"%1\",b.workspace.options.oneBasedIndex?\"#1\":\"#0\");return e})},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\"),b=this.getInput(\"AT\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at\",b);return a},domToMutation:function(a){a=\"false\"!=a.getAttribute(\"at\");this.updateAt_(a)},updateAt_:function(a){this.removeInput(\"AT\");\nthis.removeInput(\"ORDINAL\",!0);a?(this.appendValueInput(\"AT\").setCheck(\"Number\"),Blockly.Msg.ORDINAL_NUMBER_SUFFIX&&this.appendDummyInput(\"ORDINAL\").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)):this.appendDummyInput(\"AT\");var b=new Blockly.FieldDropdown(this.WHERE_OPTIONS,function(b){var c=\"FROM_START\"==b||\"FROM_END\"==b;if(c!=a){var e=this.getSourceBlock();e.updateAt_(c);e.setFieldValue(b,\"WHERE\");return null}});this.moveInputBefore(\"AT\",\"TO\");this.getInput(\"ORDINAL\")&&this.moveInputBefore(\"ORDINAL\",\n\"TO\");this.getInput(\"AT\").appendField(b,\"WHERE\")}};\nBlockly.Blocks.lists_getSublist={init:function(){this.WHERE_OPTIONS_1=[[Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_START,\"FROM_START\"],[Blockly.Msg.LISTS_GET_SUBLIST_START_FROM_END,\"FROM_END\"],[Blockly.Msg.LISTS_GET_SUBLIST_START_FIRST,\"FIRST\"]];this.WHERE_OPTIONS_2=[[Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_START,\"FROM_START\"],[Blockly.Msg.LISTS_GET_SUBLIST_END_FROM_END,\"FROM_END\"],[Blockly.Msg.LISTS_GET_SUBLIST_END_LAST,\"LAST\"]];this.setHelpUrl(Blockly.Msg.LISTS_GET_SUBLIST_HELPURL);this.setStyle(\"list_blocks\");\nthis.appendValueInput(\"LIST\").setCheck(\"Array\").appendField(Blockly.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST);this.appendDummyInput(\"AT1\");this.appendDummyInput(\"AT2\");Blockly.Msg.LISTS_GET_SUBLIST_TAIL&&this.appendDummyInput(\"TAIL\").appendField(Blockly.Msg.LISTS_GET_SUBLIST_TAIL);this.setInputsInline(!0);this.setOutput(!0,\"Array\");this.updateAt_(1,!0);this.updateAt_(2,!0);this.setTooltip(Blockly.Msg.LISTS_GET_SUBLIST_TOOLTIP)},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\"),\nb=this.getInput(\"AT1\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at1\",b);b=this.getInput(\"AT2\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at2\",b);return a},domToMutation:function(a){var b=\"true\"==a.getAttribute(\"at1\");a=\"true\"==a.getAttribute(\"at2\");this.updateAt_(1,b);this.updateAt_(2,a)},updateAt_:function(a,b){this.removeInput(\"AT\"+a);this.removeInput(\"ORDINAL\"+a,!0);b?(this.appendValueInput(\"AT\"+a).setCheck(\"Number\"),Blockly.Msg.ORDINAL_NUMBER_SUFFIX&&this.appendDummyInput(\"ORDINAL\"+a).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)):\nthis.appendDummyInput(\"AT\"+a);var c=new Blockly.FieldDropdown(this[\"WHERE_OPTIONS_\"+a],function(c){var e=\"FROM_START\"==c||\"FROM_END\"==c;if(e!=b){var d=this.getSourceBlock();d.updateAt_(a,e);d.setFieldValue(c,\"WHERE\"+a);return null}});this.getInput(\"AT\"+a).appendField(c,\"WHERE\"+a);1==a&&(this.moveInputBefore(\"AT1\",\"AT2\"),this.getInput(\"ORDINAL1\")&&this.moveInputBefore(\"ORDINAL1\",\"AT2\"));Blockly.Msg.LISTS_GET_SUBLIST_TAIL&&this.moveInputBefore(\"TAIL\",null)}};\nBlockly.Blocks.lists_sort={init:function(){this.jsonInit({message0:Blockly.Msg.LISTS_SORT_TITLE,args0:[{type:\"field_dropdown\",name:\"TYPE\",options:[[Blockly.Msg.LISTS_SORT_TYPE_NUMERIC,\"NUMERIC\"],[Blockly.Msg.LISTS_SORT_TYPE_TEXT,\"TEXT\"],[Blockly.Msg.LISTS_SORT_TYPE_IGNORECASE,\"IGNORE_CASE\"]]},{type:\"field_dropdown\",name:\"DIRECTION\",options:[[Blockly.Msg.LISTS_SORT_ORDER_ASCENDING,\"1\"],[Blockly.Msg.LISTS_SORT_ORDER_DESCENDING,\"-1\"]]},{type:\"input_value\",name:\"LIST\",check:\"Array\"}],output:\"Array\",style:\"list_blocks\",\ntooltip:Blockly.Msg.LISTS_SORT_TOOLTIP,helpUrl:Blockly.Msg.LISTS_SORT_HELPURL})}};\nBlockly.Blocks.lists_split={init:function(){var a=this,b=new Blockly.FieldDropdown([[Blockly.Msg.LISTS_SPLIT_LIST_FROM_TEXT,\"SPLIT\"],[Blockly.Msg.LISTS_SPLIT_TEXT_FROM_LIST,\"JOIN\"]],function(b){a.updateType_(b)});this.setHelpUrl(Blockly.Msg.LISTS_SPLIT_HELPURL);this.setStyle(\"list_blocks\");this.appendValueInput(\"INPUT\").setCheck(\"String\").appendField(b,\"MODE\");this.appendValueInput(\"DELIM\").setCheck(\"String\").appendField(Blockly.Msg.LISTS_SPLIT_WITH_DELIMITER);this.setInputsInline(!0);this.setOutput(!0,\n\"Array\");this.setTooltip(function(){var b=a.getFieldValue(\"MODE\");if(\"SPLIT\"==b)return Blockly.Msg.LISTS_SPLIT_TOOLTIP_SPLIT;if(\"JOIN\"==b)return Blockly.Msg.LISTS_SPLIT_TOOLTIP_JOIN;throw Error(\"Unknown mode: \"+b);})},updateType_:function(a){if(this.getFieldValue(\"MODE\")!=a){var b=this.getInput(\"INPUT\").connection;b.setShadowDom(null);var c=b.targetBlock();c&&(b.disconnect(),c.isShadow()?c.dispose():this.bumpNeighbours())}\"SPLIT\"==a?(this.outputConnection.setCheck(\"Array\"),this.getInput(\"INPUT\").setCheck(\"String\")):\n(this.outputConnection.setCheck(\"String\"),this.getInput(\"INPUT\").setCheck(\"Array\"))},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"mode\",this.getFieldValue(\"MODE\"));return a},domToMutation:function(a){this.updateType_(a.getAttribute(\"mode\"))}};Blockly.Blocks.logic={};Blockly.Constants.Logic={};Blockly.Constants.Logic.HUE=210;\nBlockly.defineBlocksWithJsonArray([{type:\"logic_boolean\",message0:\"%1\",args0:[{type:\"field_dropdown\",name:\"BOOL\",options:[[\"%{BKY_LOGIC_BOOLEAN_TRUE}\",\"TRUE\"],[\"%{BKY_LOGIC_BOOLEAN_FALSE}\",\"FALSE\"]]}],output:\"Boolean\",style:\"logic_blocks\",tooltip:\"%{BKY_LOGIC_BOOLEAN_TOOLTIP}\",helpUrl:\"%{BKY_LOGIC_BOOLEAN_HELPURL}\"},{type:\"controls_if\",message0:\"%{BKY_CONTROLS_IF_MSG_IF} %1\",args0:[{type:\"input_value\",name:\"IF0\",check:\"Boolean\"}],message1:\"%{BKY_CONTROLS_IF_MSG_THEN} %1\",args1:[{type:\"input_statement\",\nname:\"DO0\"}],previousStatement:null,nextStatement:null,style:\"logic_blocks\",helpUrl:\"%{BKY_CONTROLS_IF_HELPURL}\",mutator:\"controls_if_mutator\",extensions:[\"controls_if_tooltip\"]},{type:\"controls_ifelse\",message0:\"%{BKY_CONTROLS_IF_MSG_IF} %1\",args0:[{type:\"input_value\",name:\"IF0\",check:\"Boolean\"}],message1:\"%{BKY_CONTROLS_IF_MSG_THEN} %1\",args1:[{type:\"input_statement\",name:\"DO0\"}],message2:\"%{BKY_CONTROLS_IF_MSG_ELSE} %1\",args2:[{type:\"input_statement\",name:\"ELSE\"}],previousStatement:null,nextStatement:null,\nstyle:\"logic_blocks\",tooltip:\"%{BKYCONTROLS_IF_TOOLTIP_2}\",helpUrl:\"%{BKY_CONTROLS_IF_HELPURL}\",extensions:[\"controls_if_tooltip\"]},{type:\"logic_compare\",message0:\"%1 %2 %3\",args0:[{type:\"input_value\",name:\"A\"},{type:\"field_dropdown\",name:\"OP\",options:[[\"=\",\"EQ\"],[\"\\u2260\",\"NEQ\"],[\"\\u200f<\",\"LT\"],[\"\\u200f\\u2264\",\"LTE\"],[\"\\u200f>\",\"GT\"],[\"\\u200f\\u2265\",\"GTE\"]]},{type:\"input_value\",name:\"B\"}],inputsInline:!0,output:\"Boolean\",style:\"logic_blocks\",helpUrl:\"%{BKY_LOGIC_COMPARE_HELPURL}\",extensions:[\"logic_compare\",\n\"logic_op_tooltip\"]},{type:\"logic_operation\",message0:\"%1 %2 %3\",args0:[{type:\"input_value\",name:\"A\",check:\"Boolean\"},{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_LOGIC_OPERATION_AND}\",\"AND\"],[\"%{BKY_LOGIC_OPERATION_OR}\",\"OR\"]]},{type:\"input_value\",name:\"B\",check:\"Boolean\"}],inputsInline:!0,output:\"Boolean\",style:\"logic_blocks\",helpUrl:\"%{BKY_LOGIC_OPERATION_HELPURL}\",extensions:[\"logic_op_tooltip\"]},{type:\"logic_negate\",message0:\"%{BKY_LOGIC_NEGATE_TITLE}\",args0:[{type:\"input_value\",name:\"BOOL\",\ncheck:\"Boolean\"}],output:\"Boolean\",style:\"logic_blocks\",tooltip:\"%{BKY_LOGIC_NEGATE_TOOLTIP}\",helpUrl:\"%{BKY_LOGIC_NEGATE_HELPURL}\"},{type:\"logic_null\",message0:\"%{BKY_LOGIC_NULL}\",output:null,style:\"logic_blocks\",tooltip:\"%{BKY_LOGIC_NULL_TOOLTIP}\",helpUrl:\"%{BKY_LOGIC_NULL_HELPURL}\"},{type:\"logic_ternary\",message0:\"%{BKY_LOGIC_TERNARY_CONDITION} %1\",args0:[{type:\"input_value\",name:\"IF\",check:\"Boolean\"}],message1:\"%{BKY_LOGIC_TERNARY_IF_TRUE} %1\",args1:[{type:\"input_value\",name:\"THEN\"}],message2:\"%{BKY_LOGIC_TERNARY_IF_FALSE} %1\",\nargs2:[{type:\"input_value\",name:\"ELSE\"}],output:null,style:\"logic_blocks\",tooltip:\"%{BKY_LOGIC_TERNARY_TOOLTIP}\",helpUrl:\"%{BKY_LOGIC_TERNARY_HELPURL}\",extensions:[\"logic_ternary\"]}]);\nBlockly.defineBlocksWithJsonArray([{type:\"controls_if_if\",message0:\"%{BKY_CONTROLS_IF_IF_TITLE_IF}\",nextStatement:null,enableContextMenu:!1,style:\"logic_blocks\",tooltip:\"%{BKY_CONTROLS_IF_IF_TOOLTIP}\"},{type:\"controls_if_elseif\",message0:\"%{BKY_CONTROLS_IF_ELSEIF_TITLE_ELSEIF}\",previousStatement:null,nextStatement:null,enableContextMenu:!1,style:\"logic_blocks\",tooltip:\"%{BKY_CONTROLS_IF_ELSEIF_TOOLTIP}\"},{type:\"controls_if_else\",message0:\"%{BKY_CONTROLS_IF_ELSE_TITLE_ELSE}\",previousStatement:null,\nenableContextMenu:!1,style:\"logic_blocks\",tooltip:\"%{BKY_CONTROLS_IF_ELSE_TOOLTIP}\"}]);Blockly.Constants.Logic.TOOLTIPS_BY_OP={EQ:\"%{BKY_LOGIC_COMPARE_TOOLTIP_EQ}\",NEQ:\"%{BKY_LOGIC_COMPARE_TOOLTIP_NEQ}\",LT:\"%{BKY_LOGIC_COMPARE_TOOLTIP_LT}\",LTE:\"%{BKY_LOGIC_COMPARE_TOOLTIP_LTE}\",GT:\"%{BKY_LOGIC_COMPARE_TOOLTIP_GT}\",GTE:\"%{BKY_LOGIC_COMPARE_TOOLTIP_GTE}\",AND:\"%{BKY_LOGIC_OPERATION_TOOLTIP_AND}\",OR:\"%{BKY_LOGIC_OPERATION_TOOLTIP_OR}\"};\nBlockly.Extensions.register(\"logic_op_tooltip\",Blockly.Extensions.buildTooltipForDropdown(\"OP\",Blockly.Constants.Logic.TOOLTIPS_BY_OP));\nBlockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN={elseifCount_:0,elseCount_:0,suppressPrefixSuffix:!0,mutationToDom:function(){if(!this.elseifCount_&&!this.elseCount_)return null;var a=Blockly.utils.xml.createElement(\"mutation\");this.elseifCount_&&a.setAttribute(\"elseif\",this.elseifCount_);this.elseCount_&&a.setAttribute(\"else\",1);return a},domToMutation:function(a){this.elseifCount_=parseInt(a.getAttribute(\"elseif\"),10)||0;this.elseCount_=parseInt(a.getAttribute(\"else\"),10)||0;this.rebuildShape_()},\ndecompose:function(a){var b=a.newBlock(\"controls_if_if\");b.initSvg();for(var c=b.nextConnection,d=1;d<=this.elseifCount_;d++){var e=a.newBlock(\"controls_if_elseif\");e.initSvg();c.connect(e.previousConnection);c=e.nextConnection}this.elseCount_&&(a=a.newBlock(\"controls_if_else\"),a.initSvg(),c.connect(a.previousConnection));return b},compose:function(a){a=a.nextConnection.targetBlock();this.elseCount_=this.elseifCount_=0;for(var b=[null],c=[null],d=null;a;){switch(a.type){case \"controls_if_elseif\":this.elseifCount_++;\nb.push(a.valueConnection_);c.push(a.statementConnection_);break;case \"controls_if_else\":this.elseCount_++;d=a.statementConnection_;break;default:throw TypeError(\"Unknown block type: \"+a.type);}a=a.nextConnection&&a.nextConnection.targetBlock()}this.updateShape_();this.reconnectChildBlocks_(b,c,d)},saveConnections:function(a){a=a.nextConnection.targetBlock();for(var b=1;a;){switch(a.type){case \"controls_if_elseif\":var c=this.getInput(\"IF\"+b),d=this.getInput(\"DO\"+b);a.valueConnection_=c&&c.connection.targetConnection;\na.statementConnection_=d&&d.connection.targetConnection;b++;break;case \"controls_if_else\":d=this.getInput(\"ELSE\");a.statementConnection_=d&&d.connection.targetConnection;break;default:throw TypeError(\"Unknown block type: \"+a.type);}a=a.nextConnection&&a.nextConnection.targetBlock()}},rebuildShape_:function(){var a=[null],b=[null],c=null;this.getInput(\"ELSE\")&&(c=this.getInput(\"ELSE\").connection.targetConnection);for(var d=1;this.getInput(\"IF\"+d);){var e=this.getInput(\"IF\"+d),f=this.getInput(\"DO\"+\nd);a.push(e.connection.targetConnection);b.push(f.connection.targetConnection);d++}this.updateShape_();this.reconnectChildBlocks_(a,b,c)},updateShape_:function(){this.getInput(\"ELSE\")&&this.removeInput(\"ELSE\");for(var a=1;this.getInput(\"IF\"+a);)this.removeInput(\"IF\"+a),this.removeInput(\"DO\"+a),a++;for(a=1;a<=this.elseifCount_;a++)this.appendValueInput(\"IF\"+a).setCheck(\"Boolean\").appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSEIF),this.appendStatementInput(\"DO\"+a).appendField(Blockly.Msg.CONTROLS_IF_MSG_THEN);\nthis.elseCount_&&this.appendStatementInput(\"ELSE\").appendField(Blockly.Msg.CONTROLS_IF_MSG_ELSE)},reconnectChildBlocks_:function(a,b,c){for(var d=1;d<=this.elseifCount_;d++)Blockly.Mutator.reconnect(a[d],this,\"IF\"+d),Blockly.Mutator.reconnect(b[d],this,\"DO\"+d);Blockly.Mutator.reconnect(c,this,\"ELSE\")}};Blockly.Extensions.registerMutator(\"controls_if_mutator\",Blockly.Constants.Logic.CONTROLS_IF_MUTATOR_MIXIN,null,[\"controls_if_elseif\",\"controls_if_else\"]);\nBlockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION=function(){this.setTooltip(function(){if(this.elseifCount_||this.elseCount_){if(!this.elseifCount_&&this.elseCount_)return Blockly.Msg.CONTROLS_IF_TOOLTIP_2;if(this.elseifCount_&&!this.elseCount_)return Blockly.Msg.CONTROLS_IF_TOOLTIP_3;if(this.elseifCount_&&this.elseCount_)return Blockly.Msg.CONTROLS_IF_TOOLTIP_4}else return Blockly.Msg.CONTROLS_IF_TOOLTIP_1;return\"\"}.bind(this))};Blockly.Extensions.register(\"controls_if_tooltip\",Blockly.Constants.Logic.CONTROLS_IF_TOOLTIP_EXTENSION);\nBlockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN={onchange:function(a){this.prevBlocks_||(this.prevBlocks_=[null,null]);var b=this.getInputTargetBlock(\"A\"),c=this.getInputTargetBlock(\"B\");b&&c&&!b.outputConnection.checkType(c.outputConnection)&&(Blockly.Events.setGroup(a.group),a=this.prevBlocks_[0],a!==b&&(b.unplug(),!a||a.isDisposed()||a.isShadow()||this.getInput(\"A\").connection.connect(a.outputConnection)),b=this.prevBlocks_[1],b!==c&&(c.unplug(),!b||b.isDisposed()||b.isShadow()||this.getInput(\"B\").connection.connect(b.outputConnection)),\nthis.bumpNeighbours(),Blockly.Events.setGroup(!1));this.prevBlocks_[0]=this.getInputTargetBlock(\"A\");this.prevBlocks_[1]=this.getInputTargetBlock(\"B\")}};Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION=function(){this.mixin(Blockly.Constants.Logic.LOGIC_COMPARE_ONCHANGE_MIXIN)};Blockly.Extensions.register(\"logic_compare\",Blockly.Constants.Logic.LOGIC_COMPARE_EXTENSION);\nBlockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN={prevParentConnection_:null,onchange:function(a){var b=this.getInputTargetBlock(\"THEN\"),c=this.getInputTargetBlock(\"ELSE\"),d=this.outputConnection.targetConnection;if((b||c)&&d)for(var e=0;2>e;e++){var f=1==e?b:c;f&&!f.outputConnection.checkType(d)&&(Blockly.Events.setGroup(a.group),d===this.prevParentConnection_?(this.unplug(),d.getSourceBlock().bumpNeighbours()):(f.unplug(),f.bumpNeighbours()),Blockly.Events.setGroup(!1))}this.prevParentConnection_=\nd}};Blockly.Extensions.registerMixin(\"logic_ternary\",Blockly.Constants.Logic.LOGIC_TERNARY_ONCHANGE_MIXIN);Blockly.Blocks.loops={};Blockly.Constants.Loops={};Blockly.Constants.Loops.HUE=120;\nBlockly.defineBlocksWithJsonArray([{type:\"controls_repeat_ext\",message0:\"%{BKY_CONTROLS_REPEAT_TITLE}\",args0:[{type:\"input_value\",name:\"TIMES\",check:\"Number\"}],message1:\"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",args1:[{type:\"input_statement\",name:\"DO\"}],previousStatement:null,nextStatement:null,style:\"loop_blocks\",tooltip:\"%{BKY_CONTROLS_REPEAT_TOOLTIP}\",helpUrl:\"%{BKY_CONTROLS_REPEAT_HELPURL}\"},{type:\"controls_repeat\",message0:\"%{BKY_CONTROLS_REPEAT_TITLE}\",args0:[{type:\"field_number\",name:\"TIMES\",value:10,\nmin:0,precision:1}],message1:\"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",args1:[{type:\"input_statement\",name:\"DO\"}],previousStatement:null,nextStatement:null,style:\"loop_blocks\",tooltip:\"%{BKY_CONTROLS_REPEAT_TOOLTIP}\",helpUrl:\"%{BKY_CONTROLS_REPEAT_HELPURL}\"},{type:\"controls_whileUntil\",message0:\"%1 %2\",args0:[{type:\"field_dropdown\",name:\"MODE\",options:[[\"%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_WHILE}\",\"WHILE\"],[\"%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL}\",\"UNTIL\"]]},{type:\"input_value\",name:\"BOOL\",check:\"Boolean\"}],\nmessage1:\"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",args1:[{type:\"input_statement\",name:\"DO\"}],previousStatement:null,nextStatement:null,style:\"loop_blocks\",helpUrl:\"%{BKY_CONTROLS_WHILEUNTIL_HELPURL}\",extensions:[\"controls_whileUntil_tooltip\"]},{type:\"controls_for\",message0:\"%{BKY_CONTROLS_FOR_TITLE}\",args0:[{type:\"field_variable\",name:\"VAR\",variable:null},{type:\"input_value\",name:\"FROM\",check:\"Number\",align:\"RIGHT\"},{type:\"input_value\",name:\"TO\",check:\"Number\",align:\"RIGHT\"},{type:\"input_value\",name:\"BY\",\ncheck:\"Number\",align:\"RIGHT\"}],message1:\"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",args1:[{type:\"input_statement\",name:\"DO\"}],inputsInline:!0,previousStatement:null,nextStatement:null,style:\"loop_blocks\",helpUrl:\"%{BKY_CONTROLS_FOR_HELPURL}\",extensions:[\"contextMenu_newGetVariableBlock\",\"controls_for_tooltip\"]},{type:\"controls_forEach\",message0:\"%{BKY_CONTROLS_FOREACH_TITLE}\",args0:[{type:\"field_variable\",name:\"VAR\",variable:null},{type:\"input_value\",name:\"LIST\",check:\"Array\"}],message1:\"%{BKY_CONTROLS_REPEAT_INPUT_DO} %1\",\nargs1:[{type:\"input_statement\",name:\"DO\"}],previousStatement:null,nextStatement:null,style:\"loop_blocks\",helpUrl:\"%{BKY_CONTROLS_FOREACH_HELPURL}\",extensions:[\"contextMenu_newGetVariableBlock\",\"controls_forEach_tooltip\"]},{type:\"controls_flow_statements\",message0:\"%1\",args0:[{type:\"field_dropdown\",name:\"FLOW\",options:[[\"%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK}\",\"BREAK\"],[\"%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE}\",\"CONTINUE\"]]}],previousStatement:null,style:\"loop_blocks\",helpUrl:\"%{BKY_CONTROLS_FLOW_STATEMENTS_HELPURL}\",\nextensions:[\"controls_flow_tooltip\",\"controls_flow_in_loop_check\"]}]);Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS={WHILE:\"%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_WHILE}\",UNTIL:\"%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL}\"};Blockly.Extensions.register(\"controls_whileUntil_tooltip\",Blockly.Extensions.buildTooltipForDropdown(\"MODE\",Blockly.Constants.Loops.WHILE_UNTIL_TOOLTIPS));Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS={BREAK:\"%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK}\",CONTINUE:\"%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE}\"};\nBlockly.Extensions.register(\"controls_flow_tooltip\",Blockly.Extensions.buildTooltipForDropdown(\"FLOW\",Blockly.Constants.Loops.BREAK_CONTINUE_TOOLTIPS));\nBlockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN={customContextMenu:function(a){if(!this.isInFlyout){var b=this.getField(\"VAR\").getVariable(),c=b.name;if(!this.isCollapsed()&&null!=c){var d={enabled:!0};d.text=Blockly.Msg.VARIABLES_SET_CREATE_GET.replace(\"%1\",c);b=Blockly.Variables.generateVariableFieldDom(b);c=Blockly.utils.xml.createElement(\"block\");c.setAttribute(\"type\",\"variables_get\");c.appendChild(b);d.callback=Blockly.ContextMenu.callbackFactory(this,c);a.push(d)}}}};\nBlockly.Extensions.registerMixin(\"contextMenu_newGetVariableBlock\",Blockly.Constants.Loops.CUSTOM_CONTEXT_MENU_CREATE_VARIABLES_GET_MIXIN);Blockly.Extensions.register(\"controls_for_tooltip\",Blockly.Extensions.buildTooltipWithFieldText(\"%{BKY_CONTROLS_FOR_TOOLTIP}\",\"VAR\"));Blockly.Extensions.register(\"controls_forEach_tooltip\",Blockly.Extensions.buildTooltipWithFieldText(\"%{BKY_CONTROLS_FOREACH_TOOLTIP}\",\"VAR\"));\nBlockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN={LOOP_TYPES:[\"controls_repeat\",\"controls_repeat_ext\",\"controls_forEach\",\"controls_for\",\"controls_whileUntil\"],suppressPrefixSuffix:!0,getSurroundLoop:function(a){do{if(-1!=Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.LOOP_TYPES.indexOf(a.type))return a;a=a.getSurroundParent()}while(a);return null},onchange:function(a){if(this.workspace.isDragging&&!this.workspace.isDragging()&&a.type==Blockly.Events.BLOCK_MOVE&&a.blockId==this.id){var b=\nBlockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(this);this.setWarningText(b?null:Blockly.Msg.CONTROLS_FLOW_STATEMENTS_WARNING);if(!this.isInFlyout){var c=Blockly.Events.getGroup();Blockly.Events.setGroup(a.group);this.setEnabled(b);Blockly.Events.setGroup(c)}}}};Blockly.Extensions.registerMixin(\"controls_flow_in_loop_check\",Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN);Blockly.Blocks.math={};Blockly.Constants.Math={};Blockly.Constants.Math.HUE=230;\nBlockly.defineBlocksWithJsonArray([{type:\"math_number\",message0:\"%1\",args0:[{type:\"field_number\",name:\"NUM\",value:0}],output:\"Number\",helpUrl:\"%{BKY_MATH_NUMBER_HELPURL}\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_NUMBER_TOOLTIP}\",extensions:[\"parent_tooltip_when_inline\"]},{type:\"math_arithmetic\",message0:\"%1 %2 %3\",args0:[{type:\"input_value\",name:\"A\",check:\"Number\"},{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_MATH_ADDITION_SYMBOL}\",\"ADD\"],[\"%{BKY_MATH_SUBTRACTION_SYMBOL}\",\"MINUS\"],[\"%{BKY_MATH_MULTIPLICATION_SYMBOL}\",\n\"MULTIPLY\"],[\"%{BKY_MATH_DIVISION_SYMBOL}\",\"DIVIDE\"],[\"%{BKY_MATH_POWER_SYMBOL}\",\"POWER\"]]},{type:\"input_value\",name:\"B\",check:\"Number\"}],inputsInline:!0,output:\"Number\",style:\"math_blocks\",helpUrl:\"%{BKY_MATH_ARITHMETIC_HELPURL}\",extensions:[\"math_op_tooltip\"]},{type:\"math_single\",message0:\"%1 %2\",args0:[{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_MATH_SINGLE_OP_ROOT}\",\"ROOT\"],[\"%{BKY_MATH_SINGLE_OP_ABSOLUTE}\",\"ABS\"],[\"-\",\"NEG\"],[\"ln\",\"LN\"],[\"log10\",\"LOG10\"],[\"e^\",\"EXP\"],[\"10^\",\"POW10\"]]},\n{type:\"input_value\",name:\"NUM\",check:\"Number\"}],output:\"Number\",style:\"math_blocks\",helpUrl:\"%{BKY_MATH_SINGLE_HELPURL}\",extensions:[\"math_op_tooltip\"]},{type:\"math_trig\",message0:\"%1 %2\",args0:[{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_MATH_TRIG_SIN}\",\"SIN\"],[\"%{BKY_MATH_TRIG_COS}\",\"COS\"],[\"%{BKY_MATH_TRIG_TAN}\",\"TAN\"],[\"%{BKY_MATH_TRIG_ASIN}\",\"ASIN\"],[\"%{BKY_MATH_TRIG_ACOS}\",\"ACOS\"],[\"%{BKY_MATH_TRIG_ATAN}\",\"ATAN\"]]},{type:\"input_value\",name:\"NUM\",check:\"Number\"}],output:\"Number\",style:\"math_blocks\",\nhelpUrl:\"%{BKY_MATH_TRIG_HELPURL}\",extensions:[\"math_op_tooltip\"]},{type:\"math_constant\",message0:\"%1\",args0:[{type:\"field_dropdown\",name:\"CONSTANT\",options:[[\"\\u03c0\",\"PI\"],[\"e\",\"E\"],[\"\\u03c6\",\"GOLDEN_RATIO\"],[\"sqrt(2)\",\"SQRT2\"],[\"sqrt(\\u00bd)\",\"SQRT1_2\"],[\"\\u221e\",\"INFINITY\"]]}],output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_CONSTANT_TOOLTIP}\",helpUrl:\"%{BKY_MATH_CONSTANT_HELPURL}\"},{type:\"math_number_property\",message0:\"%1 %2\",args0:[{type:\"input_value\",name:\"NUMBER_TO_CHECK\",check:\"Number\"},\n{type:\"field_dropdown\",name:\"PROPERTY\",options:[[\"%{BKY_MATH_IS_EVEN}\",\"EVEN\"],[\"%{BKY_MATH_IS_ODD}\",\"ODD\"],[\"%{BKY_MATH_IS_PRIME}\",\"PRIME\"],[\"%{BKY_MATH_IS_WHOLE}\",\"WHOLE\"],[\"%{BKY_MATH_IS_POSITIVE}\",\"POSITIVE\"],[\"%{BKY_MATH_IS_NEGATIVE}\",\"NEGATIVE\"],[\"%{BKY_MATH_IS_DIVISIBLE_BY}\",\"DIVISIBLE_BY\"]]}],inputsInline:!0,output:\"Boolean\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_IS_TOOLTIP}\",mutator:\"math_is_divisibleby_mutator\"},{type:\"math_change\",message0:\"%{BKY_MATH_CHANGE_TITLE}\",args0:[{type:\"field_variable\",\nname:\"VAR\",variable:\"%{BKY_MATH_CHANGE_TITLE_ITEM}\"},{type:\"input_value\",name:\"DELTA\",check:\"Number\"}],previousStatement:null,nextStatement:null,style:\"variable_blocks\",helpUrl:\"%{BKY_MATH_CHANGE_HELPURL}\",extensions:[\"math_change_tooltip\"]},{type:\"math_round\",message0:\"%1 %2\",args0:[{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_MATH_ROUND_OPERATOR_ROUND}\",\"ROUND\"],[\"%{BKY_MATH_ROUND_OPERATOR_ROUNDUP}\",\"ROUNDUP\"],[\"%{BKY_MATH_ROUND_OPERATOR_ROUNDDOWN}\",\"ROUNDDOWN\"]]},{type:\"input_value\",name:\"NUM\",\ncheck:\"Number\"}],output:\"Number\",style:\"math_blocks\",helpUrl:\"%{BKY_MATH_ROUND_HELPURL}\",tooltip:\"%{BKY_MATH_ROUND_TOOLTIP}\"},{type:\"math_on_list\",message0:\"%1 %2\",args0:[{type:\"field_dropdown\",name:\"OP\",options:[[\"%{BKY_MATH_ONLIST_OPERATOR_SUM}\",\"SUM\"],[\"%{BKY_MATH_ONLIST_OPERATOR_MIN}\",\"MIN\"],[\"%{BKY_MATH_ONLIST_OPERATOR_MAX}\",\"MAX\"],[\"%{BKY_MATH_ONLIST_OPERATOR_AVERAGE}\",\"AVERAGE\"],[\"%{BKY_MATH_ONLIST_OPERATOR_MEDIAN}\",\"MEDIAN\"],[\"%{BKY_MATH_ONLIST_OPERATOR_MODE}\",\"MODE\"],[\"%{BKY_MATH_ONLIST_OPERATOR_STD_DEV}\",\n\"STD_DEV\"],[\"%{BKY_MATH_ONLIST_OPERATOR_RANDOM}\",\"RANDOM\"]]},{type:\"input_value\",name:\"LIST\",check:\"Array\"}],output:\"Number\",style:\"math_blocks\",helpUrl:\"%{BKY_MATH_ONLIST_HELPURL}\",mutator:\"math_modes_of_list_mutator\",extensions:[\"math_op_tooltip\"]},{type:\"math_modulo\",message0:\"%{BKY_MATH_MODULO_TITLE}\",args0:[{type:\"input_value\",name:\"DIVIDEND\",check:\"Number\"},{type:\"input_value\",name:\"DIVISOR\",check:\"Number\"}],inputsInline:!0,output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_MODULO_TOOLTIP}\",\nhelpUrl:\"%{BKY_MATH_MODULO_HELPURL}\"},{type:\"math_constrain\",message0:\"%{BKY_MATH_CONSTRAIN_TITLE}\",args0:[{type:\"input_value\",name:\"VALUE\",check:\"Number\"},{type:\"input_value\",name:\"LOW\",check:\"Number\"},{type:\"input_value\",name:\"HIGH\",check:\"Number\"}],inputsInline:!0,output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_CONSTRAIN_TOOLTIP}\",helpUrl:\"%{BKY_MATH_CONSTRAIN_HELPURL}\"},{type:\"math_random_int\",message0:\"%{BKY_MATH_RANDOM_INT_TITLE}\",args0:[{type:\"input_value\",name:\"FROM\",check:\"Number\"},\n{type:\"input_value\",name:\"TO\",check:\"Number\"}],inputsInline:!0,output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_RANDOM_INT_TOOLTIP}\",helpUrl:\"%{BKY_MATH_RANDOM_INT_HELPURL}\"},{type:\"math_random_float\",message0:\"%{BKY_MATH_RANDOM_FLOAT_TITLE_RANDOM}\",output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_RANDOM_FLOAT_TOOLTIP}\",helpUrl:\"%{BKY_MATH_RANDOM_FLOAT_HELPURL}\"},{type:\"math_atan2\",message0:\"%{BKY_MATH_ATAN2_TITLE}\",args0:[{type:\"input_value\",name:\"X\",check:\"Number\"},{type:\"input_value\",\nname:\"Y\",check:\"Number\"}],inputsInline:!0,output:\"Number\",style:\"math_blocks\",tooltip:\"%{BKY_MATH_ATAN2_TOOLTIP}\",helpUrl:\"%{BKY_MATH_ATAN2_HELPURL}\"}]);\nBlockly.Constants.Math.TOOLTIPS_BY_OP={ADD:\"%{BKY_MATH_ARITHMETIC_TOOLTIP_ADD}\",MINUS:\"%{BKY_MATH_ARITHMETIC_TOOLTIP_MINUS}\",MULTIPLY:\"%{BKY_MATH_ARITHMETIC_TOOLTIP_MULTIPLY}\",DIVIDE:\"%{BKY_MATH_ARITHMETIC_TOOLTIP_DIVIDE}\",POWER:\"%{BKY_MATH_ARITHMETIC_TOOLTIP_POWER}\",ROOT:\"%{BKY_MATH_SINGLE_TOOLTIP_ROOT}\",ABS:\"%{BKY_MATH_SINGLE_TOOLTIP_ABS}\",NEG:\"%{BKY_MATH_SINGLE_TOOLTIP_NEG}\",LN:\"%{BKY_MATH_SINGLE_TOOLTIP_LN}\",LOG10:\"%{BKY_MATH_SINGLE_TOOLTIP_LOG10}\",EXP:\"%{BKY_MATH_SINGLE_TOOLTIP_EXP}\",POW10:\"%{BKY_MATH_SINGLE_TOOLTIP_POW10}\",\nSIN:\"%{BKY_MATH_TRIG_TOOLTIP_SIN}\",COS:\"%{BKY_MATH_TRIG_TOOLTIP_COS}\",TAN:\"%{BKY_MATH_TRIG_TOOLTIP_TAN}\",ASIN:\"%{BKY_MATH_TRIG_TOOLTIP_ASIN}\",ACOS:\"%{BKY_MATH_TRIG_TOOLTIP_ACOS}\",ATAN:\"%{BKY_MATH_TRIG_TOOLTIP_ATAN}\",SUM:\"%{BKY_MATH_ONLIST_TOOLTIP_SUM}\",MIN:\"%{BKY_MATH_ONLIST_TOOLTIP_MIN}\",MAX:\"%{BKY_MATH_ONLIST_TOOLTIP_MAX}\",AVERAGE:\"%{BKY_MATH_ONLIST_TOOLTIP_AVERAGE}\",MEDIAN:\"%{BKY_MATH_ONLIST_TOOLTIP_MEDIAN}\",MODE:\"%{BKY_MATH_ONLIST_TOOLTIP_MODE}\",STD_DEV:\"%{BKY_MATH_ONLIST_TOOLTIP_STD_DEV}\",RANDOM:\"%{BKY_MATH_ONLIST_TOOLTIP_RANDOM}\"};\nBlockly.Extensions.register(\"math_op_tooltip\",Blockly.Extensions.buildTooltipForDropdown(\"OP\",Blockly.Constants.Math.TOOLTIPS_BY_OP));\nBlockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN={mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\"),b=\"DIVISIBLE_BY\"==this.getFieldValue(\"PROPERTY\");a.setAttribute(\"divisor_input\",b);return a},domToMutation:function(a){a=\"true\"==a.getAttribute(\"divisor_input\");this.updateShape_(a)},updateShape_:function(a){var b=this.getInput(\"DIVISOR\");a?b||this.appendValueInput(\"DIVISOR\").setCheck(\"Number\"):b&&this.removeInput(\"DIVISOR\")}};\nBlockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION=function(){this.getField(\"PROPERTY\").setValidator(function(a){a=\"DIVISIBLE_BY\"==a;this.getSourceBlock().updateShape_(a)})};Blockly.Extensions.registerMutator(\"math_is_divisibleby_mutator\",Blockly.Constants.Math.IS_DIVISIBLEBY_MUTATOR_MIXIN,Blockly.Constants.Math.IS_DIVISIBLE_MUTATOR_EXTENSION);Blockly.Extensions.register(\"math_change_tooltip\",Blockly.Extensions.buildTooltipWithFieldText(\"%{BKY_MATH_CHANGE_TOOLTIP}\",\"VAR\"));\nBlockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN={updateType_:function(a){\"MODE\"==a?this.outputConnection.setCheck(\"Array\"):this.outputConnection.setCheck(\"Number\")},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"op\",this.getFieldValue(\"OP\"));return a},domToMutation:function(a){this.updateType_(a.getAttribute(\"op\"))}};Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION=function(){this.getField(\"OP\").setValidator(function(a){this.updateType_(a)}.bind(this))};\nBlockly.Extensions.registerMutator(\"math_modes_of_list_mutator\",Blockly.Constants.Math.LIST_MODES_MUTATOR_MIXIN,Blockly.Constants.Math.LIST_MODES_MUTATOR_EXTENSION);Blockly.Blocks.procedures={};\nBlockly.Blocks.procedures_defnoreturn={init:function(){var a=new Blockly.FieldTextInput(\"\",Blockly.Procedures.rename);a.setSpellcheck(!1);this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_TITLE).appendField(a,\"NAME\").appendField(\"\",\"PARAMS\");this.setMutator(new Blockly.Mutator([\"procedures_mutatorarg\"]));(this.workspace.options.comments||this.workspace.options.parentWorkspace&&this.workspace.options.parentWorkspace.options.comments)&&Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT&&this.setCommentText(Blockly.Msg.PROCEDURES_DEFNORETURN_COMMENT);\nthis.setStyle(\"procedure_blocks\");this.setTooltip(Blockly.Msg.PROCEDURES_DEFNORETURN_TOOLTIP);this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFNORETURN_HELPURL);this.arguments_=[];this.argumentVarModels_=[];this.setStatements_(!0);this.statementConnection_=null},setStatements_:function(a){this.hasStatements_!==a&&(a?(this.appendStatementInput(\"STACK\").appendField(Blockly.Msg.PROCEDURES_DEFNORETURN_DO),this.getInput(\"RETURN\")&&this.moveInputBefore(\"STACK\",\"RETURN\")):this.removeInput(\"STACK\",!0),this.hasStatements_=\na)},updateParams_:function(){var a=\"\";this.arguments_.length&&(a=Blockly.Msg.PROCEDURES_BEFORE_PARAMS+\" \"+this.arguments_.join(\", \"));Blockly.Events.disable();try{this.setFieldValue(a,\"PARAMS\")}finally{Blockly.Events.enable()}},mutationToDom:function(a){var b=Blockly.utils.xml.createElement(\"mutation\");a&&b.setAttribute(\"name\",this.getFieldValue(\"NAME\"));for(var c=0;c<this.argumentVarModels_.length;c++){var d=Blockly.utils.xml.createElement(\"arg\"),e=this.argumentVarModels_[c];d.setAttribute(\"name\",\ne.name);d.setAttribute(\"varid\",e.getId());a&&this.paramIds_&&d.setAttribute(\"paramId\",this.paramIds_[c]);b.appendChild(d)}this.hasStatements_||b.setAttribute(\"statements\",\"false\");return b},domToMutation:function(a){this.arguments_=[];this.argumentVarModels_=[];for(var b=0,c;c=a.childNodes[b];b++)if(\"arg\"==c.nodeName.toLowerCase()){var d=c.getAttribute(\"name\");c=c.getAttribute(\"varid\")||c.getAttribute(\"varId\");this.arguments_.push(d);c=Blockly.Variables.getOrCreateVariablePackage(this.workspace,c,\nd,\"\");null!=c?this.argumentVarModels_.push(c):console.log(\"Failed to create a variable with name \"+d+\", ignoring.\")}this.updateParams_();Blockly.Procedures.mutateCallers(this);this.setStatements_(\"false\"!==a.getAttribute(\"statements\"))},decompose:function(a){var b=Blockly.utils.xml.createElement(\"block\");b.setAttribute(\"type\",\"procedures_mutatorcontainer\");var c=Blockly.utils.xml.createElement(\"statement\");c.setAttribute(\"name\",\"STACK\");b.appendChild(c);for(var d=0;d<this.arguments_.length;d++){var e=\nBlockly.utils.xml.createElement(\"block\");e.setAttribute(\"type\",\"procedures_mutatorarg\");var f=Blockly.utils.xml.createElement(\"field\");f.setAttribute(\"name\",\"NAME\");var g=Blockly.utils.xml.createTextNode(this.arguments_[d]);f.appendChild(g);e.appendChild(f);f=Blockly.utils.xml.createElement(\"next\");e.appendChild(f);c.appendChild(e);c=f}a=Blockly.Xml.domToBlock(b,a);\"procedures_defreturn\"==this.type?a.setFieldValue(this.hasStatements_,\"STATEMENTS\"):a.removeInput(\"STATEMENT_INPUT\");Blockly.Procedures.mutateCallers(this);\nreturn a},compose:function(a){this.arguments_=[];this.paramIds_=[];this.argumentVarModels_=[];for(var b=a.getInputTargetBlock(\"STACK\");b;){var c=b.getFieldValue(\"NAME\");this.arguments_.push(c);c=this.workspace.getVariable(c,\"\");this.argumentVarModels_.push(c);this.paramIds_.push(b.id);b=b.nextConnection&&b.nextConnection.targetBlock()}this.updateParams_();Blockly.Procedures.mutateCallers(this);a=a.getFieldValue(\"STATEMENTS\");if(null!==a&&(a=\"TRUE\"==a,this.hasStatements_!=a))if(a)this.setStatements_(!0),\nBlockly.Mutator.reconnect(this.statementConnection_,this,\"STACK\"),this.statementConnection_=null;else{a=this.getInput(\"STACK\").connection;if(this.statementConnection_=a.targetConnection)a=a.targetBlock(),a.unplug(),a.bumpNeighbours();this.setStatements_(!1)}},getProcedureDef:function(){return[this.getFieldValue(\"NAME\"),this.arguments_,!1]},getVars:function(){return this.arguments_},getVarModels:function(){return this.argumentVarModels_},renameVarById:function(a,b){var c=this.workspace.getVariableById(a);\nif(\"\"==c.type){c=c.name;b=this.workspace.getVariableById(b);for(var d=!1,e=0;e<this.argumentVarModels_.length;e++)this.argumentVarModels_[e].getId()==a&&(this.arguments_[e]=b.name,this.argumentVarModels_[e]=b,d=!0);d&&(this.displayRenamedVar_(c,b.name),Blockly.Procedures.mutateCallers(this))}},updateVarName:function(a){for(var b=a.name,c=!1,d=0;d<this.argumentVarModels_.length;d++)if(this.argumentVarModels_[d].getId()==a.getId()){var e=this.arguments_[d];this.arguments_[d]=b;c=!0}c&&(this.displayRenamedVar_(e,\nb),Blockly.Procedures.mutateCallers(this))},displayRenamedVar_:function(a,b){this.updateParams_();if(this.mutator&&this.mutator.isVisible())for(var c=this.mutator.workspace_.getAllBlocks(!1),d=0,e;e=c[d];d++)\"procedures_mutatorarg\"==e.type&&Blockly.Names.equals(a,e.getFieldValue(\"NAME\"))&&e.setFieldValue(b,\"NAME\")},customContextMenu:function(a){if(!this.isInFlyout){var b={enabled:!0},c=this.getFieldValue(\"NAME\");b.text=Blockly.Msg.PROCEDURES_CREATE_DO.replace(\"%1\",c);var d=Blockly.utils.xml.createElement(\"mutation\");\nd.setAttribute(\"name\",c);for(c=0;c<this.arguments_.length;c++){var e=Blockly.utils.xml.createElement(\"arg\");e.setAttribute(\"name\",this.arguments_[c]);d.appendChild(e)}c=Blockly.utils.xml.createElement(\"block\");c.setAttribute(\"type\",this.callType_);c.appendChild(d);b.callback=Blockly.ContextMenu.callbackFactory(this,c);a.push(b);if(!this.isCollapsed())for(c=0;c<this.argumentVarModels_.length;c++)b={enabled:!0},d=this.argumentVarModels_[c],b.text=Blockly.Msg.VARIABLES_SET_CREATE_GET.replace(\"%1\",d.name),\nd=Blockly.Variables.generateVariableFieldDom(d),e=Blockly.utils.xml.createElement(\"block\"),e.setAttribute(\"type\",\"variables_get\"),e.appendChild(d),b.callback=Blockly.ContextMenu.callbackFactory(this,e),a.push(b)}},callType_:\"procedures_callnoreturn\"};\nBlockly.Blocks.procedures_defreturn={init:function(){var a=new Blockly.FieldTextInput(\"\",Blockly.Procedures.rename);a.setSpellcheck(!1);this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_DEFRETURN_TITLE).appendField(a,\"NAME\").appendField(\"\",\"PARAMS\");this.appendValueInput(\"RETURN\").setAlign(Blockly.ALIGN_RIGHT).appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);this.setMutator(new Blockly.Mutator([\"procedures_mutatorarg\"]));(this.workspace.options.comments||this.workspace.options.parentWorkspace&&\nthis.workspace.options.parentWorkspace.options.comments)&&Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT&&this.setCommentText(Blockly.Msg.PROCEDURES_DEFRETURN_COMMENT);this.setStyle(\"procedure_blocks\");this.setTooltip(Blockly.Msg.PROCEDURES_DEFRETURN_TOOLTIP);this.setHelpUrl(Blockly.Msg.PROCEDURES_DEFRETURN_HELPURL);this.arguments_=[];this.argumentVarModels_=[];this.setStatements_(!0);this.statementConnection_=null},setStatements_:Blockly.Blocks.procedures_defnoreturn.setStatements_,updateParams_:Blockly.Blocks.procedures_defnoreturn.updateParams_,\nmutationToDom:Blockly.Blocks.procedures_defnoreturn.mutationToDom,domToMutation:Blockly.Blocks.procedures_defnoreturn.domToMutation,decompose:Blockly.Blocks.procedures_defnoreturn.decompose,compose:Blockly.Blocks.procedures_defnoreturn.compose,getProcedureDef:function(){return[this.getFieldValue(\"NAME\"),this.arguments_,!0]},getVars:Blockly.Blocks.procedures_defnoreturn.getVars,getVarModels:Blockly.Blocks.procedures_defnoreturn.getVarModels,renameVarById:Blockly.Blocks.procedures_defnoreturn.renameVarById,\nupdateVarName:Blockly.Blocks.procedures_defnoreturn.updateVarName,displayRenamedVar_:Blockly.Blocks.procedures_defnoreturn.displayRenamedVar_,customContextMenu:Blockly.Blocks.procedures_defnoreturn.customContextMenu,callType_:\"procedures_callreturn\"};\nBlockly.Blocks.procedures_mutatorcontainer={init:function(){this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TITLE);this.appendStatementInput(\"STACK\");this.appendDummyInput(\"STATEMENT_INPUT\").appendField(Blockly.Msg.PROCEDURES_ALLOW_STATEMENTS).appendField(new Blockly.FieldCheckbox(\"TRUE\"),\"STATEMENTS\");this.setStyle(\"procedure_blocks\");this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP);this.contextMenu=!1}};\nBlockly.Blocks.procedures_mutatorarg={init:function(){var a=new Blockly.FieldTextInput(Blockly.Procedures.DEFAULT_ARG,this.validator_);a.oldShowEditorFn_=a.showEditor_;a.showEditor_=function(){this.createdVariables_=[];this.oldShowEditorFn_()};this.appendDummyInput().appendField(Blockly.Msg.PROCEDURES_MUTATORARG_TITLE).appendField(a,\"NAME\");this.setPreviousStatement(!0);this.setNextStatement(!0);this.setStyle(\"procedure_blocks\");this.setTooltip(Blockly.Msg.PROCEDURES_MUTATORARG_TOOLTIP);this.contextMenu=\n!1;a.onFinishEditing_=this.deleteIntermediateVars_;a.createdVariables_=[];a.onFinishEditing_(\"x\")},validator_:function(a){var b=this.getSourceBlock(),c=Blockly.Mutator.findParentWs(b.workspace);a=a.replace(/[\\s\\xa0]+/g,\" \").replace(/^ | $/g,\"\");if(!a)return null;for(var d=(b.workspace.targetWorkspace||b.workspace).getAllBlocks(!1),e=a.toLowerCase(),f=0;f<d.length;f++)if(d[f].id!=this.getSourceBlock().id){var g=d[f].getFieldValue(\"NAME\");if(g&&g.toLowerCase()==e)return null}if(b.isInFlyout)return a;\n(b=c.getVariable(a,\"\"))&&b.name!=a&&c.renameVariableById(b.getId(),a);b||(b=c.createVariable(a,\"\"))&&this.createdVariables_&&this.createdVariables_.push(b);return a},deleteIntermediateVars_:function(a){var b=Blockly.Mutator.findParentWs(this.getSourceBlock().workspace);if(b)for(var c=0;c<this.createdVariables_.length;c++){var d=this.createdVariables_[c];d.name!=a&&b.deleteVariableById(d.getId())}}};\nBlockly.Blocks.procedures_callnoreturn={init:function(){this.appendDummyInput(\"TOPROW\").appendField(this.id,\"NAME\");this.setPreviousStatement(!0);this.setNextStatement(!0);this.setStyle(\"procedure_blocks\");this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLNORETURN_HELPURL);this.arguments_=[];this.argumentVarModels_=[];this.quarkConnections_={};this.quarkIds_=null;this.previousEnabledState_=!0},getProcedureCall:function(){return this.getFieldValue(\"NAME\")},renameProcedure:function(a,b){Blockly.Names.equals(a,\nthis.getProcedureCall())&&(this.setFieldValue(b,\"NAME\"),this.setTooltip((this.outputConnection?Blockly.Msg.PROCEDURES_CALLRETURN_TOOLTIP:Blockly.Msg.PROCEDURES_CALLNORETURN_TOOLTIP).replace(\"%1\",b)))},setProcedureParameters_:function(a,b){var c=Blockly.Procedures.getDefinition(this.getProcedureCall(),this.workspace),d=c&&c.mutator&&c.mutator.isVisible();d||(this.quarkConnections_={},this.quarkIds_=null);if(b)if(a.join(\"\\n\")==this.arguments_.join(\"\\n\"))this.quarkIds_=b;else{if(b.length!=a.length)throw RangeError(\"paramNames and paramIds must be the same length.\");\nthis.setCollapsed(!1);this.quarkIds_||(this.quarkConnections_={},this.quarkIds_=[]);c=this.rendered;this.rendered=!1;for(var e=0;e<this.arguments_.length;e++){var f=this.getInput(\"ARG\"+e);f&&(f=f.connection.targetConnection,this.quarkConnections_[this.quarkIds_[e]]=f,d&&f&&-1==b.indexOf(this.quarkIds_[e])&&(f.disconnect(),f.getSourceBlock().bumpNeighbours()))}this.arguments_=[].concat(a);this.argumentVarModels_=[];for(e=0;e<this.arguments_.length;e++)a=Blockly.Variables.getOrCreateVariablePackage(this.workspace,\nnull,this.arguments_[e],\"\"),this.argumentVarModels_.push(a);this.updateShape_();if(this.quarkIds_=b)for(e=0;e<this.arguments_.length;e++)b=this.quarkIds_[e],b in this.quarkConnections_&&(f=this.quarkConnections_[b],Blockly.Mutator.reconnect(f,this,\"ARG\"+e)||delete this.quarkConnections_[b]);(this.rendered=c)&&this.render()}},updateShape_:function(){for(var a=0;a<this.arguments_.length;a++){var b=this.getField(\"ARGNAME\"+a);if(b){Blockly.Events.disable();try{b.setValue(this.arguments_[a])}finally{Blockly.Events.enable()}}else b=\nnew Blockly.FieldLabel(this.arguments_[a]),this.appendValueInput(\"ARG\"+a).setAlign(Blockly.ALIGN_RIGHT).appendField(b,\"ARGNAME\"+a).init()}for(;this.getInput(\"ARG\"+a);)this.removeInput(\"ARG\"+a),a++;if(a=this.getInput(\"TOPROW\"))this.arguments_.length?this.getField(\"WITH\")||(a.appendField(Blockly.Msg.PROCEDURES_CALL_BEFORE_PARAMS,\"WITH\"),a.init()):this.getField(\"WITH\")&&a.removeField(\"WITH\")},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"name\",this.getProcedureCall());\nfor(var b=0;b<this.arguments_.length;b++){var c=Blockly.utils.xml.createElement(\"arg\");c.setAttribute(\"name\",this.arguments_[b]);a.appendChild(c)}return a},domToMutation:function(a){var b=a.getAttribute(\"name\");this.renameProcedure(this.getProcedureCall(),b);b=[];for(var c=[],d=0,e;e=a.childNodes[d];d++)\"arg\"==e.nodeName.toLowerCase()&&(b.push(e.getAttribute(\"name\")),c.push(e.getAttribute(\"paramId\")));this.setProcedureParameters_(b,c)},getVarModels:function(){return this.argumentVarModels_},onchange:function(a){if(this.workspace&&\n!this.workspace.isFlyout&&a.recordUndo)if(a.type==Blockly.Events.BLOCK_CREATE&&-1!=a.ids.indexOf(this.id)){var b=this.getProcedureCall();b=Blockly.Procedures.getDefinition(b,this.workspace);!b||b.type==this.defType_&&JSON.stringify(b.arguments_)==JSON.stringify(this.arguments_)||(b=null);if(!b){Blockly.Events.setGroup(a.group);a=Blockly.utils.xml.createElement(\"xml\");b=Blockly.utils.xml.createElement(\"block\");b.setAttribute(\"type\",this.defType_);var c=this.getRelativeToSurfaceXY(),d=c.y+2*Blockly.SNAP_RADIUS;\nb.setAttribute(\"x\",c.x+Blockly.SNAP_RADIUS*(this.RTL?-1:1));b.setAttribute(\"y\",d);c=this.mutationToDom();b.appendChild(c);c=Blockly.utils.xml.createElement(\"field\");c.setAttribute(\"name\",\"NAME\");c.appendChild(Blockly.utils.xml.createTextNode(this.getProcedureCall()));b.appendChild(c);a.appendChild(b);Blockly.Xml.domToWorkspace(a,this.workspace);Blockly.Events.setGroup(!1)}}else a.type==Blockly.Events.BLOCK_DELETE?(b=this.getProcedureCall(),b=Blockly.Procedures.getDefinition(b,this.workspace),b||(Blockly.Events.setGroup(a.group),\nthis.dispose(!0),Blockly.Events.setGroup(!1))):a.type==Blockly.Events.CHANGE&&\"disabled\"==a.element&&(b=this.getProcedureCall(),(b=Blockly.Procedures.getDefinition(b,this.workspace))&&b.id==a.blockId&&((b=Blockly.Events.getGroup())&&console.log(\"Saw an existing group while responding to a definition change\"),Blockly.Events.setGroup(a.group),a.newValue?(this.previousEnabledState_=this.isEnabled(),this.setEnabled(!1)):this.setEnabled(this.previousEnabledState_),Blockly.Events.setGroup(b)))},customContextMenu:function(a){if(this.workspace.isMovable()){var b=\n{enabled:!0};b.text=Blockly.Msg.PROCEDURES_HIGHLIGHT_DEF;var c=this.getProcedureCall(),d=this.workspace;b.callback=function(){var a=Blockly.Procedures.getDefinition(c,d);a&&(d.centerOnBlock(a.id),a.select())};a.push(b)}},defType_:\"procedures_defnoreturn\"};\nBlockly.Blocks.procedures_callreturn={init:function(){this.appendDummyInput(\"TOPROW\").appendField(\"\",\"NAME\");this.setOutput(!0);this.setStyle(\"procedure_blocks\");this.setHelpUrl(Blockly.Msg.PROCEDURES_CALLRETURN_HELPURL);this.arguments_=[];this.quarkConnections_={};this.quarkIds_=null;this.previousEnabledState_=!0},getProcedureCall:Blockly.Blocks.procedures_callnoreturn.getProcedureCall,renameProcedure:Blockly.Blocks.procedures_callnoreturn.renameProcedure,setProcedureParameters_:Blockly.Blocks.procedures_callnoreturn.setProcedureParameters_,\nupdateShape_:Blockly.Blocks.procedures_callnoreturn.updateShape_,mutationToDom:Blockly.Blocks.procedures_callnoreturn.mutationToDom,domToMutation:Blockly.Blocks.procedures_callnoreturn.domToMutation,getVarModels:Blockly.Blocks.procedures_callnoreturn.getVarModels,onchange:Blockly.Blocks.procedures_callnoreturn.onchange,customContextMenu:Blockly.Blocks.procedures_callnoreturn.customContextMenu,defType_:\"procedures_defreturn\"};\nBlockly.Blocks.procedures_ifreturn={init:function(){this.appendValueInput(\"CONDITION\").setCheck(\"Boolean\").appendField(Blockly.Msg.CONTROLS_IF_MSG_IF);this.appendValueInput(\"VALUE\").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN);this.setInputsInline(!0);this.setPreviousStatement(!0);this.setNextStatement(!0);this.setStyle(\"procedure_blocks\");this.setTooltip(Blockly.Msg.PROCEDURES_IFRETURN_TOOLTIP);this.setHelpUrl(Blockly.Msg.PROCEDURES_IFRETURN_HELPURL);this.hasReturnValue_=!0},mutationToDom:function(){var a=\nBlockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"value\",Number(this.hasReturnValue_));return a},domToMutation:function(a){this.hasReturnValue_=1==a.getAttribute(\"value\");this.hasReturnValue_||(this.removeInput(\"VALUE\"),this.appendDummyInput(\"VALUE\").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN))},onchange:function(a){if(this.workspace.isDragging&&!this.workspace.isDragging()){a=!1;var b=this;do{if(-1!=this.FUNCTION_TYPES.indexOf(b.type)){a=!0;break}b=b.getSurroundParent()}while(b);\na?(\"procedures_defnoreturn\"==b.type&&this.hasReturnValue_?(this.removeInput(\"VALUE\"),this.appendDummyInput(\"VALUE\").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN),this.hasReturnValue_=!1):\"procedures_defreturn\"!=b.type||this.hasReturnValue_||(this.removeInput(\"VALUE\"),this.appendValueInput(\"VALUE\").appendField(Blockly.Msg.PROCEDURES_DEFRETURN_RETURN),this.hasReturnValue_=!0),this.setWarningText(null),this.isInFlyout||this.setEnabled(!0)):(this.setWarningText(Blockly.Msg.PROCEDURES_IFRETURN_WARNING),\nthis.isInFlyout||this.getInheritedDisabled()||this.setEnabled(!1))}},FUNCTION_TYPES:[\"procedures_defnoreturn\",\"procedures_defreturn\"]};Blockly.Blocks.texts={};Blockly.Constants.Text={};Blockly.Constants.Text.HUE=160;\nBlockly.defineBlocksWithJsonArray([{type:\"text\",message0:\"%1\",args0:[{type:\"field_input\",name:\"TEXT\",text:\"\"}],output:\"String\",style:\"text_blocks\",helpUrl:\"%{BKY_TEXT_TEXT_HELPURL}\",tooltip:\"%{BKY_TEXT_TEXT_TOOLTIP}\",extensions:[\"text_quotes\",\"parent_tooltip_when_inline\"]},{type:\"text_multiline\",message0:\"%1 %2\",args0:[{type:\"field_image\",src:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAARCAYAAADpPU2iAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAdhgAAHYYBXaITgQAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAAP1JREFUOE+Vks0KQUEYhjmRIja4ABtZ2dm5A3t3Ia6AUm7CylYuQRaUhZSlLZJiQbFAyRnPN33y01HOW08z8873zpwzM4F3GWOCruvGIE4/rLaV+Nq1hVGMBqzhqlxgCys4wJA65xnogMHsQ5lujnYHTejBBCK2mE4abjCgMGhNxHgDFWjDSG07kdfVa2pZMf4ZyMAdWmpZMfYOsLiDMYMjlMB+K613QISRhTnITnsYg5yUd0DETmEoMlkFOeIT/A58iyK5E18BuTBfgYXfwNJv4P9/oEBerLylOnRhygmGdPpTTBZAPkde61lbQe4moWUvYUZYLfUNftIY4zwA5X2Z9AYnQrEAAAAASUVORK5CYII=\",width:12,\nheight:17,alt:\"\\u00b6\"},{type:\"field_multilinetext\",name:\"TEXT\",text:\"\"}],output:\"String\",style:\"text_blocks\",helpUrl:\"%{BKY_TEXT_TEXT_HELPURL}\",tooltip:\"%{BKY_TEXT_TEXT_TOOLTIP}\",extensions:[\"parent_tooltip_when_inline\"]},{type:\"text_join\",message0:\"\",output:\"String\",style:\"text_blocks\",helpUrl:\"%{BKY_TEXT_JOIN_HELPURL}\",tooltip:\"%{BKY_TEXT_JOIN_TOOLTIP}\",mutator:\"text_join_mutator\"},{type:\"text_create_join_container\",message0:\"%{BKY_TEXT_CREATE_JOIN_TITLE_JOIN} %1 %2\",args0:[{type:\"input_dummy\"},\n{type:\"input_statement\",name:\"STACK\"}],style:\"text_blocks\",tooltip:\"%{BKY_TEXT_CREATE_JOIN_TOOLTIP}\",enableContextMenu:!1},{type:\"text_create_join_item\",message0:\"%{BKY_TEXT_CREATE_JOIN_ITEM_TITLE_ITEM}\",previousStatement:null,nextStatement:null,style:\"text_blocks\",tooltip:\"%{BKY_TEXT_CREATE_JOIN_ITEM_TOOLTIP}\",enableContextMenu:!1},{type:\"text_append\",message0:\"%{BKY_TEXT_APPEND_TITLE}\",args0:[{type:\"field_variable\",name:\"VAR\",variable:\"%{BKY_TEXT_APPEND_VARIABLE}\"},{type:\"input_value\",name:\"TEXT\"}],\npreviousStatement:null,nextStatement:null,style:\"text_blocks\",extensions:[\"text_append_tooltip\"]},{type:\"text_length\",message0:\"%{BKY_TEXT_LENGTH_TITLE}\",args0:[{type:\"input_value\",name:\"VALUE\",check:[\"String\",\"Array\"]}],output:\"Number\",style:\"text_blocks\",tooltip:\"%{BKY_TEXT_LENGTH_TOOLTIP}\",helpUrl:\"%{BKY_TEXT_LENGTH_HELPURL}\"},{type:\"text_isEmpty\",message0:\"%{BKY_TEXT_ISEMPTY_TITLE}\",args0:[{type:\"input_value\",name:\"VALUE\",check:[\"String\",\"Array\"]}],output:\"Boolean\",style:\"text_blocks\",tooltip:\"%{BKY_TEXT_ISEMPTY_TOOLTIP}\",\nhelpUrl:\"%{BKY_TEXT_ISEMPTY_HELPURL}\"},{type:\"text_indexOf\",message0:\"%{BKY_TEXT_INDEXOF_TITLE}\",args0:[{type:\"input_value\",name:\"VALUE\",check:\"String\"},{type:\"field_dropdown\",name:\"END\",options:[[\"%{BKY_TEXT_INDEXOF_OPERATOR_FIRST}\",\"FIRST\"],[\"%{BKY_TEXT_INDEXOF_OPERATOR_LAST}\",\"LAST\"]]},{type:\"input_value\",name:\"FIND\",check:\"String\"}],output:\"Number\",style:\"text_blocks\",helpUrl:\"%{BKY_TEXT_INDEXOF_HELPURL}\",inputsInline:!0,extensions:[\"text_indexOf_tooltip\"]},{type:\"text_charAt\",message0:\"%{BKY_TEXT_CHARAT_TITLE}\",\nargs0:[{type:\"input_value\",name:\"VALUE\",check:\"String\"},{type:\"field_dropdown\",name:\"WHERE\",options:[[\"%{BKY_TEXT_CHARAT_FROM_START}\",\"FROM_START\"],[\"%{BKY_TEXT_CHARAT_FROM_END}\",\"FROM_END\"],[\"%{BKY_TEXT_CHARAT_FIRST}\",\"FIRST\"],[\"%{BKY_TEXT_CHARAT_LAST}\",\"LAST\"],[\"%{BKY_TEXT_CHARAT_RANDOM}\",\"RANDOM\"]]}],output:\"String\",style:\"text_blocks\",helpUrl:\"%{BKY_TEXT_CHARAT_HELPURL}\",inputsInline:!0,mutator:\"text_charAt_mutator\"}]);\nBlockly.Blocks.text_getSubstring={init:function(){this.WHERE_OPTIONS_1=[[Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_START,\"FROM_START\"],[Blockly.Msg.TEXT_GET_SUBSTRING_START_FROM_END,\"FROM_END\"],[Blockly.Msg.TEXT_GET_SUBSTRING_START_FIRST,\"FIRST\"]];this.WHERE_OPTIONS_2=[[Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_START,\"FROM_START\"],[Blockly.Msg.TEXT_GET_SUBSTRING_END_FROM_END,\"FROM_END\"],[Blockly.Msg.TEXT_GET_SUBSTRING_END_LAST,\"LAST\"]];this.setHelpUrl(Blockly.Msg.TEXT_GET_SUBSTRING_HELPURL);this.setStyle(\"text_blocks\");\nthis.appendValueInput(\"STRING\").setCheck(\"String\").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT);this.appendDummyInput(\"AT1\");this.appendDummyInput(\"AT2\");Blockly.Msg.TEXT_GET_SUBSTRING_TAIL&&this.appendDummyInput(\"TAIL\").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL);this.setInputsInline(!0);this.setOutput(!0,\"String\");this.updateAt_(1,!0);this.updateAt_(2,!0);this.setTooltip(Blockly.Msg.TEXT_GET_SUBSTRING_TOOLTIP)},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\"),\nb=this.getInput(\"AT1\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at1\",b);b=this.getInput(\"AT2\").type==Blockly.INPUT_VALUE;a.setAttribute(\"at2\",b);return a},domToMutation:function(a){var b=\"true\"==a.getAttribute(\"at1\");a=\"true\"==a.getAttribute(\"at2\");this.updateAt_(1,b);this.updateAt_(2,a)},updateAt_:function(a,b){this.removeInput(\"AT\"+a);this.removeInput(\"ORDINAL\"+a,!0);b?(this.appendValueInput(\"AT\"+a).setCheck(\"Number\"),Blockly.Msg.ORDINAL_NUMBER_SUFFIX&&this.appendDummyInput(\"ORDINAL\"+a).appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX)):\nthis.appendDummyInput(\"AT\"+a);2==a&&Blockly.Msg.TEXT_GET_SUBSTRING_TAIL&&(this.removeInput(\"TAIL\",!0),this.appendDummyInput(\"TAIL\").appendField(Blockly.Msg.TEXT_GET_SUBSTRING_TAIL));var c=new Blockly.FieldDropdown(this[\"WHERE_OPTIONS_\"+a],function(c){var e=\"FROM_START\"==c||\"FROM_END\"==c;if(e!=b){var d=this.getSourceBlock();d.updateAt_(a,e);d.setFieldValue(c,\"WHERE\"+a);return null}});this.getInput(\"AT\"+a).appendField(c,\"WHERE\"+a);1==a&&(this.moveInputBefore(\"AT1\",\"AT2\"),this.getInput(\"ORDINAL1\")&&\nthis.moveInputBefore(\"ORDINAL1\",\"AT2\"))}};Blockly.Blocks.text_changeCase={init:function(){var a=[[Blockly.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE,\"UPPERCASE\"],[Blockly.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE,\"LOWERCASE\"],[Blockly.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE,\"TITLECASE\"]];this.setHelpUrl(Blockly.Msg.TEXT_CHANGECASE_HELPURL);this.setStyle(\"text_blocks\");this.appendValueInput(\"TEXT\").setCheck(\"String\").appendField(new Blockly.FieldDropdown(a),\"CASE\");this.setOutput(!0,\"String\");this.setTooltip(Blockly.Msg.TEXT_CHANGECASE_TOOLTIP)}};\nBlockly.Blocks.text_trim={init:function(){var a=[[Blockly.Msg.TEXT_TRIM_OPERATOR_BOTH,\"BOTH\"],[Blockly.Msg.TEXT_TRIM_OPERATOR_LEFT,\"LEFT\"],[Blockly.Msg.TEXT_TRIM_OPERATOR_RIGHT,\"RIGHT\"]];this.setHelpUrl(Blockly.Msg.TEXT_TRIM_HELPURL);this.setStyle(\"text_blocks\");this.appendValueInput(\"TEXT\").setCheck(\"String\").appendField(new Blockly.FieldDropdown(a),\"MODE\");this.setOutput(!0,\"String\");this.setTooltip(Blockly.Msg.TEXT_TRIM_TOOLTIP)}};\nBlockly.Blocks.text_print={init:function(){this.jsonInit({message0:Blockly.Msg.TEXT_PRINT_TITLE,args0:[{type:\"input_value\",name:\"TEXT\"}],previousStatement:null,nextStatement:null,style:\"text_blocks\",tooltip:Blockly.Msg.TEXT_PRINT_TOOLTIP,helpUrl:Blockly.Msg.TEXT_PRINT_HELPURL})}};\nBlockly.Blocks.text_prompt_ext={init:function(){var a=[[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT,\"TEXT\"],[Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER,\"NUMBER\"]];this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);this.setStyle(\"text_blocks\");var b=this;a=new Blockly.FieldDropdown(a,function(a){b.updateType_(a)});this.appendValueInput(\"TEXT\").appendField(a,\"TYPE\");this.setOutput(!0,\"String\");this.setTooltip(function(){return\"TEXT\"==b.getFieldValue(\"TYPE\")?Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT:Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER})},\nupdateType_:function(a){this.outputConnection.setCheck(\"NUMBER\"==a?\"Number\":\"String\")},mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"type\",this.getFieldValue(\"TYPE\"));return a},domToMutation:function(a){this.updateType_(a.getAttribute(\"type\"))}};\nBlockly.Blocks.text_prompt={init:function(){this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);var a=[[Blockly.Msg.TEXT_PROMPT_TYPE_TEXT,\"TEXT\"],[Blockly.Msg.TEXT_PROMPT_TYPE_NUMBER,\"NUMBER\"]],b=this;this.setHelpUrl(Blockly.Msg.TEXT_PROMPT_HELPURL);this.setStyle(\"text_blocks\");a=new Blockly.FieldDropdown(a,function(a){b.updateType_(a)});this.appendDummyInput().appendField(a,\"TYPE\").appendField(this.newQuote_(!0)).appendField(new Blockly.FieldTextInput(\"\"),\"TEXT\").appendField(this.newQuote_(!1));\nthis.setOutput(!0,\"String\");this.setTooltip(function(){return\"TEXT\"==b.getFieldValue(\"TYPE\")?Blockly.Msg.TEXT_PROMPT_TOOLTIP_TEXT:Blockly.Msg.TEXT_PROMPT_TOOLTIP_NUMBER})},updateType_:Blockly.Blocks.text_prompt_ext.updateType_,mutationToDom:Blockly.Blocks.text_prompt_ext.mutationToDom,domToMutation:Blockly.Blocks.text_prompt_ext.domToMutation};\nBlockly.Blocks.text_count={init:function(){this.jsonInit({message0:Blockly.Msg.TEXT_COUNT_MESSAGE0,args0:[{type:\"input_value\",name:\"SUB\",check:\"String\"},{type:\"input_value\",name:\"TEXT\",check:\"String\"}],output:\"Number\",inputsInline:!0,style:\"text_blocks\",tooltip:Blockly.Msg.TEXT_COUNT_TOOLTIP,helpUrl:Blockly.Msg.TEXT_COUNT_HELPURL})}};\nBlockly.Blocks.text_replace={init:function(){this.jsonInit({message0:Blockly.Msg.TEXT_REPLACE_MESSAGE0,args0:[{type:\"input_value\",name:\"FROM\",check:\"String\"},{type:\"input_value\",name:\"TO\",check:\"String\"},{type:\"input_value\",name:\"TEXT\",check:\"String\"}],output:\"String\",inputsInline:!0,style:\"text_blocks\",tooltip:Blockly.Msg.TEXT_REPLACE_TOOLTIP,helpUrl:Blockly.Msg.TEXT_REPLACE_HELPURL})}};\nBlockly.Blocks.text_reverse={init:function(){this.jsonInit({message0:Blockly.Msg.TEXT_REVERSE_MESSAGE0,args0:[{type:\"input_value\",name:\"TEXT\",check:\"String\"}],output:\"String\",inputsInline:!0,style:\"text_blocks\",tooltip:Blockly.Msg.TEXT_REVERSE_TOOLTIP,helpUrl:Blockly.Msg.TEXT_REVERSE_HELPURL})}};\nBlockly.Constants.Text.QUOTE_IMAGE_MIXIN={QUOTE_IMAGE_LEFT_DATAURI:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC\",QUOTE_IMAGE_RIGHT_DATAURI:\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==\",\nQUOTE_IMAGE_WIDTH:12,QUOTE_IMAGE_HEIGHT:12,quoteField_:function(a){for(var b=0,c;c=this.inputList[b];b++)for(var d=0,e;e=c.fieldRow[d];d++)if(a==e.name){c.insertFieldAt(d,this.newQuote_(!0));c.insertFieldAt(d+2,this.newQuote_(!1));return}console.warn('field named \"'+a+'\" not found in '+this.toDevString())},newQuote_:function(a){a=this.RTL?!a:a;return new Blockly.FieldImage(a?this.QUOTE_IMAGE_LEFT_DATAURI:this.QUOTE_IMAGE_RIGHT_DATAURI,this.QUOTE_IMAGE_WIDTH,this.QUOTE_IMAGE_HEIGHT,a?\"\\u201c\":\"\\u201d\")}};\nBlockly.Constants.Text.TEXT_QUOTES_EXTENSION=function(){this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);this.quoteField_(\"TEXT\")};\nBlockly.Constants.Text.TEXT_JOIN_MUTATOR_MIXIN={mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"items\",this.itemCount_);return a},domToMutation:function(a){this.itemCount_=parseInt(a.getAttribute(\"items\"),10);this.updateShape_()},decompose:function(a){var b=a.newBlock(\"text_create_join_container\");b.initSvg();for(var c=b.getInput(\"STACK\").connection,d=0;d<this.itemCount_;d++){var e=a.newBlock(\"text_create_join_item\");e.initSvg();c.connect(e.previousConnection);\nc=e.nextConnection}return b},compose:function(a){var b=a.getInputTargetBlock(\"STACK\");for(a=[];b;)a.push(b.valueConnection_),b=b.nextConnection&&b.nextConnection.targetBlock();for(b=0;b<this.itemCount_;b++){var c=this.getInput(\"ADD\"+b).connection.targetConnection;c&&-1==a.indexOf(c)&&c.disconnect()}this.itemCount_=a.length;this.updateShape_();for(b=0;b<this.itemCount_;b++)Blockly.Mutator.reconnect(a[b],this,\"ADD\"+b)},saveConnections:function(a){a=a.getInputTargetBlock(\"STACK\");for(var b=0;a;){var c=\nthis.getInput(\"ADD\"+b);a.valueConnection_=c&&c.connection.targetConnection;b++;a=a.nextConnection&&a.nextConnection.targetBlock()}},updateShape_:function(){this.itemCount_&&this.getInput(\"EMPTY\")?this.removeInput(\"EMPTY\"):this.itemCount_||this.getInput(\"EMPTY\")||this.appendDummyInput(\"EMPTY\").appendField(this.newQuote_(!0)).appendField(this.newQuote_(!1));for(var a=0;a<this.itemCount_;a++)if(!this.getInput(\"ADD\"+a)){var b=this.appendValueInput(\"ADD\"+a).setAlign(Blockly.ALIGN_RIGHT);0==a&&b.appendField(Blockly.Msg.TEXT_JOIN_TITLE_CREATEWITH)}for(;this.getInput(\"ADD\"+\na);)this.removeInput(\"ADD\"+a),a++}};Blockly.Constants.Text.TEXT_JOIN_EXTENSION=function(){this.mixin(Blockly.Constants.Text.QUOTE_IMAGE_MIXIN);this.itemCount_=2;this.updateShape_();this.setMutator(new Blockly.Mutator([\"text_create_join_item\"]))};Blockly.Extensions.register(\"text_append_tooltip\",Blockly.Extensions.buildTooltipWithFieldText(\"%{BKY_TEXT_APPEND_TOOLTIP}\",\"VAR\"));\nBlockly.Constants.Text.TEXT_INDEXOF_TOOLTIP_EXTENSION=function(){var a=this;this.setTooltip(function(){return Blockly.Msg.TEXT_INDEXOF_TOOLTIP.replace(\"%1\",a.workspace.options.oneBasedIndex?\"0\":\"-1\")})};\nBlockly.Constants.Text.TEXT_CHARAT_MUTATOR_MIXIN={mutationToDom:function(){var a=Blockly.utils.xml.createElement(\"mutation\");a.setAttribute(\"at\",!!this.isAt_);return a},domToMutation:function(a){a=\"false\"!=a.getAttribute(\"at\");this.updateAt_(a)},updateAt_:function(a){this.removeInput(\"AT\",!0);this.removeInput(\"ORDINAL\",!0);a&&(this.appendValueInput(\"AT\").setCheck(\"Number\"),Blockly.Msg.ORDINAL_NUMBER_SUFFIX&&this.appendDummyInput(\"ORDINAL\").appendField(Blockly.Msg.ORDINAL_NUMBER_SUFFIX));Blockly.Msg.TEXT_CHARAT_TAIL&&\n(this.removeInput(\"TAIL\",!0),this.appendDummyInput(\"TAIL\").appendField(Blockly.Msg.TEXT_CHARAT_TAIL));this.isAt_=a}};\nBlockly.Constants.Text.TEXT_CHARAT_EXTENSION=function(){this.getField(\"WHERE\").setValidator(function(a){a=\"FROM_START\"==a||\"FROM_END\"==a;a!=this.isAt_&&this.getSourceBlock().updateAt_(a)});this.updateAt_(!0);var a=this;this.setTooltip(function(){var b=a.getFieldValue(\"WHERE\"),c=Blockly.Msg.TEXT_CHARAT_TOOLTIP;(\"FROM_START\"==b||\"FROM_END\"==b)&&(b=\"FROM_START\"==b?Blockly.Msg.LISTS_INDEX_FROM_START_TOOLTIP:Blockly.Msg.LISTS_INDEX_FROM_END_TOOLTIP)&&(c+=\"  \"+b.replace(\"%1\",a.workspace.options.oneBasedIndex?\n\"#1\":\"#0\"));return c})};Blockly.Extensions.register(\"text_indexOf_tooltip\",Blockly.Constants.Text.TEXT_INDEXOF_TOOLTIP_EXTENSION);Blockly.Extensions.register(\"text_quotes\",Blockly.Constants.Text.TEXT_QUOTES_EXTENSION);Blockly.Extensions.registerMutator(\"text_join_mutator\",Blockly.Constants.Text.TEXT_JOIN_MUTATOR_MIXIN,Blockly.Constants.Text.TEXT_JOIN_EXTENSION);Blockly.Extensions.registerMutator(\"text_charAt_mutator\",Blockly.Constants.Text.TEXT_CHARAT_MUTATOR_MIXIN,Blockly.Constants.Text.TEXT_CHARAT_EXTENSION);Blockly.Blocks.variables={};Blockly.Constants.Variables={};Blockly.Constants.Variables.HUE=330;\nBlockly.defineBlocksWithJsonArray([{type:\"variables_get\",message0:\"%1\",args0:[{type:\"field_variable\",name:\"VAR\",variable:\"%{BKY_VARIABLES_DEFAULT_NAME}\"}],output:null,style:\"variable_blocks\",helpUrl:\"%{BKY_VARIABLES_GET_HELPURL}\",tooltip:\"%{BKY_VARIABLES_GET_TOOLTIP}\",extensions:[\"contextMenu_variableSetterGetter\"]},{type:\"variables_set\",message0:\"%{BKY_VARIABLES_SET}\",args0:[{type:\"field_variable\",name:\"VAR\",variable:\"%{BKY_VARIABLES_DEFAULT_NAME}\"},{type:\"input_value\",name:\"VALUE\"}],previousStatement:null,\nnextStatement:null,style:\"variable_blocks\",tooltip:\"%{BKY_VARIABLES_SET_TOOLTIP}\",helpUrl:\"%{BKY_VARIABLES_SET_HELPURL}\",extensions:[\"contextMenu_variableSetterGetter\"]}]);\nBlockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN={customContextMenu:function(a){if(!this.isInFlyout){if(\"variables_get\"==this.type)var b=\"variables_set\",c=Blockly.Msg.VARIABLES_GET_CREATE_SET;else b=\"variables_get\",c=Blockly.Msg.VARIABLES_SET_CREATE_GET;var d={enabled:0<this.workspace.remainingCapacity()},e=this.getField(\"VAR\").getText();d.text=c.replace(\"%1\",e);c=Blockly.utils.xml.createElement(\"field\");c.setAttribute(\"name\",\"VAR\");c.appendChild(Blockly.utils.xml.createTextNode(e));\ne=Blockly.utils.xml.createElement(\"block\");e.setAttribute(\"type\",b);e.appendChild(c);d.callback=Blockly.ContextMenu.callbackFactory(this,e);a.push(d)}else if(\"variables_get\"==this.type||\"variables_get_reporter\"==this.type)b={text:Blockly.Msg.RENAME_VARIABLE,enabled:!0,callback:Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY(this)},e=this.getField(\"VAR\").getText(),d={text:Blockly.Msg.DELETE_VARIABLE.replace(\"%1\",e),enabled:!0,callback:Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY(this)},\na.unshift(b),a.unshift(d)}};Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY=function(a){return function(){var b=a.workspace,c=a.getField(\"VAR\").getVariable();Blockly.Variables.renameVariable(b,c)}};Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY=function(a){return function(){var b=a.workspace,c=a.getField(\"VAR\").getVariable();b.deleteVariableById(c.getId());b.refreshToolboxSelection()}};Blockly.Extensions.registerMixin(\"contextMenu_variableSetterGetter\",Blockly.Constants.Variables.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN);Blockly.Constants.VariablesDynamic={};Blockly.Constants.VariablesDynamic.HUE=310;\nBlockly.defineBlocksWithJsonArray([{type:\"variables_get_dynamic\",message0:\"%1\",args0:[{type:\"field_variable\",name:\"VAR\",variable:\"%{BKY_VARIABLES_DEFAULT_NAME}\"}],output:null,style:\"variable_dynamic_blocks\",helpUrl:\"%{BKY_VARIABLES_GET_HELPURL}\",tooltip:\"%{BKY_VARIABLES_GET_TOOLTIP}\",extensions:[\"contextMenu_variableDynamicSetterGetter\"]},{type:\"variables_set_dynamic\",message0:\"%{BKY_VARIABLES_SET}\",args0:[{type:\"field_variable\",name:\"VAR\",variable:\"%{BKY_VARIABLES_DEFAULT_NAME}\"},{type:\"input_value\",\nname:\"VALUE\"}],previousStatement:null,nextStatement:null,style:\"variable_dynamic_blocks\",tooltip:\"%{BKY_VARIABLES_SET_TOOLTIP}\",helpUrl:\"%{BKY_VARIABLES_SET_HELPURL}\",extensions:[\"contextMenu_variableDynamicSetterGetter\"]}]);\nBlockly.Constants.VariablesDynamic.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN={customContextMenu:function(a){if(!this.isInFlyout){var b=this.getFieldValue(\"VAR\");var c=this.workspace.getVariableById(b).type;if(\"variables_get_dynamic\"==this.type){b=\"variables_set_dynamic\";var d=Blockly.Msg.VARIABLES_GET_CREATE_SET}else b=\"variables_get_dynamic\",d=Blockly.Msg.VARIABLES_SET_CREATE_GET;var e={enabled:0<this.workspace.remainingCapacity()},f=this.getField(\"VAR\").getText();e.text=d.replace(\"%1\",f);\nd=Blockly.utils.xml.createElement(\"field\");d.setAttribute(\"name\",\"VAR\");d.setAttribute(\"variabletype\",c);d.appendChild(Blockly.utils.xml.createTextNode(f));f=Blockly.utils.xml.createElement(\"block\");f.setAttribute(\"type\",b);f.appendChild(d);e.callback=Blockly.ContextMenu.callbackFactory(this,f);a.push(e)}else if(\"variables_get_dynamic\"==this.type||\"variables_get_reporter_dynamic\"==this.type)b={text:Blockly.Msg.RENAME_VARIABLE,enabled:!0,callback:Blockly.Constants.Variables.RENAME_OPTION_CALLBACK_FACTORY(this)},\nf=this.getField(\"VAR\").getText(),e={text:Blockly.Msg.DELETE_VARIABLE.replace(\"%1\",f),enabled:!0,callback:Blockly.Constants.Variables.DELETE_OPTION_CALLBACK_FACTORY(this)},a.unshift(b),a.unshift(e)},onchange:function(a){a=this.getFieldValue(\"VAR\");a=Blockly.Variables.getVariable(this.workspace,a);\"variables_get_dynamic\"==this.type?this.outputConnection.setCheck(a.type):this.getInput(\"VALUE\").connection.setCheck(a.type)}};\nBlockly.Constants.VariablesDynamic.RENAME_OPTION_CALLBACK_FACTORY=function(a){return function(){var b=a.workspace,c=a.getField(\"VAR\").getVariable();Blockly.Variables.renameVariable(b,c)}};Blockly.Constants.VariablesDynamic.DELETE_OPTION_CALLBACK_FACTORY=function(a){return function(){var b=a.workspace,c=a.getField(\"VAR\").getVariable();b.deleteVariableById(c.getId());b.refreshToolboxSelection()}};Blockly.Extensions.registerMixin(\"contextMenu_variableDynamicSetterGetter\",Blockly.Constants.VariablesDynamic.CUSTOM_CONTEXT_MENU_VARIABLE_GETTER_SETTER_MIXIN);\n\nreturn Blockly.Blocks;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['./core-browser', './msg/en', './blocks', './javascript'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('./core-browser'), require('./msg/en'), require('./blocks'), require('./javascript'));\n  } else { // Browser\n    root.Blockly = factory(root.Blockly, root.En, root.BlocklyBlocks, root.BlocklyJS);\n  }\n}(this, function(Blockly, En, BlocklyBlocks, BlocklyJS) {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly module for the browser. This includes Blockly core\n * and built in blocks, the JavaScript code generator and the English block\n * localization files.\n */\n\n/* eslint-disable */\n'use strict';\n\n// Include the EN Locale by default.\nBlockly.setLocale(En);\n\nBlockly.Blocks = Blockly.Blocks || {};\nObject.keys(BlocklyBlocks).forEach(function (k) {\n  Blockly.Blocks[k] = BlocklyBlocks[k];\n});\n\nBlockly.JavaScript = BlocklyJS;\nreturn Blockly;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['./blockly'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('./blockly'));\n  } else { // Browser\n    root.Blockly = factory(root.Blockly);\n  }\n}(this, function(Blockly) {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly core module for the browser. It includes blockly.js\n *               and adds a helper method for setting the locale.\n */\n\n/* eslint-disable */\n'use strict';\n\n// Add a helper method to set the Blockly locale.\nBlockly.setLocale = function (locale) {\n  Blockly.Msg = Blockly.Msg || {};\n  Object.keys(locale).forEach(function (k) {\n    Blockly.Msg[k] = locale[k];\n  });\n};\n\nreturn Blockly;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['./browser'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('./node'));\n  } else { // Browser\n    root.Blockly = factory(root.Blockly);\n  }\n}(this, function(Blockly) {\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Blockly module.\n */\n\n/* eslint-disable */\n'use strict';\nreturn Blockly;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['./core'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('./core'));\n  } else { // Browser\n    root.Blockly.JavaScript = factory(root.Blockly);\n  }\n}(this, function(Blockly) {\n// Do not edit this file; automatically generated by gulp.\n'use strict';\n\n\nBlockly.JavaScript=new Blockly.Generator(\"JavaScript\");Blockly.JavaScript.addReservedWords(\"break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,enum,implements,interface,let,package,private,protected,public,static,await,null,true,false,arguments,\"+Object.getOwnPropertyNames(Blockly.utils.global).join(\",\"));\nBlockly.JavaScript.ORDER_ATOMIC=0;Blockly.JavaScript.ORDER_NEW=1.1;Blockly.JavaScript.ORDER_MEMBER=1.2;Blockly.JavaScript.ORDER_FUNCTION_CALL=2;Blockly.JavaScript.ORDER_INCREMENT=3;Blockly.JavaScript.ORDER_DECREMENT=3;Blockly.JavaScript.ORDER_BITWISE_NOT=4.1;Blockly.JavaScript.ORDER_UNARY_PLUS=4.2;Blockly.JavaScript.ORDER_UNARY_NEGATION=4.3;Blockly.JavaScript.ORDER_LOGICAL_NOT=4.4;Blockly.JavaScript.ORDER_TYPEOF=4.5;Blockly.JavaScript.ORDER_VOID=4.6;Blockly.JavaScript.ORDER_DELETE=4.7;\nBlockly.JavaScript.ORDER_AWAIT=4.8;Blockly.JavaScript.ORDER_EXPONENTIATION=5;Blockly.JavaScript.ORDER_MULTIPLICATION=5.1;Blockly.JavaScript.ORDER_DIVISION=5.2;Blockly.JavaScript.ORDER_MODULUS=5.3;Blockly.JavaScript.ORDER_SUBTRACTION=6.1;Blockly.JavaScript.ORDER_ADDITION=6.2;Blockly.JavaScript.ORDER_BITWISE_SHIFT=7;Blockly.JavaScript.ORDER_RELATIONAL=8;Blockly.JavaScript.ORDER_IN=8;Blockly.JavaScript.ORDER_INSTANCEOF=8;Blockly.JavaScript.ORDER_EQUALITY=9;Blockly.JavaScript.ORDER_BITWISE_AND=10;\nBlockly.JavaScript.ORDER_BITWISE_XOR=11;Blockly.JavaScript.ORDER_BITWISE_OR=12;Blockly.JavaScript.ORDER_LOGICAL_AND=13;Blockly.JavaScript.ORDER_LOGICAL_OR=14;Blockly.JavaScript.ORDER_CONDITIONAL=15;Blockly.JavaScript.ORDER_ASSIGNMENT=16;Blockly.JavaScript.ORDER_YIELD=17;Blockly.JavaScript.ORDER_COMMA=18;Blockly.JavaScript.ORDER_NONE=99;\nBlockly.JavaScript.ORDER_OVERRIDES=[[Blockly.JavaScript.ORDER_FUNCTION_CALL,Blockly.JavaScript.ORDER_MEMBER],[Blockly.JavaScript.ORDER_FUNCTION_CALL,Blockly.JavaScript.ORDER_FUNCTION_CALL],[Blockly.JavaScript.ORDER_MEMBER,Blockly.JavaScript.ORDER_MEMBER],[Blockly.JavaScript.ORDER_MEMBER,Blockly.JavaScript.ORDER_FUNCTION_CALL],[Blockly.JavaScript.ORDER_LOGICAL_NOT,Blockly.JavaScript.ORDER_LOGICAL_NOT],[Blockly.JavaScript.ORDER_MULTIPLICATION,Blockly.JavaScript.ORDER_MULTIPLICATION],[Blockly.JavaScript.ORDER_ADDITION,\nBlockly.JavaScript.ORDER_ADDITION],[Blockly.JavaScript.ORDER_LOGICAL_AND,Blockly.JavaScript.ORDER_LOGICAL_AND],[Blockly.JavaScript.ORDER_LOGICAL_OR,Blockly.JavaScript.ORDER_LOGICAL_OR]];\nBlockly.JavaScript.init=function(a){Blockly.JavaScript.definitions_=Object.create(null);Blockly.JavaScript.functionNames_=Object.create(null);Blockly.JavaScript.variableDB_?Blockly.JavaScript.variableDB_.reset():Blockly.JavaScript.variableDB_=new Blockly.Names(Blockly.JavaScript.RESERVED_WORDS_);Blockly.JavaScript.variableDB_.setVariableMap(a.getVariableMap());for(var b=[],c=Blockly.Variables.allDeveloperVariables(a),d=0;d<c.length;d++)b.push(Blockly.JavaScript.variableDB_.getName(c[d],Blockly.Names.DEVELOPER_VARIABLE_TYPE));\na=Blockly.Variables.allUsedVarModels(a);for(d=0;d<a.length;d++)b.push(Blockly.JavaScript.variableDB_.getName(a[d].getId(),Blockly.VARIABLE_CATEGORY_NAME));b.length&&(Blockly.JavaScript.definitions_.variables=\"var \"+b.join(\", \")+\";\")};\nBlockly.JavaScript.finish=function(a){var b=[],c;for(c in Blockly.JavaScript.definitions_)b.push(Blockly.JavaScript.definitions_[c]);delete Blockly.JavaScript.definitions_;delete Blockly.JavaScript.functionNames_;Blockly.JavaScript.variableDB_.reset();return b.join(\"\\n\\n\")+\"\\n\\n\\n\"+a};Blockly.JavaScript.scrubNakedValue=function(a){return a+\";\\n\"};Blockly.JavaScript.quote_=function(a){a=a.replace(/\\\\/g,\"\\\\\\\\\").replace(/\\n/g,\"\\\\\\n\").replace(/'/g,\"\\\\'\");return\"'\"+a+\"'\"};\nBlockly.JavaScript.multiline_quote_=function(a){return a.split(/\\n/g).map(Blockly.JavaScript.quote_).join(\" + '\\\\n' +\\n\")};\nBlockly.JavaScript.scrub_=function(a,b,c){var d=\"\";if(!a.outputConnection||!a.outputConnection.targetConnection){var e=a.getCommentText();e&&(e=Blockly.utils.string.wrap(e,Blockly.JavaScript.COMMENT_WRAP-3),d+=Blockly.JavaScript.prefixLines(e+\"\\n\",\"// \"));for(var f=0;f<a.inputList.length;f++)a.inputList[f].type==Blockly.INPUT_VALUE&&(e=a.inputList[f].connection.targetBlock())&&(e=Blockly.JavaScript.allNestedComments(e))&&(d+=Blockly.JavaScript.prefixLines(e,\"// \"))}a=a.nextConnection&&a.nextConnection.targetBlock();\nc=c?\"\":Blockly.JavaScript.blockToCode(a);return d+b+c};\nBlockly.JavaScript.getAdjusted=function(a,b,c,d,e){c=c||0;e=e||Blockly.JavaScript.ORDER_NONE;a.workspace.options.oneBasedIndex&&c--;var f=a.workspace.options.oneBasedIndex?\"1\":\"0\";a=0<c?Blockly.JavaScript.valueToCode(a,b,Blockly.JavaScript.ORDER_ADDITION)||f:0>c?Blockly.JavaScript.valueToCode(a,b,Blockly.JavaScript.ORDER_SUBTRACTION)||f:d?Blockly.JavaScript.valueToCode(a,b,Blockly.JavaScript.ORDER_UNARY_NEGATION)||f:Blockly.JavaScript.valueToCode(a,b,e)||f;if(Blockly.isNumber(a))a=Number(a)+c,d&&\n(a=-a);else{if(0<c){a=a+\" + \"+c;var g=Blockly.JavaScript.ORDER_ADDITION}else 0>c&&(a=a+\" - \"+-c,g=Blockly.JavaScript.ORDER_SUBTRACTION);d&&(a=c?\"-(\"+a+\")\":\"-\"+a,g=Blockly.JavaScript.ORDER_UNARY_NEGATION);g=Math.floor(g);e=Math.floor(e);g&&e>=g&&(a=\"(\"+a+\")\")}return a};Blockly.JavaScript.colour={};Blockly.JavaScript.colour_picker=function(a){return[Blockly.JavaScript.quote_(a.getFieldValue(\"COLOUR\")),Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.colour_random=function(a){return[Blockly.JavaScript.provideFunction_(\"colourRandom\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"() {\",\"  var num = Math.floor(Math.random() * Math.pow(2, 24));\",\"  return '#' + ('00000' + num.toString(16)).substr(-6);\",\"}\"])+\"()\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.colour_rgb=function(a){var b=Blockly.JavaScript.valueToCode(a,\"RED\",Blockly.JavaScript.ORDER_COMMA)||0,c=Blockly.JavaScript.valueToCode(a,\"GREEN\",Blockly.JavaScript.ORDER_COMMA)||0;a=Blockly.JavaScript.valueToCode(a,\"BLUE\",Blockly.JavaScript.ORDER_COMMA)||0;return[Blockly.JavaScript.provideFunction_(\"colourRgb\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(r, g, b) {\",\"  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;\",\"  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;\",\n\"  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;\",\"  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);\",\"  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);\",\"  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);\",\"  return '#' + r + g + b;\",\"}\"])+\"(\"+b+\", \"+c+\", \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.colour_blend=function(a){var b=Blockly.JavaScript.valueToCode(a,\"COLOUR1\",Blockly.JavaScript.ORDER_COMMA)||\"'#000000'\",c=Blockly.JavaScript.valueToCode(a,\"COLOUR2\",Blockly.JavaScript.ORDER_COMMA)||\"'#000000'\";a=Blockly.JavaScript.valueToCode(a,\"RATIO\",Blockly.JavaScript.ORDER_COMMA)||.5;return[Blockly.JavaScript.provideFunction_(\"colourBlend\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(c1, c2, ratio) {\",\"  ratio = Math.max(Math.min(Number(ratio), 1), 0);\",\"  var r1 = parseInt(c1.substring(1, 3), 16);\",\n\"  var g1 = parseInt(c1.substring(3, 5), 16);\",\"  var b1 = parseInt(c1.substring(5, 7), 16);\",\"  var r2 = parseInt(c2.substring(1, 3), 16);\",\"  var g2 = parseInt(c2.substring(3, 5), 16);\",\"  var b2 = parseInt(c2.substring(5, 7), 16);\",\"  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);\",\"  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);\",\"  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);\",\"  r = ('0' + (r || 0).toString(16)).slice(-2);\",\"  g = ('0' + (g || 0).toString(16)).slice(-2);\",\"  b = ('0' + (b || 0).toString(16)).slice(-2);\",\n\"  return '#' + r + g + b;\",\"}\"])+\"(\"+b+\", \"+c+\", \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.lists={};Blockly.JavaScript.lists_create_empty=function(a){return[\"[]\",Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.lists_create_with=function(a){for(var b=Array(a.itemCount_),c=0;c<a.itemCount_;c++)b[c]=Blockly.JavaScript.valueToCode(a,\"ADD\"+c,Blockly.JavaScript.ORDER_COMMA)||\"null\";return[\"[\"+b.join(\", \")+\"]\",Blockly.JavaScript.ORDER_ATOMIC]};\nBlockly.JavaScript.lists_repeat=function(a){var b=Blockly.JavaScript.provideFunction_(\"listsRepeat\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(value, n) {\",\"  var array = [];\",\"  for (var i = 0; i < n; i++) {\",\"    array[i] = value;\",\"  }\",\"  return array;\",\"}\"]),c=Blockly.JavaScript.valueToCode(a,\"ITEM\",Blockly.JavaScript.ORDER_COMMA)||\"null\";a=Blockly.JavaScript.valueToCode(a,\"NUM\",Blockly.JavaScript.ORDER_COMMA)||\"0\";return[b+\"(\"+c+\", \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.lists_length=function(a){return[(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\")+\".length\",Blockly.JavaScript.ORDER_MEMBER]};Blockly.JavaScript.lists_isEmpty=function(a){return[\"!\"+(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\")+\".length\",Blockly.JavaScript.ORDER_LOGICAL_NOT]};\nBlockly.JavaScript.lists_indexOf=function(a){var b=\"FIRST\"==a.getFieldValue(\"END\")?\"indexOf\":\"lastIndexOf\",c=Blockly.JavaScript.valueToCode(a,\"FIND\",Blockly.JavaScript.ORDER_NONE)||\"''\";b=(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\")+\".\"+b+\"(\"+c+\")\";return a.workspace.options.oneBasedIndex?[b+\" + 1\",Blockly.JavaScript.ORDER_ADDITION]:[b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.lists_getIndex=function(a){var b=a.getFieldValue(\"MODE\")||\"GET\",c=a.getFieldValue(\"WHERE\")||\"FROM_START\",d=Blockly.JavaScript.valueToCode(a,\"VALUE\",\"RANDOM\"==c?Blockly.JavaScript.ORDER_COMMA:Blockly.JavaScript.ORDER_MEMBER)||\"[]\";switch(c){case \"FIRST\":if(\"GET\"==b)return[d+\"[0]\",Blockly.JavaScript.ORDER_MEMBER];if(\"GET_REMOVE\"==b)return[d+\".shift()\",Blockly.JavaScript.ORDER_MEMBER];if(\"REMOVE\"==b)return d+\".shift();\\n\";break;case \"LAST\":if(\"GET\"==b)return[d+\".slice(-1)[0]\",Blockly.JavaScript.ORDER_MEMBER];\nif(\"GET_REMOVE\"==b)return[d+\".pop()\",Blockly.JavaScript.ORDER_MEMBER];if(\"REMOVE\"==b)return d+\".pop();\\n\";break;case \"FROM_START\":a=Blockly.JavaScript.getAdjusted(a,\"AT\");if(\"GET\"==b)return[d+\"[\"+a+\"]\",Blockly.JavaScript.ORDER_MEMBER];if(\"GET_REMOVE\"==b)return[d+\".splice(\"+a+\", 1)[0]\",Blockly.JavaScript.ORDER_FUNCTION_CALL];if(\"REMOVE\"==b)return d+\".splice(\"+a+\", 1);\\n\";break;case \"FROM_END\":a=Blockly.JavaScript.getAdjusted(a,\"AT\",1,!0);if(\"GET\"==b)return[d+\".slice(\"+a+\")[0]\",Blockly.JavaScript.ORDER_FUNCTION_CALL];\nif(\"GET_REMOVE\"==b)return[d+\".splice(\"+a+\", 1)[0]\",Blockly.JavaScript.ORDER_FUNCTION_CALL];if(\"REMOVE\"==b)return d+\".splice(\"+a+\", 1);\";break;case \"RANDOM\":d=Blockly.JavaScript.provideFunction_(\"listsGetRandomItem\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(list, remove) {\",\"  var x = Math.floor(Math.random() * list.length);\",\"  if (remove) {\",\"    return list.splice(x, 1)[0];\",\"  } else {\",\"    return list[x];\",\"  }\",\"}\"])+\"(\"+d+\", \"+(\"GET\"!=b)+\")\";if(\"GET\"==b||\"GET_REMOVE\"==b)return[d,\nBlockly.JavaScript.ORDER_FUNCTION_CALL];if(\"REMOVE\"==b)return d+\";\\n\"}throw Error(\"Unhandled combination (lists_getIndex).\");};\nBlockly.JavaScript.lists_setIndex=function(a){function b(){if(c.match(/^\\w+$/))return\"\";var a=Blockly.JavaScript.variableDB_.getDistinctName(\"tmpList\",Blockly.VARIABLE_CATEGORY_NAME),b=\"var \"+a+\" = \"+c+\";\\n\";c=a;return b}var c=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\",d=a.getFieldValue(\"MODE\")||\"GET\",e=a.getFieldValue(\"WHERE\")||\"FROM_START\",f=Blockly.JavaScript.valueToCode(a,\"TO\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"null\";switch(e){case \"FIRST\":if(\"SET\"==d)return c+\n\"[0] = \"+f+\";\\n\";if(\"INSERT\"==d)return c+\".unshift(\"+f+\");\\n\";break;case \"LAST\":if(\"SET\"==d)return a=b(),a+(c+\"[\"+c+\".length - 1] = \"+f+\";\\n\");if(\"INSERT\"==d)return c+\".push(\"+f+\");\\n\";break;case \"FROM_START\":e=Blockly.JavaScript.getAdjusted(a,\"AT\");if(\"SET\"==d)return c+\"[\"+e+\"] = \"+f+\";\\n\";if(\"INSERT\"==d)return c+\".splice(\"+e+\", 0, \"+f+\");\\n\";break;case \"FROM_END\":e=Blockly.JavaScript.getAdjusted(a,\"AT\",1,!1,Blockly.JavaScript.ORDER_SUBTRACTION);a=b();if(\"SET\"==d)return a+(c+\"[\"+c+\".length - \"+e+\n\"] = \"+f+\";\\n\");if(\"INSERT\"==d)return a+(c+\".splice(\"+c+\".length - \"+e+\", 0, \"+f+\");\\n\");break;case \"RANDOM\":a=b();e=Blockly.JavaScript.variableDB_.getDistinctName(\"tmpX\",Blockly.VARIABLE_CATEGORY_NAME);a+=\"var \"+e+\" = Math.floor(Math.random() * \"+c+\".length);\\n\";if(\"SET\"==d)return a+(c+\"[\"+e+\"] = \"+f+\";\\n\");if(\"INSERT\"==d)return a+(c+\".splice(\"+e+\", 0, \"+f+\");\\n\")}throw Error(\"Unhandled combination (lists_setIndex).\");};\nBlockly.JavaScript.lists.getIndex_=function(a,b,c){return\"FIRST\"==b?\"0\":\"FROM_END\"==b?a+\".length - 1 - \"+c:\"LAST\"==b?a+\".length - 1\":c};\nBlockly.JavaScript.lists_getSublist=function(a){var b=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\",c=a.getFieldValue(\"WHERE1\"),d=a.getFieldValue(\"WHERE2\");if(\"FIRST\"==c&&\"LAST\"==d)b+=\".slice(0)\";else if(b.match(/^\\w+$/)||\"FROM_END\"!=c&&\"FROM_START\"==d){switch(c){case \"FROM_START\":var e=Blockly.JavaScript.getAdjusted(a,\"AT1\");break;case \"FROM_END\":e=Blockly.JavaScript.getAdjusted(a,\"AT1\",1,!1,Blockly.JavaScript.ORDER_SUBTRACTION);e=b+\".length - \"+e;break;case \"FIRST\":e=\n\"0\";break;default:throw Error(\"Unhandled option (lists_getSublist).\");}switch(d){case \"FROM_START\":a=Blockly.JavaScript.getAdjusted(a,\"AT2\",1);break;case \"FROM_END\":a=Blockly.JavaScript.getAdjusted(a,\"AT2\",0,!1,Blockly.JavaScript.ORDER_SUBTRACTION);a=b+\".length - \"+a;break;case \"LAST\":a=b+\".length\";break;default:throw Error(\"Unhandled option (lists_getSublist).\");}b=b+\".slice(\"+e+\", \"+a+\")\"}else{e=Blockly.JavaScript.getAdjusted(a,\"AT1\");a=Blockly.JavaScript.getAdjusted(a,\"AT2\");var f=Blockly.JavaScript.lists.getIndex_,\ng={FIRST:\"First\",LAST:\"Last\",FROM_START:\"FromStart\",FROM_END:\"FromEnd\"};b=Blockly.JavaScript.provideFunction_(\"subsequence\"+g[c]+g[d],[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(sequence\"+(\"FROM_END\"==c||\"FROM_START\"==c?\", at1\":\"\")+(\"FROM_END\"==d||\"FROM_START\"==d?\", at2\":\"\")+\") {\",\"  var start = \"+f(\"sequence\",c,\"at1\")+\";\",\"  var end = \"+f(\"sequence\",d,\"at2\")+\" + 1;\",\"  return sequence.slice(start, end);\",\"}\"])+\"(\"+b+(\"FROM_END\"==c||\"FROM_START\"==c?\", \"+e:\"\")+(\"FROM_END\"==d||\"FROM_START\"==\nd?\", \"+a:\"\")+\")\"}return[b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.lists_sort=function(a){var b=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_FUNCTION_CALL)||\"[]\",c=\"1\"===a.getFieldValue(\"DIRECTION\")?1:-1;a=a.getFieldValue(\"TYPE\");var d=Blockly.JavaScript.provideFunction_(\"listsGetSortCompare\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(type, direction) {\",\"  var compareFuncs = {\",'    \"NUMERIC\": function(a, b) {',\"        return Number(a) - Number(b); },\",'    \"TEXT\": function(a, b) {',\"        return a.toString() > b.toString() ? 1 : -1; },\",\n'    \"IGNORE_CASE\": function(a, b) {',\"        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },\",\"  };\",\"  var compare = compareFuncs[type];\",\"  return function(a, b) { return compare(a, b) * direction; }\",\"}\"]);return[b+\".slice().sort(\"+d+'(\"'+a+'\", '+c+\"))\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.lists_split=function(a){var b=Blockly.JavaScript.valueToCode(a,\"INPUT\",Blockly.JavaScript.ORDER_MEMBER),c=Blockly.JavaScript.valueToCode(a,\"DELIM\",Blockly.JavaScript.ORDER_NONE)||\"''\";a=a.getFieldValue(\"MODE\");if(\"SPLIT\"==a)b||(b=\"''\"),a=\"split\";else if(\"JOIN\"==a)b||(b=\"[]\"),a=\"join\";else throw Error(\"Unknown mode: \"+a);return[b+\".\"+a+\"(\"+c+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.lists_reverse=function(a){return[(Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_FUNCTION_CALL)||\"[]\")+\".slice().reverse()\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.logic={};\nBlockly.JavaScript.controls_if=function(a){var b=0,c=\"\";Blockly.JavaScript.STATEMENT_PREFIX&&(c+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,a));do{var d=Blockly.JavaScript.valueToCode(a,\"IF\"+b,Blockly.JavaScript.ORDER_NONE)||\"false\";var e=Blockly.JavaScript.statementToCode(a,\"DO\"+b);Blockly.JavaScript.STATEMENT_SUFFIX&&(e=Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,a),Blockly.JavaScript.INDENT)+e);c+=(0<b?\" else \":\"\")+\"if (\"+\nd+\") {\\n\"+e+\"}\";++b}while(a.getInput(\"IF\"+b));if(a.getInput(\"ELSE\")||Blockly.JavaScript.STATEMENT_SUFFIX)e=Blockly.JavaScript.statementToCode(a,\"ELSE\"),Blockly.JavaScript.STATEMENT_SUFFIX&&(e=Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,a),Blockly.JavaScript.INDENT)+e),c+=\" else {\\n\"+e+\"}\";return c+\"\\n\"};Blockly.JavaScript.controls_ifelse=Blockly.JavaScript.controls_if;\nBlockly.JavaScript.logic_compare=function(a){var b={EQ:\"==\",NEQ:\"!=\",LT:\"<\",LTE:\"<=\",GT:\">\",GTE:\">=\"}[a.getFieldValue(\"OP\")],c=\"==\"==b||\"!=\"==b?Blockly.JavaScript.ORDER_EQUALITY:Blockly.JavaScript.ORDER_RELATIONAL,d=Blockly.JavaScript.valueToCode(a,\"A\",c)||\"0\";a=Blockly.JavaScript.valueToCode(a,\"B\",c)||\"0\";return[d+\" \"+b+\" \"+a,c]};\nBlockly.JavaScript.logic_operation=function(a){var b=\"AND\"==a.getFieldValue(\"OP\")?\"&&\":\"||\",c=\"&&\"==b?Blockly.JavaScript.ORDER_LOGICAL_AND:Blockly.JavaScript.ORDER_LOGICAL_OR,d=Blockly.JavaScript.valueToCode(a,\"A\",c);a=Blockly.JavaScript.valueToCode(a,\"B\",c);if(d||a){var e=\"&&\"==b?\"true\":\"false\";d||(d=e);a||(a=e)}else a=d=\"false\";return[d+\" \"+b+\" \"+a,c]};\nBlockly.JavaScript.logic_negate=function(a){var b=Blockly.JavaScript.ORDER_LOGICAL_NOT;return[\"!\"+(Blockly.JavaScript.valueToCode(a,\"BOOL\",b)||\"true\"),b]};Blockly.JavaScript.logic_boolean=function(a){return[\"TRUE\"==a.getFieldValue(\"BOOL\")?\"true\":\"false\",Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.logic_null=function(a){return[\"null\",Blockly.JavaScript.ORDER_ATOMIC]};\nBlockly.JavaScript.logic_ternary=function(a){var b=Blockly.JavaScript.valueToCode(a,\"IF\",Blockly.JavaScript.ORDER_CONDITIONAL)||\"false\",c=Blockly.JavaScript.valueToCode(a,\"THEN\",Blockly.JavaScript.ORDER_CONDITIONAL)||\"null\";a=Blockly.JavaScript.valueToCode(a,\"ELSE\",Blockly.JavaScript.ORDER_CONDITIONAL)||\"null\";return[b+\" ? \"+c+\" : \"+a,Blockly.JavaScript.ORDER_CONDITIONAL]};Blockly.JavaScript.loops={};\nBlockly.JavaScript.controls_repeat_ext=function(a){var b=a.getField(\"TIMES\")?String(Number(a.getFieldValue(\"TIMES\"))):Blockly.JavaScript.valueToCode(a,\"TIMES\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"0\",c=Blockly.JavaScript.statementToCode(a,\"DO\");c=Blockly.JavaScript.addLoopTrap(c,a);a=\"\";var d=Blockly.JavaScript.variableDB_.getDistinctName(\"count\",Blockly.VARIABLE_CATEGORY_NAME),e=b;b.match(/^\\w+$/)||Blockly.isNumber(b)||(e=Blockly.JavaScript.variableDB_.getDistinctName(\"repeat_end\",Blockly.VARIABLE_CATEGORY_NAME),\na+=\"var \"+e+\" = \"+b+\";\\n\");return a+(\"for (var \"+d+\" = 0; \"+d+\" < \"+e+\"; \"+d+\"++) {\\n\"+c+\"}\\n\")};Blockly.JavaScript.controls_repeat=Blockly.JavaScript.controls_repeat_ext;\nBlockly.JavaScript.controls_whileUntil=function(a){var b=\"UNTIL\"==a.getFieldValue(\"MODE\"),c=Blockly.JavaScript.valueToCode(a,\"BOOL\",b?Blockly.JavaScript.ORDER_LOGICAL_NOT:Blockly.JavaScript.ORDER_NONE)||\"false\",d=Blockly.JavaScript.statementToCode(a,\"DO\");d=Blockly.JavaScript.addLoopTrap(d,a);b&&(c=\"!\"+c);return\"while (\"+c+\") {\\n\"+d+\"}\\n\"};\nBlockly.JavaScript.controls_for=function(a){var b=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME),c=Blockly.JavaScript.valueToCode(a,\"FROM\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"0\",d=Blockly.JavaScript.valueToCode(a,\"TO\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"0\",e=Blockly.JavaScript.valueToCode(a,\"BY\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"1\",f=Blockly.JavaScript.statementToCode(a,\"DO\");f=Blockly.JavaScript.addLoopTrap(f,a);if(Blockly.isNumber(c)&&Blockly.isNumber(d)&&\nBlockly.isNumber(e)){var g=Number(c)<=Number(d);a=\"for (\"+b+\" = \"+c+\"; \"+b+(g?\" <= \":\" >= \")+d+\"; \"+b;b=Math.abs(Number(e));a=(1==b?a+(g?\"++\":\"--\"):a+((g?\" += \":\" -= \")+b))+(\") {\\n\"+f+\"}\\n\")}else a=\"\",g=c,c.match(/^\\w+$/)||Blockly.isNumber(c)||(g=Blockly.JavaScript.variableDB_.getDistinctName(b+\"_start\",Blockly.VARIABLE_CATEGORY_NAME),a+=\"var \"+g+\" = \"+c+\";\\n\"),c=d,d.match(/^\\w+$/)||Blockly.isNumber(d)||(c=Blockly.JavaScript.variableDB_.getDistinctName(b+\"_end\",Blockly.VARIABLE_CATEGORY_NAME),a+=\n\"var \"+c+\" = \"+d+\";\\n\"),d=Blockly.JavaScript.variableDB_.getDistinctName(b+\"_inc\",Blockly.VARIABLE_CATEGORY_NAME),a+=\"var \"+d+\" = \",a=Blockly.isNumber(e)?a+(Math.abs(e)+\";\\n\"):a+(\"Math.abs(\"+e+\");\\n\"),a=a+(\"if (\"+g+\" > \"+c+\") {\\n\")+(Blockly.JavaScript.INDENT+d+\" = -\"+d+\";\\n\"),a+=\"}\\n\",a+=\"for (\"+b+\" = \"+g+\"; \"+d+\" >= 0 ? \"+b+\" <= \"+c+\" : \"+b+\" >= \"+c+\"; \"+b+\" += \"+d+\") {\\n\"+f+\"}\\n\";return a};\nBlockly.JavaScript.controls_forEach=function(a){var b=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME),c=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"[]\",d=Blockly.JavaScript.statementToCode(a,\"DO\");d=Blockly.JavaScript.addLoopTrap(d,a);a=\"\";var e=c;c.match(/^\\w+$/)||(e=Blockly.JavaScript.variableDB_.getDistinctName(b+\"_list\",Blockly.VARIABLE_CATEGORY_NAME),a+=\"var \"+e+\" = \"+c+\";\\n\");c=Blockly.JavaScript.variableDB_.getDistinctName(b+\n\"_index\",Blockly.VARIABLE_CATEGORY_NAME);d=Blockly.JavaScript.INDENT+b+\" = \"+e+\"[\"+c+\"];\\n\"+d;return a+(\"for (var \"+c+\" in \"+e+\") {\\n\"+d+\"}\\n\")};\nBlockly.JavaScript.controls_flow_statements=function(a){var b=\"\";Blockly.JavaScript.STATEMENT_PREFIX&&(b+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,a));Blockly.JavaScript.STATEMENT_SUFFIX&&(b+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,a));if(Blockly.JavaScript.STATEMENT_PREFIX){var c=Blockly.Constants.Loops.CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(a);c&&!c.suppressPrefixSuffix&&(b+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,\nc))}switch(a.getFieldValue(\"FLOW\")){case \"BREAK\":return b+\"break;\\n\";case \"CONTINUE\":return b+\"continue;\\n\"}throw Error(\"Unknown flow statement.\");};Blockly.JavaScript.math={};Blockly.JavaScript.math_number=function(a){a=Number(a.getFieldValue(\"NUM\"));return[a,0<=a?Blockly.JavaScript.ORDER_ATOMIC:Blockly.JavaScript.ORDER_UNARY_NEGATION]};\nBlockly.JavaScript.math_arithmetic=function(a){var b={ADD:[\" + \",Blockly.JavaScript.ORDER_ADDITION],MINUS:[\" - \",Blockly.JavaScript.ORDER_SUBTRACTION],MULTIPLY:[\" * \",Blockly.JavaScript.ORDER_MULTIPLICATION],DIVIDE:[\" / \",Blockly.JavaScript.ORDER_DIVISION],POWER:[null,Blockly.JavaScript.ORDER_COMMA]}[a.getFieldValue(\"OP\")],c=b[0];b=b[1];var d=Blockly.JavaScript.valueToCode(a,\"A\",b)||\"0\";a=Blockly.JavaScript.valueToCode(a,\"B\",b)||\"0\";return c?[d+c+a,b]:[\"Math.pow(\"+d+\", \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.math_single=function(a){var b=a.getFieldValue(\"OP\");if(\"NEG\"==b)return a=Blockly.JavaScript.valueToCode(a,\"NUM\",Blockly.JavaScript.ORDER_UNARY_NEGATION)||\"0\",\"-\"==a[0]&&(a=\" \"+a),[\"-\"+a,Blockly.JavaScript.ORDER_UNARY_NEGATION];a=\"SIN\"==b||\"COS\"==b||\"TAN\"==b?Blockly.JavaScript.valueToCode(a,\"NUM\",Blockly.JavaScript.ORDER_DIVISION)||\"0\":Blockly.JavaScript.valueToCode(a,\"NUM\",Blockly.JavaScript.ORDER_NONE)||\"0\";switch(b){case \"ABS\":var c=\"Math.abs(\"+a+\")\";break;case \"ROOT\":c=\"Math.sqrt(\"+\na+\")\";break;case \"LN\":c=\"Math.log(\"+a+\")\";break;case \"EXP\":c=\"Math.exp(\"+a+\")\";break;case \"POW10\":c=\"Math.pow(10,\"+a+\")\";break;case \"ROUND\":c=\"Math.round(\"+a+\")\";break;case \"ROUNDUP\":c=\"Math.ceil(\"+a+\")\";break;case \"ROUNDDOWN\":c=\"Math.floor(\"+a+\")\";break;case \"SIN\":c=\"Math.sin(\"+a+\" / 180 * Math.PI)\";break;case \"COS\":c=\"Math.cos(\"+a+\" / 180 * Math.PI)\";break;case \"TAN\":c=\"Math.tan(\"+a+\" / 180 * Math.PI)\"}if(c)return[c,Blockly.JavaScript.ORDER_FUNCTION_CALL];switch(b){case \"LOG10\":c=\"Math.log(\"+a+\n\") / Math.log(10)\";break;case \"ASIN\":c=\"Math.asin(\"+a+\") / Math.PI * 180\";break;case \"ACOS\":c=\"Math.acos(\"+a+\") / Math.PI * 180\";break;case \"ATAN\":c=\"Math.atan(\"+a+\") / Math.PI * 180\";break;default:throw Error(\"Unknown math operator: \"+b);}return[c,Blockly.JavaScript.ORDER_DIVISION]};\nBlockly.JavaScript.math_constant=function(a){return{PI:[\"Math.PI\",Blockly.JavaScript.ORDER_MEMBER],E:[\"Math.E\",Blockly.JavaScript.ORDER_MEMBER],GOLDEN_RATIO:[\"(1 + Math.sqrt(5)) / 2\",Blockly.JavaScript.ORDER_DIVISION],SQRT2:[\"Math.SQRT2\",Blockly.JavaScript.ORDER_MEMBER],SQRT1_2:[\"Math.SQRT1_2\",Blockly.JavaScript.ORDER_MEMBER],INFINITY:[\"Infinity\",Blockly.JavaScript.ORDER_ATOMIC]}[a.getFieldValue(\"CONSTANT\")]};\nBlockly.JavaScript.math_number_property=function(a){var b=Blockly.JavaScript.valueToCode(a,\"NUMBER_TO_CHECK\",Blockly.JavaScript.ORDER_MODULUS)||\"0\",c=a.getFieldValue(\"PROPERTY\");if(\"PRIME\"==c)return[Blockly.JavaScript.provideFunction_(\"mathIsPrime\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(n) {\",\"  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods\",\"  if (n == 2 || n == 3) {\",\"    return true;\",\"  }\",\"  // False if n is NaN, negative, is 1, or not whole.\",\"  // And false if n is divisible by 2 or 3.\",\n\"  if (isNaN(n) || n <= 1 || n % 1 != 0 || n % 2 == 0 || n % 3 == 0) {\",\"    return false;\",\"  }\",\"  // Check all the numbers of form 6k +/- 1, up to sqrt(n).\",\"  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {\",\"    if (n % (x - 1) == 0 || n % (x + 1) == 0) {\",\"      return false;\",\"    }\",\"  }\",\"  return true;\",\"}\"])+\"(\"+b+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL];switch(c){case \"EVEN\":var d=b+\" % 2 == 0\";break;case \"ODD\":d=b+\" % 2 == 1\";break;case \"WHOLE\":d=b+\" % 1 == 0\";break;case \"POSITIVE\":d=\nb+\" > 0\";break;case \"NEGATIVE\":d=b+\" < 0\";break;case \"DIVISIBLE_BY\":a=Blockly.JavaScript.valueToCode(a,\"DIVISOR\",Blockly.JavaScript.ORDER_MODULUS)||\"0\",d=b+\" % \"+a+\" == 0\"}return[d,Blockly.JavaScript.ORDER_EQUALITY]};\nBlockly.JavaScript.math_change=function(a){var b=Blockly.JavaScript.valueToCode(a,\"DELTA\",Blockly.JavaScript.ORDER_ADDITION)||\"0\";a=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME);return a+\" = (typeof \"+a+\" == 'number' ? \"+a+\" : 0) + \"+b+\";\\n\"};Blockly.JavaScript.math_round=Blockly.JavaScript.math_single;Blockly.JavaScript.math_trig=Blockly.JavaScript.math_single;\nBlockly.JavaScript.math_on_list=function(a){var b=a.getFieldValue(\"OP\");switch(b){case \"SUM\":a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_MEMBER)||\"[]\";a+=\".reduce(function(x, y) {return x + y;})\";break;case \"MIN\":a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_COMMA)||\"[]\";a=\"Math.min.apply(null, \"+a+\")\";break;case \"MAX\":a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_COMMA)||\"[]\";a=\"Math.max.apply(null, \"+a+\")\";break;case \"AVERAGE\":b=Blockly.JavaScript.provideFunction_(\"mathMean\",\n[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(myList) {\",\"  return myList.reduce(function(x, y) {return x + y;}) / myList.length;\",\"}\"]);a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_NONE)||\"[]\";a=b+\"(\"+a+\")\";break;case \"MEDIAN\":b=Blockly.JavaScript.provideFunction_(\"mathMedian\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(myList) {\",\"  var localList = myList.filter(function (x) {return typeof x == 'number';});\",\"  if (!localList.length) return null;\",\n\"  localList.sort(function(a, b) {return b - a;});\",\"  if (localList.length % 2 == 0) {\",\"    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;\",\"  } else {\",\"    return localList[(localList.length - 1) / 2];\",\"  }\",\"}\"]);a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_NONE)||\"[]\";a=b+\"(\"+a+\")\";break;case \"MODE\":b=Blockly.JavaScript.provideFunction_(\"mathModes\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(values) {\",\"  var modes = [];\",\n\"  var counts = [];\",\"  var maxCount = 0;\",\"  for (var i = 0; i < values.length; i++) {\",\"    var value = values[i];\",\"    var found = false;\",\"    var thisCount;\",\"    for (var j = 0; j < counts.length; j++) {\",\"      if (counts[j][0] === value) {\",\"        thisCount = ++counts[j][1];\",\"        found = true;\",\"        break;\",\"      }\",\"    }\",\"    if (!found) {\",\"      counts.push([value, 1]);\",\"      thisCount = 1;\",\"    }\",\"    maxCount = Math.max(thisCount, maxCount);\",\"  }\",\"  for (var j = 0; j < counts.length; j++) {\",\n\"    if (counts[j][1] == maxCount) {\",\"        modes.push(counts[j][0]);\",\"    }\",\"  }\",\"  return modes;\",\"}\"]);a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_NONE)||\"[]\";a=b+\"(\"+a+\")\";break;case \"STD_DEV\":b=Blockly.JavaScript.provideFunction_(\"mathStandardDeviation\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(numbers) {\",\"  var n = numbers.length;\",\"  if (!n) return null;\",\"  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;\",\"  var variance = 0;\",\n\"  for (var j = 0; j < n; j++) {\",\"    variance += Math.pow(numbers[j] - mean, 2);\",\"  }\",\"  variance = variance / n;\",\"  return Math.sqrt(variance);\",\"}\"]);a=Blockly.JavaScript.valueToCode(a,\"LIST\",Blockly.JavaScript.ORDER_NONE)||\"[]\";a=b+\"(\"+a+\")\";break;case \"RANDOM\":b=Blockly.JavaScript.provideFunction_(\"mathRandomList\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(list) {\",\"  var x = Math.floor(Math.random() * list.length);\",\"  return list[x];\",\"}\"]);a=Blockly.JavaScript.valueToCode(a,\n\"LIST\",Blockly.JavaScript.ORDER_NONE)||\"[]\";a=b+\"(\"+a+\")\";break;default:throw Error(\"Unknown operator: \"+b);}return[a,Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.math_modulo=function(a){var b=Blockly.JavaScript.valueToCode(a,\"DIVIDEND\",Blockly.JavaScript.ORDER_MODULUS)||\"0\";a=Blockly.JavaScript.valueToCode(a,\"DIVISOR\",Blockly.JavaScript.ORDER_MODULUS)||\"0\";return[b+\" % \"+a,Blockly.JavaScript.ORDER_MODULUS]};\nBlockly.JavaScript.math_constrain=function(a){var b=Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_COMMA)||\"0\",c=Blockly.JavaScript.valueToCode(a,\"LOW\",Blockly.JavaScript.ORDER_COMMA)||\"0\";a=Blockly.JavaScript.valueToCode(a,\"HIGH\",Blockly.JavaScript.ORDER_COMMA)||\"Infinity\";return[\"Math.min(Math.max(\"+b+\", \"+c+\"), \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.math_random_int=function(a){var b=Blockly.JavaScript.valueToCode(a,\"FROM\",Blockly.JavaScript.ORDER_COMMA)||\"0\";a=Blockly.JavaScript.valueToCode(a,\"TO\",Blockly.JavaScript.ORDER_COMMA)||\"0\";return[Blockly.JavaScript.provideFunction_(\"mathRandomInt\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(a, b) {\",\"  if (a > b) {\",\"    // Swap a and b to ensure a is smaller.\",\"    var c = a;\",\"    a = b;\",\"    b = c;\",\"  }\",\"  return Math.floor(Math.random() * (b - a + 1) + a);\",\n\"}\"])+\"(\"+b+\", \"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.math_random_float=function(a){return[\"Math.random()\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.math_atan2=function(a){var b=Blockly.JavaScript.valueToCode(a,\"X\",Blockly.JavaScript.ORDER_COMMA)||\"0\";return[\"Math.atan2(\"+(Blockly.JavaScript.valueToCode(a,\"Y\",Blockly.JavaScript.ORDER_COMMA)||\"0\")+\", \"+b+\") / Math.PI * 180\",Blockly.JavaScript.ORDER_DIVISION]};Blockly.JavaScript.procedures={};\nBlockly.JavaScript.procedures_defreturn=function(a){var b=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"),Blockly.PROCEDURE_CATEGORY_NAME),c=\"\";Blockly.JavaScript.STATEMENT_PREFIX&&(c+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,a));Blockly.JavaScript.STATEMENT_SUFFIX&&(c+=Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,a));c&&(c=Blockly.JavaScript.prefixLines(c,Blockly.JavaScript.INDENT));var d=\"\";Blockly.JavaScript.INFINITE_LOOP_TRAP&&(d=Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.INFINITE_LOOP_TRAP,\na),Blockly.JavaScript.INDENT));var e=Blockly.JavaScript.statementToCode(a,\"STACK\"),f=Blockly.JavaScript.valueToCode(a,\"RETURN\",Blockly.JavaScript.ORDER_NONE)||\"\",g=\"\";e&&f&&(g=c);f&&(f=Blockly.JavaScript.INDENT+\"return \"+f+\";\\n\");for(var k=[],h=0;h<a.arguments_.length;h++)k[h]=Blockly.JavaScript.variableDB_.getName(a.arguments_[h],Blockly.VARIABLE_CATEGORY_NAME);c=\"function \"+b+\"(\"+k.join(\", \")+\") {\\n\"+c+d+e+g+f+\"}\";c=Blockly.JavaScript.scrub_(a,c);Blockly.JavaScript.definitions_[\"%\"+b]=c;return null};\nBlockly.JavaScript.procedures_defnoreturn=Blockly.JavaScript.procedures_defreturn;Blockly.JavaScript.procedures_callreturn=function(a){for(var b=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"NAME\"),Blockly.PROCEDURE_CATEGORY_NAME),c=[],d=0;d<a.arguments_.length;d++)c[d]=Blockly.JavaScript.valueToCode(a,\"ARG\"+d,Blockly.JavaScript.ORDER_COMMA)||\"null\";return[b+\"(\"+c.join(\", \")+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.procedures_callnoreturn=function(a){return Blockly.JavaScript.procedures_callreturn(a)[0]+\";\\n\"};\nBlockly.JavaScript.procedures_ifreturn=function(a){var b=\"if (\"+(Blockly.JavaScript.valueToCode(a,\"CONDITION\",Blockly.JavaScript.ORDER_NONE)||\"false\")+\") {\\n\";Blockly.JavaScript.STATEMENT_SUFFIX&&(b+=Blockly.JavaScript.prefixLines(Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,a),Blockly.JavaScript.INDENT));a.hasReturnValue_?(a=Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_NONE)||\"null\",b+=Blockly.JavaScript.INDENT+\"return \"+a+\";\\n\"):b+=Blockly.JavaScript.INDENT+\n\"return;\\n\";return b+\"}\\n\"};Blockly.JavaScript.texts={};Blockly.JavaScript.text=function(a){return[Blockly.JavaScript.quote_(a.getFieldValue(\"TEXT\")),Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.text_multiline=function(a){a=Blockly.JavaScript.multiline_quote_(a.getFieldValue(\"TEXT\"));a.includes(\"\\n\")&&(a=\"(\"+a+\")\");return[a,Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.text.forceString_=function(a){return Blockly.JavaScript.text.forceString_.strRegExp.test(a)?a:\"String(\"+a+\")\"};\nBlockly.JavaScript.text.forceString_.strRegExp=/^\\s*'([^']|\\\\')*'\\s*$/;\nBlockly.JavaScript.text_join=function(a){switch(a.itemCount_){case 0:return[\"''\",Blockly.JavaScript.ORDER_ATOMIC];case 1:return a=Blockly.JavaScript.valueToCode(a,\"ADD0\",Blockly.JavaScript.ORDER_NONE)||\"''\",a=Blockly.JavaScript.text.forceString_(a),[a,Blockly.JavaScript.ORDER_FUNCTION_CALL];case 2:var b=Blockly.JavaScript.valueToCode(a,\"ADD0\",Blockly.JavaScript.ORDER_NONE)||\"''\";a=Blockly.JavaScript.valueToCode(a,\"ADD1\",Blockly.JavaScript.ORDER_NONE)||\"''\";a=Blockly.JavaScript.text.forceString_(b)+\n\" + \"+Blockly.JavaScript.text.forceString_(a);return[a,Blockly.JavaScript.ORDER_ADDITION];default:b=Array(a.itemCount_);for(var c=0;c<a.itemCount_;c++)b[c]=Blockly.JavaScript.valueToCode(a,\"ADD\"+c,Blockly.JavaScript.ORDER_COMMA)||\"''\";a=\"[\"+b.join(\",\")+\"].join('')\";return[a,Blockly.JavaScript.ORDER_FUNCTION_CALL]}};\nBlockly.JavaScript.text_append=function(a){var b=Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME);a=Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_NONE)||\"''\";return b+\" += \"+Blockly.JavaScript.text.forceString_(a)+\";\\n\"};Blockly.JavaScript.text_length=function(a){return[(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_FUNCTION_CALL)||\"''\")+\".length\",Blockly.JavaScript.ORDER_MEMBER]};\nBlockly.JavaScript.text_isEmpty=function(a){return[\"!\"+(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_MEMBER)||\"''\")+\".length\",Blockly.JavaScript.ORDER_LOGICAL_NOT]};\nBlockly.JavaScript.text_indexOf=function(a){var b=\"FIRST\"==a.getFieldValue(\"END\")?\"indexOf\":\"lastIndexOf\",c=Blockly.JavaScript.valueToCode(a,\"FIND\",Blockly.JavaScript.ORDER_NONE)||\"''\";b=(Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_MEMBER)||\"''\")+\".\"+b+\"(\"+c+\")\";return a.workspace.options.oneBasedIndex?[b+\" + 1\",Blockly.JavaScript.ORDER_ADDITION]:[b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.text_charAt=function(a){var b=a.getFieldValue(\"WHERE\")||\"FROM_START\",c=Blockly.JavaScript.valueToCode(a,\"VALUE\",\"RANDOM\"==b?Blockly.JavaScript.ORDER_NONE:Blockly.JavaScript.ORDER_MEMBER)||\"''\";switch(b){case \"FIRST\":return[c+\".charAt(0)\",Blockly.JavaScript.ORDER_FUNCTION_CALL];case \"LAST\":return[c+\".slice(-1)\",Blockly.JavaScript.ORDER_FUNCTION_CALL];case \"FROM_START\":return a=Blockly.JavaScript.getAdjusted(a,\"AT\"),[c+\".charAt(\"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL];case \"FROM_END\":return a=\nBlockly.JavaScript.getAdjusted(a,\"AT\",1,!0),[c+\".slice(\"+a+\").charAt(0)\",Blockly.JavaScript.ORDER_FUNCTION_CALL];case \"RANDOM\":return[Blockly.JavaScript.provideFunction_(\"textRandomLetter\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(text) {\",\"  var x = Math.floor(Math.random() * text.length);\",\"  return text[x];\",\"}\"])+\"(\"+c+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]}throw Error(\"Unhandled option (text_charAt).\");};\nBlockly.JavaScript.text.getIndex_=function(a,b,c){return\"FIRST\"==b?\"0\":\"FROM_END\"==b?a+\".length - 1 - \"+c:\"LAST\"==b?a+\".length - 1\":c};\nBlockly.JavaScript.text_getSubstring=function(a){var b=Blockly.JavaScript.valueToCode(a,\"STRING\",Blockly.JavaScript.ORDER_FUNCTION_CALL)||\"''\",c=a.getFieldValue(\"WHERE1\"),d=a.getFieldValue(\"WHERE2\");if(\"FIRST\"!=c||\"LAST\"!=d)if(b.match(/^'?\\w+'?$/)||\"FROM_END\"!=c&&\"LAST\"!=c&&\"FROM_END\"!=d&&\"LAST\"!=d){switch(c){case \"FROM_START\":var e=Blockly.JavaScript.getAdjusted(a,\"AT1\");break;case \"FROM_END\":e=Blockly.JavaScript.getAdjusted(a,\"AT1\",1,!1,Blockly.JavaScript.ORDER_SUBTRACTION);e=b+\".length - \"+e;break;\ncase \"FIRST\":e=\"0\";break;default:throw Error(\"Unhandled option (text_getSubstring).\");}switch(d){case \"FROM_START\":a=Blockly.JavaScript.getAdjusted(a,\"AT2\",1);break;case \"FROM_END\":a=Blockly.JavaScript.getAdjusted(a,\"AT2\",0,!1,Blockly.JavaScript.ORDER_SUBTRACTION);a=b+\".length - \"+a;break;case \"LAST\":a=b+\".length\";break;default:throw Error(\"Unhandled option (text_getSubstring).\");}b=b+\".slice(\"+e+\", \"+a+\")\"}else{e=Blockly.JavaScript.getAdjusted(a,\"AT1\");a=Blockly.JavaScript.getAdjusted(a,\"AT2\");var f=\nBlockly.JavaScript.text.getIndex_,g={FIRST:\"First\",LAST:\"Last\",FROM_START:\"FromStart\",FROM_END:\"FromEnd\"};b=Blockly.JavaScript.provideFunction_(\"subsequence\"+g[c]+g[d],[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(sequence\"+(\"FROM_END\"==c||\"FROM_START\"==c?\", at1\":\"\")+(\"FROM_END\"==d||\"FROM_START\"==d?\", at2\":\"\")+\") {\",\"  var start = \"+f(\"sequence\",c,\"at1\")+\";\",\"  var end = \"+f(\"sequence\",d,\"at2\")+\" + 1;\",\"  return sequence.slice(start, end);\",\"}\"])+\"(\"+b+(\"FROM_END\"==c||\"FROM_START\"==\nc?\", \"+e:\"\")+(\"FROM_END\"==d||\"FROM_START\"==d?\", \"+a:\"\")+\")\"}return[b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};\nBlockly.JavaScript.text_changeCase=function(a){var b={UPPERCASE:\".toUpperCase()\",LOWERCASE:\".toLowerCase()\",TITLECASE:null}[a.getFieldValue(\"CASE\")];a=Blockly.JavaScript.valueToCode(a,\"TEXT\",b?Blockly.JavaScript.ORDER_MEMBER:Blockly.JavaScript.ORDER_NONE)||\"''\";return[b?a+b:Blockly.JavaScript.provideFunction_(\"textToTitleCase\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(str) {\",\"  return str.replace(/\\\\S+/g,\",\"      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});\",\n\"}\"])+\"(\"+a+\")\",Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.text_trim=function(a){var b={LEFT:\".replace(/^[\\\\s\\\\xa0]+/, '')\",RIGHT:\".replace(/[\\\\s\\\\xa0]+$/, '')\",BOTH:\".trim()\"}[a.getFieldValue(\"MODE\")];return[(Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_MEMBER)||\"''\")+b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.text_print=function(a){return\"window.alert(\"+(Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_NONE)||\"''\")+\");\\n\"};\nBlockly.JavaScript.text_prompt_ext=function(a){var b=\"window.prompt(\"+(a.getField(\"TEXT\")?Blockly.JavaScript.quote_(a.getFieldValue(\"TEXT\")):Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_NONE)||\"''\")+\")\";\"NUMBER\"==a.getFieldValue(\"TYPE\")&&(b=\"Number(\"+b+\")\");return[b,Blockly.JavaScript.ORDER_FUNCTION_CALL]};Blockly.JavaScript.text_prompt=Blockly.JavaScript.text_prompt_ext;\nBlockly.JavaScript.text_count=function(a){var b=Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_MEMBER)||\"''\";a=Blockly.JavaScript.valueToCode(a,\"SUB\",Blockly.JavaScript.ORDER_NONE)||\"''\";return[Blockly.JavaScript.provideFunction_(\"textCount\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(haystack, needle) {\",\"  if (needle.length === 0) {\",\"    return haystack.length + 1;\",\"  } else {\",\"    return haystack.split(needle).length - 1;\",\"  }\",\"}\"])+\"(\"+b+\", \"+a+\")\",Blockly.JavaScript.ORDER_SUBTRACTION]};\nBlockly.JavaScript.text_replace=function(a){var b=Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_MEMBER)||\"''\",c=Blockly.JavaScript.valueToCode(a,\"FROM\",Blockly.JavaScript.ORDER_NONE)||\"''\";a=Blockly.JavaScript.valueToCode(a,\"TO\",Blockly.JavaScript.ORDER_NONE)||\"''\";return[Blockly.JavaScript.provideFunction_(\"textReplace\",[\"function \"+Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_+\"(haystack, needle, replacement) {\",'  needle = needle.replace(/([-()\\\\[\\\\]{}+?*.$\\\\^|,:#<!\\\\\\\\])/g,\"\\\\\\\\$1\")',\n'                 .replace(/\\\\x08/g,\"\\\\\\\\x08\");',\"  return haystack.replace(new RegExp(needle, 'g'), replacement);\",\"}\"])+\"(\"+b+\", \"+c+\", \"+a+\")\",Blockly.JavaScript.ORDER_MEMBER]};Blockly.JavaScript.text_reverse=function(a){return[(Blockly.JavaScript.valueToCode(a,\"TEXT\",Blockly.JavaScript.ORDER_MEMBER)||\"''\")+\".split('').reverse().join('')\",Blockly.JavaScript.ORDER_MEMBER]};Blockly.JavaScript.variables={};Blockly.JavaScript.variables_get=function(a){return[Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME),Blockly.JavaScript.ORDER_ATOMIC]};Blockly.JavaScript.variables_set=function(a){var b=Blockly.JavaScript.valueToCode(a,\"VALUE\",Blockly.JavaScript.ORDER_ASSIGNMENT)||\"0\";return Blockly.JavaScript.variableDB_.getName(a.getFieldValue(\"VAR\"),Blockly.VARIABLE_CATEGORY_NAME)+\" = \"+b+\";\\n\"};Blockly.JavaScript.variablesDynamic={};Blockly.JavaScript.variables_get_dynamic=Blockly.JavaScript.variables_get;Blockly.JavaScript.variables_set_dynamic=Blockly.JavaScript.variables_set;\n\nreturn Blockly.JavaScript;\n})); \n","/* eslint-disable */\n;(function(root, factory) {\n  if (typeof define === 'function' && define.amd) { // AMD\n    define(['../core'], factory);\n  } else if (typeof exports === 'object') { // Node.js\n    module.exports = factory(require('../core'));\n  } else { // Browser\n    root.Blockly.Msg = factory(root.Blockly);\n  }\n}(this, function(Blockly) {\n\n      var Blockly = {};Blockly.Msg={};// This file was automatically generated.  Do not modify.\n\n'use strict';\n\nBlockly.Msg[\"ADD_COMMENT\"] = \"Add Comment\";\nBlockly.Msg[\"CANNOT_DELETE_VARIABLE_PROCEDURE\"] = \"Can't delete the variable '%1' because it's part of the definition of the function '%2'\";\nBlockly.Msg[\"CHANGE_VALUE_TITLE\"] = \"Change value:\";\nBlockly.Msg[\"CLEAN_UP\"] = \"Clean up Blocks\";\nBlockly.Msg[\"COLLAPSED_WARNINGS_WARNING\"] = \"Collapsed blocks contain warnings.\";\nBlockly.Msg[\"COLLAPSE_ALL\"] = \"Collapse Blocks\";\nBlockly.Msg[\"COLLAPSE_BLOCK\"] = \"Collapse Block\";\nBlockly.Msg[\"COLOUR_BLEND_COLOUR1\"] = \"colour 1\";\nBlockly.Msg[\"COLOUR_BLEND_COLOUR2\"] = \"colour 2\";\nBlockly.Msg[\"COLOUR_BLEND_HELPURL\"] = \"https://meyerweb.com/eric/tools/color-blend/#:::rgbp\";\nBlockly.Msg[\"COLOUR_BLEND_RATIO\"] = \"ratio\";\nBlockly.Msg[\"COLOUR_BLEND_TITLE\"] = \"blend\";\nBlockly.Msg[\"COLOUR_BLEND_TOOLTIP\"] = \"Blends two colours together with a given ratio (0.0 - 1.0).\";\nBlockly.Msg[\"COLOUR_PICKER_HELPURL\"] = \"https://en.wikipedia.org/wiki/Color\";\nBlockly.Msg[\"COLOUR_PICKER_TOOLTIP\"] = \"Choose a colour from the palette.\";\nBlockly.Msg[\"COLOUR_RANDOM_HELPURL\"] = \"http://randomcolour.com\";\nBlockly.Msg[\"COLOUR_RANDOM_TITLE\"] = \"random colour\";\nBlockly.Msg[\"COLOUR_RANDOM_TOOLTIP\"] = \"Choose a colour at random.\";\nBlockly.Msg[\"COLOUR_RGB_BLUE\"] = \"blue\";\nBlockly.Msg[\"COLOUR_RGB_GREEN\"] = \"green\";\nBlockly.Msg[\"COLOUR_RGB_HELPURL\"] = \"https://www.december.com/html/spec/colorpercompact.html\";\nBlockly.Msg[\"COLOUR_RGB_RED\"] = \"red\";\nBlockly.Msg[\"COLOUR_RGB_TITLE\"] = \"colour with\";\nBlockly.Msg[\"COLOUR_RGB_TOOLTIP\"] = \"Create a colour with the specified amount of red, green, and blue. All values must be between 0 and 100.\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_HELPURL\"] = \"https://github.com/google/blockly/wiki/Loops#loop-termination-blocks\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK\"] = \"break out of loop\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE\"] = \"continue with next iteration of loop\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK\"] = \"Break out of the containing loop.\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE\"] = \"Skip the rest of this loop, and continue with the next iteration.\";\nBlockly.Msg[\"CONTROLS_FLOW_STATEMENTS_WARNING\"] = \"Warning: This block may only be used within a loop.\";\nBlockly.Msg[\"CONTROLS_FOREACH_HELPURL\"] = \"https://github.com/google/blockly/wiki/Loops#for-each\";\nBlockly.Msg[\"CONTROLS_FOREACH_TITLE\"] = \"for each item %1 in list %2\";\nBlockly.Msg[\"CONTROLS_FOREACH_TOOLTIP\"] = \"For each item in a list, set the variable '%1' to the item, and then do some statements.\";\nBlockly.Msg[\"CONTROLS_FOR_HELPURL\"] = \"https://github.com/google/blockly/wiki/Loops#count-with\";\nBlockly.Msg[\"CONTROLS_FOR_TITLE\"] = \"count with %1 from %2 to %3 by %4\";\nBlockly.Msg[\"CONTROLS_FOR_TOOLTIP\"] = \"Have the variable '%1' take on the values from the start number to the end number, counting by the specified interval, and do the specified blocks.\";\nBlockly.Msg[\"CONTROLS_IF_ELSEIF_TOOLTIP\"] = \"Add a condition to the if block.\";\nBlockly.Msg[\"CONTROLS_IF_ELSE_TOOLTIP\"] = \"Add a final, catch-all condition to the if block.\";\nBlockly.Msg[\"CONTROLS_IF_HELPURL\"] = \"https://github.com/google/blockly/wiki/IfElse\";\nBlockly.Msg[\"CONTROLS_IF_IF_TOOLTIP\"] = \"Add, remove, or reorder sections to reconfigure this if block.\";\nBlockly.Msg[\"CONTROLS_IF_MSG_ELSE\"] = \"else\";\nBlockly.Msg[\"CONTROLS_IF_MSG_ELSEIF\"] = \"else if\";\nBlockly.Msg[\"CONTROLS_IF_MSG_IF\"] = \"if\";\nBlockly.Msg[\"CONTROLS_IF_TOOLTIP_1\"] = \"If a value is true, then do some statements.\";\nBlockly.Msg[\"CONTROLS_IF_TOOLTIP_2\"] = \"If a value is true, then do the first block of statements. Otherwise, do the second block of statements.\";\nBlockly.Msg[\"CONTROLS_IF_TOOLTIP_3\"] = \"If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements.\";\nBlockly.Msg[\"CONTROLS_IF_TOOLTIP_4\"] = \"If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements. If none of the values are true, do the last block of statements.\";\nBlockly.Msg[\"CONTROLS_REPEAT_HELPURL\"] = \"https://en.wikipedia.org/wiki/For_loop\";\nBlockly.Msg[\"CONTROLS_REPEAT_INPUT_DO\"] = \"do\";\nBlockly.Msg[\"CONTROLS_REPEAT_TITLE\"] = \"repeat %1 times\";\nBlockly.Msg[\"CONTROLS_REPEAT_TOOLTIP\"] = \"Do some statements several times.\";\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_HELPURL\"] = \"https://github.com/google/blockly/wiki/Loops#repeat\";\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_OPERATOR_UNTIL\"] = \"repeat until\";\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_OPERATOR_WHILE\"] = \"repeat while\";\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL\"] = \"While a value is false, then do some statements.\";\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_TOOLTIP_WHILE\"] = \"While a value is true, then do some statements.\";\nBlockly.Msg[\"DELETE_ALL_BLOCKS\"] = \"Delete all %1 blocks?\";\nBlockly.Msg[\"DELETE_BLOCK\"] = \"Delete Block\";\nBlockly.Msg[\"DELETE_VARIABLE\"] = \"Delete the '%1' variable\";\nBlockly.Msg[\"DELETE_VARIABLE_CONFIRMATION\"] = \"Delete %1 uses of the '%2' variable?\";\nBlockly.Msg[\"DELETE_X_BLOCKS\"] = \"Delete %1 Blocks\";\nBlockly.Msg[\"DISABLE_BLOCK\"] = \"Disable Block\";\nBlockly.Msg[\"DUPLICATE_BLOCK\"] = \"Duplicate\";\nBlockly.Msg[\"DUPLICATE_COMMENT\"] = \"Duplicate Comment\";\nBlockly.Msg[\"ENABLE_BLOCK\"] = \"Enable Block\";\nBlockly.Msg[\"EXPAND_ALL\"] = \"Expand Blocks\";\nBlockly.Msg[\"EXPAND_BLOCK\"] = \"Expand Block\";\nBlockly.Msg[\"EXTERNAL_INPUTS\"] = \"External Inputs\";\nBlockly.Msg[\"HELP\"] = \"Help\";\nBlockly.Msg[\"INLINE_INPUTS\"] = \"Inline Inputs\";\nBlockly.Msg[\"IOS_CANCEL\"] = \"Cancel\";\nBlockly.Msg[\"IOS_ERROR\"] = \"Error\";\nBlockly.Msg[\"IOS_OK\"] = \"OK\";\nBlockly.Msg[\"IOS_PROCEDURES_ADD_INPUT\"] = \"+ Add Input\";\nBlockly.Msg[\"IOS_PROCEDURES_ALLOW_STATEMENTS\"] = \"Allow statements\";\nBlockly.Msg[\"IOS_PROCEDURES_DUPLICATE_INPUTS_ERROR\"] = \"This function has duplicate inputs.\";\nBlockly.Msg[\"IOS_PROCEDURES_INPUTS\"] = \"INPUTS\";\nBlockly.Msg[\"IOS_VARIABLES_ADD_BUTTON\"] = \"Add\";\nBlockly.Msg[\"IOS_VARIABLES_ADD_VARIABLE\"] = \"+ Add Variable\";\nBlockly.Msg[\"IOS_VARIABLES_DELETE_BUTTON\"] = \"Delete\";\nBlockly.Msg[\"IOS_VARIABLES_EMPTY_NAME_ERROR\"] = \"You can't use an empty variable name.\";\nBlockly.Msg[\"IOS_VARIABLES_RENAME_BUTTON\"] = \"Rename\";\nBlockly.Msg[\"IOS_VARIABLES_VARIABLE_NAME\"] = \"Variable name\";\nBlockly.Msg[\"LISTS_CREATE_EMPTY_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#create-empty-list\";\nBlockly.Msg[\"LISTS_CREATE_EMPTY_TITLE\"] = \"create empty list\";\nBlockly.Msg[\"LISTS_CREATE_EMPTY_TOOLTIP\"] = \"Returns a list, of length 0, containing no data records\";\nBlockly.Msg[\"LISTS_CREATE_WITH_CONTAINER_TITLE_ADD\"] = \"list\";\nBlockly.Msg[\"LISTS_CREATE_WITH_CONTAINER_TOOLTIP\"] = \"Add, remove, or reorder sections to reconfigure this list block.\";\nBlockly.Msg[\"LISTS_CREATE_WITH_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#create-list-with\";\nBlockly.Msg[\"LISTS_CREATE_WITH_INPUT_WITH\"] = \"create list with\";\nBlockly.Msg[\"LISTS_CREATE_WITH_ITEM_TOOLTIP\"] = \"Add an item to the list.\";\nBlockly.Msg[\"LISTS_CREATE_WITH_TOOLTIP\"] = \"Create a list with any number of items.\";\nBlockly.Msg[\"LISTS_GET_INDEX_FIRST\"] = \"first\";\nBlockly.Msg[\"LISTS_GET_INDEX_FROM_END\"] = \"# from end\";\nBlockly.Msg[\"LISTS_GET_INDEX_FROM_START\"] = \"#\";\nBlockly.Msg[\"LISTS_GET_INDEX_GET\"] = \"get\";\nBlockly.Msg[\"LISTS_GET_INDEX_GET_REMOVE\"] = \"get and remove\";\nBlockly.Msg[\"LISTS_GET_INDEX_LAST\"] = \"last\";\nBlockly.Msg[\"LISTS_GET_INDEX_RANDOM\"] = \"random\";\nBlockly.Msg[\"LISTS_GET_INDEX_REMOVE\"] = \"remove\";\nBlockly.Msg[\"LISTS_GET_INDEX_TAIL\"] = \"\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_FIRST\"] = \"Returns the first item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_FROM\"] = \"Returns the item at the specified position in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_LAST\"] = \"Returns the last item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_RANDOM\"] = \"Returns a random item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST\"] = \"Removes and returns the first item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM\"] = \"Removes and returns the item at the specified position in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST\"] = \"Removes and returns the last item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM\"] = \"Removes and returns a random item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST\"] = \"Removes the first item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM\"] = \"Removes the item at the specified position in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST\"] = \"Removes the last item in a list.\";\nBlockly.Msg[\"LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM\"] = \"Removes a random item in a list.\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_END_FROM_END\"] = \"to # from end\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_END_FROM_START\"] = \"to #\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_END_LAST\"] = \"to last\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#getting-a-sublist\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_START_FIRST\"] = \"get sub-list from first\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_START_FROM_END\"] = \"get sub-list from # from end\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_START_FROM_START\"] = \"get sub-list from #\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_TAIL\"] = \"\";\nBlockly.Msg[\"LISTS_GET_SUBLIST_TOOLTIP\"] = \"Creates a copy of the specified portion of a list.\";\nBlockly.Msg[\"LISTS_INDEX_FROM_END_TOOLTIP\"] = \"%1 is the last item.\";\nBlockly.Msg[\"LISTS_INDEX_FROM_START_TOOLTIP\"] = \"%1 is the first item.\";\nBlockly.Msg[\"LISTS_INDEX_OF_FIRST\"] = \"find first occurrence of item\";\nBlockly.Msg[\"LISTS_INDEX_OF_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list\";\nBlockly.Msg[\"LISTS_INDEX_OF_LAST\"] = \"find last occurrence of item\";\nBlockly.Msg[\"LISTS_INDEX_OF_TOOLTIP\"] = \"Returns the index of the first/last occurrence of the item in the list. Returns %1 if item is not found.\";\nBlockly.Msg[\"LISTS_INLIST\"] = \"in list\";\nBlockly.Msg[\"LISTS_ISEMPTY_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#is-empty\";\nBlockly.Msg[\"LISTS_ISEMPTY_TITLE\"] = \"%1 is empty\";\nBlockly.Msg[\"LISTS_ISEMPTY_TOOLTIP\"] = \"Returns true if the list is empty.\";\nBlockly.Msg[\"LISTS_LENGTH_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#length-of\";\nBlockly.Msg[\"LISTS_LENGTH_TITLE\"] = \"length of %1\";\nBlockly.Msg[\"LISTS_LENGTH_TOOLTIP\"] = \"Returns the length of a list.\";\nBlockly.Msg[\"LISTS_REPEAT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#create-list-with\";\nBlockly.Msg[\"LISTS_REPEAT_TITLE\"] = \"create list with item %1 repeated %2 times\";\nBlockly.Msg[\"LISTS_REPEAT_TOOLTIP\"] = \"Creates a list consisting of the given value repeated the specified number of times.\";\nBlockly.Msg[\"LISTS_REVERSE_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#reversing-a-list\";\nBlockly.Msg[\"LISTS_REVERSE_MESSAGE0\"] = \"reverse %1\";\nBlockly.Msg[\"LISTS_REVERSE_TOOLTIP\"] = \"Reverse a copy of a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#in-list--set\";\nBlockly.Msg[\"LISTS_SET_INDEX_INPUT_TO\"] = \"as\";\nBlockly.Msg[\"LISTS_SET_INDEX_INSERT\"] = \"insert at\";\nBlockly.Msg[\"LISTS_SET_INDEX_SET\"] = \"set\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST\"] = \"Inserts the item at the start of a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_INSERT_FROM\"] = \"Inserts the item at the specified position in a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_INSERT_LAST\"] = \"Append the item to the end of a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM\"] = \"Inserts the item randomly in a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_SET_FIRST\"] = \"Sets the first item in a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_SET_FROM\"] = \"Sets the item at the specified position in a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_SET_LAST\"] = \"Sets the last item in a list.\";\nBlockly.Msg[\"LISTS_SET_INDEX_TOOLTIP_SET_RANDOM\"] = \"Sets a random item in a list.\";\nBlockly.Msg[\"LISTS_SORT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#sorting-a-list\";\nBlockly.Msg[\"LISTS_SORT_ORDER_ASCENDING\"] = \"ascending\";\nBlockly.Msg[\"LISTS_SORT_ORDER_DESCENDING\"] = \"descending\";\nBlockly.Msg[\"LISTS_SORT_TITLE\"] = \"sort %1 %2 %3\";\nBlockly.Msg[\"LISTS_SORT_TOOLTIP\"] = \"Sort a copy of a list.\";\nBlockly.Msg[\"LISTS_SORT_TYPE_IGNORECASE\"] = \"alphabetic, ignore case\";\nBlockly.Msg[\"LISTS_SORT_TYPE_NUMERIC\"] = \"numeric\";\nBlockly.Msg[\"LISTS_SORT_TYPE_TEXT\"] = \"alphabetic\";\nBlockly.Msg[\"LISTS_SPLIT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists\";\nBlockly.Msg[\"LISTS_SPLIT_LIST_FROM_TEXT\"] = \"make list from text\";\nBlockly.Msg[\"LISTS_SPLIT_TEXT_FROM_LIST\"] = \"make text from list\";\nBlockly.Msg[\"LISTS_SPLIT_TOOLTIP_JOIN\"] = \"Join a list of texts into one text, separated by a delimiter.\";\nBlockly.Msg[\"LISTS_SPLIT_TOOLTIP_SPLIT\"] = \"Split text into a list of texts, breaking at each delimiter.\";\nBlockly.Msg[\"LISTS_SPLIT_WITH_DELIMITER\"] = \"with delimiter\";\nBlockly.Msg[\"LOGIC_BOOLEAN_FALSE\"] = \"false\";\nBlockly.Msg[\"LOGIC_BOOLEAN_HELPURL\"] = \"https://github.com/google/blockly/wiki/Logic#values\";\nBlockly.Msg[\"LOGIC_BOOLEAN_TOOLTIP\"] = \"Returns either true or false.\";\nBlockly.Msg[\"LOGIC_BOOLEAN_TRUE\"] = \"true\";\nBlockly.Msg[\"LOGIC_COMPARE_HELPURL\"] = \"https://en.wikipedia.org/wiki/Inequality_(mathematics)\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_EQ\"] = \"Return true if both inputs equal each other.\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_GT\"] = \"Return true if the first input is greater than the second input.\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_GTE\"] = \"Return true if the first input is greater than or equal to the second input.\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_LT\"] = \"Return true if the first input is smaller than the second input.\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_LTE\"] = \"Return true if the first input is smaller than or equal to the second input.\";\nBlockly.Msg[\"LOGIC_COMPARE_TOOLTIP_NEQ\"] = \"Return true if both inputs are not equal to each other.\";\nBlockly.Msg[\"LOGIC_NEGATE_HELPURL\"] = \"https://github.com/google/blockly/wiki/Logic#not\";\nBlockly.Msg[\"LOGIC_NEGATE_TITLE\"] = \"not %1\";\nBlockly.Msg[\"LOGIC_NEGATE_TOOLTIP\"] = \"Returns true if the input is false. Returns false if the input is true.\";\nBlockly.Msg[\"LOGIC_NULL\"] = \"null\";\nBlockly.Msg[\"LOGIC_NULL_HELPURL\"] = \"https://en.wikipedia.org/wiki/Nullable_type\";\nBlockly.Msg[\"LOGIC_NULL_TOOLTIP\"] = \"Returns null.\";\nBlockly.Msg[\"LOGIC_OPERATION_AND\"] = \"and\";\nBlockly.Msg[\"LOGIC_OPERATION_HELPURL\"] = \"https://github.com/google/blockly/wiki/Logic#logical-operations\";\nBlockly.Msg[\"LOGIC_OPERATION_OR\"] = \"or\";\nBlockly.Msg[\"LOGIC_OPERATION_TOOLTIP_AND\"] = \"Return true if both inputs are true.\";\nBlockly.Msg[\"LOGIC_OPERATION_TOOLTIP_OR\"] = \"Return true if at least one of the inputs is true.\";\nBlockly.Msg[\"LOGIC_TERNARY_CONDITION\"] = \"test\";\nBlockly.Msg[\"LOGIC_TERNARY_HELPURL\"] = \"https://en.wikipedia.org/wiki/%3F:\";\nBlockly.Msg[\"LOGIC_TERNARY_IF_FALSE\"] = \"if false\";\nBlockly.Msg[\"LOGIC_TERNARY_IF_TRUE\"] = \"if true\";\nBlockly.Msg[\"LOGIC_TERNARY_TOOLTIP\"] = \"Check the condition in 'test'. If the condition is true, returns the 'if true' value; otherwise returns the 'if false' value.\";\nBlockly.Msg[\"MATH_ADDITION_SYMBOL\"] = \"+\";\nBlockly.Msg[\"MATH_ARITHMETIC_HELPURL\"] = \"https://en.wikipedia.org/wiki/Arithmetic\";\nBlockly.Msg[\"MATH_ARITHMETIC_TOOLTIP_ADD\"] = \"Return the sum of the two numbers.\";\nBlockly.Msg[\"MATH_ARITHMETIC_TOOLTIP_DIVIDE\"] = \"Return the quotient of the two numbers.\";\nBlockly.Msg[\"MATH_ARITHMETIC_TOOLTIP_MINUS\"] = \"Return the difference of the two numbers.\";\nBlockly.Msg[\"MATH_ARITHMETIC_TOOLTIP_MULTIPLY\"] = \"Return the product of the two numbers.\";\nBlockly.Msg[\"MATH_ARITHMETIC_TOOLTIP_POWER\"] = \"Return the first number raised to the power of the second number.\";\nBlockly.Msg[\"MATH_ATAN2_HELPURL\"] = \"https://en.wikipedia.org/wiki/Atan2\";\nBlockly.Msg[\"MATH_ATAN2_TITLE\"] = \"atan2 of X:%1 Y:%2\";\nBlockly.Msg[\"MATH_ATAN2_TOOLTIP\"] = \"Return the arctangent of point (X, Y) in degrees from -180 to 180.\";\nBlockly.Msg[\"MATH_CHANGE_HELPURL\"] = \"https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter\";\nBlockly.Msg[\"MATH_CHANGE_TITLE\"] = \"change %1 by %2\";\nBlockly.Msg[\"MATH_CHANGE_TOOLTIP\"] = \"Add a number to variable '%1'.\";\nBlockly.Msg[\"MATH_CONSTANT_HELPURL\"] = \"https://en.wikipedia.org/wiki/Mathematical_constant\";\nBlockly.Msg[\"MATH_CONSTANT_TOOLTIP\"] = \"Return one of the common constants:  (3.141), e (2.718),  (1.618), sqrt(2) (1.414), sqrt() (0.707), or  (infinity).\";\nBlockly.Msg[\"MATH_CONSTRAIN_HELPURL\"] = \"https://en.wikipedia.org/wiki/Clamping_(graphics)\";\nBlockly.Msg[\"MATH_CONSTRAIN_TITLE\"] = \"constrain %1 low %2 high %3\";\nBlockly.Msg[\"MATH_CONSTRAIN_TOOLTIP\"] = \"Constrain a number to be between the specified limits (inclusive).\";\nBlockly.Msg[\"MATH_DIVISION_SYMBOL\"] = \"\";\nBlockly.Msg[\"MATH_IS_DIVISIBLE_BY\"] = \"is divisible by\";\nBlockly.Msg[\"MATH_IS_EVEN\"] = \"is even\";\nBlockly.Msg[\"MATH_IS_NEGATIVE\"] = \"is negative\";\nBlockly.Msg[\"MATH_IS_ODD\"] = \"is odd\";\nBlockly.Msg[\"MATH_IS_POSITIVE\"] = \"is positive\";\nBlockly.Msg[\"MATH_IS_PRIME\"] = \"is prime\";\nBlockly.Msg[\"MATH_IS_TOOLTIP\"] = \"Check if a number is an even, odd, prime, whole, positive, negative, or if it is divisible by certain number. Returns true or false.\";\nBlockly.Msg[\"MATH_IS_WHOLE\"] = \"is whole\";\nBlockly.Msg[\"MATH_MODULO_HELPURL\"] = \"https://en.wikipedia.org/wiki/Modulo_operation\";\nBlockly.Msg[\"MATH_MODULO_TITLE\"] = \"remainder of %1  %2\";\nBlockly.Msg[\"MATH_MODULO_TOOLTIP\"] = \"Return the remainder from dividing the two numbers.\";\nBlockly.Msg[\"MATH_MULTIPLICATION_SYMBOL\"] = \"\";\nBlockly.Msg[\"MATH_NUMBER_HELPURL\"] = \"https://en.wikipedia.org/wiki/Number\";\nBlockly.Msg[\"MATH_NUMBER_TOOLTIP\"] = \"A number.\";\nBlockly.Msg[\"MATH_ONLIST_HELPURL\"] = \"\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_AVERAGE\"] = \"average of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_MAX\"] = \"max of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_MEDIAN\"] = \"median of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_MIN\"] = \"min of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_MODE\"] = \"modes of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_RANDOM\"] = \"random item of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_STD_DEV\"] = \"standard deviation of list\";\nBlockly.Msg[\"MATH_ONLIST_OPERATOR_SUM\"] = \"sum of list\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_AVERAGE\"] = \"Return the average (arithmetic mean) of the numeric values in the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_MAX\"] = \"Return the largest number in the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_MEDIAN\"] = \"Return the median number in the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_MIN\"] = \"Return the smallest number in the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_MODE\"] = \"Return a list of the most common item(s) in the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_RANDOM\"] = \"Return a random element from the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_STD_DEV\"] = \"Return the standard deviation of the list.\";\nBlockly.Msg[\"MATH_ONLIST_TOOLTIP_SUM\"] = \"Return the sum of all the numbers in the list.\";\nBlockly.Msg[\"MATH_POWER_SYMBOL\"] = \"^\";\nBlockly.Msg[\"MATH_RANDOM_FLOAT_HELPURL\"] = \"https://en.wikipedia.org/wiki/Random_number_generation\";\nBlockly.Msg[\"MATH_RANDOM_FLOAT_TITLE_RANDOM\"] = \"random fraction\";\nBlockly.Msg[\"MATH_RANDOM_FLOAT_TOOLTIP\"] = \"Return a random fraction between 0.0 (inclusive) and 1.0 (exclusive).\";\nBlockly.Msg[\"MATH_RANDOM_INT_HELPURL\"] = \"https://en.wikipedia.org/wiki/Random_number_generation\";\nBlockly.Msg[\"MATH_RANDOM_INT_TITLE\"] = \"random integer from %1 to %2\";\nBlockly.Msg[\"MATH_RANDOM_INT_TOOLTIP\"] = \"Return a random integer between the two specified limits, inclusive.\";\nBlockly.Msg[\"MATH_ROUND_HELPURL\"] = \"https://en.wikipedia.org/wiki/Rounding\";\nBlockly.Msg[\"MATH_ROUND_OPERATOR_ROUND\"] = \"round\";\nBlockly.Msg[\"MATH_ROUND_OPERATOR_ROUNDDOWN\"] = \"round down\";\nBlockly.Msg[\"MATH_ROUND_OPERATOR_ROUNDUP\"] = \"round up\";\nBlockly.Msg[\"MATH_ROUND_TOOLTIP\"] = \"Round a number up or down.\";\nBlockly.Msg[\"MATH_SINGLE_HELPURL\"] = \"https://en.wikipedia.org/wiki/Square_root\";\nBlockly.Msg[\"MATH_SINGLE_OP_ABSOLUTE\"] = \"absolute\";\nBlockly.Msg[\"MATH_SINGLE_OP_ROOT\"] = \"square root\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_ABS\"] = \"Return the absolute value of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_EXP\"] = \"Return e to the power of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_LN\"] = \"Return the natural logarithm of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_LOG10\"] = \"Return the base 10 logarithm of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_NEG\"] = \"Return the negation of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_POW10\"] = \"Return 10 to the power of a number.\";\nBlockly.Msg[\"MATH_SINGLE_TOOLTIP_ROOT\"] = \"Return the square root of a number.\";\nBlockly.Msg[\"MATH_SUBTRACTION_SYMBOL\"] = \"-\";\nBlockly.Msg[\"MATH_TRIG_ACOS\"] = \"acos\";\nBlockly.Msg[\"MATH_TRIG_ASIN\"] = \"asin\";\nBlockly.Msg[\"MATH_TRIG_ATAN\"] = \"atan\";\nBlockly.Msg[\"MATH_TRIG_COS\"] = \"cos\";\nBlockly.Msg[\"MATH_TRIG_HELPURL\"] = \"https://en.wikipedia.org/wiki/Trigonometric_functions\";\nBlockly.Msg[\"MATH_TRIG_SIN\"] = \"sin\";\nBlockly.Msg[\"MATH_TRIG_TAN\"] = \"tan\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_ACOS\"] = \"Return the arccosine of a number.\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_ASIN\"] = \"Return the arcsine of a number.\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_ATAN\"] = \"Return the arctangent of a number.\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_COS\"] = \"Return the cosine of a degree (not radian).\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_SIN\"] = \"Return the sine of a degree (not radian).\";\nBlockly.Msg[\"MATH_TRIG_TOOLTIP_TAN\"] = \"Return the tangent of a degree (not radian).\";\nBlockly.Msg[\"NEW_COLOUR_VARIABLE\"] = \"Create colour variable...\";\nBlockly.Msg[\"NEW_NUMBER_VARIABLE\"] = \"Create number variable...\";\nBlockly.Msg[\"NEW_STRING_VARIABLE\"] = \"Create string variable...\";\nBlockly.Msg[\"NEW_VARIABLE\"] = \"Create variable...\";\nBlockly.Msg[\"NEW_VARIABLE_TITLE\"] = \"New variable name:\";\nBlockly.Msg[\"NEW_VARIABLE_TYPE_TITLE\"] = \"New variable type:\";\nBlockly.Msg[\"ORDINAL_NUMBER_SUFFIX\"] = \"\";\nBlockly.Msg[\"PROCEDURES_ALLOW_STATEMENTS\"] = \"allow statements\";\nBlockly.Msg[\"PROCEDURES_BEFORE_PARAMS\"] = \"with:\";\nBlockly.Msg[\"PROCEDURES_CALLNORETURN_HELPURL\"] = \"https://en.wikipedia.org/wiki/Subroutine\";\nBlockly.Msg[\"PROCEDURES_CALLNORETURN_TOOLTIP\"] = \"Run the user-defined function '%1'.\";\nBlockly.Msg[\"PROCEDURES_CALLRETURN_HELPURL\"] = \"https://en.wikipedia.org/wiki/Subroutine\";\nBlockly.Msg[\"PROCEDURES_CALLRETURN_TOOLTIP\"] = \"Run the user-defined function '%1' and use its output.\";\nBlockly.Msg[\"PROCEDURES_CALL_BEFORE_PARAMS\"] = \"with:\";\nBlockly.Msg[\"PROCEDURES_CREATE_DO\"] = \"Create '%1'\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_COMMENT\"] = \"Describe this function...\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_DO\"] = \"\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_HELPURL\"] = \"https://en.wikipedia.org/wiki/Subroutine\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_PROCEDURE\"] = \"do something\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_TITLE\"] = \"to\";\nBlockly.Msg[\"PROCEDURES_DEFNORETURN_TOOLTIP\"] = \"Creates a function with no output.\";\nBlockly.Msg[\"PROCEDURES_DEFRETURN_HELPURL\"] = \"https://en.wikipedia.org/wiki/Subroutine\";\nBlockly.Msg[\"PROCEDURES_DEFRETURN_RETURN\"] = \"return\";\nBlockly.Msg[\"PROCEDURES_DEFRETURN_TOOLTIP\"] = \"Creates a function with an output.\";\nBlockly.Msg[\"PROCEDURES_DEF_DUPLICATE_WARNING\"] = \"Warning: This function has duplicate parameters.\";\nBlockly.Msg[\"PROCEDURES_HIGHLIGHT_DEF\"] = \"Highlight function definition\";\nBlockly.Msg[\"PROCEDURES_IFRETURN_HELPURL\"] = \"http://c2.com/cgi/wiki?GuardClause\";\nBlockly.Msg[\"PROCEDURES_IFRETURN_TOOLTIP\"] = \"If a value is true, then return a second value.\";\nBlockly.Msg[\"PROCEDURES_IFRETURN_WARNING\"] = \"Warning: This block may be used only within a function definition.\";\nBlockly.Msg[\"PROCEDURES_MUTATORARG_TITLE\"] = \"input name:\";\nBlockly.Msg[\"PROCEDURES_MUTATORARG_TOOLTIP\"] = \"Add an input to the function.\";\nBlockly.Msg[\"PROCEDURES_MUTATORCONTAINER_TITLE\"] = \"inputs\";\nBlockly.Msg[\"PROCEDURES_MUTATORCONTAINER_TOOLTIP\"] = \"Add, remove, or reorder inputs to this function.\";\nBlockly.Msg[\"REDO\"] = \"Redo\";\nBlockly.Msg[\"REMOVE_COMMENT\"] = \"Remove Comment\";\nBlockly.Msg[\"RENAME_VARIABLE\"] = \"Rename variable...\";\nBlockly.Msg[\"RENAME_VARIABLE_TITLE\"] = \"Rename all '%1' variables to:\";\nBlockly.Msg[\"TEXT_APPEND_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#text-modification\";\nBlockly.Msg[\"TEXT_APPEND_TITLE\"] = \"to %1 append text %2\";\nBlockly.Msg[\"TEXT_APPEND_TOOLTIP\"] = \"Append some text to variable '%1'.\";\nBlockly.Msg[\"TEXT_CHANGECASE_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#adjusting-text-case\";\nBlockly.Msg[\"TEXT_CHANGECASE_OPERATOR_LOWERCASE\"] = \"to lower case\";\nBlockly.Msg[\"TEXT_CHANGECASE_OPERATOR_TITLECASE\"] = \"to Title Case\";\nBlockly.Msg[\"TEXT_CHANGECASE_OPERATOR_UPPERCASE\"] = \"to UPPER CASE\";\nBlockly.Msg[\"TEXT_CHANGECASE_TOOLTIP\"] = \"Return a copy of the text in a different case.\";\nBlockly.Msg[\"TEXT_CHARAT_FIRST\"] = \"get first letter\";\nBlockly.Msg[\"TEXT_CHARAT_FROM_END\"] = \"get letter # from end\";\nBlockly.Msg[\"TEXT_CHARAT_FROM_START\"] = \"get letter #\";\nBlockly.Msg[\"TEXT_CHARAT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#extracting-text\";\nBlockly.Msg[\"TEXT_CHARAT_LAST\"] = \"get last letter\";\nBlockly.Msg[\"TEXT_CHARAT_RANDOM\"] = \"get random letter\";\nBlockly.Msg[\"TEXT_CHARAT_TAIL\"] = \"\";\nBlockly.Msg[\"TEXT_CHARAT_TITLE\"] = \"in text %1 %2\";\nBlockly.Msg[\"TEXT_CHARAT_TOOLTIP\"] = \"Returns the letter at the specified position.\";\nBlockly.Msg[\"TEXT_COUNT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#counting-substrings\";\nBlockly.Msg[\"TEXT_COUNT_MESSAGE0\"] = \"count %1 in %2\";\nBlockly.Msg[\"TEXT_COUNT_TOOLTIP\"] = \"Count how many times some text occurs within some other text.\";\nBlockly.Msg[\"TEXT_CREATE_JOIN_ITEM_TOOLTIP\"] = \"Add an item to the text.\";\nBlockly.Msg[\"TEXT_CREATE_JOIN_TITLE_JOIN\"] = \"join\";\nBlockly.Msg[\"TEXT_CREATE_JOIN_TOOLTIP\"] = \"Add, remove, or reorder sections to reconfigure this text block.\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_END_FROM_END\"] = \"to letter # from end\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_END_FROM_START\"] = \"to letter #\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_END_LAST\"] = \"to last letter\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_INPUT_IN_TEXT\"] = \"in text\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_START_FIRST\"] = \"get substring from first letter\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_START_FROM_END\"] = \"get substring from letter # from end\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_START_FROM_START\"] = \"get substring from letter #\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_TAIL\"] = \"\";\nBlockly.Msg[\"TEXT_GET_SUBSTRING_TOOLTIP\"] = \"Returns a specified portion of the text.\";\nBlockly.Msg[\"TEXT_INDEXOF_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#finding-text\";\nBlockly.Msg[\"TEXT_INDEXOF_OPERATOR_FIRST\"] = \"find first occurrence of text\";\nBlockly.Msg[\"TEXT_INDEXOF_OPERATOR_LAST\"] = \"find last occurrence of text\";\nBlockly.Msg[\"TEXT_INDEXOF_TITLE\"] = \"in text %1 %2 %3\";\nBlockly.Msg[\"TEXT_INDEXOF_TOOLTIP\"] = \"Returns the index of the first/last occurrence of the first text in the second text. Returns %1 if text is not found.\";\nBlockly.Msg[\"TEXT_ISEMPTY_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#checking-for-empty-text\";\nBlockly.Msg[\"TEXT_ISEMPTY_TITLE\"] = \"%1 is empty\";\nBlockly.Msg[\"TEXT_ISEMPTY_TOOLTIP\"] = \"Returns true if the provided text is empty.\";\nBlockly.Msg[\"TEXT_JOIN_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#text-creation\";\nBlockly.Msg[\"TEXT_JOIN_TITLE_CREATEWITH\"] = \"create text with\";\nBlockly.Msg[\"TEXT_JOIN_TOOLTIP\"] = \"Create a piece of text by joining together any number of items.\";\nBlockly.Msg[\"TEXT_LENGTH_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#text-modification\";\nBlockly.Msg[\"TEXT_LENGTH_TITLE\"] = \"length of %1\";\nBlockly.Msg[\"TEXT_LENGTH_TOOLTIP\"] = \"Returns the number of letters (including spaces) in the provided text.\";\nBlockly.Msg[\"TEXT_PRINT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#printing-text\";\nBlockly.Msg[\"TEXT_PRINT_TITLE\"] = \"print %1\";\nBlockly.Msg[\"TEXT_PRINT_TOOLTIP\"] = \"Print the specified text, number or other value.\";\nBlockly.Msg[\"TEXT_PROMPT_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#getting-input-from-the-user\";\nBlockly.Msg[\"TEXT_PROMPT_TOOLTIP_NUMBER\"] = \"Prompt for user for a number.\";\nBlockly.Msg[\"TEXT_PROMPT_TOOLTIP_TEXT\"] = \"Prompt for user for some text.\";\nBlockly.Msg[\"TEXT_PROMPT_TYPE_NUMBER\"] = \"prompt for number with message\";\nBlockly.Msg[\"TEXT_PROMPT_TYPE_TEXT\"] = \"prompt for text with message\";\nBlockly.Msg[\"TEXT_REPLACE_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#replacing-substrings\";\nBlockly.Msg[\"TEXT_REPLACE_MESSAGE0\"] = \"replace %1 with %2 in %3\";\nBlockly.Msg[\"TEXT_REPLACE_TOOLTIP\"] = \"Replace all occurances of some text within some other text.\";\nBlockly.Msg[\"TEXT_REVERSE_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#reversing-text\";\nBlockly.Msg[\"TEXT_REVERSE_MESSAGE0\"] = \"reverse %1\";\nBlockly.Msg[\"TEXT_REVERSE_TOOLTIP\"] = \"Reverses the order of the characters in the text.\";\nBlockly.Msg[\"TEXT_TEXT_HELPURL\"] = \"https://en.wikipedia.org/wiki/String_(computer_science)\";\nBlockly.Msg[\"TEXT_TEXT_TOOLTIP\"] = \"A letter, word, or line of text.\";\nBlockly.Msg[\"TEXT_TRIM_HELPURL\"] = \"https://github.com/google/blockly/wiki/Text#trimming-removing-spaces\";\nBlockly.Msg[\"TEXT_TRIM_OPERATOR_BOTH\"] = \"trim spaces from both sides of\";\nBlockly.Msg[\"TEXT_TRIM_OPERATOR_LEFT\"] = \"trim spaces from left side of\";\nBlockly.Msg[\"TEXT_TRIM_OPERATOR_RIGHT\"] = \"trim spaces from right side of\";\nBlockly.Msg[\"TEXT_TRIM_TOOLTIP\"] = \"Return a copy of the text with spaces removed from one or both ends.\";\nBlockly.Msg[\"TODAY\"] = \"Today\";\nBlockly.Msg[\"UNDO\"] = \"Undo\";\nBlockly.Msg[\"UNNAMED_KEY\"] = \"unnamed\";\nBlockly.Msg[\"VARIABLES_DEFAULT_NAME\"] = \"item\";\nBlockly.Msg[\"VARIABLES_GET_CREATE_SET\"] = \"Create 'set %1'\";\nBlockly.Msg[\"VARIABLES_GET_HELPURL\"] = \"https://github.com/google/blockly/wiki/Variables#get\";\nBlockly.Msg[\"VARIABLES_GET_TOOLTIP\"] = \"Returns the value of this variable.\";\nBlockly.Msg[\"VARIABLES_SET\"] = \"set %1 to %2\";\nBlockly.Msg[\"VARIABLES_SET_CREATE_GET\"] = \"Create 'get %1'\";\nBlockly.Msg[\"VARIABLES_SET_HELPURL\"] = \"https://github.com/google/blockly/wiki/Variables#set\";\nBlockly.Msg[\"VARIABLES_SET_TOOLTIP\"] = \"Sets this variable to be equal to the input.\";\nBlockly.Msg[\"VARIABLE_ALREADY_EXISTS\"] = \"A variable named '%1' already exists.\";\nBlockly.Msg[\"VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE\"] = \"A variable named '%1' already exists for another type: '%2'.\";\nBlockly.Msg[\"WORKSPACE_ARIA_LABEL\"] = \"Blockly Workspace\";\nBlockly.Msg[\"WORKSPACE_COMMENT_DEFAULT_TEXT\"] = \"Say something...\";\nBlockly.Msg[\"CONTROLS_FOREACH_INPUT_DO\"] = Blockly.Msg[\"CONTROLS_REPEAT_INPUT_DO\"];\nBlockly.Msg[\"CONTROLS_FOR_INPUT_DO\"] = Blockly.Msg[\"CONTROLS_REPEAT_INPUT_DO\"];\nBlockly.Msg[\"CONTROLS_IF_ELSEIF_TITLE_ELSEIF\"] = Blockly.Msg[\"CONTROLS_IF_MSG_ELSEIF\"];\nBlockly.Msg[\"CONTROLS_IF_ELSE_TITLE_ELSE\"] = Blockly.Msg[\"CONTROLS_IF_MSG_ELSE\"];\nBlockly.Msg[\"CONTROLS_IF_IF_TITLE_IF\"] = Blockly.Msg[\"CONTROLS_IF_MSG_IF\"];\nBlockly.Msg[\"CONTROLS_IF_MSG_THEN\"] = Blockly.Msg[\"CONTROLS_REPEAT_INPUT_DO\"];\nBlockly.Msg[\"CONTROLS_WHILEUNTIL_INPUT_DO\"] = Blockly.Msg[\"CONTROLS_REPEAT_INPUT_DO\"];\nBlockly.Msg[\"LISTS_CREATE_WITH_ITEM_TITLE\"] = Blockly.Msg[\"VARIABLES_DEFAULT_NAME\"];\nBlockly.Msg[\"LISTS_GET_INDEX_HELPURL\"] = Blockly.Msg[\"LISTS_INDEX_OF_HELPURL\"];\nBlockly.Msg[\"LISTS_GET_INDEX_INPUT_IN_LIST\"] = Blockly.Msg[\"LISTS_INLIST\"];\nBlockly.Msg[\"LISTS_GET_SUBLIST_INPUT_IN_LIST\"] = Blockly.Msg[\"LISTS_INLIST\"];\nBlockly.Msg[\"LISTS_INDEX_OF_INPUT_IN_LIST\"] = Blockly.Msg[\"LISTS_INLIST\"];\nBlockly.Msg[\"LISTS_SET_INDEX_INPUT_IN_LIST\"] = Blockly.Msg[\"LISTS_INLIST\"];\nBlockly.Msg[\"MATH_CHANGE_TITLE_ITEM\"] = Blockly.Msg[\"VARIABLES_DEFAULT_NAME\"];\nBlockly.Msg[\"PROCEDURES_DEFRETURN_COMMENT\"] = Blockly.Msg[\"PROCEDURES_DEFNORETURN_COMMENT\"];\nBlockly.Msg[\"PROCEDURES_DEFRETURN_DO\"] = Blockly.Msg[\"PROCEDURES_DEFNORETURN_DO\"];\nBlockly.Msg[\"PROCEDURES_DEFRETURN_PROCEDURE\"] = Blockly.Msg[\"PROCEDURES_DEFNORETURN_PROCEDURE\"];\nBlockly.Msg[\"PROCEDURES_DEFRETURN_TITLE\"] = Blockly.Msg[\"PROCEDURES_DEFNORETURN_TITLE\"];\nBlockly.Msg[\"TEXT_APPEND_VARIABLE\"] = Blockly.Msg[\"VARIABLES_DEFAULT_NAME\"];\nBlockly.Msg[\"TEXT_CREATE_JOIN_ITEM_TITLE_ITEM\"] = Blockly.Msg[\"VARIABLES_DEFAULT_NAME\"];\n\nBlockly.Msg[\"MATH_HUE\"] = \"230\";\nBlockly.Msg[\"LOOPS_HUE\"] = \"120\";\nBlockly.Msg[\"LISTS_HUE\"] = \"260\";\nBlockly.Msg[\"LOGIC_HUE\"] = \"210\";\nBlockly.Msg[\"VARIABLES_HUE\"] = \"330\";\nBlockly.Msg[\"TEXTS_HUE\"] = \"160\";\nBlockly.Msg[\"PROCEDURES_HUE\"] = \"290\";\nBlockly.Msg[\"COLOUR_HUE\"] = \"20\";\nBlockly.Msg[\"VARIABLES_DYNAMIC_HUE\"] = \"310\";\nreturn Blockly.Msg;\n})); \n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export class Bounds {\n    readonly top: number;\n    readonly left: number;\n    readonly width: number;\n    readonly height: number;\n\n    constructor(x: number, y: number, w: number, h: number) {\n        this.left = x;\n        this.top = y;\n        this.width = w;\n        this.height = h;\n    }\n\n    add(x: number, y: number, w: number, h: number): Bounds {\n        return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);\n    }\n\n    static fromClientRect(clientRect: ClientRect): Bounds {\n        return new Bounds(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    }\n}\n\nexport const parseBounds = (node: Element): Bounds => {\n    return Bounds.fromClientRect(node.getBoundingClientRect());\n};\n\nexport const parseDocumentSize = (document: Document): Bounds => {\n    const body = document.body;\n    const documentElement = document.documentElement;\n\n    if (!body || !documentElement) {\n        throw new Error(`Unable to get document size`);\n    }\n    const width = Math.max(\n        Math.max(body.scrollWidth, documentElement.scrollWidth),\n        Math.max(body.offsetWidth, documentElement.offsetWidth),\n        Math.max(body.clientWidth, documentElement.clientWidth)\n    );\n\n    const height = Math.max(\n        Math.max(body.scrollHeight, documentElement.scrollHeight),\n        Math.max(body.offsetHeight, documentElement.offsetHeight),\n        Math.max(body.clientHeight, documentElement.clientHeight)\n    );\n\n    return new Bounds(0, 0, width, height);\n};\n","export const toCodePoints = (str: string): number[] => {\n    const codePoints = [];\n    let i = 0;\n    const length = str.length;\n    while (i < length) {\n        const value = str.charCodeAt(i++);\n        if (value >= 0xd800 && value <= 0xdbff && i < length) {\n            const extra = str.charCodeAt(i++);\n            if ((extra & 0xfc00) === 0xdc00) {\n                codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            } else {\n                codePoints.push(value);\n                i--;\n            }\n        } else {\n            codePoints.push(value);\n        }\n    }\n    return codePoints;\n};\n\nexport const fromCodePoint = (...codePoints: number[]): string => {\n    if (String.fromCodePoint) {\n        return String.fromCodePoint(...codePoints);\n    }\n\n    const length = codePoints.length;\n    if (!length) {\n        return '';\n    }\n\n    const codeUnits = [];\n\n    let index = -1;\n    let result = '';\n    while (++index < length) {\n        let codePoint = codePoints[index];\n        if (codePoint <= 0xffff) {\n            codeUnits.push(codePoint);\n        } else {\n            codePoint -= 0x10000;\n            codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);\n        }\n        if (index + 1 === length || codeUnits.length > 0x4000) {\n            result += String.fromCharCode(...codeUnits);\n            codeUnits.length = 0;\n        }\n    }\n    return result;\n};\n\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\n\nexport const decode = (base64: string): ArrayBuffer | number[] => {\n    let bufferLength = base64.length * 0.75,\n        len = base64.length,\n        i,\n        p = 0,\n        encoded1,\n        encoded2,\n        encoded3,\n        encoded4;\n\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    const buffer =\n        typeof ArrayBuffer !== 'undefined' &&\n        typeof Uint8Array !== 'undefined' &&\n        typeof Uint8Array.prototype.slice !== 'undefined'\n            ? new ArrayBuffer(bufferLength)\n            : new Array(bufferLength);\n    const bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return buffer;\n};\n\nexport const polyUint16Array = (buffer: number[]): number[] => {\n    const length = buffer.length;\n    const bytes = [];\n    for (let i = 0; i < length; i += 2) {\n        bytes.push((buffer[i + 1] << 8) | buffer[i]);\n    }\n    return bytes;\n};\n\nexport const polyUint32Array = (buffer: number[]): number[] => {\n    const length = buffer.length;\n    const bytes = [];\n    for (let i = 0; i < length; i += 4) {\n        bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);\n    }\n    return bytes;\n};\n","import {decode, polyUint16Array, polyUint32Array} from './Util';\n\nexport type int = number;\n\n/** Shift size for getting the index-2 table offset. */\nexport const UTRIE2_SHIFT_2 = 5;\n\n/** Shift size for getting the index-1 table offset. */\nexport const UTRIE2_SHIFT_1 = 6 + 5;\n\n/**\n * Shift size for shifting left the index array values.\n * Increases possible data size with 16-bit index values at the cost\n * of compactability.\n * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.\n */\nexport const UTRIE2_INDEX_SHIFT = 2;\n\n/**\n * Difference between the two shift sizes,\n * for getting an index-1 offset from an index-2 offset. 6=11-5\n */\nexport const UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;\n\n/**\n * The part of the index-2 table for U+D800..U+DBFF stores values for\n * lead surrogate code _units_ not code _points_.\n * Values for lead surrogate code _points_ are indexed with this portion of the table.\n * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)\n */\nexport const UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;\n\n/** Number of entries in a data block. 32=0x20 */\nexport const UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;\n/** Mask for getting the lower bits for the in-data-block offset. */\nexport const UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;\n\nexport const UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;\n/** Count the lengths of both BMP pieces. 2080=0x820 */\nexport const UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;\n/**\n * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.\n * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.\n */\nexport const UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;\nexport const UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */\n/**\n * The index-1 table, only used for supplementary code points, at offset 2112=0x840.\n * Variable length, for code points up to highStart, where the last single-value range starts.\n * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.\n * (For 0x100000 supplementary code points U+10000..U+10ffff.)\n *\n * The part of the index-2 table for supplementary code points starts\n * after this index-1 table.\n *\n * Both the index-1 table and the following part of the index-2 table\n * are omitted completely if there is only BMP data.\n */\nexport const UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;\n\n/**\n * Number of index-1 entries for the BMP. 32=0x20\n * This part of the index-1 table is omitted from the serialized form.\n */\nexport const UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;\n\n/** Number of entries in an index-2 block. 64=0x40 */\nexport const UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;\n/** Mask for getting the lower bits for the in-index-2-block offset. */\nexport const UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;\n\nconst slice16 = (view: number[] | Uint16Array, start: number, end?: number) => {\n    if (view.slice) {\n        return view.slice(start, end);\n    }\n\n    return new Uint16Array(Array.prototype.slice.call(view, start, end))\n};\n\nconst slice32 = (view: number[] | Uint32Array, start: number, end?: number) => {\n    if (view.slice) {\n        return view.slice(start, end);\n    }\n\n    return new Uint32Array(Array.prototype.slice.call(view, start, end));\n};\n\nexport const createTrieFromBase64 = (base64: string): Trie => {\n    const buffer = decode(base64);\n    const view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);\n    const view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);\n    const headerLength = 24;\n\n    const index = slice16(view16, headerLength / 2, view32[4] / 2);\n    const data =\n        view32[5] === 2\n            ? slice16(view16, (headerLength + view32[4]) / 2)\n            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));\n\n    return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);\n};\n\nexport class Trie {\n    initialValue: int;\n    errorValue: int;\n    highStart: int;\n    highValueIndex: int;\n    index: Uint16Array | number[];\n    data: Uint32Array | Uint16Array | number[];\n\n    constructor(\n        initialValue: int,\n        errorValue: int,\n        highStart: int,\n        highValueIndex: int,\n        index: Uint16Array | number[],\n        data: Uint32Array | Uint16Array | number[]\n    ) {\n        this.initialValue = initialValue;\n        this.errorValue = errorValue;\n        this.highStart = highStart;\n        this.highValueIndex = highValueIndex;\n        this.index = index;\n        this.data = data;\n    }\n\n    /**\n     * Get the value for a code point as stored in the Trie.\n     *\n     * @param codePoint the code point\n     * @return the value\n     */\n    get(codePoint: number): number {\n        let ix;\n        if (codePoint >= 0) {\n            if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {\n                // Ordinary BMP code point, excluding leading surrogates.\n                // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.\n                // 16 bit data is stored in the index array itself.\n                ix = this.index[codePoint >> UTRIE2_SHIFT_2];\n                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                return this.data[ix];\n            }\n\n            if (codePoint <= 0xffff) {\n                // Lead Surrogate Code Point.  A Separate index section is stored for\n                // lead surrogate code units and code points.\n                //   The main index has the code unit data.\n                //   For this function, we need the code point data.\n                // Note: this expression could be refactored for slightly improved efficiency, but\n                //       surrogate code points will be so rare in practice that it's not worth it.\n                ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];\n                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                return this.data[ix];\n            }\n\n            if (codePoint < this.highStart) {\n                // Supplemental code point, use two-level lookup.\n                ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);\n                ix = this.index[ix];\n                ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;\n                ix = this.index[ix];\n                ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);\n                return this.data[ix];\n            }\n            if (codePoint <= 0x10ffff) {\n                return this.data[this.highValueIndex];\n            }\n        }\n\n        // Fall through.  The code point is outside of the legal range of 0..0x10ffff.\n        return this.errorValue;\n    }\n}\n","export const base64 =\n    'KwAAAAAAAAAACA4AIDoAAPAfAAACAAAAAAAIABAAGABAAEgAUABYAF4AZgBeAGYAYABoAHAAeABeAGYAfACEAIAAiACQAJgAoACoAK0AtQC9AMUAXgBmAF4AZgBeAGYAzQDVAF4AZgDRANkA3gDmAOwA9AD8AAQBDAEUARoBIgGAAIgAJwEvATcBPwFFAU0BTAFUAVwBZAFsAXMBewGDATAAiwGTAZsBogGkAawBtAG8AcIBygHSAdoB4AHoAfAB+AH+AQYCDgIWAv4BHgImAi4CNgI+AkUCTQJTAlsCYwJrAnECeQKBAk0CiQKRApkCoQKoArACuALAAsQCzAIwANQC3ALkAjAA7AL0AvwCAQMJAxADGAMwACADJgMuAzYDPgOAAEYDSgNSA1IDUgNaA1oDYANiA2IDgACAAGoDgAByA3YDfgOAAIQDgACKA5IDmgOAAIAAogOqA4AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAK8DtwOAAIAAvwPHA88D1wPfAyAD5wPsA/QD/AOAAIAABAQMBBIEgAAWBB4EJgQuBDMEIAM7BEEEXgBJBCADUQRZBGEEaQQwADAAcQQ+AXkEgQSJBJEEgACYBIAAoASoBK8EtwQwAL8ExQSAAIAAgACAAIAAgACgAM0EXgBeAF4AXgBeAF4AXgBeANUEXgDZBOEEXgDpBPEE+QQBBQkFEQUZBSEFKQUxBTUFPQVFBUwFVAVcBV4AYwVeAGsFcwV7BYMFiwWSBV4AmgWgBacFXgBeAF4AXgBeAKsFXgCyBbEFugW7BcIFwgXIBcIFwgXQBdQF3AXkBesF8wX7BQMGCwYTBhsGIwYrBjMGOwZeAD8GRwZNBl4AVAZbBl4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAGMGXgBqBnEGXgBeAF4AXgBeAF4AXgBeAF4AXgB5BoAG4wSGBo4GkwaAAIADHgR5AF4AXgBeAJsGgABGA4AAowarBrMGswagALsGwwbLBjAA0wbaBtoG3QbaBtoG2gbaBtoG2gblBusG8wb7BgMHCwcTBxsHCwcjBysHMAc1BzUHOgdCB9oGSgdSB1oHYAfaBloHaAfaBlIH2gbaBtoG2gbaBtoG2gbaBjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHbQdeAF4ANQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQd1B30HNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B4MH2gaKB68EgACAAIAAgACAAIAAgACAAI8HlwdeAJ8HpweAAIAArwe3B14AXgC/B8UHygcwANAH2AfgB4AA6AfwBz4B+AcACFwBCAgPCBcIogEYAR8IJwiAAC8INwg/CCADRwhPCFcIXwhnCEoDGgSAAIAAgABvCHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIhAiLCI4IMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAANQc1BzUHNQc1BzUHNQc1BzUHNQc1B54INQc1B6II2gaqCLIIugiAAIAAvgjGCIAAgACAAIAAgACAAIAAgACAAIAAywiHAYAA0wiAANkI3QjlCO0I9Aj8CIAAgACAAAIJCgkSCRoJIgknCTYHLwk3CZYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiAAIAAAAFAAXgBeAGAAcABeAHwAQACQAKAArQC9AJ4AXgBeAE0A3gBRAN4A7AD8AMwBGgEAAKcBNwEFAUwBXAF4QkhCmEKnArcCgAHHAsABz4LAAcABwAHAAd+C6ABoAG+C/4LAAcABwAHAAc+DF4MAAcAB54M3gweDV4Nng3eDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEeDqABVg6WDqABoQ6gAaABoAHXDvcONw/3DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DncPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB7cPPwlGCU4JMACAAIAAgABWCV4JYQmAAGkJcAl4CXwJgAkwADAAMAAwAIgJgACLCZMJgACZCZ8JowmrCYAAswkwAF4AXgB8AIAAuwkABMMJyQmAAM4JgADVCTAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAqwYWBNkIMAAwADAAMADdCeAJ6AnuCR4E9gkwAP4JBQoNCjAAMACAABUK0wiAAB0KJAosCjQKgAAwADwKQwqAAEsKvQmdCVMKWwowADAAgACAALcEMACAAGMKgABrCjAAMAAwADAAMAAwADAAMAAwADAAMAAeBDAAMAAwADAAMAAwADAAMAAwADAAMAAwAIkEPQFzCnoKiQSCCooKkAqJBJgKoAqkCokEGAGsCrQKvArBCjAAMADJCtEKFQHZCuEK/gHpCvEKMAAwADAAMACAAIwE+QowAIAAPwEBCzAAMAAwADAAMACAAAkLEQswAIAAPwEZCyELgAAOCCkLMAAxCzkLMAAwADAAMAAwADAAXgBeAEELMAAwADAAMAAwADAAMAAwAEkLTQtVC4AAXAtkC4AAiQkwADAAMAAwADAAMAAwADAAbAtxC3kLgAuFC4sLMAAwAJMLlwufCzAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAApwswADAAMACAAIAAgACvC4AAgACAAIAAgACAALcLMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAvwuAAMcLgACAAIAAgACAAIAAyguAAIAAgACAAIAA0QswADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAANkLgACAAIAA4AswADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACJCR4E6AswADAAhwHwC4AA+AsADAgMEAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACAAIAAGAwdDCUMMAAwAC0MNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQw1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHPQwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADUHNQc1BzUHNQc1BzUHNQc2BzAAMAA5DDUHNQc1BzUHNQc1BzUHNQc1BzUHNQdFDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAATQxSDFoMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAF4AXgBeAF4AXgBeAF4AYgxeAGoMXgBxDHkMfwxeAIUMXgBeAI0MMAAwADAAMAAwAF4AXgCVDJ0MMAAwADAAMABeAF4ApQxeAKsMswy7DF4Awgy9DMoMXgBeAF4AXgBeAF4AXgBeAF4AXgDRDNkMeQBqCeAM3Ax8AOYM7Az0DPgMXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgCgAAANoAAHDQ4NFg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAeDSYNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAC4NMABeAF4ANg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAD4NRg1ODVYNXg1mDTAAbQ0wADAAMAAwADAAMAAwADAA2gbaBtoG2gbaBtoG2gbaBnUNeg3CBYANwgWFDdoGjA3aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gaUDZwNpA2oDdoG2gawDbcNvw3HDdoG2gbPDdYN3A3fDeYN2gbsDfMN2gbaBvoN/g3aBgYODg7aBl4AXgBeABYOXgBeACUG2gYeDl4AJA5eACwO2w3aBtoGMQ45DtoG2gbaBtoGQQ7aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B1EO2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQdZDjUHNQc1BzUHNQc1B2EONQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHaA41BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B3AO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B2EO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBkkOeA6gAKAAoAAwADAAMAAwAKAAoACgAKAAoACgAKAAgA4wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAD//wQABAAEAAQABAAEAAQABAAEAA0AAwABAAEAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAKABMAFwAeABsAGgAeABcAFgASAB4AGwAYAA8AGAAcAEsASwBLAEsASwBLAEsASwBLAEsAGAAYAB4AHgAeABMAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAFgAbABIAHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYADQARAB4ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkAFgAaABsAGwAbAB4AHQAdAB4ATwAXAB4ADQAeAB4AGgAbAE8ATwAOAFAAHQAdAB0ATwBPABcATwBPAE8AFgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwArAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAAQABAANAA0ASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAUAArACsAKwArACsAKwArACsABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAGgAaAFAAUABQAFAAUABMAB4AGwBQAB4AKwArACsABAAEAAQAKwBQAFAAUABQAFAAUAArACsAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUAArAFAAUAArACsABAArAAQABAAEAAQABAArACsAKwArAAQABAArACsABAAEAAQAKwArACsABAArACsAKwArACsAKwArAFAAUABQAFAAKwBQACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwAEAAQAUABQAFAABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQAKwArAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeABsAKwArACsAKwArACsAKwBQAAQABAAEAAQABAAEACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAKwArACsAKwArACsAKwArAAQABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwAEAFAAKwBQAFAAUABQAFAAUAArACsAKwBQAFAAUAArAFAAUABQAFAAKwArACsAUABQACsAUAArAFAAUAArACsAKwBQAFAAKwArACsAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQAKwArACsABAAEAAQAKwAEAAQABAAEACsAKwBQACsAKwArACsAKwArAAQAKwArACsAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAB4AHgAeAB4AHgAeABsAHgArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArAFAAUABQACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAB4AUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArACsAKwArACsAKwArAFAAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwArAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAKwBcAFwAKwBcACsAKwBcACsAKwArACsAKwArAFwAXABcAFwAKwBcAFwAXABcAFwAXABcACsAXABcAFwAKwBcACsAXAArACsAXABcACsAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgArACoAKgBcACsAKwBcAFwAXABcAFwAKwBcACsAKgAqACoAKgAqACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAFwAXABcAFwAUAAOAA4ADgAOAB4ADgAOAAkADgAOAA0ACQATABMAEwATABMACQAeABMAHgAeAB4ABAAEAB4AHgAeAB4AHgAeAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUAANAAQAHgAEAB4ABAAWABEAFgARAAQABABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAAQABAAEAAQABAANAAQABABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsADQANAB4AHgAeAB4AHgAeAAQAHgAeAB4AHgAeAB4AKwAeAB4ADgAOAA0ADgAeAB4AHgAeAB4ACQAJACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgAeAB4AHgBcAFwAXABcAFwAXAAqACoAKgAqAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAKgAqACoAKgAqACoAKgBcAFwAXAAqACoAKgAqAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAXAAqAEsASwBLAEsASwBLAEsASwBLAEsAKgAqACoAKgAqACoAUABQAFAAUABQAFAAKwBQACsAKwArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQACsAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwAEAAQABAAeAA0AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAEQArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAADQANAA0AUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAA0ADQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoADQANABUAXAANAB4ADQAbAFwAKgArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAB4AHgATABMADQANAA4AHgATABMAHgAEAAQABAAJACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAUABQAFAAUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwAeACsAKwArABMAEwBLAEsASwBLAEsASwBLAEsASwBLAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwBcAFwAXABcAFwAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcACsAKwArACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwAeAB4AXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsABABLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKgAqACoAKgAqACoAKgBcACoAKgAqACoAKgAqACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAUABQAFAAUABQAFAAUAArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4ADQANAA0ADQAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAHgAeAB4AHgBQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwANAA0ADQANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwBQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsABAAEAAQAHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAABABQAFAAUABQAAQABAAEAFAAUAAEAAQABAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAKwBQACsAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAKwArAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAKwAeAB4AHgAeAB4AHgAeAA4AHgArAA0ADQANAA0ADQANAA0ACQANAA0ADQAIAAQACwAEAAQADQAJAA0ADQAMAB0AHQAeABcAFwAWABcAFwAXABYAFwAdAB0AHgAeABQAFAAUAA0AAQABAAQABAAEAAQABAAJABoAGgAaABoAGgAaABoAGgAeABcAFwAdABUAFQAeAB4AHgAeAB4AHgAYABYAEQAVABUAFQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgANAB4ADQANAA0ADQAeAA0ADQANAAcAHgAeAB4AHgArAAQABAAEAAQABAAEAAQABAAEAAQAUABQACsAKwBPAFAAUABQAFAAUAAeAB4AHgAWABEATwBQAE8ATwBPAE8AUABQAFAAUABQAB4AHgAeABYAEQArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGgAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgBQABoAHgAdAB4AUAAeABoAHgAeAB4AHgAeAB4AHgAeAB4ATwAeAFAAGwAeAB4AUABQAFAAUABQAB4AHgAeAB0AHQAeAFAAHgBQAB4AUAAeAFAATwBQAFAAHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AUABQAFAAUABPAE8AUABQAFAAUABQAE8AUABQAE8AUABPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAE8ATwBPAE8ATwBPAE8ATwBPAE8AUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAATwAeAB4AKwArACsAKwAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB0AHQAeAB4AHgAdAB0AHgAeAB0AHgAeAB4AHQAeAB0AGwAbAB4AHQAeAB4AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB0AHgAdAB4AHQAdAB0AHQAdAB0AHgAdAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAdAB0AHQAdAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAlACUAHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB0AHQAeAB4AHgAeAB0AHQAdAB4AHgAdAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB0AHQAeAB4AHQAeAB4AHgAeAB0AHQAeAB4AHgAeACUAJQAdAB0AJQAeACUAJQAlACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHQAdAB0AHgAdACUAHQAdAB4AHQAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHQAdAB0AHQAlAB4AJQAlACUAHQAlACUAHQAdAB0AJQAlAB0AHQAlAB0AHQAlACUAJQAeAB0AHgAeAB4AHgAdAB0AJQAdAB0AHQAdAB0AHQAlACUAJQAlACUAHQAlACUAIAAlAB0AHQAlACUAJQAlACUAJQAlACUAHgAeAB4AJQAlACAAIAAgACAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeABcAFwAXABcAFwAXAB4AEwATACUAHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACUAJQBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwArACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAE8ATwBPAE8ATwBPAE8ATwAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeACsAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUAArACsAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQBQAFAAUABQACsAKwArACsAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAABAAEAAQAKwAEAAQAKwArACsAKwArAAQABAAEAAQAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsABAAEAAQAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsADQANAA0ADQANAA0ADQANAB4AKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAUABQAFAAUABQAA0ADQANAA0ADQANABQAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwANAA0ADQANAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAeAAQABAAEAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLACsADQArAB4AKwArAAQABAAEAAQAUABQAB4AUAArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwAEAAQABAAEAAQABAAEAAQABAAOAA0ADQATABMAHgAeAB4ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AUABQAFAAUAAEAAQAKwArAAQADQANAB4AUAArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXABcAA0ADQANACoASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUAArACsAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANACsADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEcARwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwAeAAQABAANAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAEAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUAArACsAUAArACsAUABQACsAKwBQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAeAB4ADQANAA0ADQAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAArAAQABAArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAEAAQABAAEAAQABAAEACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAFgAWAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAKwBQACsAKwArACsAKwArAFAAKwArACsAKwBQACsAUAArAFAAKwBQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQACsAUAArAFAAKwBQACsAUABQACsAUAArACsAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAUABQAFAAUAArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUAArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAlACUAJQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeACUAJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeACUAJQAlACUAJQAeACUAJQAlACUAJQAgACAAIAAlACUAIAAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIQAhACEAIQAhACUAJQAgACAAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAIAAlACUAJQAlACAAJQAgACAAIAAgACAAIAAgACAAIAAlACUAJQAgACUAJQAlACUAIAAgACAAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeACUAHgAlAB4AJQAlACUAJQAlACAAJQAlACUAJQAeACUAHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAIAAgACAAIAAgAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFwAXABcAFQAVABUAHgAeAB4AHgAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAlACAAIAAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsA';\n","/* @flow */\n'use strict';\n\nimport {createTrieFromBase64} from './Trie';\nimport {base64} from './linebreak-trie';\nimport {fromCodePoint, toCodePoints} from './Util';\n\nexport const LETTER_NUMBER_MODIFIER = 50;\n\n// Non-tailorable Line Breaking Classes\nconst BK = 1; //  Cause a line break (after)\nconst CR = 2; //  Cause a line break (after), except between CR and LF\nconst LF = 3; //  Cause a line break (after)\nconst CM = 4; //  Prohibit a line break between the character and the preceding character\nconst NL = 5; //  Cause a line break (after)\nconst SG = 6; //  Do not occur in well-formed text\nconst WJ = 7; //  Prohibit line breaks before and after\nconst ZW = 8; //  Provide a break opportunity\nconst GL = 9; //  Prohibit line breaks before and after\nconst SP = 10; // Enable indirect line breaks\nconst ZWJ = 11; // Prohibit line breaks within joiner sequences\n// Break Opportunities\nconst B2 = 12; //  Provide a line break opportunity before and after the character\nconst BA = 13; //  Generally provide a line break opportunity after the character\nconst BB = 14; //  Generally provide a line break opportunity before the character\nconst HY = 15; //  Provide a line break opportunity after the character, except in numeric context\nconst CB = 16; //   Provide a line break opportunity contingent on additional information\n// Characters Prohibiting Certain Breaks\nconst CL = 17; //  Prohibit line breaks before\nconst CP = 18; //  Prohibit line breaks before\nconst EX = 19; //  Prohibit line breaks before\nconst IN = 20; //  Allow only indirect line breaks between pairs\nconst NS = 21; //  Allow only indirect line breaks before\nconst OP = 22; //  Prohibit line breaks after\nconst QU = 23; //  Act like they are both opening and closing\n// Numeric Context\nconst IS = 24; //  Prevent breaks after any and before numeric\nconst NU = 25; //  Form numeric expressions for line breaking purposes\nconst PO = 26; //  Do not break following a numeric expression\nconst PR = 27; //  Do not break in front of a numeric expression\nconst SY = 28; //  Prevent a break before; and allow a break after\n// Other Characters\nconst AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID\nconst AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters\nconst CJ = 31; //  Treat as NS or ID for strict or normal breaking.\nconst EB = 32; //  Do not break from following Emoji Modifier\nconst EM = 33; //  Do not break from preceding Emoji Base\nconst H2 = 34; //  Form Korean syllable blocks\nconst H3 = 35; //  Form Korean syllable blocks\nconst HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic\nconst ID = 37; //  Break before or after; except in some numeric context\nconst JL = 38; //  Form Korean syllable blocks\nconst JV = 39; //  Form Korean syllable blocks\nconst JT = 40; //  Form Korean syllable blocks\nconst RI = 41; //  Keep pairs together. For pairs; break before and after other classes\nconst SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis\nconst XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions\n\nexport const classes: {[key: string]: number} = {\n    BK,\n    CR,\n    LF,\n    CM,\n    NL,\n    SG,\n    WJ,\n    ZW,\n    GL,\n    SP,\n    ZWJ,\n    B2,\n    BA,\n    BB,\n    HY,\n    CB,\n    CL,\n    CP,\n    EX,\n    IN,\n    NS,\n    OP,\n    QU,\n    IS,\n    NU,\n    PO,\n    PR,\n    SY,\n    AI,\n    AL,\n    CJ,\n    EB,\n    EM,\n    H2,\n    H3,\n    HL,\n    ID,\n    JL,\n    JV,\n    JT,\n    RI,\n    SA,\n    XX,\n};\n\nexport const BREAK_MANDATORY = '!';\nexport const BREAK_NOT_ALLOWED = '';\nexport const BREAK_ALLOWED = '';\nexport const UnicodeTrie = createTrieFromBase64(base64);\n\nconst ALPHABETICS = [AL, HL];\nconst HARD_LINE_BREAKS = [BK, CR, LF, NL];\nconst SPACE = [SP, ZW];\nconst PREFIX_POSTFIX = [PR, PO];\nconst LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);\nconst KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];\nconst HYPHEN = [HY, BA];\n\nexport const codePointsToCharacterClasses = (\n    codePoints: number[],\n    lineBreak: string = 'strict'\n): [number[], number[], boolean[]] => {\n    const types: number[] = [];\n    const indicies: number[] = [];\n    const categories: boolean[] = [];\n    codePoints.forEach((codePoint, index) => {\n        let classType = UnicodeTrie.get(codePoint);\n        if (classType > LETTER_NUMBER_MODIFIER) {\n            categories.push(true);\n            classType -= LETTER_NUMBER_MODIFIER;\n        } else {\n            categories.push(false);\n        }\n\n        if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {\n            // U+2010,  U+2013,  U+301C,  U+30A0\n            if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {\n                indicies.push(index);\n                return types.push(CB);\n            }\n        }\n\n        if (classType === CM || classType === ZWJ) {\n            // LB10 Treat any remaining combining mark or ZWJ as AL.\n            if (index === 0) {\n                indicies.push(index);\n                return types.push(AL);\n            }\n\n            // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of\n            // the base character in all of the following rules. Treat ZWJ as if it were CM.\n            const prev = types[index - 1];\n            if (LINE_BREAKS.indexOf(prev) === -1) {\n                indicies.push(indicies[index - 1]);\n                return types.push(prev);\n            }\n            indicies.push(index);\n            return types.push(AL);\n        }\n\n        indicies.push(index);\n\n        if (classType === CJ) {\n            return types.push(lineBreak === 'strict' ? NS : ID);\n        }\n\n        if (classType === SA) {\n            return types.push(AL);\n        }\n\n        if (classType === AI) {\n            return types.push(AL);\n        }\n\n        // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL\n        // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised\n        // to take into account the actual line breaking properties for these characters.\n        if (classType === XX) {\n            if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {\n                return types.push(ID);\n            } else {\n                return types.push(AL);\n            }\n        }\n\n        types.push(classType);\n    });\n\n    return [indicies, types, categories];\n};\n\nconst isAdjacentWithSpaceIgnored = (\n    a: number[] | number,\n    b: number,\n    currentIndex: number,\n    classTypes: number[]\n): boolean => {\n    const current = classTypes[currentIndex];\n    if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {\n        let i = currentIndex;\n        while (i <= classTypes.length) {\n            i++;\n            let next = classTypes[i];\n\n            if (next === b) {\n                return true;\n            }\n\n            if (next !== SP) {\n                break;\n            }\n        }\n    }\n\n    if (current === SP) {\n        let i = currentIndex;\n\n        while (i > 0) {\n            i--;\n            const prev = classTypes[i];\n\n            if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {\n                let n = currentIndex;\n                while (n <= classTypes.length) {\n                    n++;\n                    let next = classTypes[n];\n\n                    if (next === b) {\n                        return true;\n                    }\n\n                    if (next !== SP) {\n                        break;\n                    }\n                }\n            }\n\n            if (prev !== SP) {\n                break;\n            }\n        }\n    }\n    return false;\n};\n\nconst previousNonSpaceClassType = (currentIndex: number, classTypes: number[]): number => {\n    let i = currentIndex;\n    while (i >= 0) {\n        let type = classTypes[i];\n        if (type === SP) {\n            i--;\n        } else {\n            return type;\n        }\n    }\n    return 0;\n};\n\nconst _lineBreakAtIndex = (\n    codePoints: number[],\n    classTypes: number[],\n    indicies: number[],\n    index: number,\n    forbiddenBreaks?: boolean[]\n) => {\n    if (indicies[index] === 0) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    let currentIndex = index - 1;\n    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    let beforeIndex = currentIndex - 1;\n    let afterIndex = currentIndex + 1;\n    let current = classTypes[currentIndex];\n\n    // LB4 Always break after hard line breaks.\n    // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.\n    let before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;\n    let next = classTypes[afterIndex];\n\n    if (current === CR && next === LF) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {\n        return BREAK_MANDATORY;\n    }\n\n    // LB6 Do not break before hard line breaks.\n    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB7 Do not break before spaces or zero width space.\n    if (SPACE.indexOf(next) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.\n    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {\n        return BREAK_ALLOWED;\n    }\n\n    // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.\n    if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB11 Do not break before or after Word joiner and related characters.\n    if (current === WJ || next === WJ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB12 Do not break after NBSP and related characters.\n    if (current === GL) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.\n    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB13 Do not break before ] or ! or ; or /, even after spaces.\n    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB14 Do not break after [, even after spaces.\n    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB15 Do not break within [, even with intervening spaces.\n    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.\n    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB17 Do not break within , even with intervening spaces.\n    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB18 Break after spaces.\n    if (current === SP) {\n        return BREAK_ALLOWED;\n    }\n\n    // LB19 Do not break before or after quotation marks, such as   .\n    if (current === QU || next === QU) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB20 Break before and after unresolved CB.\n    if (next === CB || current === CB) {\n        return BREAK_ALLOWED;\n    }\n\n    // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.\n    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB21a Don't break after Hebrew + Hyphen.\n    if (before === HL && HYPHEN.indexOf(current) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB21b Dont break between Solidus and Hebrew letters.\n    if (current === SY && next === HL) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.\n    if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB23 Do not break between digits and letters.\n    if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.\n    if (\n        (current === PR && [ID, EB, EM].indexOf(next) !== -1) ||\n        ([ID, EB, EM].indexOf(current) !== -1 && next === PO)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.\n    if (\n        (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||\n        (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB25 Do not break between the following pairs of classes relevant to numbers:\n    if (\n        // (PR | PO)  ( OP | HY )? NU\n        ([PR, PO].indexOf(current) !== -1 &&\n            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||\n        // ( OP | HY )  NU\n        ([OP, HY].indexOf(current) !== -1 && next === NU) ||\n        // NU \t(NU | SY | IS)\n        (current === NU && [NU, SY, IS].indexOf(next) !== -1)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)\n    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {\n        let prevIndex = currentIndex;\n        while (prevIndex >= 0) {\n            let type = classTypes[prevIndex];\n            if (type === NU) {\n                return BREAK_NOT_ALLOWED;\n            } else if ([SY, IS].indexOf(type) !== -1) {\n                prevIndex--;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // NU (NU | SY | IS)* (CL | CP)?  (PO | PR))\n    if ([PR, PO].indexOf(next) !== -1) {\n        let prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;\n        while (prevIndex >= 0) {\n            let type = classTypes[prevIndex];\n            if (type === NU) {\n                return BREAK_NOT_ALLOWED;\n            } else if ([SY, IS].indexOf(type) !== -1) {\n                prevIndex--;\n            } else {\n                break;\n            }\n        }\n    }\n\n    // LB26 Do not break a Korean syllable.\n    if (\n        (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||\n        ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||\n        ([JT, H3].indexOf(current) !== -1 && next === JT)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB27 Treat a Korean Syllable Block the same as ID.\n    if (\n        (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||\n        (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB28 Do not break between alphabetics (at).\n    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB29 Do not break between numeric punctuation and alphabetics (e.g.).\n    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.\n    if (\n        (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP) ||\n        (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)\n    ) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB30a Break between two regional indicator symbols if and only if there are an even number of regional\n    // indicators preceding the position of the break.\n    if (current === RI && next === RI) {\n        let i = indicies[currentIndex];\n        let count = 1;\n        while (i > 0) {\n            i--;\n            if (classTypes[i] === RI) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        if (count % 2 !== 0) {\n            return BREAK_NOT_ALLOWED;\n        }\n    }\n\n    // LB30b Do not break between an emoji base and an emoji modifier.\n    if (current === EB && next === EM) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    return BREAK_ALLOWED;\n};\n\nexport const lineBreakAtIndex = (codePoints: number[], index: number) => {\n    // LB2 Never break at the start of text.\n    if (index === 0) {\n        return BREAK_NOT_ALLOWED;\n    }\n\n    // LB3 Always break at the end of text.\n    if (index >= codePoints.length) {\n        return BREAK_MANDATORY;\n    }\n\n    const [indicies, classTypes] = codePointsToCharacterClasses(codePoints);\n\n    return _lineBreakAtIndex(codePoints, classTypes, indicies, index);\n};\n\nexport type LINE_BREAK = 'auto' | 'normal' | 'strict';\nexport type WORD_BREAK = 'normal' | 'break-all' | 'break-word' | 'keep-all';\n\ninterface IOptions {\n    lineBreak?: LINE_BREAK;\n    wordBreak?: WORD_BREAK;\n}\n\nconst cssFormattedClasses = (\n    codePoints: number[],\n    options?: IOptions\n): [number[], number[], boolean[] | undefined] => {\n    if (!options) {\n        options = {lineBreak: 'normal', wordBreak: 'normal'};\n    }\n    let [indicies, classTypes, isLetterNumber] = codePointsToCharacterClasses(codePoints, options.lineBreak);\n\n    if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {\n        classTypes = classTypes.map(type => ([NU, AL, SA].indexOf(type) !== -1 ? ID : type));\n    }\n\n    const forbiddenBreakpoints =\n        options.wordBreak === 'keep-all'\n            ? isLetterNumber.map((letterNumber, i) => {\n                  return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;\n              })\n            : undefined;\n\n    return [indicies, classTypes, forbiddenBreakpoints];\n};\n\nexport const inlineBreakOpportunities = (str: string, options?: IOptions): string => {\n    const codePoints = toCodePoints(str);\n    let output = BREAK_NOT_ALLOWED;\n    const [indicies, classTypes, forbiddenBreakpoints] = cssFormattedClasses(codePoints, options);\n\n    codePoints.forEach((codePoint, i) => {\n        output +=\n            fromCodePoint(codePoint) +\n            (i >= codePoints.length - 1\n                ? BREAK_MANDATORY\n                : _lineBreakAtIndex(codePoints, classTypes, indicies, i + 1, forbiddenBreakpoints));\n    });\n\n    return output;\n};\n\nclass Break {\n    private readonly codePoints: number[];\n    readonly required: boolean;\n    readonly start: number;\n    readonly end: number;\n\n    constructor(codePoints: number[], lineBreak: string, start: number, end: number) {\n        this.codePoints = codePoints;\n        this.required = lineBreak === BREAK_MANDATORY;\n        this.start = start;\n        this.end = end;\n    }\n\n    slice(): string {\n        return fromCodePoint(...this.codePoints.slice(this.start, this.end));\n    }\n}\n\nexport type LineBreak =\n    | {\n          done: true;\n          value: null;\n      }\n    | {\n          done: false;\n          value: Break;\n      };\n\ninterface ILineBreakIterator {\n    next: () => LineBreak;\n}\n\nexport const LineBreaker = (str: string, options?: IOptions): ILineBreakIterator => {\n    const codePoints = toCodePoints(str);\n    const [indicies, classTypes, forbiddenBreakpoints] = cssFormattedClasses(codePoints, options);\n    const length = codePoints.length;\n    let lastEnd = 0;\n    let nextIndex = 0;\n\n    return {\n        next: () => {\n            if (nextIndex >= length) {\n                return {done: true, value: null};\n            }\n            let lineBreak = BREAK_NOT_ALLOWED;\n            while (\n                nextIndex < length &&\n                (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===\n                    BREAK_NOT_ALLOWED\n            ) {}\n\n            if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {\n                const value = new Break(codePoints, lineBreak, lastEnd, nextIndex);\n                lastEnd = nextIndex;\n                return {value, done: false};\n            }\n\n            return {done: true, value: null};\n        },\n    };\n};\n","// https://www.w3.org/TR/css-syntax-3\n\nimport {fromCodePoint, toCodePoints} from 'css-line-break';\n\nexport enum TokenType {\n    STRING_TOKEN,\n    BAD_STRING_TOKEN,\n    LEFT_PARENTHESIS_TOKEN,\n    RIGHT_PARENTHESIS_TOKEN,\n    COMMA_TOKEN,\n    HASH_TOKEN,\n    DELIM_TOKEN,\n    AT_KEYWORD_TOKEN,\n    PREFIX_MATCH_TOKEN,\n    DASH_MATCH_TOKEN,\n    INCLUDE_MATCH_TOKEN,\n    LEFT_CURLY_BRACKET_TOKEN,\n    RIGHT_CURLY_BRACKET_TOKEN,\n    SUFFIX_MATCH_TOKEN,\n    SUBSTRING_MATCH_TOKEN,\n    DIMENSION_TOKEN,\n    PERCENTAGE_TOKEN,\n    NUMBER_TOKEN,\n    FUNCTION,\n    FUNCTION_TOKEN,\n    IDENT_TOKEN,\n    COLUMN_TOKEN,\n    URL_TOKEN,\n    BAD_URL_TOKEN,\n    CDC_TOKEN,\n    CDO_TOKEN,\n    COLON_TOKEN,\n    SEMICOLON_TOKEN,\n    LEFT_SQUARE_BRACKET_TOKEN,\n    RIGHT_SQUARE_BRACKET_TOKEN,\n    UNICODE_RANGE_TOKEN,\n    WHITESPACE_TOKEN,\n    EOF_TOKEN\n}\n\ninterface IToken {\n    type: TokenType;\n}\n\nexport interface Token extends IToken {\n    type:\n        | TokenType.BAD_URL_TOKEN\n        | TokenType.BAD_STRING_TOKEN\n        | TokenType.LEFT_PARENTHESIS_TOKEN\n        | TokenType.RIGHT_PARENTHESIS_TOKEN\n        | TokenType.COMMA_TOKEN\n        | TokenType.SUBSTRING_MATCH_TOKEN\n        | TokenType.PREFIX_MATCH_TOKEN\n        | TokenType.SUFFIX_MATCH_TOKEN\n        | TokenType.COLON_TOKEN\n        | TokenType.SEMICOLON_TOKEN\n        | TokenType.LEFT_SQUARE_BRACKET_TOKEN\n        | TokenType.RIGHT_SQUARE_BRACKET_TOKEN\n        | TokenType.LEFT_CURLY_BRACKET_TOKEN\n        | TokenType.RIGHT_CURLY_BRACKET_TOKEN\n        | TokenType.DASH_MATCH_TOKEN\n        | TokenType.INCLUDE_MATCH_TOKEN\n        | TokenType.COLUMN_TOKEN\n        | TokenType.WHITESPACE_TOKEN\n        | TokenType.CDC_TOKEN\n        | TokenType.CDO_TOKEN\n        | TokenType.EOF_TOKEN;\n}\n\nexport interface StringValueToken extends IToken {\n    type:\n        | TokenType.STRING_TOKEN\n        | TokenType.DELIM_TOKEN\n        | TokenType.FUNCTION_TOKEN\n        | TokenType.IDENT_TOKEN\n        | TokenType.URL_TOKEN\n        | TokenType.AT_KEYWORD_TOKEN;\n    value: string;\n}\n\nexport interface HashToken extends IToken {\n    type: TokenType.HASH_TOKEN;\n    flags: number;\n    value: string;\n}\n\nexport interface NumberValueToken extends IToken {\n    type: TokenType.PERCENTAGE_TOKEN | TokenType.NUMBER_TOKEN;\n    flags: number;\n    number: number;\n}\n\nexport interface DimensionToken extends IToken {\n    type: TokenType.DIMENSION_TOKEN;\n    flags: number;\n    unit: string;\n    number: number;\n}\n\nexport interface UnicodeRangeToken extends IToken {\n    type: TokenType.UNICODE_RANGE_TOKEN;\n    start: number;\n    end: number;\n}\n\nexport type CSSToken = Token | StringValueToken | NumberValueToken | DimensionToken | UnicodeRangeToken | HashToken;\n\nexport const FLAG_UNRESTRICTED = 1 << 0;\nexport const FLAG_ID = 1 << 1;\nexport const FLAG_INTEGER = 1 << 2;\nexport const FLAG_NUMBER = 1 << 3;\n\nconst LINE_FEED = 0x000a;\nconst SOLIDUS = 0x002f;\nconst REVERSE_SOLIDUS = 0x005c;\nconst CHARACTER_TABULATION = 0x0009;\nconst SPACE = 0x0020;\nconst QUOTATION_MARK = 0x0022;\nconst EQUALS_SIGN = 0x003d;\nconst NUMBER_SIGN = 0x0023;\nconst DOLLAR_SIGN = 0x0024;\nconst PERCENTAGE_SIGN = 0x0025;\nconst APOSTROPHE = 0x0027;\nconst LEFT_PARENTHESIS = 0x0028;\nconst RIGHT_PARENTHESIS = 0x0029;\nconst LOW_LINE = 0x005f;\nconst HYPHEN_MINUS = 0x002d;\nconst EXCLAMATION_MARK = 0x0021;\nconst LESS_THAN_SIGN = 0x003c;\nconst GREATER_THAN_SIGN = 0x003e;\nconst COMMERCIAL_AT = 0x0040;\nconst LEFT_SQUARE_BRACKET = 0x005b;\nconst RIGHT_SQUARE_BRACKET = 0x005d;\nconst CIRCUMFLEX_ACCENT = 0x003d;\nconst LEFT_CURLY_BRACKET = 0x007b;\nconst QUESTION_MARK = 0x003f;\nconst RIGHT_CURLY_BRACKET = 0x007d;\nconst VERTICAL_LINE = 0x007c;\nconst TILDE = 0x007e;\nconst CONTROL = 0x0080;\nconst REPLACEMENT_CHARACTER = 0xfffd;\nconst ASTERISK = 0x002a;\nconst PLUS_SIGN = 0x002b;\nconst COMMA = 0x002c;\nconst COLON = 0x003a;\nconst SEMICOLON = 0x003b;\nconst FULL_STOP = 0x002e;\nconst NULL = 0x0000;\nconst BACKSPACE = 0x0008;\nconst LINE_TABULATION = 0x000b;\nconst SHIFT_OUT = 0x000e;\nconst INFORMATION_SEPARATOR_ONE = 0x001f;\nconst DELETE = 0x007f;\nconst EOF = -1;\nconst ZERO = 0x0030;\nconst a = 0x0061;\nconst e = 0x0065;\nconst f = 0x0066;\nconst u = 0x0075;\nconst z = 0x007a;\nconst A = 0x0041;\nconst E = 0x0045;\nconst F = 0x0046;\nconst U = 0x0055;\nconst Z = 0x005a;\n\nconst isDigit = (codePoint: number) => codePoint >= ZERO && codePoint <= 0x0039;\nconst isSurrogateCodePoint = (codePoint: number) => codePoint >= 0xd800 && codePoint <= 0xdfff;\nconst isHex = (codePoint: number) =>\n    isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);\nconst isLowerCaseLetter = (codePoint: number) => codePoint >= a && codePoint <= z;\nconst isUpperCaseLetter = (codePoint: number) => codePoint >= A && codePoint <= Z;\nconst isLetter = (codePoint: number) => isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);\nconst isNonASCIICodePoint = (codePoint: number) => codePoint >= CONTROL;\nconst isWhiteSpace = (codePoint: number): boolean =>\n    codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;\nconst isNameStartCodePoint = (codePoint: number): boolean =>\n    isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;\nconst isNameCodePoint = (codePoint: number): boolean =>\n    isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;\nconst isNonPrintableCodePoint = (codePoint: number): boolean => {\n    return (\n        (codePoint >= NULL && codePoint <= BACKSPACE) ||\n        codePoint === LINE_TABULATION ||\n        (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||\n        codePoint === DELETE\n    );\n};\nconst isValidEscape = (c1: number, c2: number): boolean => {\n    if (c1 !== REVERSE_SOLIDUS) {\n        return false;\n    }\n\n    return c2 !== LINE_FEED;\n};\nconst isIdentifierStart = (c1: number, c2: number, c3: number): boolean => {\n    if (c1 === HYPHEN_MINUS) {\n        return isNameStartCodePoint(c2) || isValidEscape(c2, c3);\n    } else if (isNameStartCodePoint(c1)) {\n        return true;\n    } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {\n        return true;\n    }\n    return false;\n};\n\nconst isNumberStart = (c1: number, c2: number, c3: number): boolean => {\n    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n        if (isDigit(c2)) {\n            return true;\n        }\n\n        return c2 === FULL_STOP && isDigit(c3);\n    }\n\n    if (c1 === FULL_STOP) {\n        return isDigit(c2);\n    }\n\n    return isDigit(c1);\n};\n\nconst stringToNumber = (codePoints: number[]): number => {\n    let c = 0;\n    let sign = 1;\n    if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {\n        if (codePoints[c] === HYPHEN_MINUS) {\n            sign = -1;\n        }\n        c++;\n    }\n\n    const integers = [];\n\n    while (isDigit(codePoints[c])) {\n        integers.push(codePoints[c++]);\n    }\n\n    const int = integers.length ? parseInt(fromCodePoint(...integers), 10) : 0;\n\n    if (codePoints[c] === FULL_STOP) {\n        c++;\n    }\n\n    const fraction = [];\n    while (isDigit(codePoints[c])) {\n        fraction.push(codePoints[c++]);\n    }\n\n    const fracd = fraction.length;\n    const frac = fracd ? parseInt(fromCodePoint(...fraction), 10) : 0;\n\n    if (codePoints[c] === E || codePoints[c] === e) {\n        c++;\n    }\n\n    let expsign = 1;\n\n    if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {\n        if (codePoints[c] === HYPHEN_MINUS) {\n            expsign = -1;\n        }\n        c++;\n    }\n\n    const exponent = [];\n\n    while (isDigit(codePoints[c])) {\n        exponent.push(codePoints[c++]);\n    }\n\n    const exp = exponent.length ? parseInt(fromCodePoint(...exponent), 10) : 0;\n\n    return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);\n};\n\nconst LEFT_PARENTHESIS_TOKEN: Token = {\n    type: TokenType.LEFT_PARENTHESIS_TOKEN\n};\nconst RIGHT_PARENTHESIS_TOKEN: Token = {\n    type: TokenType.RIGHT_PARENTHESIS_TOKEN\n};\nconst COMMA_TOKEN: Token = {type: TokenType.COMMA_TOKEN};\nconst SUFFIX_MATCH_TOKEN: Token = {type: TokenType.SUFFIX_MATCH_TOKEN};\nconst PREFIX_MATCH_TOKEN: Token = {type: TokenType.PREFIX_MATCH_TOKEN};\nconst COLUMN_TOKEN: Token = {type: TokenType.COLUMN_TOKEN};\nconst DASH_MATCH_TOKEN: Token = {type: TokenType.DASH_MATCH_TOKEN};\nconst INCLUDE_MATCH_TOKEN: Token = {type: TokenType.INCLUDE_MATCH_TOKEN};\nconst LEFT_CURLY_BRACKET_TOKEN: Token = {\n    type: TokenType.LEFT_CURLY_BRACKET_TOKEN\n};\nconst RIGHT_CURLY_BRACKET_TOKEN: Token = {\n    type: TokenType.RIGHT_CURLY_BRACKET_TOKEN\n};\nconst SUBSTRING_MATCH_TOKEN: Token = {type: TokenType.SUBSTRING_MATCH_TOKEN};\nconst BAD_URL_TOKEN: Token = {type: TokenType.BAD_URL_TOKEN};\nconst BAD_STRING_TOKEN: Token = {type: TokenType.BAD_STRING_TOKEN};\nconst CDO_TOKEN: Token = {type: TokenType.CDO_TOKEN};\nconst CDC_TOKEN: Token = {type: TokenType.CDC_TOKEN};\nconst COLON_TOKEN: Token = {type: TokenType.COLON_TOKEN};\nconst SEMICOLON_TOKEN: Token = {type: TokenType.SEMICOLON_TOKEN};\nconst LEFT_SQUARE_BRACKET_TOKEN: Token = {\n    type: TokenType.LEFT_SQUARE_BRACKET_TOKEN\n};\nconst RIGHT_SQUARE_BRACKET_TOKEN: Token = {\n    type: TokenType.RIGHT_SQUARE_BRACKET_TOKEN\n};\nconst WHITESPACE_TOKEN: Token = {type: TokenType.WHITESPACE_TOKEN};\nexport const EOF_TOKEN: Token = {type: TokenType.EOF_TOKEN};\n\nexport class Tokenizer {\n    private _value: number[];\n\n    constructor() {\n        this._value = [];\n    }\n\n    write(chunk: string) {\n        this._value = this._value.concat(toCodePoints(chunk));\n    }\n\n    read(): CSSToken[] {\n        const tokens = [];\n        let token = this.consumeToken();\n        while (token !== EOF_TOKEN) {\n            tokens.push(token);\n            token = this.consumeToken();\n        }\n        return tokens;\n    }\n\n    private consumeToken(): CSSToken {\n        const codePoint = this.consumeCodePoint();\n\n        switch (codePoint) {\n            case QUOTATION_MARK:\n                return this.consumeStringToken(QUOTATION_MARK);\n            case NUMBER_SIGN:\n                const c1 = this.peekCodePoint(0);\n                const c2 = this.peekCodePoint(1);\n                const c3 = this.peekCodePoint(2);\n                if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {\n                    const flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;\n                    const value = this.consumeName();\n\n                    return {type: TokenType.HASH_TOKEN, value, flags};\n                }\n                break;\n            case DOLLAR_SIGN:\n                if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                    this.consumeCodePoint();\n                    return SUFFIX_MATCH_TOKEN;\n                }\n                break;\n            case APOSTROPHE:\n                return this.consumeStringToken(APOSTROPHE);\n            case LEFT_PARENTHESIS:\n                return LEFT_PARENTHESIS_TOKEN;\n            case RIGHT_PARENTHESIS:\n                return RIGHT_PARENTHESIS_TOKEN;\n            case ASTERISK:\n                if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                    this.consumeCodePoint();\n                    return SUBSTRING_MATCH_TOKEN;\n                }\n                break;\n            case PLUS_SIGN:\n                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeNumericToken();\n                }\n                break;\n            case COMMA:\n                return COMMA_TOKEN;\n            case HYPHEN_MINUS:\n                const e1 = codePoint;\n                const e2 = this.peekCodePoint(0);\n                const e3 = this.peekCodePoint(1);\n\n                if (isNumberStart(e1, e2, e3)) {\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeNumericToken();\n                }\n\n                if (isIdentifierStart(e1, e2, e3)) {\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeIdentLikeToken();\n                }\n\n                if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {\n                    this.consumeCodePoint();\n                    this.consumeCodePoint();\n                    return CDC_TOKEN;\n                }\n                break;\n\n            case FULL_STOP:\n                if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeNumericToken();\n                }\n                break;\n            case SOLIDUS:\n                if (this.peekCodePoint(0) === ASTERISK) {\n                    this.consumeCodePoint();\n                    while (true) {\n                        let c = this.consumeCodePoint();\n                        if (c === ASTERISK) {\n                            c = this.consumeCodePoint();\n                            if (c === SOLIDUS) {\n                                return this.consumeToken();\n                            }\n                        }\n                        if (c === EOF) {\n                            return this.consumeToken();\n                        }\n                    }\n                }\n                break;\n            case COLON:\n                return COLON_TOKEN;\n            case SEMICOLON:\n                return SEMICOLON_TOKEN;\n            case LESS_THAN_SIGN:\n                if (\n                    this.peekCodePoint(0) === EXCLAMATION_MARK &&\n                    this.peekCodePoint(1) === HYPHEN_MINUS &&\n                    this.peekCodePoint(2) === HYPHEN_MINUS\n                ) {\n                    this.consumeCodePoint();\n                    this.consumeCodePoint();\n                    return CDO_TOKEN;\n                }\n                break;\n            case COMMERCIAL_AT:\n                const a1 = this.peekCodePoint(0);\n                const a2 = this.peekCodePoint(1);\n                const a3 = this.peekCodePoint(2);\n                if (isIdentifierStart(a1, a2, a3)) {\n                    const value = this.consumeName();\n                    return {type: TokenType.AT_KEYWORD_TOKEN, value};\n                }\n                break;\n            case LEFT_SQUARE_BRACKET:\n                return LEFT_SQUARE_BRACKET_TOKEN;\n            case REVERSE_SOLIDUS:\n                if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                    this.reconsumeCodePoint(codePoint);\n                    return this.consumeIdentLikeToken();\n                }\n                break;\n            case RIGHT_SQUARE_BRACKET:\n                return RIGHT_SQUARE_BRACKET_TOKEN;\n            case CIRCUMFLEX_ACCENT:\n                if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                    this.consumeCodePoint();\n                    return PREFIX_MATCH_TOKEN;\n                }\n                break;\n            case LEFT_CURLY_BRACKET:\n                return LEFT_CURLY_BRACKET_TOKEN;\n            case RIGHT_CURLY_BRACKET:\n                return RIGHT_CURLY_BRACKET_TOKEN;\n            case u:\n            case U:\n                const u1 = this.peekCodePoint(0);\n                const u2 = this.peekCodePoint(1);\n                if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {\n                    this.consumeCodePoint();\n                    this.consumeUnicodeRangeToken();\n                }\n                this.reconsumeCodePoint(codePoint);\n                return this.consumeIdentLikeToken();\n            case VERTICAL_LINE:\n                if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                    this.consumeCodePoint();\n                    return DASH_MATCH_TOKEN;\n                }\n                if (this.peekCodePoint(0) === VERTICAL_LINE) {\n                    this.consumeCodePoint();\n                    return COLUMN_TOKEN;\n                }\n                break;\n            case TILDE:\n                if (this.peekCodePoint(0) === EQUALS_SIGN) {\n                    this.consumeCodePoint();\n                    return INCLUDE_MATCH_TOKEN;\n                }\n                break;\n            case EOF:\n                return EOF_TOKEN;\n        }\n\n        if (isWhiteSpace(codePoint)) {\n            this.consumeWhiteSpace();\n            return WHITESPACE_TOKEN;\n        }\n\n        if (isDigit(codePoint)) {\n            this.reconsumeCodePoint(codePoint);\n            return this.consumeNumericToken();\n        }\n\n        if (isNameStartCodePoint(codePoint)) {\n            this.reconsumeCodePoint(codePoint);\n            return this.consumeIdentLikeToken();\n        }\n\n        return {type: TokenType.DELIM_TOKEN, value: fromCodePoint(codePoint)};\n    }\n\n    private consumeCodePoint(): number {\n        const value = this._value.shift();\n\n        return typeof value === 'undefined' ? -1 : value;\n    }\n\n    private reconsumeCodePoint(codePoint: number) {\n        this._value.unshift(codePoint);\n    }\n\n    private peekCodePoint(delta: number): number {\n        if (delta >= this._value.length) {\n            return -1;\n        }\n\n        return this._value[delta];\n    }\n\n    private consumeUnicodeRangeToken(): UnicodeRangeToken {\n        const digits = [];\n        let codePoint = this.consumeCodePoint();\n        while (isHex(codePoint) && digits.length < 6) {\n            digits.push(codePoint);\n            codePoint = this.consumeCodePoint();\n        }\n        let questionMarks = false;\n        while (codePoint === QUESTION_MARK && digits.length < 6) {\n            digits.push(codePoint);\n            codePoint = this.consumeCodePoint();\n            questionMarks = true;\n        }\n\n        if (questionMarks) {\n            const start = parseInt(fromCodePoint(...digits.map(digit => (digit === QUESTION_MARK ? ZERO : digit))), 16);\n            const end = parseInt(fromCodePoint(...digits.map(digit => (digit === QUESTION_MARK ? F : digit))), 16);\n            return {type: TokenType.UNICODE_RANGE_TOKEN, start, end};\n        }\n\n        const start = parseInt(fromCodePoint(...digits), 16);\n        if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {\n            this.consumeCodePoint();\n            codePoint = this.consumeCodePoint();\n            const endDigits = [];\n            while (isHex(codePoint) && endDigits.length < 6) {\n                endDigits.push(codePoint);\n                codePoint = this.consumeCodePoint();\n            }\n            const end = parseInt(fromCodePoint(...endDigits), 16);\n\n            return {type: TokenType.UNICODE_RANGE_TOKEN, start, end};\n        } else {\n            return {type: TokenType.UNICODE_RANGE_TOKEN, start, end: start};\n        }\n    }\n\n    private consumeIdentLikeToken(): StringValueToken | Token {\n        const value = this.consumeName();\n        if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n            this.consumeCodePoint();\n            return this.consumeUrlToken();\n        } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {\n            this.consumeCodePoint();\n            return {type: TokenType.FUNCTION_TOKEN, value};\n        }\n\n        return {type: TokenType.IDENT_TOKEN, value};\n    }\n\n    private consumeUrlToken(): StringValueToken | Token {\n        const value = [];\n        this.consumeWhiteSpace();\n\n        if (this.peekCodePoint(0) === EOF) {\n            return {type: TokenType.URL_TOKEN, value: ''};\n        }\n\n        const next = this.peekCodePoint(0);\n        if (next === APOSTROPHE || next === QUOTATION_MARK) {\n            const stringToken = this.consumeStringToken(this.consumeCodePoint());\n            if (stringToken.type === TokenType.STRING_TOKEN) {\n                this.consumeWhiteSpace();\n\n                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n                    this.consumeCodePoint();\n                    return {type: TokenType.URL_TOKEN, value: stringToken.value};\n                }\n            }\n\n            this.consumeBadUrlRemnants();\n            return BAD_URL_TOKEN;\n        }\n\n        while (true) {\n            const codePoint = this.consumeCodePoint();\n            if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {\n                return {type: TokenType.URL_TOKEN, value: fromCodePoint(...value)};\n            } else if (isWhiteSpace(codePoint)) {\n                this.consumeWhiteSpace();\n                if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {\n                    this.consumeCodePoint();\n                    return {type: TokenType.URL_TOKEN, value: fromCodePoint(...value)};\n                }\n                this.consumeBadUrlRemnants();\n                return BAD_URL_TOKEN;\n            } else if (\n                codePoint === QUOTATION_MARK ||\n                codePoint === APOSTROPHE ||\n                codePoint === LEFT_PARENTHESIS ||\n                isNonPrintableCodePoint(codePoint)\n            ) {\n                this.consumeBadUrlRemnants();\n                return BAD_URL_TOKEN;\n            } else if (codePoint === REVERSE_SOLIDUS) {\n                if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                    value.push(this.consumeEscapedCodePoint());\n                } else {\n                    this.consumeBadUrlRemnants();\n                    return BAD_URL_TOKEN;\n                }\n            } else {\n                value.push(codePoint);\n            }\n        }\n    }\n\n    private consumeWhiteSpace(): void {\n        while (isWhiteSpace(this.peekCodePoint(0))) {\n            this.consumeCodePoint();\n        }\n    }\n\n    private consumeBadUrlRemnants(): void {\n        while (true) {\n            let codePoint = this.consumeCodePoint();\n            if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {\n                return;\n            }\n\n            if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                this.consumeEscapedCodePoint();\n            }\n        }\n    }\n\n    private consumeStringSlice(count: number): string {\n        const SLICE_STACK_SIZE = 60000;\n        let value = '';\n        while (count > 0) {\n            const amount = Math.min(SLICE_STACK_SIZE, count);\n            value += fromCodePoint(...this._value.splice(0, amount));\n            count -= amount;\n        }\n        this._value.shift();\n\n        return value;\n    }\n\n    private consumeStringToken(endingCodePoint: number): StringValueToken | Token {\n        let value = '';\n        let i = 0;\n\n        do {\n            const codePoint = this._value[i];\n            if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {\n                value += this.consumeStringSlice(i);\n                return {type: TokenType.STRING_TOKEN, value};\n            }\n\n            if (codePoint === LINE_FEED) {\n                this._value.splice(0, i);\n                return BAD_STRING_TOKEN;\n            }\n\n            if (codePoint === REVERSE_SOLIDUS) {\n                const next = this._value[i + 1];\n                if (next !== EOF && next !== undefined) {\n                    if (next === LINE_FEED) {\n                        value += this.consumeStringSlice(i);\n                        i = -1;\n                        this._value.shift();\n                    } else if (isValidEscape(codePoint, next)) {\n                        value += this.consumeStringSlice(i);\n                        value += fromCodePoint(this.consumeEscapedCodePoint());\n                        i = -1;\n                    }\n                }\n            }\n\n            i++;\n        } while (true);\n    }\n\n    private consumeNumber() {\n        let repr = [];\n        let type = FLAG_INTEGER;\n        let c1 = this.peekCodePoint(0);\n        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {\n            repr.push(this.consumeCodePoint());\n        }\n\n        while (isDigit(this.peekCodePoint(0))) {\n            repr.push(this.consumeCodePoint());\n        }\n        c1 = this.peekCodePoint(0);\n        let c2 = this.peekCodePoint(1);\n        if (c1 === FULL_STOP && isDigit(c2)) {\n            repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n            type = FLAG_NUMBER;\n            while (isDigit(this.peekCodePoint(0))) {\n                repr.push(this.consumeCodePoint());\n            }\n        }\n\n        c1 = this.peekCodePoint(0);\n        c2 = this.peekCodePoint(1);\n        let c3 = this.peekCodePoint(2);\n        if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {\n            repr.push(this.consumeCodePoint(), this.consumeCodePoint());\n            type = FLAG_NUMBER;\n            while (isDigit(this.peekCodePoint(0))) {\n                repr.push(this.consumeCodePoint());\n            }\n        }\n\n        return [stringToNumber(repr), type];\n    }\n\n    private consumeNumericToken(): NumberValueToken | DimensionToken {\n        const [number, flags] = this.consumeNumber();\n        const c1 = this.peekCodePoint(0);\n        const c2 = this.peekCodePoint(1);\n        const c3 = this.peekCodePoint(2);\n\n        if (isIdentifierStart(c1, c2, c3)) {\n            let unit = this.consumeName();\n            return {type: TokenType.DIMENSION_TOKEN, number, flags, unit};\n        }\n\n        if (c1 === PERCENTAGE_SIGN) {\n            this.consumeCodePoint();\n            return {type: TokenType.PERCENTAGE_TOKEN, number, flags};\n        }\n\n        return {type: TokenType.NUMBER_TOKEN, number, flags};\n    }\n\n    private consumeEscapedCodePoint(): number {\n        const codePoint = this.consumeCodePoint();\n\n        if (isHex(codePoint)) {\n            let hex = fromCodePoint(codePoint);\n            while (isHex(this.peekCodePoint(0)) && hex.length < 6) {\n                hex += fromCodePoint(this.consumeCodePoint());\n            }\n\n            if (isWhiteSpace(this.peekCodePoint(0))) {\n                this.consumeCodePoint();\n            }\n\n            const hexCodePoint = parseInt(hex, 16);\n\n            if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {\n                return REPLACEMENT_CHARACTER;\n            }\n\n            return hexCodePoint;\n        }\n\n        if (codePoint === EOF) {\n            return REPLACEMENT_CHARACTER;\n        }\n\n        return codePoint;\n    }\n\n    private consumeName(): string {\n        let result = '';\n        while (true) {\n            const codePoint = this.consumeCodePoint();\n            if (isNameCodePoint(codePoint)) {\n                result += fromCodePoint(codePoint);\n            } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {\n                result += fromCodePoint(this.consumeEscapedCodePoint());\n            } else {\n                this.reconsumeCodePoint(codePoint);\n                return result;\n            }\n        }\n    }\n}\n","import {\n    CSSToken,\n    DimensionToken,\n    EOF_TOKEN,\n    NumberValueToken,\n    StringValueToken,\n    Tokenizer,\n    TokenType\n} from './tokenizer';\n\nexport type CSSBlockType =\n    | TokenType.LEFT_PARENTHESIS_TOKEN\n    | TokenType.LEFT_SQUARE_BRACKET_TOKEN\n    | TokenType.LEFT_CURLY_BRACKET_TOKEN;\n\nexport interface CSSBlock {\n    type: CSSBlockType;\n    values: CSSValue[];\n}\n\nexport interface CSSFunction {\n    type: TokenType.FUNCTION;\n    name: string;\n    values: CSSValue[];\n}\n\nexport type CSSValue = CSSFunction | CSSToken | CSSBlock;\n\nexport class Parser {\n    private _tokens: CSSToken[];\n\n    constructor(tokens: CSSToken[]) {\n        this._tokens = tokens;\n    }\n\n    static create(value: string): Parser {\n        const tokenizer = new Tokenizer();\n        tokenizer.write(value);\n        return new Parser(tokenizer.read());\n    }\n\n    static parseValue(value: string): CSSValue {\n        return Parser.create(value).parseComponentValue();\n    }\n\n    static parseValues(value: string): CSSValue[] {\n        return Parser.create(value).parseComponentValues();\n    }\n\n    parseComponentValue(): CSSValue {\n        let token = this.consumeToken();\n        while (token.type === TokenType.WHITESPACE_TOKEN) {\n            token = this.consumeToken();\n        }\n\n        if (token.type === TokenType.EOF_TOKEN) {\n            throw new SyntaxError(`Error parsing CSS component value, unexpected EOF`);\n        }\n\n        this.reconsumeToken(token);\n        const value = this.consumeComponentValue();\n\n        do {\n            token = this.consumeToken();\n        } while (token.type === TokenType.WHITESPACE_TOKEN);\n\n        if (token.type === TokenType.EOF_TOKEN) {\n            return value;\n        }\n\n        throw new SyntaxError(`Error parsing CSS component value, multiple values found when expecting only one`);\n    }\n\n    parseComponentValues(): CSSValue[] {\n        const values = [];\n        while (true) {\n            let value = this.consumeComponentValue();\n            if (value.type === TokenType.EOF_TOKEN) {\n                return values;\n            }\n            values.push(value);\n            values.push();\n        }\n    }\n\n    private consumeComponentValue(): CSSValue {\n        const token = this.consumeToken();\n\n        switch (token.type) {\n            case TokenType.LEFT_CURLY_BRACKET_TOKEN:\n            case TokenType.LEFT_SQUARE_BRACKET_TOKEN:\n            case TokenType.LEFT_PARENTHESIS_TOKEN:\n                return this.consumeSimpleBlock(token.type);\n            case TokenType.FUNCTION_TOKEN:\n                return this.consumeFunction(token);\n        }\n\n        return token;\n    }\n\n    private consumeSimpleBlock(type: CSSBlockType): CSSBlock {\n        const block: CSSBlock = {type, values: []};\n\n        let token = this.consumeToken();\n        while (true) {\n            if (token.type === TokenType.EOF_TOKEN || isEndingTokenFor(token, type)) {\n                return block;\n            }\n\n            this.reconsumeToken(token);\n            block.values.push(this.consumeComponentValue());\n            token = this.consumeToken();\n        }\n    }\n\n    private consumeFunction(functionToken: StringValueToken): CSSFunction {\n        const cssFunction: CSSFunction = {\n            name: functionToken.value,\n            values: [],\n            type: TokenType.FUNCTION\n        };\n\n        while (true) {\n            const token = this.consumeToken();\n            if (token.type === TokenType.EOF_TOKEN || token.type === TokenType.RIGHT_PARENTHESIS_TOKEN) {\n                return cssFunction;\n            }\n\n            this.reconsumeToken(token);\n            cssFunction.values.push(this.consumeComponentValue());\n        }\n    }\n\n    private consumeToken(): CSSToken {\n        const token = this._tokens.shift();\n        return typeof token === 'undefined' ? EOF_TOKEN : token;\n    }\n\n    private reconsumeToken(token: CSSToken): void {\n        this._tokens.unshift(token);\n    }\n}\n\nexport const isDimensionToken = (token: CSSValue): token is DimensionToken => token.type === TokenType.DIMENSION_TOKEN;\nexport const isNumberToken = (token: CSSValue): token is NumberValueToken => token.type === TokenType.NUMBER_TOKEN;\nexport const isIdentToken = (token: CSSValue): token is StringValueToken => token.type === TokenType.IDENT_TOKEN;\nexport const isStringToken = (token: CSSValue): token is StringValueToken => token.type === TokenType.STRING_TOKEN;\nexport const isIdentWithValue = (token: CSSValue, value: string): boolean =>\n    isIdentToken(token) && token.value === value;\n\nexport const nonWhiteSpace = (token: CSSValue) => token.type !== TokenType.WHITESPACE_TOKEN;\nexport const nonFunctionArgSeparator = (token: CSSValue) =>\n    token.type !== TokenType.WHITESPACE_TOKEN && token.type !== TokenType.COMMA_TOKEN;\n\nexport const parseFunctionArgs = (tokens: CSSValue[]): CSSValue[][] => {\n    const args: CSSValue[][] = [];\n    let arg: CSSValue[] = [];\n    tokens.forEach(token => {\n        if (token.type === TokenType.COMMA_TOKEN) {\n            if (arg.length === 0) {\n                throw new Error(`Error parsing function args, zero tokens for arg`);\n            }\n            args.push(arg);\n            arg = [];\n            return;\n        }\n\n        if (token.type !== TokenType.WHITESPACE_TOKEN) {\n            arg.push(token);\n        }\n    });\n    if (arg.length) {\n        args.push(arg);\n    }\n\n    return args;\n};\n\nconst isEndingTokenFor = (token: CSSToken, type: CSSBlockType): boolean => {\n    if (type === TokenType.LEFT_CURLY_BRACKET_TOKEN && token.type === TokenType.RIGHT_CURLY_BRACKET_TOKEN) {\n        return true;\n    }\n    if (type === TokenType.LEFT_SQUARE_BRACKET_TOKEN && token.type === TokenType.RIGHT_SQUARE_BRACKET_TOKEN) {\n        return true;\n    }\n\n    return type === TokenType.LEFT_PARENTHESIS_TOKEN && token.type === TokenType.RIGHT_PARENTHESIS_TOKEN;\n};\n","import {CSSValue} from '../syntax/parser';\nimport {DimensionToken, NumberValueToken, TokenType} from '../syntax/tokenizer';\n\nexport type Length = DimensionToken | NumberValueToken;\n\nexport const isLength = (token: CSSValue): token is Length =>\n    token.type === TokenType.NUMBER_TOKEN || token.type === TokenType.DIMENSION_TOKEN;\n","import {DimensionToken, FLAG_INTEGER, NumberValueToken, TokenType} from '../syntax/tokenizer';\nimport {CSSValue, isDimensionToken} from '../syntax/parser';\nimport {isLength} from './length';\nexport type LengthPercentage = DimensionToken | NumberValueToken;\nexport type LengthPercentageTuple = [LengthPercentage] | [LengthPercentage, LengthPercentage];\n\nexport const isLengthPercentage = (token: CSSValue): token is LengthPercentage =>\n    token.type === TokenType.PERCENTAGE_TOKEN || isLength(token);\nexport const parseLengthPercentageTuple = (tokens: LengthPercentage[]): LengthPercentageTuple =>\n    tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];\nexport const ZERO_LENGTH: NumberValueToken = {\n    type: TokenType.NUMBER_TOKEN,\n    number: 0,\n    flags: FLAG_INTEGER\n};\n\nexport const FIFTY_PERCENT: NumberValueToken = {\n    type: TokenType.PERCENTAGE_TOKEN,\n    number: 50,\n    flags: FLAG_INTEGER\n};\n\nexport const HUNDRED_PERCENT: NumberValueToken = {\n    type: TokenType.PERCENTAGE_TOKEN,\n    number: 100,\n    flags: FLAG_INTEGER\n};\n\nexport const getAbsoluteValueForTuple = (\n    tuple: LengthPercentageTuple,\n    width: number,\n    height: number\n): [number, number] => {\n    let [x, y] = tuple;\n    return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];\n};\nexport const getAbsoluteValue = (token: LengthPercentage, parent: number) => {\n    if (token.type === TokenType.PERCENTAGE_TOKEN) {\n        return (token.number / 100) * parent;\n    }\n\n    if (isDimensionToken(token)) {\n        switch (token.unit) {\n            case 'rem':\n            case 'em':\n                return 16 * token.number; // TODO use correct font-size\n            case 'px':\n            default:\n                return token.number;\n        }\n    }\n\n    return token.number;\n};\n","import {CSSValue, isIdentToken} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\nimport {ITypeDescriptor} from '../ITypeDescriptor';\nimport {HUNDRED_PERCENT, ZERO_LENGTH} from './length-percentage';\nimport {GradientCorner} from './image';\n\nconst DEG = 'deg';\nconst GRAD = 'grad';\nconst RAD = 'rad';\nconst TURN = 'turn';\n\nexport const angle: ITypeDescriptor<number> = {\n    name: 'angle',\n    parse: (value: CSSValue): number => {\n        if (value.type === TokenType.DIMENSION_TOKEN) {\n            switch (value.unit) {\n                case DEG:\n                    return (Math.PI * value.number) / 180;\n                case GRAD:\n                    return (Math.PI / 200) * value.number;\n                case RAD:\n                    return value.number;\n                case TURN:\n                    return Math.PI * 2 * value.number;\n            }\n        }\n\n        throw new Error(`Unsupported angle type`);\n    }\n};\n\nexport const isAngle = (value: CSSValue): boolean => {\n    if (value.type === TokenType.DIMENSION_TOKEN) {\n        if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const parseNamedSide = (tokens: CSSValue[]): number | GradientCorner => {\n    const sideOrCorner = tokens\n        .filter(isIdentToken)\n        .map(ident => ident.value)\n        .join(' ');\n\n    switch (sideOrCorner) {\n        case 'to bottom right':\n        case 'to right bottom':\n        case 'left top':\n        case 'top left':\n            return [ZERO_LENGTH, ZERO_LENGTH];\n        case 'to top':\n        case 'bottom':\n            return deg(0);\n        case 'to bottom left':\n        case 'to left bottom':\n        case 'right top':\n        case 'top right':\n            return [ZERO_LENGTH, HUNDRED_PERCENT];\n        case 'to right':\n        case 'left':\n            return deg(90);\n        case 'to top left':\n        case 'to left top':\n        case 'right bottom':\n        case 'bottom right':\n            return [HUNDRED_PERCENT, HUNDRED_PERCENT];\n        case 'to bottom':\n        case 'top':\n            return deg(180);\n        case 'to top right':\n        case 'to right top':\n        case 'left bottom':\n        case 'bottom left':\n            return [HUNDRED_PERCENT, ZERO_LENGTH];\n        case 'to left':\n        case 'right':\n            return deg(270);\n    }\n\n    return 0;\n};\n\nexport const deg = (deg: number): number => (Math.PI * deg) / 180;\n","import {CSSValue, nonFunctionArgSeparator} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\nimport {ITypeDescriptor} from '../ITypeDescriptor';\nimport {angle, deg} from './angle';\nimport {getAbsoluteValue, isLengthPercentage} from './length-percentage';\nexport type Color = number;\n\nexport const color: ITypeDescriptor<Color> = {\n    name: 'color',\n    parse: (value: CSSValue): Color => {\n        if (value.type === TokenType.FUNCTION) {\n            const colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];\n            if (typeof colorFunction === 'undefined') {\n                throw new Error(`Attempting to parse an unsupported color function \"${value.name}\"`);\n            }\n            return colorFunction(value.values);\n        }\n\n        if (value.type === TokenType.HASH_TOKEN) {\n            if (value.value.length === 3) {\n                const r = value.value.substring(0, 1);\n                const g = value.value.substring(1, 2);\n                const b = value.value.substring(2, 3);\n                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);\n            }\n\n            if (value.value.length === 4) {\n                const r = value.value.substring(0, 1);\n                const g = value.value.substring(1, 2);\n                const b = value.value.substring(2, 3);\n                const a = value.value.substring(3, 4);\n                return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);\n            }\n\n            if (value.value.length === 6) {\n                const r = value.value.substring(0, 2);\n                const g = value.value.substring(2, 4);\n                const b = value.value.substring(4, 6);\n                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);\n            }\n\n            if (value.value.length === 8) {\n                const r = value.value.substring(0, 2);\n                const g = value.value.substring(2, 4);\n                const b = value.value.substring(4, 6);\n                const a = value.value.substring(6, 8);\n                return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);\n            }\n        }\n\n        if (value.type === TokenType.IDENT_TOKEN) {\n            const namedColor = COLORS[value.value.toUpperCase()];\n            if (typeof namedColor !== 'undefined') {\n                return namedColor;\n            }\n        }\n\n        return COLORS.TRANSPARENT;\n    }\n};\n\nexport const isTransparent = (color: Color) => (0xff & color) === 0;\n\nexport const asString = (color: Color) => {\n    const alpha = 0xff & color;\n    const blue = 0xff & (color >> 8);\n    const green = 0xff & (color >> 16);\n    const red = 0xff & (color >> 24);\n    return alpha < 255 ? `rgba(${red},${green},${blue},${alpha / 255})` : `rgb(${red},${green},${blue})`;\n};\n\nexport const pack = (r: number, g: number, b: number, a: number): Color =>\n    ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;\n\nconst getTokenColorValue = (token: CSSValue, i: number): number => {\n    if (token.type === TokenType.NUMBER_TOKEN) {\n        return token.number;\n    }\n\n    if (token.type === TokenType.PERCENTAGE_TOKEN) {\n        const max = i === 3 ? 1 : 255;\n        return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);\n    }\n\n    return 0;\n};\n\nconst rgb = (args: CSSValue[]): number => {\n    const tokens = args.filter(nonFunctionArgSeparator);\n\n    if (tokens.length === 3) {\n        const [r, g, b] = tokens.map(getTokenColorValue);\n        return pack(r, g, b, 1);\n    }\n\n    if (tokens.length === 4) {\n        const [r, g, b, a] = tokens.map(getTokenColorValue);\n        return pack(r, g, b, a);\n    }\n\n    return 0;\n};\n\nfunction hue2rgb(t1: number, t2: number, hue: number): number {\n    if (hue < 0) {\n        hue += 1;\n    }\n    if (hue >= 1) {\n        hue -= 1;\n    }\n\n    if (hue < 1 / 6) {\n        return (t2 - t1) * hue * 6 + t1;\n    } else if (hue < 1 / 2) {\n        return t2;\n    } else if (hue < 2 / 3) {\n        return (t2 - t1) * 6 * (2 / 3 - hue) + t1;\n    } else {\n        return t1;\n    }\n}\n\nconst hsl = (args: CSSValue[]): number => {\n    const tokens = args.filter(nonFunctionArgSeparator);\n    const [hue, saturation, lightness, alpha] = tokens;\n\n    const h = (hue.type === TokenType.NUMBER_TOKEN ? deg(hue.number) : angle.parse(hue)) / (Math.PI * 2);\n    const s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;\n    const l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;\n    const a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;\n\n    if (s === 0) {\n        return pack(l * 255, l * 255, l * 255, 1);\n    }\n\n    const t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n\n    const t1 = l * 2 - t2;\n    const r = hue2rgb(t1, t2, h + 1 / 3);\n    const g = hue2rgb(t1, t2, h);\n    const b = hue2rgb(t1, t2, h - 1 / 3);\n    return pack(r * 255, g * 255, b * 255, a);\n};\n\nconst SUPPORTED_COLOR_FUNCTIONS: {\n    [key: string]: (args: CSSValue[]) => number;\n} = {\n    hsl: hsl,\n    hsla: hsl,\n    rgb: rgb,\n    rgba: rgb\n};\n\nexport const COLORS: {[key: string]: Color} = {\n    ALICEBLUE: 0xf0f8ffff,\n    ANTIQUEWHITE: 0xfaebd7ff,\n    AQUA: 0x00ffffff,\n    AQUAMARINE: 0x7fffd4ff,\n    AZURE: 0xf0ffffff,\n    BEIGE: 0xf5f5dcff,\n    BISQUE: 0xffe4c4ff,\n    BLACK: 0x000000ff,\n    BLANCHEDALMOND: 0xffebcdff,\n    BLUE: 0x0000ffff,\n    BLUEVIOLET: 0x8a2be2ff,\n    BROWN: 0xa52a2aff,\n    BURLYWOOD: 0xdeb887ff,\n    CADETBLUE: 0x5f9ea0ff,\n    CHARTREUSE: 0x7fff00ff,\n    CHOCOLATE: 0xd2691eff,\n    CORAL: 0xff7f50ff,\n    CORNFLOWERBLUE: 0x6495edff,\n    CORNSILK: 0xfff8dcff,\n    CRIMSON: 0xdc143cff,\n    CYAN: 0x00ffffff,\n    DARKBLUE: 0x00008bff,\n    DARKCYAN: 0x008b8bff,\n    DARKGOLDENROD: 0xb886bbff,\n    DARKGRAY: 0xa9a9a9ff,\n    DARKGREEN: 0x006400ff,\n    DARKGREY: 0xa9a9a9ff,\n    DARKKHAKI: 0xbdb76bff,\n    DARKMAGENTA: 0x8b008bff,\n    DARKOLIVEGREEN: 0x556b2fff,\n    DARKORANGE: 0xff8c00ff,\n    DARKORCHID: 0x9932ccff,\n    DARKRED: 0x8b0000ff,\n    DARKSALMON: 0xe9967aff,\n    DARKSEAGREEN: 0x8fbc8fff,\n    DARKSLATEBLUE: 0x483d8bff,\n    DARKSLATEGRAY: 0x2f4f4fff,\n    DARKSLATEGREY: 0x2f4f4fff,\n    DARKTURQUOISE: 0x00ced1ff,\n    DARKVIOLET: 0x9400d3ff,\n    DEEPPINK: 0xff1493ff,\n    DEEPSKYBLUE: 0x00bfffff,\n    DIMGRAY: 0x696969ff,\n    DIMGREY: 0x696969ff,\n    DODGERBLUE: 0x1e90ffff,\n    FIREBRICK: 0xb22222ff,\n    FLORALWHITE: 0xfffaf0ff,\n    FORESTGREEN: 0x228b22ff,\n    FUCHSIA: 0xff00ffff,\n    GAINSBORO: 0xdcdcdcff,\n    GHOSTWHITE: 0xf8f8ffff,\n    GOLD: 0xffd700ff,\n    GOLDENROD: 0xdaa520ff,\n    GRAY: 0x808080ff,\n    GREEN: 0x008000ff,\n    GREENYELLOW: 0xadff2fff,\n    GREY: 0x808080ff,\n    HONEYDEW: 0xf0fff0ff,\n    HOTPINK: 0xff69b4ff,\n    INDIANRED: 0xcd5c5cff,\n    INDIGO: 0x4b0082ff,\n    IVORY: 0xfffff0ff,\n    KHAKI: 0xf0e68cff,\n    LAVENDER: 0xe6e6faff,\n    LAVENDERBLUSH: 0xfff0f5ff,\n    LAWNGREEN: 0x7cfc00ff,\n    LEMONCHIFFON: 0xfffacdff,\n    LIGHTBLUE: 0xadd8e6ff,\n    LIGHTCORAL: 0xf08080ff,\n    LIGHTCYAN: 0xe0ffffff,\n    LIGHTGOLDENRODYELLOW: 0xfafad2ff,\n    LIGHTGRAY: 0xd3d3d3ff,\n    LIGHTGREEN: 0x90ee90ff,\n    LIGHTGREY: 0xd3d3d3ff,\n    LIGHTPINK: 0xffb6c1ff,\n    LIGHTSALMON: 0xffa07aff,\n    LIGHTSEAGREEN: 0x20b2aaff,\n    LIGHTSKYBLUE: 0x87cefaff,\n    LIGHTSLATEGRAY: 0x778899ff,\n    LIGHTSLATEGREY: 0x778899ff,\n    LIGHTSTEELBLUE: 0xb0c4deff,\n    LIGHTYELLOW: 0xffffe0ff,\n    LIME: 0x00ff00ff,\n    LIMEGREEN: 0x32cd32ff,\n    LINEN: 0xfaf0e6ff,\n    MAGENTA: 0xff00ffff,\n    MAROON: 0x800000ff,\n    MEDIUMAQUAMARINE: 0x66cdaaff,\n    MEDIUMBLUE: 0x0000cdff,\n    MEDIUMORCHID: 0xba55d3ff,\n    MEDIUMPURPLE: 0x9370dbff,\n    MEDIUMSEAGREEN: 0x3cb371ff,\n    MEDIUMSLATEBLUE: 0x7b68eeff,\n    MEDIUMSPRINGGREEN: 0x00fa9aff,\n    MEDIUMTURQUOISE: 0x48d1ccff,\n    MEDIUMVIOLETRED: 0xc71585ff,\n    MIDNIGHTBLUE: 0x191970ff,\n    MINTCREAM: 0xf5fffaff,\n    MISTYROSE: 0xffe4e1ff,\n    MOCCASIN: 0xffe4b5ff,\n    NAVAJOWHITE: 0xffdeadff,\n    NAVY: 0x000080ff,\n    OLDLACE: 0xfdf5e6ff,\n    OLIVE: 0x808000ff,\n    OLIVEDRAB: 0x6b8e23ff,\n    ORANGE: 0xffa500ff,\n    ORANGERED: 0xff4500ff,\n    ORCHID: 0xda70d6ff,\n    PALEGOLDENROD: 0xeee8aaff,\n    PALEGREEN: 0x98fb98ff,\n    PALETURQUOISE: 0xafeeeeff,\n    PALEVIOLETRED: 0xdb7093ff,\n    PAPAYAWHIP: 0xffefd5ff,\n    PEACHPUFF: 0xffdab9ff,\n    PERU: 0xcd853fff,\n    PINK: 0xffc0cbff,\n    PLUM: 0xdda0ddff,\n    POWDERBLUE: 0xb0e0e6ff,\n    PURPLE: 0x800080ff,\n    REBECCAPURPLE: 0x663399ff,\n    RED: 0xff0000ff,\n    ROSYBROWN: 0xbc8f8fff,\n    ROYALBLUE: 0x4169e1ff,\n    SADDLEBROWN: 0x8b4513ff,\n    SALMON: 0xfa8072ff,\n    SANDYBROWN: 0xf4a460ff,\n    SEAGREEN: 0x2e8b57ff,\n    SEASHELL: 0xfff5eeff,\n    SIENNA: 0xa0522dff,\n    SILVER: 0xc0c0c0ff,\n    SKYBLUE: 0x87ceebff,\n    SLATEBLUE: 0x6a5acdff,\n    SLATEGRAY: 0x708090ff,\n    SLATEGREY: 0x708090ff,\n    SNOW: 0xfffafaff,\n    SPRINGGREEN: 0x00ff7fff,\n    STEELBLUE: 0x4682b4ff,\n    TAN: 0xd2b48cff,\n    TEAL: 0x008080ff,\n    THISTLE: 0xd8bfd8ff,\n    TOMATO: 0xff6347ff,\n    TRANSPARENT: 0x00000000,\n    TURQUOISE: 0x40e0d0ff,\n    VIOLET: 0xee82eeff,\n    WHEAT: 0xf5deb3ff,\n    WHITE: 0xffffffff,\n    WHITESMOKE: 0xf5f5f5ff,\n    YELLOW: 0xffff00ff,\n    YELLOWGREEN: 0x9acd32ff\n};\n","import {CSSValue} from './syntax/parser';\nimport {CSSTypes} from './types/index';\n\nexport enum PropertyDescriptorParsingType {\n    VALUE,\n    LIST,\n    IDENT_VALUE,\n    TYPE_VALUE,\n    TOKEN_VALUE\n}\n\nexport interface IPropertyDescriptor {\n    name: string;\n    type: PropertyDescriptorParsingType;\n    initialValue: string;\n    prefix: boolean;\n}\n\nexport interface IPropertyIdentValueDescriptor<T> extends IPropertyDescriptor {\n    type: PropertyDescriptorParsingType.IDENT_VALUE;\n    parse: (token: string) => T;\n}\n\nexport interface IPropertyTypeValueDescriptor extends IPropertyDescriptor {\n    type: PropertyDescriptorParsingType.TYPE_VALUE;\n    format: CSSTypes;\n}\n\nexport interface IPropertyValueDescriptor<T> extends IPropertyDescriptor {\n    type: PropertyDescriptorParsingType.VALUE;\n    parse: (token: CSSValue) => T;\n}\n\nexport interface IPropertyListDescriptor<T> extends IPropertyDescriptor {\n    type: PropertyDescriptorParsingType.LIST;\n    parse: (tokens: CSSValue[]) => T;\n}\n\nexport interface IPropertyTokenValueDescriptor extends IPropertyDescriptor {\n    type: PropertyDescriptorParsingType.TOKEN_VALUE;\n}\n\nexport type CSSPropertyDescriptor<T> =\n    | IPropertyValueDescriptor<T>\n    | IPropertyListDescriptor<T>\n    | IPropertyIdentValueDescriptor<T>\n    | IPropertyTypeValueDescriptor\n    | IPropertyTokenValueDescriptor;\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\nexport enum BACKGROUND_CLIP {\n    BORDER_BOX = 0,\n    PADDING_BOX = 1,\n    CONTENT_BOX = 2\n}\n\nexport type BackgroundClip = BACKGROUND_CLIP[];\n\nexport const backgroundClip: IPropertyListDescriptor<BackgroundClip> = {\n    name: 'background-clip',\n    initialValue: 'border-box',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): BackgroundClip => {\n        return tokens.map(token => {\n            if (isIdentToken(token)) {\n                switch (token.value) {\n                    case 'padding-box':\n                        return BACKGROUND_CLIP.PADDING_BOX;\n                    case 'content-box':\n                        return BACKGROUND_CLIP.CONTENT_BOX;\n                }\n            }\n            return BACKGROUND_CLIP.BORDER_BOX;\n        });\n    }\n};\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nexport const backgroundColor: IPropertyTypeValueDescriptor = {\n    name: `background-color`,\n    initialValue: 'transparent',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'color'\n};\n","import {CSSValue} from '../../syntax/parser';\nimport {\n    CSSRadialExtent,\n    CSSRadialGradientImage,\n    CSSRadialShape,\n    GradientColorStop,\n    GradientCorner,\n    UnprocessedGradientColorStop\n} from '../image';\nimport {color as colorType} from '../color';\nimport {getAbsoluteValue, HUNDRED_PERCENT, isLengthPercentage, ZERO_LENGTH} from '../length-percentage';\n\nexport const parseColorStop = (args: CSSValue[]): UnprocessedGradientColorStop => {\n    const color = colorType.parse(args[0]);\n    const stop = args[1];\n    return stop && isLengthPercentage(stop) ? {color, stop} : {color, stop: null};\n};\n\nexport const processColorStops = (stops: UnprocessedGradientColorStop[], lineLength: number): GradientColorStop[] => {\n    const first = stops[0];\n    const last = stops[stops.length - 1];\n    if (first.stop === null) {\n        first.stop = ZERO_LENGTH;\n    }\n\n    if (last.stop === null) {\n        last.stop = HUNDRED_PERCENT;\n    }\n\n    const processStops: (number | null)[] = [];\n    let previous = 0;\n    for (let i = 0; i < stops.length; i++) {\n        const stop = stops[i].stop;\n        if (stop !== null) {\n            const absoluteValue = getAbsoluteValue(stop, lineLength);\n            if (absoluteValue > previous) {\n                processStops.push(absoluteValue);\n            } else {\n                processStops.push(previous);\n            }\n            previous = absoluteValue;\n        } else {\n            processStops.push(null);\n        }\n    }\n\n    let gapBegin = null;\n    for (let i = 0; i < processStops.length; i++) {\n        const stop = processStops[i];\n        if (stop === null) {\n            if (gapBegin === null) {\n                gapBegin = i;\n            }\n        } else if (gapBegin !== null) {\n            const gapLength = i - gapBegin;\n            const beforeGap = processStops[gapBegin - 1] as number;\n            const gapValue = (stop - beforeGap) / (gapLength + 1);\n            for (let g = 1; g <= gapLength; g++) {\n                processStops[gapBegin + g - 1] = gapValue * g;\n            }\n            gapBegin = null;\n        }\n    }\n\n    return stops.map(({color}, i) => {\n        return {color, stop: Math.max(Math.min(1, (processStops[i] as number) / lineLength), 0)};\n    });\n};\n\nconst getAngleFromCorner = (corner: GradientCorner, width: number, height: number): number => {\n    const centerX = width / 2;\n    const centerY = height / 2;\n    const x = getAbsoluteValue(corner[0], width) - centerX;\n    const y = centerY - getAbsoluteValue(corner[1], height);\n\n    return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);\n};\n\nexport const calculateGradientDirection = (\n    angle: number | GradientCorner,\n    width: number,\n    height: number\n): [number, number, number, number, number] => {\n    const radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);\n\n    const lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));\n\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const halfLineLength = lineLength / 2;\n\n    const yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;\n    const xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;\n\n    return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];\n};\n\nconst distance = (a: number, b: number): number => Math.sqrt(a * a + b * b);\n\nconst findCorner = (width: number, height: number, x: number, y: number, closest: boolean): [number, number] => {\n    const corners = [[0, 0], [0, height], [width, 0], [width, height]];\n\n    return corners.reduce(\n        (stat, corner) => {\n            const [cx, cy] = corner;\n            const d = distance(x - cx, y - cy);\n            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {\n                return {\n                    optimumCorner: corner,\n                    optimumDistance: d\n                };\n            }\n\n            return stat;\n        },\n        {\n            optimumDistance: closest ? Infinity : -Infinity,\n            optimumCorner: null\n        }\n    ).optimumCorner as [number, number];\n};\n\nexport const calculateRadius = (\n    gradient: CSSRadialGradientImage,\n    x: number,\n    y: number,\n    width: number,\n    height: number\n): [number, number] => {\n    let rx = 0;\n    let ry = 0;\n\n    switch (gradient.size) {\n        case CSSRadialExtent.CLOSEST_SIDE:\n            // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.\n            // If the shape is an ellipse, it exactly meets the closest side in each dimension.\n            if (gradient.shape === CSSRadialShape.CIRCLE) {\n                rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));\n            } else if (gradient.shape === CSSRadialShape.ELLIPSE) {\n                rx = Math.min(Math.abs(x), Math.abs(x - width));\n                ry = Math.min(Math.abs(y), Math.abs(y - height));\n            }\n            break;\n\n        case CSSRadialExtent.CLOSEST_CORNER:\n            // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.\n            // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.\n            if (gradient.shape === CSSRadialShape.CIRCLE) {\n                rx = ry = Math.min(\n                    distance(x, y),\n                    distance(x, y - height),\n                    distance(x - width, y),\n                    distance(x - width, y - height)\n                );\n            } else if (gradient.shape === CSSRadialShape.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"closest-side\")\n                const c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));\n                const [cx, cy] = findCorner(width, height, x, y, true);\n                rx = distance(cx - x, (cy - y) / c);\n                ry = c * rx;\n            }\n            break;\n\n        case CSSRadialExtent.FARTHEST_SIDE:\n            // Same as closest-side, except the ending shape is sized based on the farthest side(s)\n            if (gradient.shape === CSSRadialShape.CIRCLE) {\n                rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));\n            } else if (gradient.shape === CSSRadialShape.ELLIPSE) {\n                rx = Math.max(Math.abs(x), Math.abs(x - width));\n                ry = Math.max(Math.abs(y), Math.abs(y - height));\n            }\n            break;\n\n        case CSSRadialExtent.FARTHEST_CORNER:\n            // Same as closest-corner, except the ending shape is sized based on the farthest corner.\n            // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.\n            if (gradient.shape === CSSRadialShape.CIRCLE) {\n                rx = ry = Math.max(\n                    distance(x, y),\n                    distance(x, y - height),\n                    distance(x - width, y),\n                    distance(x - width, y - height)\n                );\n            } else if (gradient.shape === CSSRadialShape.ELLIPSE) {\n                // Compute the ratio ry/rx (which is to be the same as for \"farthest-side\")\n                const c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));\n                const [cx, cy] = findCorner(width, height, x, y, false);\n                rx = distance(cx - x, (cy - y) / c);\n                ry = c * rx;\n            }\n            break;\n    }\n\n    if (Array.isArray(gradient.size)) {\n        rx = getAbsoluteValue(gradient.size[0], width);\n        ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;\n    }\n\n    return [rx, ry];\n};\n","import {CSSValue, parseFunctionArgs} from '../../syntax/parser';\nimport {TokenType} from '../../syntax/tokenizer';\nimport {isAngle, angle as angleType, parseNamedSide, deg} from '../angle';\nimport {CSSImageType, CSSLinearGradientImage, GradientCorner, UnprocessedGradientColorStop} from '../image';\nimport {parseColorStop} from './gradient';\n\nexport const linearGradient = (tokens: CSSValue[]): CSSLinearGradientImage => {\n    let angle: number | GradientCorner = deg(180);\n    const stops: UnprocessedGradientColorStop[] = [];\n\n    parseFunctionArgs(tokens).forEach((arg, i) => {\n        if (i === 0) {\n            const firstToken = arg[0];\n            if (firstToken.type === TokenType.IDENT_TOKEN && firstToken.value === 'to') {\n                angle = parseNamedSide(arg);\n                return;\n            } else if (isAngle(firstToken)) {\n                angle = angleType.parse(firstToken);\n                return;\n            }\n        }\n        const colorStop = parseColorStop(arg);\n        stops.push(colorStop);\n    });\n\n    return {angle, stops, type: CSSImageType.LINEAR_GRADIENT};\n};\n","import {CSSValue, parseFunctionArgs} from '../../syntax/parser';\nimport {CSSImageType, CSSLinearGradientImage, GradientCorner, UnprocessedGradientColorStop} from '../image';\nimport {TokenType} from '../../syntax/tokenizer';\nimport {isAngle, angle as angleType, parseNamedSide, deg} from '../angle';\nimport {parseColorStop} from './gradient';\n\nexport const prefixLinearGradient = (tokens: CSSValue[]): CSSLinearGradientImage => {\n    let angle: number | GradientCorner = deg(180);\n    const stops: UnprocessedGradientColorStop[] = [];\n\n    parseFunctionArgs(tokens).forEach((arg, i) => {\n        if (i === 0) {\n            const firstToken = arg[0];\n            if (\n                firstToken.type === TokenType.IDENT_TOKEN &&\n                ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1\n            ) {\n                angle = parseNamedSide(arg);\n                return;\n            } else if (isAngle(firstToken)) {\n                angle = (angleType.parse(firstToken) + deg(270)) % deg(360);\n                return;\n            }\n        }\n        const colorStop = parseColorStop(arg);\n        stops.push(colorStop);\n    });\n\n    return {\n        angle,\n        stops,\n        type: CSSImageType.LINEAR_GRADIENT\n    };\n};\n","const testRangeBounds = (document: Document) => {\n    const TEST_HEIGHT = 123;\n\n    if (document.createRange) {\n        const range = document.createRange();\n        if (range.getBoundingClientRect) {\n            const testElement = document.createElement('boundtest');\n            testElement.style.height = `${TEST_HEIGHT}px`;\n            testElement.style.display = 'block';\n            document.body.appendChild(testElement);\n\n            range.selectNode(testElement);\n            const rangeBounds = range.getBoundingClientRect();\n            const rangeHeight = Math.round(rangeBounds.height);\n            document.body.removeChild(testElement);\n            if (rangeHeight === TEST_HEIGHT) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\nconst testCORS = (): boolean => typeof new Image().crossOrigin !== 'undefined';\n\nconst testResponseType = (): boolean => typeof new XMLHttpRequest().responseType === 'string';\n\nconst testSVG = (document: Document): boolean => {\n    const img = new Image();\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        return false;\n    }\n\n    img.src = `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>`;\n\n    try {\n        ctx.drawImage(img, 0, 0);\n        canvas.toDataURL();\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\nconst isGreenPixel = (data: Uint8ClampedArray): boolean =>\n    data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;\n\nconst testForeignObject = (document: Document): Promise<boolean> => {\n    const canvas = document.createElement('canvas');\n    const size = 100;\n    canvas.width = size;\n    canvas.height = size;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n        return Promise.reject(false);\n    }\n    ctx.fillStyle = 'rgb(0, 255, 0)';\n    ctx.fillRect(0, 0, size, size);\n\n    const img = new Image();\n    const greenImageSrc = canvas.toDataURL();\n    img.src = greenImageSrc;\n    const svg = createForeignObjectSVG(size, size, 0, 0, img);\n    ctx.fillStyle = 'red';\n    ctx.fillRect(0, 0, size, size);\n\n    return loadSerializedSVG(svg)\n        .then((img: HTMLImageElement) => {\n            ctx.drawImage(img, 0, 0);\n            const data = ctx.getImageData(0, 0, size, size).data;\n            ctx.fillStyle = 'red';\n            ctx.fillRect(0, 0, size, size);\n\n            const node = document.createElement('div');\n            node.style.backgroundImage = `url(${greenImageSrc})`;\n            node.style.height = `${size}px`;\n            // Firefox 55 does not render inline <img /> tags\n            return isGreenPixel(data)\n                ? loadSerializedSVG(createForeignObjectSVG(size, size, 0, 0, node))\n                : Promise.reject(false);\n        })\n        .then((img: HTMLImageElement) => {\n            ctx.drawImage(img, 0, 0);\n            // Edge does not render background-images\n            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);\n        })\n        .catch(() => false);\n};\n\nexport const createForeignObjectSVG = (width: number, height: number, x: number, y: number, node: Node) => {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttributeNS(null, 'width', width.toString());\n    svg.setAttributeNS(null, 'height', height.toString());\n\n    foreignObject.setAttributeNS(null, 'width', '100%');\n    foreignObject.setAttributeNS(null, 'height', '100%');\n    foreignObject.setAttributeNS(null, 'x', x.toString());\n    foreignObject.setAttributeNS(null, 'y', y.toString());\n    foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n\n    foreignObject.appendChild(node);\n\n    return svg;\n};\n\nexport const loadSerializedSVG = (svg: Node): Promise<HTMLImageElement> => {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n\n        img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(new XMLSerializer().serializeToString(svg))}`;\n    });\n};\n\nexport const FEATURES = {\n    get SUPPORT_RANGE_BOUNDS() {\n        'use strict';\n        const value = testRangeBounds(document);\n        Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', {value});\n        return value;\n    },\n    get SUPPORT_SVG_DRAWING() {\n        'use strict';\n        const value = testSVG(document);\n        Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', {value});\n        return value;\n    },\n    get SUPPORT_FOREIGNOBJECT_DRAWING() {\n        'use strict';\n        const value =\n            typeof Array.from === 'function' && typeof window.fetch === 'function'\n                ? testForeignObject(document)\n                : Promise.resolve(false);\n        Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', {value});\n        return value;\n    },\n    get SUPPORT_CORS_IMAGES() {\n        'use strict';\n        const value = testCORS();\n        Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', {value});\n        return value;\n    },\n    get SUPPORT_RESPONSE_TYPE() {\n        'use strict';\n        const value = testResponseType();\n        Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', {value});\n        return value;\n    },\n    get SUPPORT_CORS_XHR() {\n        'use strict';\n        const value = 'withCredentials' in new XMLHttpRequest();\n        Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', {value});\n        return value;\n    }\n};\n","export interface LoggerOptions {\n    id: string;\n    enabled: boolean;\n}\n\nexport class Logger {\n    static instances: {[key: string]: Logger} = {};\n\n    private readonly id: string;\n    private readonly enabled: boolean;\n    private readonly start: number;\n\n    constructor({id, enabled}: LoggerOptions) {\n        this.id = id;\n        this.enabled = enabled;\n        this.start = Date.now();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    debug(...args: any) {\n        if (this.enabled) {\n            // eslint-disable-next-line no-console\n            if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {\n                // eslint-disable-next-line no-console\n                console.debug(this.id, `${this.getTime()}ms`, ...args);\n            } else {\n                this.info(...args);\n            }\n        }\n    }\n\n    getTime(): number {\n        return Date.now() - this.start;\n    }\n\n    static create(options: LoggerOptions) {\n        Logger.instances[options.id] = new Logger(options);\n    }\n\n    static destroy(id: string) {\n        delete Logger.instances[id];\n    }\n\n    static getInstance(id: string): Logger {\n        const instance = Logger.instances[id];\n        if (typeof instance === 'undefined') {\n            throw new Error(`No logger instance found with id ${id}`);\n        }\n        return instance;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    info(...args: any) {\n        if (this.enabled) {\n            // eslint-disable-next-line no-console\n            if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {\n                // eslint-disable-next-line no-console\n                console.info(this.id, `${this.getTime()}ms`, ...args);\n            }\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    error(...args: any) {\n        if (this.enabled) {\n            // eslint-disable-next-line no-console\n            if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {\n                // eslint-disable-next-line no-console\n                console.error(this.id, `${this.getTime()}ms`, ...args);\n            } else {\n                this.info(...args);\n            }\n        }\n    }\n}\n","import {FEATURES} from './features';\nimport {Logger} from './logger';\n\nexport class CacheStorage {\n    private static _caches: {[key: string]: Cache} = {};\n    private static _link?: HTMLAnchorElement;\n    private static _origin: string = 'about:blank';\n    private static _current: Cache | null = null;\n\n    static create(name: string, options: ResourceOptions): Cache {\n        return (CacheStorage._caches[name] = new Cache(name, options));\n    }\n\n    static destroy(name: string): void {\n        delete CacheStorage._caches[name];\n    }\n\n    static open(name: string): Cache {\n        const cache = CacheStorage._caches[name];\n        if (typeof cache !== 'undefined') {\n            return cache;\n        }\n\n        throw new Error(`Cache with key \"${name}\" not found`);\n    }\n\n    static getOrigin(url: string): string {\n        const link = CacheStorage._link;\n        if (!link) {\n            return 'about:blank';\n        }\n\n        link.href = url;\n        link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/\n        return link.protocol + link.hostname + link.port;\n    }\n\n    static isSameOrigin(src: string): boolean {\n        return CacheStorage.getOrigin(src) === CacheStorage._origin;\n    }\n\n    static setContext(window: Window) {\n        CacheStorage._link = window.document.createElement('a');\n        CacheStorage._origin = CacheStorage.getOrigin(window.location.href);\n    }\n\n    static getInstance(): Cache {\n        const current = CacheStorage._current;\n        if (current === null) {\n            throw new Error(`No cache instance attached`);\n        }\n        return current;\n    }\n\n    static attachInstance(cache: Cache) {\n        CacheStorage._current = cache;\n    }\n\n    static detachInstance() {\n        CacheStorage._current = null;\n    }\n}\n\nexport interface ResourceOptions {\n    imageTimeout: number;\n    useCORS: boolean;\n    allowTaint: boolean;\n    proxy?: string;\n}\n\nexport class Cache {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    private readonly _cache: {[key: string]: Promise<any>};\n    private readonly _options: ResourceOptions;\n    private readonly id: string;\n\n    constructor(id: string, options: ResourceOptions) {\n        this.id = id;\n        this._options = options;\n        this._cache = {};\n    }\n\n    addImage(src: string): Promise<void> {\n        const result = Promise.resolve();\n        if (this.has(src)) {\n            return result;\n        }\n\n        if (isBlobImage(src) || isRenderable(src)) {\n            this._cache[src] = this.loadImage(src);\n            return result;\n        }\n\n        return result;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    match(src: string): Promise<any> {\n        return this._cache[src];\n    }\n\n    private async loadImage(key: string) {\n        const isSameOrigin = CacheStorage.isSameOrigin(key);\n        const useCORS =\n            !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;\n        const useProxy =\n            !isInlineImage(key) &&\n            !isSameOrigin &&\n            typeof this._options.proxy === 'string' &&\n            FEATURES.SUPPORT_CORS_XHR &&\n            !useCORS;\n        if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !useProxy && !useCORS) {\n            return;\n        }\n\n        let src = key;\n        if (useProxy) {\n            src = await this.proxy(src);\n        }\n\n        Logger.getInstance(this.id).debug(`Added image ${key.substring(0, 256)}`);\n\n        return await new Promise((resolve, reject) => {\n            const img = new Image();\n            img.onload = () => resolve(img);\n            img.onerror = reject;\n            //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous\n            if (isInlineBase64Image(src) || useCORS) {\n                img.crossOrigin = 'anonymous';\n            }\n            img.src = src;\n            if (img.complete === true) {\n                // Inline XML images may fail to parse, throwing an Error later on\n                setTimeout(() => resolve(img), 500);\n            }\n            if (this._options.imageTimeout > 0) {\n                setTimeout(\n                    () => reject(`Timed out (${this._options.imageTimeout}ms) loading image`),\n                    this._options.imageTimeout\n                );\n            }\n        });\n    }\n\n    private has(key: string): boolean {\n        return typeof this._cache[key] !== 'undefined';\n    }\n\n    keys(): Promise<string[]> {\n        return Promise.resolve(Object.keys(this._cache));\n    }\n\n    private proxy(src: string): Promise<string> {\n        const proxy = this._options.proxy;\n\n        if (!proxy) {\n            throw new Error('No proxy defined');\n        }\n\n        const key = src.substring(0, 256);\n\n        return new Promise((resolve, reject) => {\n            const responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';\n            const xhr = new XMLHttpRequest();\n            xhr.onload = () => {\n                if (xhr.status === 200) {\n                    if (responseType === 'text') {\n                        resolve(xhr.response);\n                    } else {\n                        const reader = new FileReader();\n                        reader.addEventListener('load', () => resolve(reader.result as string), false);\n                        reader.addEventListener('error', e => reject(e), false);\n                        reader.readAsDataURL(xhr.response);\n                    }\n                } else {\n                    reject(`Failed to proxy resource ${key} with status code ${xhr.status}`);\n                }\n            };\n\n            xhr.onerror = reject;\n            xhr.open('GET', `${proxy}?url=${encodeURIComponent(src)}&responseType=${responseType}`);\n\n            if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {\n                xhr.responseType = responseType;\n            }\n\n            if (this._options.imageTimeout) {\n                const timeout = this._options.imageTimeout;\n                xhr.timeout = timeout;\n                xhr.ontimeout = () => reject(`Timed out (${timeout}ms) proxying ${key}`);\n            }\n\n            xhr.send();\n        });\n    }\n}\n\nconst INLINE_SVG = /^data:image\\/svg\\+xml/i;\nconst INLINE_BASE64 = /^data:image\\/.*;base64,/i;\nconst INLINE_IMG = /^data:image\\/.*/i;\n\nconst isRenderable = (src: string): boolean => FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);\nconst isInlineImage = (src: string): boolean => INLINE_IMG.test(src);\nconst isInlineBase64Image = (src: string): boolean => INLINE_BASE64.test(src);\nconst isBlobImage = (src: string): boolean => src.substr(0, 4) === 'blob';\n\nconst isSVG = (src: string): boolean => src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src);\n","import {CSSValue, isIdentToken, isNumberToken, nonFunctionArgSeparator, parseFunctionArgs} from '../../syntax/parser';\nimport {\n    CSSImageType,\n    CSSLinearGradientImage,\n    CSSRadialExtent,\n    CSSRadialGradientImage,\n    CSSRadialShape,\n    CSSRadialSize,\n    UnprocessedGradientColorStop\n} from '../image';\nimport {deg} from '../angle';\nimport {TokenType} from '../../syntax/tokenizer';\nimport {color as colorType} from '../color';\nimport {HUNDRED_PERCENT, LengthPercentage, ZERO_LENGTH} from '../length-percentage';\n\nexport const webkitGradient = (tokens: CSSValue[]): CSSLinearGradientImage | CSSRadialGradientImage => {\n    let angle = deg(180);\n    const stops: UnprocessedGradientColorStop[] = [];\n    let type = CSSImageType.LINEAR_GRADIENT;\n    let shape: CSSRadialShape = CSSRadialShape.CIRCLE;\n    let size: CSSRadialSize = CSSRadialExtent.FARTHEST_CORNER;\n    const position: LengthPercentage[] = [];\n    parseFunctionArgs(tokens).forEach((arg, i) => {\n        const firstToken = arg[0];\n        if (i === 0) {\n            if (isIdentToken(firstToken) && firstToken.value === 'linear') {\n                type = CSSImageType.LINEAR_GRADIENT;\n                return;\n            } else if (isIdentToken(firstToken) && firstToken.value === 'radial') {\n                type = CSSImageType.RADIAL_GRADIENT;\n                return;\n            }\n        }\n\n        if (firstToken.type === TokenType.FUNCTION) {\n            if (firstToken.name === 'from') {\n                const color = colorType.parse(firstToken.values[0]);\n                stops.push({stop: ZERO_LENGTH, color});\n            } else if (firstToken.name === 'to') {\n                const color = colorType.parse(firstToken.values[0]);\n                stops.push({stop: HUNDRED_PERCENT, color});\n            } else if (firstToken.name === 'color-stop') {\n                const values = firstToken.values.filter(nonFunctionArgSeparator);\n                if (values.length === 2) {\n                    const color = colorType.parse(values[1]);\n                    const stop = values[0];\n                    if (isNumberToken(stop)) {\n                        stops.push({\n                            stop: {type: TokenType.PERCENTAGE_TOKEN, number: stop.number * 100, flags: stop.flags},\n                            color\n                        });\n                    }\n                }\n            }\n        }\n    });\n\n    return type === CSSImageType.LINEAR_GRADIENT\n        ? {\n              angle: (angle + deg(180)) % deg(360),\n              stops,\n              type\n          }\n        : {size, shape, stops, position, type};\n};\n","import {CSSValue, isIdentToken, parseFunctionArgs} from '../../syntax/parser';\nimport {\n    CSSImageType,\n    CSSRadialExtent,\n    CSSRadialGradientImage,\n    CSSRadialShape,\n    CSSRadialSize,\n    UnprocessedGradientColorStop\n} from '../image';\nimport {parseColorStop} from './gradient';\nimport {FIFTY_PERCENT, HUNDRED_PERCENT, isLengthPercentage, LengthPercentage, ZERO_LENGTH} from '../length-percentage';\nimport {isLength} from '../length';\nexport const CLOSEST_SIDE = 'closest-side';\nexport const FARTHEST_SIDE = 'farthest-side';\nexport const CLOSEST_CORNER = 'closest-corner';\nexport const FARTHEST_CORNER = 'farthest-corner';\nexport const CIRCLE = 'circle';\nexport const ELLIPSE = 'ellipse';\nexport const COVER = 'cover';\nexport const CONTAIN = 'contain';\n\nexport const radialGradient = (tokens: CSSValue[]): CSSRadialGradientImage => {\n    let shape: CSSRadialShape = CSSRadialShape.CIRCLE;\n    let size: CSSRadialSize = CSSRadialExtent.FARTHEST_CORNER;\n    const stops: UnprocessedGradientColorStop[] = [];\n    const position: LengthPercentage[] = [];\n    parseFunctionArgs(tokens).forEach((arg, i) => {\n        let isColorStop = true;\n        if (i === 0) {\n            let isAtPosition = false;\n            isColorStop = arg.reduce((acc, token) => {\n                if (isAtPosition) {\n                    if (isIdentToken(token)) {\n                        switch (token.value) {\n                            case 'center':\n                                position.push(FIFTY_PERCENT);\n                                return acc;\n                            case 'top':\n                            case 'left':\n                                position.push(ZERO_LENGTH);\n                                return acc;\n                            case 'right':\n                            case 'bottom':\n                                position.push(HUNDRED_PERCENT);\n                                return acc;\n                        }\n                    } else if (isLengthPercentage(token) || isLength(token)) {\n                        position.push(token);\n                    }\n                } else if (isIdentToken(token)) {\n                    switch (token.value) {\n                        case CIRCLE:\n                            shape = CSSRadialShape.CIRCLE;\n                            return false;\n                        case ELLIPSE:\n                            shape = CSSRadialShape.ELLIPSE;\n                            return false;\n                        case 'at':\n                            isAtPosition = true;\n                            return false;\n                        case CLOSEST_SIDE:\n                            size = CSSRadialExtent.CLOSEST_SIDE;\n                            return false;\n                        case COVER:\n                        case FARTHEST_SIDE:\n                            size = CSSRadialExtent.FARTHEST_SIDE;\n                            return false;\n                        case CONTAIN:\n                        case CLOSEST_CORNER:\n                            size = CSSRadialExtent.CLOSEST_CORNER;\n                            return false;\n                        case FARTHEST_CORNER:\n                            size = CSSRadialExtent.FARTHEST_CORNER;\n                            return false;\n                    }\n                } else if (isLength(token) || isLengthPercentage(token)) {\n                    if (!Array.isArray(size)) {\n                        size = [];\n                    }\n                    size.push(token);\n                    return false;\n                }\n                return acc;\n            }, isColorStop);\n        }\n\n        if (isColorStop) {\n            const colorStop = parseColorStop(arg);\n            stops.push(colorStop);\n        }\n    });\n\n    return {size, shape, stops, position, type: CSSImageType.RADIAL_GRADIENT};\n};\n","import {CSSValue, isIdentToken, parseFunctionArgs} from '../../syntax/parser';\nimport {\n    CSSImageType,\n    CSSRadialExtent,\n    CSSRadialGradientImage,\n    CSSRadialShape,\n    CSSRadialSize,\n    UnprocessedGradientColorStop\n} from '../image';\nimport {parseColorStop} from './gradient';\nimport {FIFTY_PERCENT, HUNDRED_PERCENT, isLengthPercentage, LengthPercentage, ZERO_LENGTH} from '../length-percentage';\nimport {isLength} from '../length';\nimport {\n    CIRCLE,\n    CLOSEST_CORNER,\n    CLOSEST_SIDE,\n    CONTAIN,\n    COVER,\n    ELLIPSE,\n    FARTHEST_CORNER,\n    FARTHEST_SIDE\n} from './radial-gradient';\n\nexport const prefixRadialGradient = (tokens: CSSValue[]): CSSRadialGradientImage => {\n    let shape: CSSRadialShape = CSSRadialShape.CIRCLE;\n    let size: CSSRadialSize = CSSRadialExtent.FARTHEST_CORNER;\n    const stops: UnprocessedGradientColorStop[] = [];\n    const position: LengthPercentage[] = [];\n\n    parseFunctionArgs(tokens).forEach((arg, i) => {\n        let isColorStop = true;\n        if (i === 0) {\n            isColorStop = arg.reduce((acc, token) => {\n                if (isIdentToken(token)) {\n                    switch (token.value) {\n                        case 'center':\n                            position.push(FIFTY_PERCENT);\n                            return false;\n                        case 'top':\n                        case 'left':\n                            position.push(ZERO_LENGTH);\n                            return false;\n                        case 'right':\n                        case 'bottom':\n                            position.push(HUNDRED_PERCENT);\n                            return false;\n                    }\n                } else if (isLengthPercentage(token) || isLength(token)) {\n                    position.push(token);\n                    return false;\n                }\n\n                return acc;\n            }, isColorStop);\n        } else if (i === 1) {\n            isColorStop = arg.reduce((acc, token) => {\n                if (isIdentToken(token)) {\n                    switch (token.value) {\n                        case CIRCLE:\n                            shape = CSSRadialShape.CIRCLE;\n                            return false;\n                        case ELLIPSE:\n                            shape = CSSRadialShape.ELLIPSE;\n                            return false;\n                        case CONTAIN:\n                        case CLOSEST_SIDE:\n                            size = CSSRadialExtent.CLOSEST_SIDE;\n                            return false;\n                        case FARTHEST_SIDE:\n                            size = CSSRadialExtent.FARTHEST_SIDE;\n                            return false;\n                        case CLOSEST_CORNER:\n                            size = CSSRadialExtent.CLOSEST_CORNER;\n                            return false;\n                        case COVER:\n                        case FARTHEST_CORNER:\n                            size = CSSRadialExtent.FARTHEST_CORNER;\n                            return false;\n                    }\n                } else if (isLength(token) || isLengthPercentage(token)) {\n                    if (!Array.isArray(size)) {\n                        size = [];\n                    }\n                    size.push(token);\n                    return false;\n                }\n\n                return acc;\n            }, isColorStop);\n        }\n\n        if (isColorStop) {\n            const colorStop = parseColorStop(arg);\n            stops.push(colorStop);\n        }\n    });\n\n    return {size, shape, stops, position, type: CSSImageType.RADIAL_GRADIENT};\n};\n","import {CSSValue} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\nimport {Color} from './color';\nimport {linearGradient} from './functions/linear-gradient';\nimport {prefixLinearGradient} from './functions/-prefix-linear-gradient';\nimport {ITypeDescriptor} from '../ITypeDescriptor';\nimport {CacheStorage} from '../../core/cache-storage';\nimport {LengthPercentage} from './length-percentage';\nimport {webkitGradient} from './functions/-webkit-gradient';\nimport {radialGradient} from './functions/radial-gradient';\nimport {prefixRadialGradient} from './functions/-prefix-radial-gradient';\n\nexport enum CSSImageType {\n    URL,\n    LINEAR_GRADIENT,\n    RADIAL_GRADIENT\n}\n\nexport const isLinearGradient = (background: ICSSImage): background is CSSLinearGradientImage => {\n    return background.type === CSSImageType.LINEAR_GRADIENT;\n};\n\nexport const isRadialGradient = (background: ICSSImage): background is CSSRadialGradientImage => {\n    return background.type === CSSImageType.RADIAL_GRADIENT;\n};\n\nexport interface UnprocessedGradientColorStop {\n    color: Color;\n    stop: LengthPercentage | null;\n}\n\nexport interface GradientColorStop {\n    color: Color;\n    stop: number;\n}\n\nexport interface ICSSImage {\n    type: CSSImageType;\n}\n\nexport interface CSSURLImage extends ICSSImage {\n    url: string;\n    type: CSSImageType.URL;\n}\n\n// interface ICSSGeneratedImage extends ICSSImage {}\n\nexport type GradientCorner = [LengthPercentage, LengthPercentage];\n\ninterface ICSSGradientImage extends ICSSImage {\n    stops: UnprocessedGradientColorStop[];\n}\n\nexport interface CSSLinearGradientImage extends ICSSGradientImage {\n    angle: number | GradientCorner;\n    type: CSSImageType.LINEAR_GRADIENT;\n}\n\nexport enum CSSRadialShape {\n    CIRCLE,\n    ELLIPSE\n}\n\nexport enum CSSRadialExtent {\n    CLOSEST_SIDE,\n    FARTHEST_SIDE,\n    CLOSEST_CORNER,\n    FARTHEST_CORNER\n}\n\nexport type CSSRadialSize = CSSRadialExtent | LengthPercentage[];\n\nexport interface CSSRadialGradientImage extends ICSSGradientImage {\n    type: CSSImageType.RADIAL_GRADIENT;\n    shape: CSSRadialShape;\n    size: CSSRadialSize;\n    position: LengthPercentage[];\n}\n\nexport const image: ITypeDescriptor<ICSSImage> = {\n    name: 'image',\n    parse: (value: CSSValue): ICSSImage => {\n        if (value.type === TokenType.URL_TOKEN) {\n            const image: CSSURLImage = {url: value.value, type: CSSImageType.URL};\n            CacheStorage.getInstance().addImage(value.value);\n            return image;\n        }\n\n        if (value.type === TokenType.FUNCTION) {\n            const imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];\n            if (typeof imageFunction === 'undefined') {\n                throw new Error(`Attempting to parse an unsupported image function \"${value.name}\"`);\n            }\n            return imageFunction(value.values);\n        }\n\n        throw new Error(`Unsupported image type`);\n    }\n};\n\nexport function isSupportedImage(value: CSSValue) {\n    return value.type !== TokenType.FUNCTION || SUPPORTED_IMAGE_FUNCTIONS[value.name];\n}\n\nconst SUPPORTED_IMAGE_FUNCTIONS: Record<string, (args: CSSValue[]) => ICSSImage> = {\n    'linear-gradient': linearGradient,\n    '-moz-linear-gradient': prefixLinearGradient,\n    '-ms-linear-gradient': prefixLinearGradient,\n    '-o-linear-gradient': prefixLinearGradient,\n    '-webkit-linear-gradient': prefixLinearGradient,\n    'radial-gradient': radialGradient,\n    '-moz-radial-gradient': prefixRadialGradient,\n    '-ms-radial-gradient': prefixRadialGradient,\n    '-o-radial-gradient': prefixRadialGradient,\n    '-webkit-radial-gradient': prefixRadialGradient,\n    '-webkit-gradient': webkitGradient\n};\n","import {TokenType} from '../syntax/tokenizer';\nimport {ICSSImage, image, isSupportedImage} from '../types/image';\nimport {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, nonFunctionArgSeparator} from '../syntax/parser';\n\nexport const backgroundImage: IPropertyListDescriptor<ICSSImage[]> = {\n    name: 'background-image',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]) => {\n        if (tokens.length === 0) {\n            return [];\n        }\n\n        const first = tokens[0];\n\n        if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {\n            return [];\n        }\n\n        return tokens.filter(value => nonFunctionArgSeparator(value) && isSupportedImage(value)).map(image.parse);\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\n\nexport const enum BACKGROUND_ORIGIN {\n    BORDER_BOX = 0,\n    PADDING_BOX = 1,\n    CONTENT_BOX = 2\n}\n\nexport type BackgroundOrigin = BACKGROUND_ORIGIN[];\n\nexport const backgroundOrigin: IPropertyListDescriptor<BackgroundOrigin> = {\n    name: 'background-origin',\n    initialValue: 'border-box',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): BackgroundOrigin => {\n        return tokens.map(token => {\n            if (isIdentToken(token)) {\n                switch (token.value) {\n                    case 'padding-box':\n                        return BACKGROUND_ORIGIN.PADDING_BOX;\n                    case 'content-box':\n                        return BACKGROUND_ORIGIN.CONTENT_BOX;\n                }\n            }\n            return BACKGROUND_ORIGIN.BORDER_BOX;\n        });\n    }\n};\n","import {PropertyDescriptorParsingType, IPropertyListDescriptor} from '../IPropertyDescriptor';\nimport {CSSValue, parseFunctionArgs} from '../syntax/parser';\nimport {isLengthPercentage, LengthPercentageTuple, parseLengthPercentageTuple} from '../types/length-percentage';\nexport type BackgroundPosition = BackgroundImagePosition[];\n\nexport type BackgroundImagePosition = LengthPercentageTuple;\n\nexport const backgroundPosition: IPropertyListDescriptor<BackgroundPosition> = {\n    name: 'background-position',\n    initialValue: '0% 0%',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]): BackgroundPosition => {\n        return parseFunctionArgs(tokens)\n            .map((values: CSSValue[]) => values.filter(isLengthPercentage))\n            .map(parseLengthPercentageTuple);\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken, parseFunctionArgs} from '../syntax/parser';\nexport type BackgroundRepeat = BACKGROUND_REPEAT[];\n\nexport enum BACKGROUND_REPEAT {\n    REPEAT = 0,\n    NO_REPEAT = 1,\n    REPEAT_X = 2,\n    REPEAT_Y = 3\n}\n\nexport const backgroundRepeat: IPropertyListDescriptor<BackgroundRepeat> = {\n    name: 'background-repeat',\n    initialValue: 'repeat',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): BackgroundRepeat => {\n        return parseFunctionArgs(tokens)\n            .map(values =>\n                values\n                    .filter(isIdentToken)\n                    .map(token => token.value)\n                    .join(' ')\n            )\n            .map(parseBackgroundRepeat);\n    }\n};\n\nconst parseBackgroundRepeat = (value: string): BACKGROUND_REPEAT => {\n    switch (value) {\n        case 'no-repeat':\n            return BACKGROUND_REPEAT.NO_REPEAT;\n        case 'repeat-x':\n        case 'repeat no-repeat':\n            return BACKGROUND_REPEAT.REPEAT_X;\n        case 'repeat-y':\n        case 'no-repeat repeat':\n            return BACKGROUND_REPEAT.REPEAT_Y;\n        case 'repeat':\n        default:\n            return BACKGROUND_REPEAT.REPEAT;\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken, parseFunctionArgs} from '../syntax/parser';\nimport {isLengthPercentage, LengthPercentage} from '../types/length-percentage';\nimport {StringValueToken} from '../syntax/tokenizer';\n\nexport enum BACKGROUND_SIZE {\n    AUTO = 'auto',\n    CONTAIN = 'contain',\n    COVER = 'cover'\n}\n\nexport type BackgroundSizeInfo = LengthPercentage | StringValueToken;\nexport type BackgroundSize = BackgroundSizeInfo[][];\n\nexport const backgroundSize: IPropertyListDescriptor<BackgroundSize> = {\n    name: 'background-size',\n    initialValue: '0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): BackgroundSize => {\n        return parseFunctionArgs(tokens).map(values => values.filter(isBackgroundSizeInfoToken));\n    }\n};\n\nconst isBackgroundSizeInfoToken = (value: CSSValue): value is BackgroundSizeInfo =>\n    isIdentToken(value) || isLengthPercentage(value);\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nconst borderColorForSide = (side: string): IPropertyTypeValueDescriptor => ({\n    name: `border-${side}-color`,\n    initialValue: 'transparent',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'color'\n});\n\nexport const borderTopColor: IPropertyTypeValueDescriptor = borderColorForSide('top');\nexport const borderRightColor: IPropertyTypeValueDescriptor = borderColorForSide('right');\nexport const borderBottomColor: IPropertyTypeValueDescriptor = borderColorForSide('bottom');\nexport const borderLeftColor: IPropertyTypeValueDescriptor = borderColorForSide('left');\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\nimport {isLengthPercentage, LengthPercentageTuple, parseLengthPercentageTuple} from '../types/length-percentage';\nexport type BorderRadius = LengthPercentageTuple;\n\nconst borderRadiusForSide = (side: string): IPropertyListDescriptor<BorderRadius> => ({\n    name: `border-radius-${side}`,\n    initialValue: '0 0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): BorderRadius => parseLengthPercentageTuple(tokens.filter(isLengthPercentage))\n});\n\nexport const borderTopLeftRadius: IPropertyListDescriptor<BorderRadius> = borderRadiusForSide('top-left');\nexport const borderTopRightRadius: IPropertyListDescriptor<BorderRadius> = borderRadiusForSide('top-right');\nexport const borderBottomRightRadius: IPropertyListDescriptor<BorderRadius> = borderRadiusForSide('bottom-right');\nexport const borderBottomLeftRadius: IPropertyListDescriptor<BorderRadius> = borderRadiusForSide('bottom-left');\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum BORDER_STYLE {\n    NONE = 0,\n    SOLID = 1\n}\n\nconst borderStyleForSide = (side: string): IPropertyIdentValueDescriptor<BORDER_STYLE> => ({\n    name: `border-${side}-style`,\n    initialValue: 'solid',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (style: string): BORDER_STYLE => {\n        switch (style) {\n            case 'none':\n                return BORDER_STYLE.NONE;\n        }\n        return BORDER_STYLE.SOLID;\n    }\n});\n\nexport const borderTopStyle: IPropertyIdentValueDescriptor<BORDER_STYLE> = borderStyleForSide('top');\nexport const borderRightStyle: IPropertyIdentValueDescriptor<BORDER_STYLE> = borderStyleForSide('right');\nexport const borderBottomStyle: IPropertyIdentValueDescriptor<BORDER_STYLE> = borderStyleForSide('bottom');\nexport const borderLeftStyle: IPropertyIdentValueDescriptor<BORDER_STYLE> = borderStyleForSide('left');\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isDimensionToken} from '../syntax/parser';\nconst borderWidthForSide = (side: string): IPropertyValueDescriptor<number> => ({\n    name: `border-${side}-width`,\n    initialValue: '0',\n    type: PropertyDescriptorParsingType.VALUE,\n    prefix: false,\n    parse: (token: CSSValue): number => {\n        if (isDimensionToken(token)) {\n            return token.number;\n        }\n        return 0;\n    }\n});\n\nexport const borderTopWidth: IPropertyValueDescriptor<number> = borderWidthForSide('top');\nexport const borderRightWidth: IPropertyValueDescriptor<number> = borderWidthForSide('right');\nexport const borderBottomWidth: IPropertyValueDescriptor<number> = borderWidthForSide('bottom');\nexport const borderLeftWidth: IPropertyValueDescriptor<number> = borderWidthForSide('left');\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nexport const color: IPropertyTypeValueDescriptor = {\n    name: `color`,\n    initialValue: 'transparent',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'color'\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\nexport const enum DISPLAY {\n    NONE = 0,\n    BLOCK = 1 << 1,\n    INLINE = 1 << 2,\n    RUN_IN = 1 << 3,\n    FLOW = 1 << 4,\n    FLOW_ROOT = 1 << 5,\n    TABLE = 1 << 6,\n    FLEX = 1 << 7,\n    GRID = 1 << 8,\n    RUBY = 1 << 9,\n    SUBGRID = 1 << 10,\n    LIST_ITEM = 1 << 11,\n    TABLE_ROW_GROUP = 1 << 12,\n    TABLE_HEADER_GROUP = 1 << 13,\n    TABLE_FOOTER_GROUP = 1 << 14,\n    TABLE_ROW = 1 << 15,\n    TABLE_CELL = 1 << 16,\n    TABLE_COLUMN_GROUP = 1 << 17,\n    TABLE_COLUMN = 1 << 18,\n    TABLE_CAPTION = 1 << 19,\n    RUBY_BASE = 1 << 20,\n    RUBY_TEXT = 1 << 21,\n    RUBY_BASE_CONTAINER = 1 << 22,\n    RUBY_TEXT_CONTAINER = 1 << 23,\n    CONTENTS = 1 << 24,\n    INLINE_BLOCK = 1 << 25,\n    INLINE_LIST_ITEM = 1 << 26,\n    INLINE_TABLE = 1 << 27,\n    INLINE_FLEX = 1 << 28,\n    INLINE_GRID = 1 << 29\n}\n\nexport type Display = number;\n\nexport const display: IPropertyListDescriptor<Display> = {\n    name: 'display',\n    initialValue: 'inline-block',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): Display => {\n        return tokens.filter(isIdentToken).reduce((bit, token) => {\n            return bit | parseDisplayValue(token.value);\n        }, DISPLAY.NONE);\n    }\n};\n\nconst parseDisplayValue = (display: string): Display => {\n    switch (display) {\n        case 'block':\n            return DISPLAY.BLOCK;\n        case 'inline':\n            return DISPLAY.INLINE;\n        case 'run-in':\n            return DISPLAY.RUN_IN;\n        case 'flow':\n            return DISPLAY.FLOW;\n        case 'flow-root':\n            return DISPLAY.FLOW_ROOT;\n        case 'table':\n            return DISPLAY.TABLE;\n        case 'flex':\n        case '-webkit-flex':\n            return DISPLAY.FLEX;\n        case 'grid':\n        case '-ms-grid':\n            return DISPLAY.GRID;\n        case 'ruby':\n            return DISPLAY.RUBY;\n        case 'subgrid':\n            return DISPLAY.SUBGRID;\n        case 'list-item':\n            return DISPLAY.LIST_ITEM;\n        case 'table-row-group':\n            return DISPLAY.TABLE_ROW_GROUP;\n        case 'table-header-group':\n            return DISPLAY.TABLE_HEADER_GROUP;\n        case 'table-footer-group':\n            return DISPLAY.TABLE_FOOTER_GROUP;\n        case 'table-row':\n            return DISPLAY.TABLE_ROW;\n        case 'table-cell':\n            return DISPLAY.TABLE_CELL;\n        case 'table-column-group':\n            return DISPLAY.TABLE_COLUMN_GROUP;\n        case 'table-column':\n            return DISPLAY.TABLE_COLUMN;\n        case 'table-caption':\n            return DISPLAY.TABLE_CAPTION;\n        case 'ruby-base':\n            return DISPLAY.RUBY_BASE;\n        case 'ruby-text':\n            return DISPLAY.RUBY_TEXT;\n        case 'ruby-base-container':\n            return DISPLAY.RUBY_BASE_CONTAINER;\n        case 'ruby-text-container':\n            return DISPLAY.RUBY_TEXT_CONTAINER;\n        case 'contents':\n            return DISPLAY.CONTENTS;\n        case 'inline-block':\n            return DISPLAY.INLINE_BLOCK;\n        case 'inline-list-item':\n            return DISPLAY.INLINE_LIST_ITEM;\n        case 'inline-table':\n            return DISPLAY.INLINE_TABLE;\n        case 'inline-flex':\n            return DISPLAY.INLINE_FLEX;\n        case 'inline-grid':\n            return DISPLAY.INLINE_GRID;\n    }\n\n    return DISPLAY.NONE;\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum FLOAT {\n    NONE = 0,\n    LEFT = 1,\n    RIGHT = 2,\n    INLINE_START = 3,\n    INLINE_END = 4\n}\n\nexport const float: IPropertyIdentValueDescriptor<FLOAT> = {\n    name: 'float',\n    initialValue: 'none',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (float: string) => {\n        switch (float) {\n            case 'left':\n                return FLOAT.LEFT;\n            case 'right':\n                return FLOAT.RIGHT;\n            case 'inline-start':\n                return FLOAT.INLINE_START;\n            case 'inline-end':\n                return FLOAT.INLINE_END;\n        }\n        return FLOAT.NONE;\n    }\n};\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\nexport const letterSpacing: IPropertyValueDescriptor<number> = {\n    name: 'letter-spacing',\n    initialValue: '0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.VALUE,\n    parse: (token: CSSValue) => {\n        if (token.type === TokenType.IDENT_TOKEN && token.value === 'normal') {\n            return 0;\n        }\n\n        if (token.type === TokenType.NUMBER_TOKEN) {\n            return token.number;\n        }\n\n        if (token.type === TokenType.DIMENSION_TOKEN) {\n            return token.number;\n        }\n\n        return 0;\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum LINE_BREAK {\n    NORMAL = 'normal',\n    STRICT = 'strict'\n}\n\nexport const lineBreak: IPropertyIdentValueDescriptor<LINE_BREAK> = {\n    name: 'line-break',\n    initialValue: 'normal',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (lineBreak: string): LINE_BREAK => {\n        switch (lineBreak) {\n            case 'strict':\n                return LINE_BREAK.STRICT;\n            case 'normal':\n            default:\n                return LINE_BREAK.NORMAL;\n        }\n    }\n};\n","import {IPropertyTokenValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\nimport {getAbsoluteValue, isLengthPercentage} from '../types/length-percentage';\nexport const lineHeight: IPropertyTokenValueDescriptor = {\n    name: 'line-height',\n    initialValue: 'normal',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TOKEN_VALUE\n};\n\nexport const computeLineHeight = (token: CSSValue, fontSize: number): number => {\n    if (isIdentToken(token) && token.value === 'normal') {\n        return 1.2 * fontSize;\n    } else if (token.type === TokenType.NUMBER_TOKEN) {\n        return fontSize * token.number;\n    } else if (isLengthPercentage(token)) {\n        return getAbsoluteValue(token, fontSize);\n    }\n\n    return fontSize;\n};\n","import {TokenType} from '../syntax/tokenizer';\nimport {ICSSImage, image} from '../types/image';\nimport {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\n\nexport const listStyleImage: IPropertyValueDescriptor<ICSSImage | null> = {\n    name: 'list-style-image',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.VALUE,\n    prefix: false,\n    parse: (token: CSSValue) => {\n        if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {\n            return null;\n        }\n\n        return image.parse(token);\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum LIST_STYLE_POSITION {\n    INSIDE = 0,\n    OUTSIDE = 1\n}\n\nexport const listStylePosition: IPropertyIdentValueDescriptor<LIST_STYLE_POSITION> = {\n    name: 'list-style-position',\n    initialValue: 'outside',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (position: string) => {\n        switch (position) {\n            case 'inside':\n                return LIST_STYLE_POSITION.INSIDE;\n            case 'outside':\n            default:\n                return LIST_STYLE_POSITION.OUTSIDE;\n        }\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum LIST_STYLE_TYPE {\n    NONE = -1,\n    DISC = 0,\n    CIRCLE = 1,\n    SQUARE = 2,\n    DECIMAL = 3,\n    CJK_DECIMAL = 4,\n    DECIMAL_LEADING_ZERO = 5,\n    LOWER_ROMAN = 6,\n    UPPER_ROMAN = 7,\n    LOWER_GREEK = 8,\n    LOWER_ALPHA = 9,\n    UPPER_ALPHA = 10,\n    ARABIC_INDIC = 11,\n    ARMENIAN = 12,\n    BENGALI = 13,\n    CAMBODIAN = 14,\n    CJK_EARTHLY_BRANCH = 15,\n    CJK_HEAVENLY_STEM = 16,\n    CJK_IDEOGRAPHIC = 17,\n    DEVANAGARI = 18,\n    ETHIOPIC_NUMERIC = 19,\n    GEORGIAN = 20,\n    GUJARATI = 21,\n    GURMUKHI = 22,\n    HEBREW = 22,\n    HIRAGANA = 23,\n    HIRAGANA_IROHA = 24,\n    JAPANESE_FORMAL = 25,\n    JAPANESE_INFORMAL = 26,\n    KANNADA = 27,\n    KATAKANA = 28,\n    KATAKANA_IROHA = 29,\n    KHMER = 30,\n    KOREAN_HANGUL_FORMAL = 31,\n    KOREAN_HANJA_FORMAL = 32,\n    KOREAN_HANJA_INFORMAL = 33,\n    LAO = 34,\n    LOWER_ARMENIAN = 35,\n    MALAYALAM = 36,\n    MONGOLIAN = 37,\n    MYANMAR = 38,\n    ORIYA = 39,\n    PERSIAN = 40,\n    SIMP_CHINESE_FORMAL = 41,\n    SIMP_CHINESE_INFORMAL = 42,\n    TAMIL = 43,\n    TELUGU = 44,\n    THAI = 45,\n    TIBETAN = 46,\n    TRAD_CHINESE_FORMAL = 47,\n    TRAD_CHINESE_INFORMAL = 48,\n    UPPER_ARMENIAN = 49,\n    DISCLOSURE_OPEN = 50,\n    DISCLOSURE_CLOSED = 51\n}\n\nexport const listStyleType: IPropertyIdentValueDescriptor<LIST_STYLE_TYPE> = {\n    name: 'list-style-type',\n    initialValue: 'none',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (type: string) => {\n        switch (type) {\n            case 'disc':\n                return LIST_STYLE_TYPE.DISC;\n            case 'circle':\n                return LIST_STYLE_TYPE.CIRCLE;\n            case 'square':\n                return LIST_STYLE_TYPE.SQUARE;\n            case 'decimal':\n                return LIST_STYLE_TYPE.DECIMAL;\n            case 'cjk-decimal':\n                return LIST_STYLE_TYPE.CJK_DECIMAL;\n            case 'decimal-leading-zero':\n                return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;\n            case 'lower-roman':\n                return LIST_STYLE_TYPE.LOWER_ROMAN;\n            case 'upper-roman':\n                return LIST_STYLE_TYPE.UPPER_ROMAN;\n            case 'lower-greek':\n                return LIST_STYLE_TYPE.LOWER_GREEK;\n            case 'lower-alpha':\n                return LIST_STYLE_TYPE.LOWER_ALPHA;\n            case 'upper-alpha':\n                return LIST_STYLE_TYPE.UPPER_ALPHA;\n            case 'arabic-indic':\n                return LIST_STYLE_TYPE.ARABIC_INDIC;\n            case 'armenian':\n                return LIST_STYLE_TYPE.ARMENIAN;\n            case 'bengali':\n                return LIST_STYLE_TYPE.BENGALI;\n            case 'cambodian':\n                return LIST_STYLE_TYPE.CAMBODIAN;\n            case 'cjk-earthly-branch':\n                return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;\n            case 'cjk-heavenly-stem':\n                return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;\n            case 'cjk-ideographic':\n                return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;\n            case 'devanagari':\n                return LIST_STYLE_TYPE.DEVANAGARI;\n            case 'ethiopic-numeric':\n                return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;\n            case 'georgian':\n                return LIST_STYLE_TYPE.GEORGIAN;\n            case 'gujarati':\n                return LIST_STYLE_TYPE.GUJARATI;\n            case 'gurmukhi':\n                return LIST_STYLE_TYPE.GURMUKHI;\n            case 'hebrew':\n                return LIST_STYLE_TYPE.HEBREW;\n            case 'hiragana':\n                return LIST_STYLE_TYPE.HIRAGANA;\n            case 'hiragana-iroha':\n                return LIST_STYLE_TYPE.HIRAGANA_IROHA;\n            case 'japanese-formal':\n                return LIST_STYLE_TYPE.JAPANESE_FORMAL;\n            case 'japanese-informal':\n                return LIST_STYLE_TYPE.JAPANESE_INFORMAL;\n            case 'kannada':\n                return LIST_STYLE_TYPE.KANNADA;\n            case 'katakana':\n                return LIST_STYLE_TYPE.KATAKANA;\n            case 'katakana-iroha':\n                return LIST_STYLE_TYPE.KATAKANA_IROHA;\n            case 'khmer':\n                return LIST_STYLE_TYPE.KHMER;\n            case 'korean-hangul-formal':\n                return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;\n            case 'korean-hanja-formal':\n                return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;\n            case 'korean-hanja-informal':\n                return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;\n            case 'lao':\n                return LIST_STYLE_TYPE.LAO;\n            case 'lower-armenian':\n                return LIST_STYLE_TYPE.LOWER_ARMENIAN;\n            case 'malayalam':\n                return LIST_STYLE_TYPE.MALAYALAM;\n            case 'mongolian':\n                return LIST_STYLE_TYPE.MONGOLIAN;\n            case 'myanmar':\n                return LIST_STYLE_TYPE.MYANMAR;\n            case 'oriya':\n                return LIST_STYLE_TYPE.ORIYA;\n            case 'persian':\n                return LIST_STYLE_TYPE.PERSIAN;\n            case 'simp-chinese-formal':\n                return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;\n            case 'simp-chinese-informal':\n                return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;\n            case 'tamil':\n                return LIST_STYLE_TYPE.TAMIL;\n            case 'telugu':\n                return LIST_STYLE_TYPE.TELUGU;\n            case 'thai':\n                return LIST_STYLE_TYPE.THAI;\n            case 'tibetan':\n                return LIST_STYLE_TYPE.TIBETAN;\n            case 'trad-chinese-formal':\n                return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;\n            case 'trad-chinese-informal':\n                return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;\n            case 'upper-armenian':\n                return LIST_STYLE_TYPE.UPPER_ARMENIAN;\n            case 'disclosure-open':\n                return LIST_STYLE_TYPE.DISCLOSURE_OPEN;\n            case 'disclosure-closed':\n                return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;\n            case 'none':\n            default:\n                return LIST_STYLE_TYPE.NONE;\n        }\n    }\n};\n","import {IPropertyTokenValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nconst marginForSide = (side: string): IPropertyTokenValueDescriptor => ({\n    name: `margin-${side}`,\n    initialValue: '0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TOKEN_VALUE\n});\n\nexport const marginTop: IPropertyTokenValueDescriptor = marginForSide('top');\nexport const marginRight: IPropertyTokenValueDescriptor = marginForSide('right');\nexport const marginBottom: IPropertyTokenValueDescriptor = marginForSide('bottom');\nexport const marginLeft: IPropertyTokenValueDescriptor = marginForSide('left');\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\nexport enum OVERFLOW {\n    VISIBLE = 0,\n    HIDDEN = 1,\n    SCROLL = 2,\n    AUTO = 3\n}\n\nexport const overflow: IPropertyListDescriptor<OVERFLOW[]> = {\n    name: 'overflow',\n    initialValue: 'visible',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): OVERFLOW[] => {\n        return tokens.filter(isIdentToken).map(overflow => {\n            switch (overflow.value) {\n                case 'hidden':\n                    return OVERFLOW.HIDDEN;\n                case 'scroll':\n                    return OVERFLOW.SCROLL;\n                case 'auto':\n                    return OVERFLOW.AUTO;\n                case 'visible':\n                default:\n                    return OVERFLOW.VISIBLE;\n            }\n        });\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum OVERFLOW_WRAP {\n    NORMAL = 'normal',\n    BREAK_WORD = 'break-word'\n}\n\nexport const overflowWrap: IPropertyIdentValueDescriptor<OVERFLOW_WRAP> = {\n    name: 'overflow-wrap',\n    initialValue: 'normal',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (overflow: string) => {\n        switch (overflow) {\n            case 'break-word':\n                return OVERFLOW_WRAP.BREAK_WORD;\n            case 'normal':\n            default:\n                return OVERFLOW_WRAP.NORMAL;\n        }\n    }\n};\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nconst paddingForSide = (side: string): IPropertyTypeValueDescriptor => ({\n    name: `padding-${side}`,\n    initialValue: '0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'length-percentage'\n});\n\nexport const paddingTop: IPropertyTypeValueDescriptor = paddingForSide('top');\nexport const paddingRight: IPropertyTypeValueDescriptor = paddingForSide('right');\nexport const paddingBottom: IPropertyTypeValueDescriptor = paddingForSide('bottom');\nexport const paddingLeft: IPropertyTypeValueDescriptor = paddingForSide('left');\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum TEXT_ALIGN {\n    LEFT = 0,\n    CENTER = 1,\n    RIGHT = 2\n}\n\nexport const textAlign: IPropertyIdentValueDescriptor<TEXT_ALIGN> = {\n    name: 'text-align',\n    initialValue: 'left',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (textAlign: string) => {\n        switch (textAlign) {\n            case 'right':\n                return TEXT_ALIGN.RIGHT;\n            case 'center':\n            case 'justify':\n                return TEXT_ALIGN.CENTER;\n            case 'left':\n            default:\n                return TEXT_ALIGN.LEFT;\n        }\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum POSITION {\n    STATIC = 0,\n    RELATIVE = 1,\n    ABSOLUTE = 2,\n    FIXED = 3,\n    STICKY = 4\n}\n\nexport const position: IPropertyIdentValueDescriptor<POSITION> = {\n    name: 'position',\n    initialValue: 'static',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (position: string) => {\n        switch (position) {\n            case 'relative':\n                return POSITION.RELATIVE;\n            case 'absolute':\n                return POSITION.ABSOLUTE;\n            case 'fixed':\n                return POSITION.FIXED;\n            case 'sticky':\n                return POSITION.STICKY;\n        }\n\n        return POSITION.STATIC;\n    }\n};\n","import {PropertyDescriptorParsingType, IPropertyListDescriptor} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentWithValue, parseFunctionArgs} from '../syntax/parser';\nimport {ZERO_LENGTH} from '../types/length-percentage';\nimport {color, Color, COLORS} from '../types/color';\nimport {isLength, Length} from '../types/length';\n\nexport type TextShadow = TextShadowItem[];\ninterface TextShadowItem {\n    color: Color;\n    offsetX: Length;\n    offsetY: Length;\n    blur: Length;\n}\n\nexport const textShadow: IPropertyListDescriptor<TextShadow> = {\n    name: 'text-shadow',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]): TextShadow => {\n        if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {\n            return [];\n        }\n\n        return parseFunctionArgs(tokens).map((values: CSSValue[]) => {\n            const shadow: TextShadowItem = {\n                color: COLORS.TRANSPARENT,\n                offsetX: ZERO_LENGTH,\n                offsetY: ZERO_LENGTH,\n                blur: ZERO_LENGTH\n            };\n            let c = 0;\n            for (let i = 0; i < values.length; i++) {\n                const token = values[i];\n                if (isLength(token)) {\n                    if (c === 0) {\n                        shadow.offsetX = token;\n                    } else if (c === 1) {\n                        shadow.offsetY = token;\n                    } else {\n                        shadow.blur = token;\n                    }\n                    c++;\n                } else {\n                    shadow.color = color.parse(token);\n                }\n            }\n            return shadow;\n        });\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum TEXT_TRANSFORM {\n    NONE = 0,\n    LOWERCASE = 1,\n    UPPERCASE = 2,\n    CAPITALIZE = 3\n}\n\nexport const textTransform: IPropertyIdentValueDescriptor<TEXT_TRANSFORM> = {\n    name: 'text-transform',\n    initialValue: 'none',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (textTransform: string) => {\n        switch (textTransform) {\n            case 'uppercase':\n                return TEXT_TRANSFORM.UPPERCASE;\n            case 'lowercase':\n                return TEXT_TRANSFORM.LOWERCASE;\n            case 'capitalize':\n                return TEXT_TRANSFORM.CAPITALIZE;\n        }\n\n        return TEXT_TRANSFORM.NONE;\n    }\n};\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\nimport {NumberValueToken, TokenType} from '../syntax/tokenizer';\nexport type Matrix = [number, number, number, number, number, number];\nexport type Transform = Matrix | null;\n\nexport const transform: IPropertyValueDescriptor<Transform> = {\n    name: 'transform',\n    initialValue: 'none',\n    prefix: true,\n    type: PropertyDescriptorParsingType.VALUE,\n    parse: (token: CSSValue) => {\n        if (token.type === TokenType.IDENT_TOKEN && token.value === 'none') {\n            return null;\n        }\n\n        if (token.type === TokenType.FUNCTION) {\n            const transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];\n            if (typeof transformFunction === 'undefined') {\n                throw new Error(`Attempting to parse an unsupported transform function \"${token.name}\"`);\n            }\n            return transformFunction(token.values);\n        }\n\n        return null;\n    }\n};\n\nconst matrix = (args: CSSValue[]): Transform => {\n    const values = args.filter(arg => arg.type === TokenType.NUMBER_TOKEN).map((arg: NumberValueToken) => arg.number);\n\n    return values.length === 6 ? (values as Matrix) : null;\n};\n\n// doesn't support 3D transforms at the moment\nconst matrix3d = (args: CSSValue[]): Transform => {\n    const values = args.filter(arg => arg.type === TokenType.NUMBER_TOKEN).map((arg: NumberValueToken) => arg.number);\n\n    const [a1, b1, {}, {}, a2, b2, {}, {}, {}, {}, {}, {}, a4, b4, {}, {}] = values;\n\n    return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;\n};\n\nconst SUPPORTED_TRANSFORM_FUNCTIONS: {\n    [key: string]: (args: CSSValue[]) => Transform;\n} = {\n    matrix: matrix,\n    matrix3d: matrix3d\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\nimport {isLengthPercentage, LengthPercentage} from '../types/length-percentage';\nimport {FLAG_INTEGER, TokenType} from '../syntax/tokenizer';\nexport type TransformOrigin = [LengthPercentage, LengthPercentage];\n\nconst DEFAULT_VALUE: LengthPercentage = {\n    type: TokenType.PERCENTAGE_TOKEN,\n    number: 50,\n    flags: FLAG_INTEGER\n};\nconst DEFAULT: TransformOrigin = [DEFAULT_VALUE, DEFAULT_VALUE];\n\nexport const transformOrigin: IPropertyListDescriptor<TransformOrigin> = {\n    name: 'transform-origin',\n    initialValue: '50% 50%',\n    prefix: true,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]) => {\n        const origins: LengthPercentage[] = tokens.filter(isLengthPercentage);\n\n        if (origins.length !== 2) {\n            return DEFAULT;\n        }\n\n        return [origins[0], origins[1]];\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum VISIBILITY {\n    VISIBLE = 0,\n    HIDDEN = 1,\n    COLLAPSE = 2\n}\n\nexport const visibility: IPropertyIdentValueDescriptor<VISIBILITY> = {\n    name: 'visible',\n    initialValue: 'none',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (visibility: string) => {\n        switch (visibility) {\n            case 'hidden':\n                return VISIBILITY.HIDDEN;\n            case 'collapse':\n                return VISIBILITY.COLLAPSE;\n            case 'visible':\n            default:\n                return VISIBILITY.VISIBLE;\n        }\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum WORD_BREAK {\n    NORMAL = 'normal',\n    BREAK_ALL = 'break-all',\n    KEEP_ALL = 'keep-all'\n}\n\nexport const wordBreak: IPropertyIdentValueDescriptor<WORD_BREAK> = {\n    name: 'word-break',\n    initialValue: 'normal',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (wordBreak: string): WORD_BREAK => {\n        switch (wordBreak) {\n            case 'break-all':\n                return WORD_BREAK.BREAK_ALL;\n            case 'keep-all':\n                return WORD_BREAK.KEEP_ALL;\n            case 'normal':\n            default:\n                return WORD_BREAK.NORMAL;\n        }\n    }\n};\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isNumberToken} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\n\ninterface zIndex {\n    order: number;\n    auto: boolean;\n}\n\nexport const zIndex: IPropertyValueDescriptor<zIndex> = {\n    name: 'z-index',\n    initialValue: 'auto',\n    prefix: false,\n    type: PropertyDescriptorParsingType.VALUE,\n    parse: (token: CSSValue): zIndex => {\n        if (token.type === TokenType.IDENT_TOKEN) {\n            return {auto: true, order: 0};\n        }\n\n        if (isNumberToken(token)) {\n            return {auto: false, order: token.number};\n        }\n\n        throw new Error(`Invalid z-index number parsed`);\n    }\n};\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isNumberToken} from '../syntax/parser';\nexport const opacity: IPropertyValueDescriptor<number> = {\n    name: 'opacity',\n    initialValue: '1',\n    type: PropertyDescriptorParsingType.VALUE,\n    prefix: false,\n    parse: (token: CSSValue): number => {\n        if (isNumberToken(token)) {\n            return token.number;\n        }\n        return 1;\n    }\n};\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nexport const textDecorationColor: IPropertyTypeValueDescriptor = {\n    name: `text-decoration-color`,\n    initialValue: 'transparent',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'color'\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\n\nexport const enum TEXT_DECORATION_LINE {\n    NONE = 0,\n    UNDERLINE = 1,\n    OVERLINE = 2,\n    LINE_THROUGH = 3,\n    BLINK = 4\n}\n\nexport type TextDecorationLine = TEXT_DECORATION_LINE[];\n\nexport const textDecorationLine: IPropertyListDescriptor<TextDecorationLine> = {\n    name: 'text-decoration-line',\n    initialValue: 'none',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]): TextDecorationLine => {\n        return tokens\n            .filter(isIdentToken)\n            .map(token => {\n                switch (token.value) {\n                    case 'underline':\n                        return TEXT_DECORATION_LINE.UNDERLINE;\n                    case 'overline':\n                        return TEXT_DECORATION_LINE.OVERLINE;\n                    case 'line-through':\n                        return TEXT_DECORATION_LINE.LINE_THROUGH;\n                    case 'none':\n                        return TEXT_DECORATION_LINE.BLINK;\n                }\n                return TEXT_DECORATION_LINE.NONE;\n            })\n            .filter(line => line !== TEXT_DECORATION_LINE.NONE);\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\nimport {StringValueToken, TokenType} from '../syntax/tokenizer';\n\nexport type FONT_FAMILY = string;\n\nexport type FontFamily = FONT_FAMILY[];\n\nexport const fontFamily: IPropertyListDescriptor<FontFamily> = {\n    name: `font-family`,\n    initialValue: '',\n    prefix: false,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]) => {\n        return tokens.filter(isStringToken).map(token => token.value);\n    }\n};\n\nconst isStringToken = (token: CSSValue): token is StringValueToken =>\n    token.type === TokenType.STRING_TOKEN || token.type === TokenType.IDENT_TOKEN;\n","import {IPropertyTypeValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\n\nexport const fontSize: IPropertyTypeValueDescriptor = {\n    name: `font-size`,\n    initialValue: '0',\n    prefix: false,\n    type: PropertyDescriptorParsingType.TYPE_VALUE,\n    format: 'length'\n};\n","import {IPropertyValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken, isNumberToken} from '../syntax/parser';\nexport const fontWeight: IPropertyValueDescriptor<number> = {\n    name: 'font-weight',\n    initialValue: 'normal',\n    type: PropertyDescriptorParsingType.VALUE,\n    prefix: false,\n    parse: (token: CSSValue): number => {\n        if (isNumberToken(token)) {\n            return token.number;\n        }\n\n        if (isIdentToken(token)) {\n            switch (token.value) {\n                case 'bold':\n                    return 700;\n                case 'normal':\n                default:\n                    return 400;\n            }\n        }\n\n        return 400;\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken} from '../syntax/parser';\nexport const fontVariant: IPropertyListDescriptor<string[]> = {\n    name: 'font-variant',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]): string[] => {\n        return tokens.filter(isIdentToken).map(token => token.value);\n    }\n};\n","import {IPropertyIdentValueDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nexport enum FONT_STYLE {\n    NORMAL = 'normal',\n    ITALIC = 'italic',\n    OBLIQUE = 'oblique'\n}\n\nexport const fontStyle: IPropertyIdentValueDescriptor<FONT_STYLE> = {\n    name: 'font-style',\n    initialValue: 'normal',\n    prefix: false,\n    type: PropertyDescriptorParsingType.IDENT_VALUE,\n    parse: (overflow: string) => {\n        switch (overflow) {\n            case 'oblique':\n                return FONT_STYLE.OBLIQUE;\n            case 'italic':\n                return FONT_STYLE.ITALIC;\n            case 'normal':\n            default:\n                return FONT_STYLE.NORMAL;\n        }\n    }\n};\n","export const contains = (bit: number, value: number): boolean => (bit & value) !== 0;\n","import {TokenType} from '../syntax/tokenizer';\nimport {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue} from '../syntax/parser';\n\nexport type Content = CSSValue[];\n\nexport const content: IPropertyListDescriptor<Content> = {\n    name: 'content',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]) => {\n        if (tokens.length === 0) {\n            return [];\n        }\n\n        const first = tokens[0];\n\n        if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {\n            return [];\n        }\n\n        return tokens;\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isNumberToken, nonWhiteSpace} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\n\nexport interface COUNTER_INCREMENT {\n    counter: string;\n    increment: number;\n}\n\nexport type CounterIncrement = COUNTER_INCREMENT[] | null;\n\nexport const counterIncrement: IPropertyListDescriptor<CounterIncrement> = {\n    name: 'counter-increment',\n    initialValue: 'none',\n    prefix: true,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]) => {\n        if (tokens.length === 0) {\n            return null;\n        }\n\n        const first = tokens[0];\n\n        if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {\n            return null;\n        }\n\n        const increments = [];\n        const filtered = tokens.filter(nonWhiteSpace);\n\n        for (let i = 0; i < filtered.length; i++) {\n            const counter = filtered[i];\n            const next = filtered[i + 1];\n            if (counter.type === TokenType.IDENT_TOKEN) {\n                const increment = next && isNumberToken(next) ? next.number : 1;\n                increments.push({counter: counter.value, increment});\n            }\n        }\n\n        return increments;\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentToken, isNumberToken, nonWhiteSpace} from '../syntax/parser';\n\nexport interface COUNTER_RESET {\n    counter: string;\n    reset: number;\n}\n\nexport type CounterReset = COUNTER_RESET[];\n\nexport const counterReset: IPropertyListDescriptor<CounterReset> = {\n    name: 'counter-reset',\n    initialValue: 'none',\n    prefix: true,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]) => {\n        if (tokens.length === 0) {\n            return [];\n        }\n\n        const resets = [];\n        const filtered = tokens.filter(nonWhiteSpace);\n\n        for (let i = 0; i < filtered.length; i++) {\n            const counter = filtered[i];\n            const next = filtered[i + 1];\n            if (isIdentToken(counter) && counter.value !== 'none') {\n                const reset = next && isNumberToken(next) ? next.number : 0;\n                resets.push({counter: counter.value, reset});\n            }\n        }\n\n        return resets;\n    }\n};\n","import {IPropertyListDescriptor, PropertyDescriptorParsingType} from '../IPropertyDescriptor';\nimport {CSSValue, isStringToken} from '../syntax/parser';\nimport {TokenType} from '../syntax/tokenizer';\n\nexport interface QUOTE {\n    open: string;\n    close: string;\n}\n\nexport type Quotes = QUOTE[] | null;\n\nexport const quotes: IPropertyListDescriptor<Quotes> = {\n    name: 'quotes',\n    initialValue: 'none',\n    prefix: true,\n    type: PropertyDescriptorParsingType.LIST,\n    parse: (tokens: CSSValue[]) => {\n        if (tokens.length === 0) {\n            return null;\n        }\n\n        const first = tokens[0];\n\n        if (first.type === TokenType.IDENT_TOKEN && first.value === 'none') {\n            return null;\n        }\n\n        const quotes = [];\n        const filtered = tokens.filter(isStringToken);\n\n        if (filtered.length % 2 !== 0) {\n            return null;\n        }\n\n        for (let i = 0; i < filtered.length; i += 2) {\n            const open = filtered[i].value;\n            const close = filtered[i + 1].value;\n            quotes.push({open, close});\n        }\n\n        return quotes;\n    }\n};\n\nexport const getQuote = (quotes: Quotes, depth: number, open: boolean): string => {\n    if (!quotes) {\n        return '';\n    }\n\n    const quote = quotes[Math.min(depth, quotes.length - 1)];\n    if (!quote) {\n        return '';\n    }\n\n    return open ? quote.open : quote.close;\n};\n","import {PropertyDescriptorParsingType, IPropertyListDescriptor} from '../IPropertyDescriptor';\nimport {CSSValue, isIdentWithValue, parseFunctionArgs} from '../syntax/parser';\nimport {ZERO_LENGTH} from '../types/length-percentage';\nimport {color, Color} from '../types/color';\nimport {isLength, Length} from '../types/length';\n\nexport type BoxShadow = BoxShadowItem[];\ninterface BoxShadowItem {\n    inset: boolean;\n    color: Color;\n    offsetX: Length;\n    offsetY: Length;\n    blur: Length;\n    spread: Length;\n}\n\nexport const boxShadow: IPropertyListDescriptor<BoxShadow> = {\n    name: 'box-shadow',\n    initialValue: 'none',\n    type: PropertyDescriptorParsingType.LIST,\n    prefix: false,\n    parse: (tokens: CSSValue[]): BoxShadow => {\n        if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {\n            return [];\n        }\n\n        return parseFunctionArgs(tokens).map((values: CSSValue[]) => {\n            const shadow: BoxShadowItem = {\n                color: 0x000000ff,\n                offsetX: ZERO_LENGTH,\n                offsetY: ZERO_LENGTH,\n                blur: ZERO_LENGTH,\n                spread: ZERO_LENGTH,\n                inset: false\n            };\n            let c = 0;\n            for (let i = 0; i < values.length; i++) {\n                const token = values[i];\n                if (isIdentWithValue(token, 'inset')) {\n                    shadow.inset = true;\n                } else if (isLength(token)) {\n                    if (c === 0) {\n                        shadow.offsetX = token;\n                    } else if (c === 1) {\n                        shadow.offsetY = token;\n                    } else if (c === 2) {\n                        shadow.blur = token;\n                    } else {\n                        shadow.spread = token;\n                    }\n                    c++;\n                } else {\n                    shadow.color = color.parse(token);\n                }\n            }\n            return shadow;\n        });\n    }\n};\n","import {CSSPropertyDescriptor, PropertyDescriptorParsingType} from './IPropertyDescriptor';\nimport {backgroundClip} from './property-descriptors/background-clip';\nimport {backgroundColor} from './property-descriptors/background-color';\nimport {backgroundImage} from './property-descriptors/background-image';\nimport {backgroundOrigin} from './property-descriptors/background-origin';\nimport {backgroundPosition} from './property-descriptors/background-position';\nimport {backgroundRepeat} from './property-descriptors/background-repeat';\nimport {backgroundSize} from './property-descriptors/background-size';\nimport {\n    borderBottomColor,\n    borderLeftColor,\n    borderRightColor,\n    borderTopColor\n} from './property-descriptors/border-color';\nimport {\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n    borderTopLeftRadius,\n    borderTopRightRadius\n} from './property-descriptors/border-radius';\nimport {\n    borderBottomStyle,\n    borderLeftStyle,\n    borderRightStyle,\n    borderTopStyle\n} from './property-descriptors/border-style';\nimport {\n    borderBottomWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderTopWidth\n} from './property-descriptors/border-width';\nimport {color} from './property-descriptors/color';\nimport {display, DISPLAY} from './property-descriptors/display';\nimport {float, FLOAT} from './property-descriptors/float';\nimport {letterSpacing} from './property-descriptors/letter-spacing';\nimport {lineBreak} from './property-descriptors/line-break';\nimport {lineHeight} from './property-descriptors/line-height';\nimport {listStyleImage} from './property-descriptors/list-style-image';\nimport {listStylePosition} from './property-descriptors/list-style-position';\nimport {listStyleType} from './property-descriptors/list-style-type';\nimport {marginBottom, marginLeft, marginRight, marginTop} from './property-descriptors/margin';\nimport {overflow, OVERFLOW} from './property-descriptors/overflow';\nimport {overflowWrap} from './property-descriptors/overflow-wrap';\nimport {paddingBottom, paddingLeft, paddingRight, paddingTop} from './property-descriptors/padding';\nimport {textAlign} from './property-descriptors/text-align';\nimport {position, POSITION} from './property-descriptors/position';\nimport {textShadow} from './property-descriptors/text-shadow';\nimport {textTransform} from './property-descriptors/text-transform';\nimport {transform} from './property-descriptors/transform';\nimport {transformOrigin} from './property-descriptors/transform-origin';\nimport {visibility, VISIBILITY} from './property-descriptors/visibility';\nimport {wordBreak} from './property-descriptors/word-break';\nimport {zIndex} from './property-descriptors/z-index';\nimport {CSSValue, isIdentToken, Parser} from './syntax/parser';\nimport {Tokenizer} from './syntax/tokenizer';\nimport {Color, color as colorType, isTransparent} from './types/color';\nimport {angle} from './types/angle';\nimport {image} from './types/image';\nimport {opacity} from './property-descriptors/opacity';\nimport {textDecorationColor} from './property-descriptors/text-decoration-color';\nimport {textDecorationLine} from './property-descriptors/text-decoration-line';\nimport {isLengthPercentage, LengthPercentage, ZERO_LENGTH} from './types/length-percentage';\nimport {fontFamily} from './property-descriptors/font-family';\nimport {fontSize} from './property-descriptors/font-size';\nimport {isLength} from './types/length';\nimport {fontWeight} from './property-descriptors/font-weight';\nimport {fontVariant} from './property-descriptors/font-variant';\nimport {fontStyle} from './property-descriptors/font-style';\nimport {contains} from '../core/bitwise';\nimport {content} from './property-descriptors/content';\nimport {counterIncrement} from './property-descriptors/counter-increment';\nimport {counterReset} from './property-descriptors/counter-reset';\nimport {quotes} from './property-descriptors/quotes';\nimport {boxShadow} from './property-descriptors/box-shadow';\n\nexport class CSSParsedDeclaration {\n    backgroundClip: ReturnType<typeof backgroundClip.parse>;\n    backgroundColor: Color;\n    backgroundImage: ReturnType<typeof backgroundImage.parse>;\n    backgroundOrigin: ReturnType<typeof backgroundOrigin.parse>;\n    backgroundPosition: ReturnType<typeof backgroundPosition.parse>;\n    backgroundRepeat: ReturnType<typeof backgroundRepeat.parse>;\n    backgroundSize: ReturnType<typeof backgroundSize.parse>;\n    borderTopColor: Color;\n    borderRightColor: Color;\n    borderBottomColor: Color;\n    borderLeftColor: Color;\n    borderTopLeftRadius: ReturnType<typeof borderTopLeftRadius.parse>;\n    borderTopRightRadius: ReturnType<typeof borderTopRightRadius.parse>;\n    borderBottomRightRadius: ReturnType<typeof borderBottomRightRadius.parse>;\n    borderBottomLeftRadius: ReturnType<typeof borderBottomLeftRadius.parse>;\n    borderTopStyle: ReturnType<typeof borderTopStyle.parse>;\n    borderRightStyle: ReturnType<typeof borderRightStyle.parse>;\n    borderBottomStyle: ReturnType<typeof borderBottomStyle.parse>;\n    borderLeftStyle: ReturnType<typeof borderLeftStyle.parse>;\n    borderTopWidth: ReturnType<typeof borderTopWidth.parse>;\n    borderRightWidth: ReturnType<typeof borderRightWidth.parse>;\n    borderBottomWidth: ReturnType<typeof borderBottomWidth.parse>;\n    borderLeftWidth: ReturnType<typeof borderLeftWidth.parse>;\n    boxShadow: ReturnType<typeof boxShadow.parse>;\n    color: Color;\n    display: ReturnType<typeof display.parse>;\n    float: ReturnType<typeof float.parse>;\n    fontFamily: ReturnType<typeof fontFamily.parse>;\n    fontSize: LengthPercentage;\n    fontStyle: ReturnType<typeof fontStyle.parse>;\n    fontVariant: ReturnType<typeof fontVariant.parse>;\n    fontWeight: ReturnType<typeof fontWeight.parse>;\n    letterSpacing: ReturnType<typeof letterSpacing.parse>;\n    lineBreak: ReturnType<typeof lineBreak.parse>;\n    lineHeight: CSSValue;\n    listStyleImage: ReturnType<typeof listStyleImage.parse>;\n    listStylePosition: ReturnType<typeof listStylePosition.parse>;\n    listStyleType: ReturnType<typeof listStyleType.parse>;\n    marginTop: CSSValue;\n    marginRight: CSSValue;\n    marginBottom: CSSValue;\n    marginLeft: CSSValue;\n    opacity: ReturnType<typeof opacity.parse>;\n    overflowX: OVERFLOW;\n    overflowY: OVERFLOW;\n    overflowWrap: ReturnType<typeof overflowWrap.parse>;\n    paddingTop: LengthPercentage;\n    paddingRight: LengthPercentage;\n    paddingBottom: LengthPercentage;\n    paddingLeft: LengthPercentage;\n    position: ReturnType<typeof position.parse>;\n    textAlign: ReturnType<typeof textAlign.parse>;\n    textDecorationColor: Color;\n    textDecorationLine: ReturnType<typeof textDecorationLine.parse>;\n    textShadow: ReturnType<typeof textShadow.parse>;\n    textTransform: ReturnType<typeof textTransform.parse>;\n    transform: ReturnType<typeof transform.parse>;\n    transformOrigin: ReturnType<typeof transformOrigin.parse>;\n    visibility: ReturnType<typeof visibility.parse>;\n    wordBreak: ReturnType<typeof wordBreak.parse>;\n    zIndex: ReturnType<typeof zIndex.parse>;\n\n    constructor(declaration: CSSStyleDeclaration) {\n        this.backgroundClip = parse(backgroundClip, declaration.backgroundClip);\n        this.backgroundColor = parse(backgroundColor, declaration.backgroundColor);\n        this.backgroundImage = parse(backgroundImage, declaration.backgroundImage);\n        this.backgroundOrigin = parse(backgroundOrigin, declaration.backgroundOrigin);\n        this.backgroundPosition = parse(backgroundPosition, declaration.backgroundPosition);\n        this.backgroundRepeat = parse(backgroundRepeat, declaration.backgroundRepeat);\n        this.backgroundSize = parse(backgroundSize, declaration.backgroundSize);\n        this.borderTopColor = parse(borderTopColor, declaration.borderTopColor);\n        this.borderRightColor = parse(borderRightColor, declaration.borderRightColor);\n        this.borderBottomColor = parse(borderBottomColor, declaration.borderBottomColor);\n        this.borderLeftColor = parse(borderLeftColor, declaration.borderLeftColor);\n        this.borderTopLeftRadius = parse(borderTopLeftRadius, declaration.borderTopLeftRadius);\n        this.borderTopRightRadius = parse(borderTopRightRadius, declaration.borderTopRightRadius);\n        this.borderBottomRightRadius = parse(borderBottomRightRadius, declaration.borderBottomRightRadius);\n        this.borderBottomLeftRadius = parse(borderBottomLeftRadius, declaration.borderBottomLeftRadius);\n        this.borderTopStyle = parse(borderTopStyle, declaration.borderTopStyle);\n        this.borderRightStyle = parse(borderRightStyle, declaration.borderRightStyle);\n        this.borderBottomStyle = parse(borderBottomStyle, declaration.borderBottomStyle);\n        this.borderLeftStyle = parse(borderLeftStyle, declaration.borderLeftStyle);\n        this.borderTopWidth = parse(borderTopWidth, declaration.borderTopWidth);\n        this.borderRightWidth = parse(borderRightWidth, declaration.borderRightWidth);\n        this.borderBottomWidth = parse(borderBottomWidth, declaration.borderBottomWidth);\n        this.borderLeftWidth = parse(borderLeftWidth, declaration.borderLeftWidth);\n        this.boxShadow = parse(boxShadow, declaration.boxShadow);\n        this.color = parse(color, declaration.color);\n        this.display = parse(display, declaration.display);\n        this.float = parse(float, declaration.cssFloat);\n        this.fontFamily = parse(fontFamily, declaration.fontFamily);\n        this.fontSize = parse(fontSize, declaration.fontSize);\n        this.fontStyle = parse(fontStyle, declaration.fontStyle);\n        this.fontVariant = parse(fontVariant, declaration.fontVariant);\n        this.fontWeight = parse(fontWeight, declaration.fontWeight);\n        this.letterSpacing = parse(letterSpacing, declaration.letterSpacing);\n        this.lineBreak = parse(lineBreak, declaration.lineBreak);\n        this.lineHeight = parse(lineHeight, declaration.lineHeight);\n        this.listStyleImage = parse(listStyleImage, declaration.listStyleImage);\n        this.listStylePosition = parse(listStylePosition, declaration.listStylePosition);\n        this.listStyleType = parse(listStyleType, declaration.listStyleType);\n        this.marginTop = parse(marginTop, declaration.marginTop);\n        this.marginRight = parse(marginRight, declaration.marginRight);\n        this.marginBottom = parse(marginBottom, declaration.marginBottom);\n        this.marginLeft = parse(marginLeft, declaration.marginLeft);\n        this.opacity = parse(opacity, declaration.opacity);\n        const overflowTuple = parse(overflow, declaration.overflow);\n        this.overflowX = overflowTuple[0];\n        this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];\n        this.overflowWrap = parse(overflowWrap, declaration.overflowWrap);\n        this.paddingTop = parse(paddingTop, declaration.paddingTop);\n        this.paddingRight = parse(paddingRight, declaration.paddingRight);\n        this.paddingBottom = parse(paddingBottom, declaration.paddingBottom);\n        this.paddingLeft = parse(paddingLeft, declaration.paddingLeft);\n        this.position = parse(position, declaration.position);\n        this.textAlign = parse(textAlign, declaration.textAlign);\n        this.textDecorationColor = parse(textDecorationColor, declaration.textDecorationColor || declaration.color);\n        this.textDecorationLine = parse(textDecorationLine, declaration.textDecorationLine);\n        this.textShadow = parse(textShadow, declaration.textShadow);\n        this.textTransform = parse(textTransform, declaration.textTransform);\n        this.transform = parse(transform, declaration.transform);\n        this.transformOrigin = parse(transformOrigin, declaration.transformOrigin);\n        this.visibility = parse(visibility, declaration.visibility);\n        this.wordBreak = parse(wordBreak, declaration.wordBreak);\n        this.zIndex = parse(zIndex, declaration.zIndex);\n    }\n\n    isVisible(): boolean {\n        return this.display > 0 && this.opacity > 0 && this.visibility === VISIBILITY.VISIBLE;\n    }\n\n    isTransparent(): boolean {\n        return isTransparent(this.backgroundColor);\n    }\n\n    isTransformed(): boolean {\n        return this.transform !== null;\n    }\n\n    isPositioned(): boolean {\n        return this.position !== POSITION.STATIC;\n    }\n\n    isPositionedWithZIndex(): boolean {\n        return this.isPositioned() && !this.zIndex.auto;\n    }\n\n    isFloating(): boolean {\n        return this.float !== FLOAT.NONE;\n    }\n\n    isInlineLevel(): boolean {\n        return (\n            contains(this.display, DISPLAY.INLINE) ||\n            contains(this.display, DISPLAY.INLINE_BLOCK) ||\n            contains(this.display, DISPLAY.INLINE_FLEX) ||\n            contains(this.display, DISPLAY.INLINE_GRID) ||\n            contains(this.display, DISPLAY.INLINE_LIST_ITEM) ||\n            contains(this.display, DISPLAY.INLINE_TABLE)\n        );\n    }\n}\n\nexport class CSSParsedPseudoDeclaration {\n    content: ReturnType<typeof content.parse>;\n    quotes: ReturnType<typeof quotes.parse>;\n\n    constructor(declaration: CSSStyleDeclaration) {\n        this.content = parse(content, declaration.content);\n        this.quotes = parse(quotes, declaration.quotes);\n    }\n}\n\nexport class CSSParsedCounterDeclaration {\n    counterIncrement: ReturnType<typeof counterIncrement.parse>;\n    counterReset: ReturnType<typeof counterReset.parse>;\n\n    constructor(declaration: CSSStyleDeclaration) {\n        this.counterIncrement = parse(counterIncrement, declaration.counterIncrement);\n        this.counterReset = parse(counterReset, declaration.counterReset);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst parse = (descriptor: CSSPropertyDescriptor<any>, style?: string | null) => {\n    const tokenizer = new Tokenizer();\n    const value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;\n    tokenizer.write(value);\n    const parser = new Parser(tokenizer.read());\n    switch (descriptor.type) {\n        case PropertyDescriptorParsingType.IDENT_VALUE:\n            const token = parser.parseComponentValue();\n            return descriptor.parse(isIdentToken(token) ? token.value : descriptor.initialValue);\n        case PropertyDescriptorParsingType.VALUE:\n            return descriptor.parse(parser.parseComponentValue());\n        case PropertyDescriptorParsingType.LIST:\n            return descriptor.parse(parser.parseComponentValues());\n        case PropertyDescriptorParsingType.TOKEN_VALUE:\n            return parser.parseComponentValue();\n        case PropertyDescriptorParsingType.TYPE_VALUE:\n            switch (descriptor.format) {\n                case 'angle':\n                    return angle.parse(parser.parseComponentValue());\n                case 'color':\n                    return colorType.parse(parser.parseComponentValue());\n                case 'image':\n                    return image.parse(parser.parseComponentValue());\n                case 'length':\n                    const length = parser.parseComponentValue();\n                    return isLength(length) ? length : ZERO_LENGTH;\n                case 'length-percentage':\n                    const value = parser.parseComponentValue();\n                    return isLengthPercentage(value) ? value : ZERO_LENGTH;\n            }\n    }\n\n    throw new Error(`Attempting to parse unsupported css format type ${descriptor.format}`);\n};\n","import {CSSParsedDeclaration} from '../css/index';\nimport {TextContainer} from './text-container';\nimport {Bounds, parseBounds} from '../css/layout/bounds';\nimport {isHTMLElementNode} from './node-parser';\n\nexport const enum FLAGS {\n    CREATES_STACKING_CONTEXT = 1 << 1,\n    CREATES_REAL_STACKING_CONTEXT = 1 << 2,\n    IS_LIST_OWNER = 1 << 3\n}\n\nexport class ElementContainer {\n    readonly styles: CSSParsedDeclaration;\n    readonly textNodes: TextContainer[];\n    readonly elements: ElementContainer[];\n    bounds: Bounds;\n    flags: number;\n\n    constructor(element: Element) {\n        this.styles = new CSSParsedDeclaration(window.getComputedStyle(element, null));\n        this.textNodes = [];\n        this.elements = [];\n        if (this.styles.transform !== null && isHTMLElementNode(element)) {\n            // getBoundingClientRect takes transforms into account\n            element.style.transform = 'none';\n        }\n        this.bounds = parseBounds(element);\n        this.flags = 0;\n    }\n}\n","import {OVERFLOW_WRAP} from '../property-descriptors/overflow-wrap';\nimport {CSSParsedDeclaration} from '../index';\nimport {fromCodePoint, LineBreaker, toCodePoints} from 'css-line-break';\nimport {Bounds, parseBounds} from './bounds';\nimport {FEATURES} from '../../core/features';\n\nexport class TextBounds {\n    readonly text: string;\n    readonly bounds: Bounds;\n\n    constructor(text: string, bounds: Bounds) {\n        this.text = text;\n        this.bounds = bounds;\n    }\n}\n\nexport const parseTextBounds = (value: string, styles: CSSParsedDeclaration, node: Text): TextBounds[] => {\n    const textList = breakText(value, styles);\n    const textBounds: TextBounds[] = [];\n    let offset = 0;\n    textList.forEach(text => {\n        if (styles.textDecorationLine.length || text.trim().length > 0) {\n            if (FEATURES.SUPPORT_RANGE_BOUNDS) {\n                textBounds.push(new TextBounds(text, getRangeBounds(node, offset, text.length)));\n            } else {\n                const replacementNode = node.splitText(text.length);\n                textBounds.push(new TextBounds(text, getWrapperBounds(node)));\n                node = replacementNode;\n            }\n        } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {\n            node = node.splitText(text.length);\n        }\n        offset += text.length;\n    });\n\n    return textBounds;\n};\n\nconst getWrapperBounds = (node: Text): Bounds => {\n    const ownerDocument = node.ownerDocument;\n    if (ownerDocument) {\n        const wrapper = ownerDocument.createElement('html2canvaswrapper');\n        wrapper.appendChild(node.cloneNode(true));\n        const parentNode = node.parentNode;\n        if (parentNode) {\n            parentNode.replaceChild(wrapper, node);\n            const bounds = parseBounds(wrapper);\n            if (wrapper.firstChild) {\n                parentNode.replaceChild(wrapper.firstChild, wrapper);\n            }\n            return bounds;\n        }\n    }\n\n    return new Bounds(0, 0, 0, 0);\n};\n\nconst getRangeBounds = (node: Text, offset: number, length: number): Bounds => {\n    const ownerDocument = node.ownerDocument;\n    if (!ownerDocument) {\n        throw new Error('Node has no owner document');\n    }\n    const range = ownerDocument.createRange();\n    range.setStart(node, offset);\n    range.setEnd(node, offset + length);\n    return Bounds.fromClientRect(range.getBoundingClientRect());\n};\n\nconst breakText = (value: string, styles: CSSParsedDeclaration): string[] => {\n    return styles.letterSpacing !== 0 ? toCodePoints(value).map(i => fromCodePoint(i)) : breakWords(value, styles);\n};\n\nconst breakWords = (str: string, styles: CSSParsedDeclaration): string[] => {\n    const breaker = LineBreaker(str, {\n        lineBreak: styles.lineBreak,\n        wordBreak: styles.overflowWrap === OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : styles.wordBreak\n    });\n\n    const words = [];\n    let bk;\n\n    while (!(bk = breaker.next()).done) {\n        if (bk.value) {\n            words.push(bk.value.slice());\n        }\n    }\n\n    return words;\n};\n","import {CSSParsedDeclaration} from '../css/index';\nimport {TEXT_TRANSFORM} from '../css/property-descriptors/text-transform';\nimport {parseTextBounds, TextBounds} from '../css/layout/text';\n\nexport class TextContainer {\n    text: string;\n    textBounds: TextBounds[];\n\n    constructor(node: Text, styles: CSSParsedDeclaration) {\n        this.text = transform(node.data, styles.textTransform);\n        this.textBounds = parseTextBounds(this.text, styles, node);\n    }\n}\n\nconst transform = (text: string, transform: TEXT_TRANSFORM) => {\n    switch (transform) {\n        case TEXT_TRANSFORM.LOWERCASE:\n            return text.toLowerCase();\n        case TEXT_TRANSFORM.CAPITALIZE:\n            return text.replace(CAPITALIZE, capitalize);\n        case TEXT_TRANSFORM.UPPERCASE:\n            return text.toUpperCase();\n        default:\n            return text;\n    }\n};\n\nconst CAPITALIZE = /(^|\\s|:|-|\\(|\\))([a-z])/g;\n\nconst capitalize = (m: string, p1: string, p2: string) => {\n    if (m.length > 0) {\n        return p1 + p2.toUpperCase();\n    }\n\n    return m;\n};\n","import {ElementContainer} from '../element-container';\nimport {CacheStorage} from '../../core/cache-storage';\n\nexport class ImageElementContainer extends ElementContainer {\n    src: string;\n    intrinsicWidth: number;\n    intrinsicHeight: number;\n\n    constructor(img: HTMLImageElement) {\n        super(img);\n        this.src = img.currentSrc || img.src;\n        this.intrinsicWidth = img.naturalWidth;\n        this.intrinsicHeight = img.naturalHeight;\n        CacheStorage.getInstance().addImage(this.src);\n    }\n}\n","import {ElementContainer} from '../element-container';\n\nexport class CanvasElementContainer extends ElementContainer {\n    canvas: HTMLCanvasElement;\n    intrinsicWidth: number;\n    intrinsicHeight: number;\n\n    constructor(canvas: HTMLCanvasElement) {\n        super(canvas);\n        this.canvas = canvas;\n        this.intrinsicWidth = canvas.width;\n        this.intrinsicHeight = canvas.height;\n    }\n}\n","import {ElementContainer} from '../element-container';\nimport {CacheStorage} from '../../core/cache-storage';\n\nexport class SVGElementContainer extends ElementContainer {\n    svg: string;\n    intrinsicWidth: number;\n    intrinsicHeight: number;\n\n    constructor(img: SVGSVGElement) {\n        super(img);\n        const s = new XMLSerializer();\n        this.svg = `data:image/svg+xml,${encodeURIComponent(s.serializeToString(img))}`;\n        this.intrinsicWidth = img.width.baseVal.value;\n        this.intrinsicHeight = img.height.baseVal.value;\n\n        CacheStorage.getInstance().addImage(this.svg);\n    }\n}\n","import {ElementContainer} from '../element-container';\nexport class LIElementContainer extends ElementContainer {\n    readonly value: number;\n\n    constructor(element: HTMLLIElement) {\n        super(element);\n        this.value = element.value;\n    }\n}\n","import {ElementContainer} from '../element-container';\nexport class OLElementContainer extends ElementContainer {\n    readonly start: number;\n    readonly reversed: boolean;\n\n    constructor(element: HTMLOListElement) {\n        super(element);\n        this.start = element.start;\n        this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;\n    }\n}\n","import {ElementContainer} from '../element-container';\nimport {BORDER_STYLE} from '../../css/property-descriptors/border-style';\nimport {BACKGROUND_CLIP} from '../../css/property-descriptors/background-clip';\nimport {BACKGROUND_ORIGIN} from '../../css/property-descriptors/background-origin';\nimport {TokenType} from '../../css/syntax/tokenizer';\nimport {LengthPercentageTuple} from '../../css/types/length-percentage';\nimport {Bounds} from '../../css/layout/bounds';\n\nconst CHECKBOX_BORDER_RADIUS: LengthPercentageTuple = [\n    {\n        type: TokenType.DIMENSION_TOKEN,\n        flags: 0,\n        unit: 'px',\n        number: 3\n    }\n];\n\nconst RADIO_BORDER_RADIUS: LengthPercentageTuple = [\n    {\n        type: TokenType.PERCENTAGE_TOKEN,\n        flags: 0,\n        number: 50\n    }\n];\n\nconst reformatInputBounds = (bounds: Bounds): Bounds => {\n    if (bounds.width > bounds.height) {\n        return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);\n    } else if (bounds.width < bounds.height) {\n        return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);\n    }\n    return bounds;\n};\n\nconst getInputValue = (node: HTMLInputElement): string => {\n    const value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\\u2022') : node.value;\n\n    return value.length === 0 ? node.placeholder || '' : value;\n};\n\nexport const CHECKBOX = 'checkbox';\nexport const RADIO = 'radio';\nexport const PASSWORD = 'password';\nexport const INPUT_COLOR = 0x2a2a2aff;\n\nexport class InputElementContainer extends ElementContainer {\n    readonly type: string;\n    readonly checked: boolean;\n    readonly value: string;\n\n    constructor(input: HTMLInputElement) {\n        super(input);\n        this.type = input.type.toLowerCase();\n        this.checked = input.checked;\n        this.value = getInputValue(input);\n\n        if (this.type === CHECKBOX || this.type === RADIO) {\n            this.styles.backgroundColor = 0xdededeff;\n            this.styles.borderTopColor = this.styles.borderRightColor = this.styles.borderBottomColor = this.styles.borderLeftColor = 0xa5a5a5ff;\n            this.styles.borderTopWidth = this.styles.borderRightWidth = this.styles.borderBottomWidth = this.styles.borderLeftWidth = 1;\n            this.styles.borderTopStyle = this.styles.borderRightStyle = this.styles.borderBottomStyle = this.styles.borderLeftStyle =\n                BORDER_STYLE.SOLID;\n            this.styles.backgroundClip = [BACKGROUND_CLIP.BORDER_BOX];\n            this.styles.backgroundOrigin = [BACKGROUND_ORIGIN.BORDER_BOX];\n            this.bounds = reformatInputBounds(this.bounds);\n        }\n\n        switch (this.type) {\n            case CHECKBOX:\n                this.styles.borderTopRightRadius = this.styles.borderTopLeftRadius = this.styles.borderBottomRightRadius = this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;\n                break;\n            case RADIO:\n                this.styles.borderTopRightRadius = this.styles.borderTopLeftRadius = this.styles.borderBottomRightRadius = this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;\n                break;\n        }\n    }\n}\n","import {ElementContainer} from '../element-container';\nexport class SelectElementContainer extends ElementContainer {\n    readonly value: string;\n    constructor(element: HTMLSelectElement) {\n        super(element);\n        const option = element.options[element.selectedIndex || 0];\n        this.value = option ? option.text || '' : '';\n    }\n}\n","import {ElementContainer} from '../element-container';\nexport class TextareaElementContainer extends ElementContainer {\n    readonly value: string;\n    constructor(element: HTMLTextAreaElement) {\n        super(element);\n        this.value = element.value;\n    }\n}\n","import {ElementContainer} from '../element-container';\nimport {parseTree} from '../node-parser';\nimport {Color, color, COLORS, isTransparent} from '../../css/types/color';\nimport {Parser} from '../../css/syntax/parser';\n\nconst parseColor = (value: string): Color => color.parse(Parser.create(value).parseComponentValue());\n\nexport class IFrameElementContainer extends ElementContainer {\n    src: string;\n    width: number;\n    height: number;\n    tree?: ElementContainer;\n    backgroundColor: Color;\n\n    constructor(iframe: HTMLIFrameElement) {\n        super(iframe);\n        this.src = iframe.src;\n        this.width = parseInt(iframe.width, 10) || 0;\n        this.height = parseInt(iframe.height, 10) || 0;\n        this.backgroundColor = this.styles.backgroundColor;\n        try {\n            if (\n                iframe.contentWindow &&\n                iframe.contentWindow.document &&\n                iframe.contentWindow.document.documentElement\n            ) {\n                this.tree = parseTree(iframe.contentWindow.document.documentElement);\n\n                // http://www.w3.org/TR/css3-background/#special-backgrounds\n                const documentBackgroundColor = iframe.contentWindow.document.documentElement\n                    ? parseColor(getComputedStyle(iframe.contentWindow.document.documentElement)\n                          .backgroundColor as string)\n                    : COLORS.TRANSPARENT;\n                const bodyBackgroundColor = iframe.contentWindow.document.body\n                    ? parseColor(getComputedStyle(iframe.contentWindow.document.body).backgroundColor as string)\n                    : COLORS.TRANSPARENT;\n\n                this.backgroundColor = isTransparent(documentBackgroundColor)\n                    ? isTransparent(bodyBackgroundColor)\n                        ? this.styles.backgroundColor\n                        : bodyBackgroundColor\n                    : documentBackgroundColor;\n            }\n        } catch (e) {}\n    }\n}\n","import {CSSParsedDeclaration} from '../css/index';\nimport {ElementContainer, FLAGS} from './element-container';\nimport {TextContainer} from './text-container';\nimport {ImageElementContainer} from './replaced-elements/image-element-container';\nimport {CanvasElementContainer} from './replaced-elements/canvas-element-container';\nimport {SVGElementContainer} from './replaced-elements/svg-element-container';\nimport {LIElementContainer} from './elements/li-element-container';\nimport {OLElementContainer} from './elements/ol-element-container';\nimport {InputElementContainer} from './replaced-elements/input-element-container';\nimport {SelectElementContainer} from './elements/select-element-container';\nimport {TextareaElementContainer} from './elements/textarea-element-container';\nimport {IFrameElementContainer} from './replaced-elements/iframe-element-container';\n\nconst LIST_OWNERS = ['OL', 'UL', 'MENU'];\n\nconst parseNodeTree = (node: Node, parent: ElementContainer, root: ElementContainer) => {\n    for (let childNode = node.firstChild, nextNode; childNode; childNode = nextNode) {\n        nextNode = childNode.nextSibling;\n\n        if (isTextNode(childNode) && childNode.data.trim().length > 0) {\n            parent.textNodes.push(new TextContainer(childNode, parent.styles));\n        } else if (isElementNode(childNode)) {\n            const container = createContainer(childNode);\n            if (container.styles.isVisible()) {\n                if (createsRealStackingContext(childNode, container, root)) {\n                    container.flags |= FLAGS.CREATES_REAL_STACKING_CONTEXT;\n                } else if (createsStackingContext(container.styles)) {\n                    container.flags |= FLAGS.CREATES_STACKING_CONTEXT;\n                }\n\n                if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {\n                    container.flags |= FLAGS.IS_LIST_OWNER;\n                }\n\n                parent.elements.push(container);\n                if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {\n                    parseNodeTree(childNode, container, root);\n                }\n            }\n        }\n    }\n};\n\nconst createContainer = (element: Element): ElementContainer => {\n    if (isImageElement(element)) {\n        return new ImageElementContainer(element);\n    }\n\n    if (isCanvasElement(element)) {\n        return new CanvasElementContainer(element);\n    }\n\n    if (isSVGElement(element)) {\n        return new SVGElementContainer(element);\n    }\n\n    if (isLIElement(element)) {\n        return new LIElementContainer(element);\n    }\n\n    if (isOLElement(element)) {\n        return new OLElementContainer(element);\n    }\n\n    if (isInputElement(element)) {\n        return new InputElementContainer(element);\n    }\n\n    if (isSelectElement(element)) {\n        return new SelectElementContainer(element);\n    }\n\n    if (isTextareaElement(element)) {\n        return new TextareaElementContainer(element);\n    }\n\n    if (isIFrameElement(element)) {\n        return new IFrameElementContainer(element);\n    }\n\n    return new ElementContainer(element);\n};\n\nexport const parseTree = (element: HTMLElement): ElementContainer => {\n    const container = createContainer(element);\n    container.flags |= FLAGS.CREATES_REAL_STACKING_CONTEXT;\n    parseNodeTree(element, container, container);\n    return container;\n};\n\nconst createsRealStackingContext = (node: Element, container: ElementContainer, root: ElementContainer): boolean => {\n    return (\n        container.styles.isPositionedWithZIndex() ||\n        container.styles.opacity < 1 ||\n        container.styles.isTransformed() ||\n        (isBodyElement(node) && root.styles.isTransparent())\n    );\n};\n\nconst createsStackingContext = (styles: CSSParsedDeclaration): boolean => styles.isPositioned() || styles.isFloating();\n\nexport const isTextNode = (node: Node): node is Text => node.nodeType === Node.TEXT_NODE;\nexport const isElementNode = (node: Node): node is Element => node.nodeType === Node.ELEMENT_NODE;\nexport const isHTMLElementNode = (node: Node): node is HTMLElement =>\n    typeof (node as HTMLElement).style !== 'undefined';\n\nexport const isLIElement = (node: Element): node is HTMLLIElement => node.tagName === 'LI';\nexport const isOLElement = (node: Element): node is HTMLOListElement => node.tagName === 'OL';\nexport const isInputElement = (node: Element): node is HTMLInputElement => node.tagName === 'INPUT';\nexport const isHTMLElement = (node: Element): node is HTMLHtmlElement => node.tagName === 'HTML';\nexport const isSVGElement = (node: Element): node is SVGSVGElement => node.tagName === 'svg';\nexport const isBodyElement = (node: Element): node is HTMLBodyElement => node.tagName === 'BODY';\nexport const isCanvasElement = (node: Element): node is HTMLCanvasElement => node.tagName === 'CANVAS';\nexport const isImageElement = (node: Element): node is HTMLImageElement => node.tagName === 'IMG';\nexport const isIFrameElement = (node: Element): node is HTMLIFrameElement => node.tagName === 'IFRAME';\nexport const isStyleElement = (node: Element): node is HTMLStyleElement => node.tagName === 'STYLE';\nexport const isScriptElement = (node: Element): node is HTMLScriptElement => node.tagName === 'SCRIPT';\nexport const isTextareaElement = (node: Element): node is HTMLTextAreaElement => node.tagName === 'TEXTAREA';\nexport const isSelectElement = (node: Element): node is HTMLSelectElement => node.tagName === 'SELECT';\n","import {LIST_STYLE_TYPE} from '../../property-descriptors/list-style-type';\nimport {fromCodePoint} from 'css-line-break';\nimport {contains} from '../../../core/bitwise';\nimport {CSSParsedCounterDeclaration} from '../../index';\n\nexport class CounterState {\n    readonly counters: {[key: string]: number[]};\n    constructor() {\n        this.counters = {};\n    }\n\n    getCounterValue(name: string) {\n        const counter = this.counters[name];\n\n        if (counter && counter.length) {\n            return counter[counter.length - 1];\n        }\n        return 1;\n    }\n\n    getCounterValues(name: string): number[] {\n        const counter = this.counters[name];\n        return counter ? counter : [];\n    }\n\n    pop(counters: string[]) {\n        counters.forEach(counter => this.counters[counter].pop());\n    }\n\n    parse(style: CSSParsedCounterDeclaration): string[] {\n        const counterIncrement = style.counterIncrement;\n        const counterReset = style.counterReset;\n        let canReset = true;\n\n        if (counterIncrement !== null) {\n            counterIncrement.forEach(entry => {\n                const counter = this.counters[entry.counter];\n                if (counter && entry.increment !== 0) {\n                    canReset = false;\n                    counter[Math.max(0, counter.length - 1)] += entry.increment;\n                }\n            });\n        }\n\n        const counterNames: string[] = [];\n        if (canReset) {\n            counterReset.forEach(entry => {\n                let counter = this.counters[entry.counter];\n                counterNames.push(entry.counter);\n                if (!counter) {\n                    counter = this.counters[entry.counter] = [];\n                }\n                counter.push(entry.reset);\n            });\n        }\n\n        return counterNames;\n    }\n}\n\ninterface CounterSymbols {\n    integers: number[];\n    values: string[];\n}\n\nconst ROMAN_UPPER: CounterSymbols = {\n    integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],\n    values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']\n};\n\nconst ARMENIAN: CounterSymbols = {\n    integers: [\n        9000,\n        8000,\n        7000,\n        6000,\n        5000,\n        4000,\n        3000,\n        2000,\n        1000,\n        900,\n        800,\n        700,\n        600,\n        500,\n        400,\n        300,\n        200,\n        100,\n        90,\n        80,\n        70,\n        60,\n        50,\n        40,\n        30,\n        20,\n        10,\n        9,\n        8,\n        7,\n        6,\n        5,\n        4,\n        3,\n        2,\n        1\n    ],\n    values: [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ]\n};\n\nconst HEBREW: CounterSymbols = {\n    integers: [\n        10000,\n        9000,\n        8000,\n        7000,\n        6000,\n        5000,\n        4000,\n        3000,\n        2000,\n        1000,\n        400,\n        300,\n        200,\n        100,\n        90,\n        80,\n        70,\n        60,\n        50,\n        40,\n        30,\n        20,\n        19,\n        18,\n        17,\n        16,\n        15,\n        10,\n        9,\n        8,\n        7,\n        6,\n        5,\n        4,\n        3,\n        2,\n        1\n    ],\n    values: [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ]\n};\n\nconst GEORGIAN: CounterSymbols = {\n    integers: [\n        10000,\n        9000,\n        8000,\n        7000,\n        6000,\n        5000,\n        4000,\n        3000,\n        2000,\n        1000,\n        900,\n        800,\n        700,\n        600,\n        500,\n        400,\n        300,\n        200,\n        100,\n        90,\n        80,\n        70,\n        60,\n        50,\n        40,\n        30,\n        20,\n        10,\n        9,\n        8,\n        7,\n        6,\n        5,\n        4,\n        3,\n        2,\n        1\n    ],\n    values: [\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        '',\n        ''\n    ]\n};\n\nconst createAdditiveCounter = (\n    value: number,\n    min: number,\n    max: number,\n    symbols: CounterSymbols,\n    fallback: LIST_STYLE_TYPE,\n    suffix: string\n) => {\n    if (value < min || value > max) {\n        return createCounterText(value, fallback, suffix.length > 0);\n    }\n\n    return (\n        symbols.integers.reduce((string, integer, index) => {\n            while (value >= integer) {\n                value -= integer;\n                string += symbols.values[index];\n            }\n            return string;\n        }, '') + suffix\n    );\n};\n\nconst createCounterStyleWithSymbolResolver = (\n    value: number,\n    codePointRangeLength: number,\n    isNumeric: boolean,\n    resolver: (codePoint: number) => string\n): string => {\n    let string = '';\n\n    do {\n        if (!isNumeric) {\n            value--;\n        }\n        string = resolver(value) + string;\n        value /= codePointRangeLength;\n    } while (value * codePointRangeLength >= codePointRangeLength);\n\n    return string;\n};\n\nconst createCounterStyleFromRange = (\n    value: number,\n    codePointRangeStart: number,\n    codePointRangeEnd: number,\n    isNumeric: boolean,\n    suffix: string\n): string => {\n    const codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;\n\n    return (\n        (value < 0 ? '-' : '') +\n        (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, codePoint =>\n            fromCodePoint(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart)\n        ) +\n            suffix)\n    );\n};\n\nconst createCounterStyleFromSymbols = (value: number, symbols: string, suffix: string = '. '): string => {\n    const codePointRangeLength = symbols.length;\n    return (\n        createCounterStyleWithSymbolResolver(\n            Math.abs(value),\n            codePointRangeLength,\n            false,\n            codePoint => symbols[Math.floor(codePoint % codePointRangeLength)]\n        ) + suffix\n    );\n};\n\nconst CJK_ZEROS = 1 << 0;\nconst CJK_TEN_COEFFICIENTS = 1 << 1;\nconst CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;\nconst CJK_HUNDRED_COEFFICIENTS = 1 << 3;\n\nconst createCJKCounter = (\n    value: number,\n    numbers: string,\n    multipliers: string,\n    negativeSign: string,\n    suffix: string,\n    flags: number\n): string => {\n    if (value < -9999 || value > 9999) {\n        return createCounterText(value, LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);\n    }\n    let tmp = Math.abs(value);\n    let string = suffix;\n\n    if (tmp === 0) {\n        return numbers[0] + string;\n    }\n\n    for (let digit = 0; tmp > 0 && digit <= 4; digit++) {\n        let coefficient = tmp % 10;\n\n        if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {\n            string = numbers[coefficient] + string;\n        } else if (\n            coefficient > 1 ||\n            (coefficient === 1 && digit === 0) ||\n            (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||\n            (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||\n            (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))\n        ) {\n            string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;\n        } else if (coefficient === 1 && digit > 0) {\n            string = multipliers[digit - 1] + string;\n        }\n        tmp = Math.floor(tmp / 10);\n    }\n\n    return (value < 0 ? negativeSign : '') + string;\n};\n\nconst CHINESE_INFORMAL_MULTIPLIERS = '';\nconst CHINESE_FORMAL_MULTIPLIERS = '';\nconst JAPANESE_NEGATIVE = '';\nconst KOREAN_NEGATIVE = '';\n\nexport const createCounterText = (value: number, type: LIST_STYLE_TYPE, appendSuffix: boolean): string => {\n    const defaultSuffix = appendSuffix ? '. ' : '';\n    const cjkSuffix = appendSuffix ? '' : '';\n    const koreanSuffix = appendSuffix ? ', ' : '';\n    const spaceSuffix = appendSuffix ? ' ' : '';\n    switch (type) {\n        case LIST_STYLE_TYPE.DISC:\n            return '' + spaceSuffix;\n        case LIST_STYLE_TYPE.CIRCLE:\n            return '' + spaceSuffix;\n        case LIST_STYLE_TYPE.SQUARE:\n            return '' + spaceSuffix;\n        case LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:\n            const string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n            return string.length < 4 ? `0${string}` : string;\n        case LIST_STYLE_TYPE.CJK_DECIMAL:\n            return createCounterStyleFromSymbols(value, '', cjkSuffix);\n        case LIST_STYLE_TYPE.LOWER_ROMAN:\n            return createAdditiveCounter(\n                value,\n                1,\n                3999,\n                ROMAN_UPPER,\n                LIST_STYLE_TYPE.DECIMAL,\n                defaultSuffix\n            ).toLowerCase();\n        case LIST_STYLE_TYPE.UPPER_ROMAN:\n            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);\n        case LIST_STYLE_TYPE.LOWER_GREEK:\n            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);\n        case LIST_STYLE_TYPE.LOWER_ALPHA:\n            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);\n        case LIST_STYLE_TYPE.UPPER_ALPHA:\n            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);\n        case LIST_STYLE_TYPE.ARABIC_INDIC:\n            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);\n        case LIST_STYLE_TYPE.ARMENIAN:\n        case LIST_STYLE_TYPE.UPPER_ARMENIAN:\n            return createAdditiveCounter(value, 1, 9999, ARMENIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);\n        case LIST_STYLE_TYPE.LOWER_ARMENIAN:\n            return createAdditiveCounter(\n                value,\n                1,\n                9999,\n                ARMENIAN,\n                LIST_STYLE_TYPE.DECIMAL,\n                defaultSuffix\n            ).toLowerCase();\n        case LIST_STYLE_TYPE.BENGALI:\n            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);\n        case LIST_STYLE_TYPE.CAMBODIAN:\n        case LIST_STYLE_TYPE.KHMER:\n            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);\n        case LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:\n            return createCounterStyleFromSymbols(value, '', cjkSuffix);\n        case LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:\n            return createCounterStyleFromSymbols(value, '', cjkSuffix);\n        case LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:\n        case LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                CHINESE_INFORMAL_MULTIPLIERS,\n                '',\n                cjkSuffix,\n                CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                CHINESE_FORMAL_MULTIPLIERS,\n                '',\n                cjkSuffix,\n                CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                CHINESE_INFORMAL_MULTIPLIERS,\n                '',\n                cjkSuffix,\n                CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                CHINESE_FORMAL_MULTIPLIERS,\n                '',\n                cjkSuffix,\n                CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.JAPANESE_INFORMAL:\n            return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, 0);\n        case LIST_STYLE_TYPE.JAPANESE_FORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                '',\n                JAPANESE_NEGATIVE,\n                cjkSuffix,\n                CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                '',\n                KOREAN_NEGATIVE,\n                koreanSuffix,\n                CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:\n            return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, 0);\n        case LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:\n            return createCJKCounter(\n                value,\n                '',\n                '',\n                KOREAN_NEGATIVE,\n                koreanSuffix,\n                CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS\n            );\n        case LIST_STYLE_TYPE.DEVANAGARI:\n            return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);\n        case LIST_STYLE_TYPE.GEORGIAN:\n            return createAdditiveCounter(value, 1, 19999, GEORGIAN, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);\n        case LIST_STYLE_TYPE.GUJARATI:\n            return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);\n        case LIST_STYLE_TYPE.GURMUKHI:\n            return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);\n        case LIST_STYLE_TYPE.HEBREW:\n            return createAdditiveCounter(value, 1, 10999, HEBREW, LIST_STYLE_TYPE.DECIMAL, defaultSuffix);\n        case LIST_STYLE_TYPE.HIRAGANA:\n            return createCounterStyleFromSymbols(\n                value,\n                ''\n            );\n        case LIST_STYLE_TYPE.HIRAGANA_IROHA:\n            return createCounterStyleFromSymbols(\n                value,\n                ''\n            );\n        case LIST_STYLE_TYPE.KANNADA:\n            return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);\n        case LIST_STYLE_TYPE.KATAKANA:\n            return createCounterStyleFromSymbols(\n                value,\n                '',\n                cjkSuffix\n            );\n        case LIST_STYLE_TYPE.KATAKANA_IROHA:\n            return createCounterStyleFromSymbols(\n                value,\n                '',\n                cjkSuffix\n            );\n        case LIST_STYLE_TYPE.LAO:\n            return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);\n        case LIST_STYLE_TYPE.MONGOLIAN:\n            return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);\n        case LIST_STYLE_TYPE.MYANMAR:\n            return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);\n        case LIST_STYLE_TYPE.ORIYA:\n            return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);\n        case LIST_STYLE_TYPE.PERSIAN:\n            return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);\n        case LIST_STYLE_TYPE.TAMIL:\n            return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);\n        case LIST_STYLE_TYPE.TELUGU:\n            return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);\n        case LIST_STYLE_TYPE.THAI:\n            return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);\n        case LIST_STYLE_TYPE.TIBETAN:\n            return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);\n        case LIST_STYLE_TYPE.DECIMAL:\n        default:\n            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);\n    }\n};\n","import {Bounds} from '../css/layout/bounds';\nimport {\n    isBodyElement,\n    isCanvasElement,\n    isElementNode,\n    isHTMLElementNode,\n    isIFrameElement,\n    isScriptElement,\n    isSelectElement,\n    isStyleElement,\n    isTextareaElement,\n    isTextNode\n} from './node-parser';\nimport {Logger} from '../core/logger';\nimport {isIdentToken, nonFunctionArgSeparator} from '../css/syntax/parser';\nimport {TokenType} from '../css/syntax/tokenizer';\nimport {CounterState, createCounterText} from '../css/types/functions/counter';\nimport {LIST_STYLE_TYPE, listStyleType} from '../css/property-descriptors/list-style-type';\nimport {CSSParsedCounterDeclaration, CSSParsedPseudoDeclaration} from '../css/index';\nimport {getQuote} from '../css/property-descriptors/quotes';\n\nexport interface CloneOptions {\n    id: string;\n    ignoreElements?: (element: Element) => boolean;\n    onclone?: (document: Document) => void;\n}\n\nexport type CloneConfigurations = CloneOptions & {\n    inlineImages: boolean;\n    copyStyles: boolean;\n};\n\nconst IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';\n\nexport class DocumentCloner {\n    private readonly scrolledElements: [Element, number, number][];\n    private readonly options: CloneConfigurations;\n    private readonly referenceElement: HTMLElement;\n    clonedReferenceElement?: HTMLElement;\n    private readonly documentElement: HTMLElement;\n    private readonly counters: CounterState;\n    private quoteDepth: number;\n\n    constructor(element: HTMLElement, options: CloneConfigurations) {\n        this.options = options;\n        this.scrolledElements = [];\n        this.referenceElement = element;\n        this.counters = new CounterState();\n        this.quoteDepth = 0;\n        if (!element.ownerDocument) {\n            throw new Error('Cloned element does not have an owner document');\n        }\n\n        this.documentElement = this.cloneNode(element.ownerDocument.documentElement) as HTMLElement;\n    }\n\n    toIFrame(ownerDocument: Document, windowSize: Bounds): Promise<HTMLIFrameElement> {\n        const iframe: HTMLIFrameElement = createIFrameContainer(ownerDocument, windowSize);\n\n        if (!iframe.contentWindow) {\n            return Promise.reject(`Unable to find iframe window`);\n        }\n\n        const scrollX = (ownerDocument.defaultView as Window).pageXOffset;\n        const scrollY = (ownerDocument.defaultView as Window).pageYOffset;\n\n        const cloneWindow = iframe.contentWindow;\n        const documentClone: Document = cloneWindow.document;\n\n        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle\n         if window url is about:blank, we can assign the url to current by writing onto the document\n         */\n\n        const iframeLoad = iframeLoader(iframe).then(async () => {\n            this.scrolledElements.forEach(restoreNodeScroll);\n            if (cloneWindow) {\n                cloneWindow.scrollTo(windowSize.left, windowSize.top);\n                if (\n                    /(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&\n                    (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)\n                ) {\n                    documentClone.documentElement.style.top = -windowSize.top + 'px';\n                    documentClone.documentElement.style.left = -windowSize.left + 'px';\n                    documentClone.documentElement.style.position = 'absolute';\n                }\n            }\n\n            const onclone = this.options.onclone;\n\n            if (typeof this.clonedReferenceElement === 'undefined') {\n                return Promise.reject(`Error finding the ${this.referenceElement.nodeName} in the cloned document`);\n            }\n\n            if (documentClone.fonts && documentClone.fonts.ready) {\n                await documentClone.fonts.ready;\n            }\n\n            if (typeof onclone === 'function') {\n                return Promise.resolve()\n                    .then(() => onclone(documentClone))\n                    .then(() => iframe);\n            }\n\n            return iframe;\n        });\n\n        documentClone.open();\n        documentClone.write(`${serializeDoctype(document.doctype)}<html></html>`);\n        // Chrome scrolls the parent document for some reason after the write to the cloned window???\n        restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);\n        documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);\n        documentClone.close();\n\n        return iframeLoad;\n    }\n\n    createElementClone(node: HTMLElement): HTMLElement {\n        if (isCanvasElement(node)) {\n            return this.createCanvasClone(node);\n        }\n        /*\n        if (isIFrameElement(node)) {\n            return this.createIFrameClone(node);\n        }\n*/\n        if (isStyleElement(node)) {\n            return this.createStyleClone(node);\n        }\n\n        return node.cloneNode(false) as HTMLElement;\n    }\n\n    createStyleClone(node: HTMLStyleElement): HTMLStyleElement {\n        try {\n            const sheet = node.sheet as CSSStyleSheet | undefined;\n            if (sheet && sheet.cssRules) {\n                const css: string = [].slice.call(sheet.cssRules, 0).reduce((css: string, rule: CSSRule) => {\n                    if (rule && typeof rule.cssText === 'string') {\n                        return css + rule.cssText;\n                    }\n                    return css;\n                }, '');\n                const style = node.cloneNode(false) as HTMLStyleElement;\n                style.textContent = css;\n                return style;\n            }\n        } catch (e) {\n            // accessing node.sheet.cssRules throws a DOMException\n            Logger.getInstance(this.options.id).error('Unable to access cssRules property', e);\n            if (e.name !== 'SecurityError') {\n                throw e;\n            }\n        }\n        return node.cloneNode(false) as HTMLStyleElement;\n    }\n\n    createCanvasClone(canvas: HTMLCanvasElement): HTMLImageElement | HTMLCanvasElement {\n        if (this.options.inlineImages && canvas.ownerDocument) {\n            const img = canvas.ownerDocument.createElement('img');\n            try {\n                img.src = canvas.toDataURL();\n                return img;\n            } catch (e) {\n                Logger.getInstance(this.options.id).info(`Unable to clone canvas contents, canvas is tainted`);\n            }\n        }\n\n        const clonedCanvas = canvas.cloneNode(false) as HTMLCanvasElement;\n\n        try {\n            clonedCanvas.width = canvas.width;\n            clonedCanvas.height = canvas.height;\n            const ctx = canvas.getContext('2d');\n            const clonedCtx = clonedCanvas.getContext('2d');\n            if (clonedCtx) {\n                if (ctx) {\n                    clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);\n                } else {\n                    clonedCtx.drawImage(canvas, 0, 0);\n                }\n            }\n            return clonedCanvas;\n        } catch (e) {}\n\n        return clonedCanvas;\n    }\n    /*\n    createIFrameClone(iframe: HTMLIFrameElement) {\n        const tempIframe = <HTMLIFrameElement>iframe.cloneNode(false);\n        const iframeKey = generateIframeKey();\n        tempIframe.setAttribute('data-html2canvas-internal-iframe-key', iframeKey);\n\n        const {width, height} = parseBounds(iframe);\n\n        this.resourceLoader.cache[iframeKey] = getIframeDocumentElement(iframe, this.options)\n            .then(documentElement => {\n                return this.renderer(\n                    documentElement,\n                    {\n                        allowTaint: this.options.allowTaint,\n                        backgroundColor: '#ffffff',\n                        canvas: null,\n                        imageTimeout: this.options.imageTimeout,\n                        logging: this.options.logging,\n                        proxy: this.options.proxy,\n                        removeContainer: this.options.removeContainer,\n                        scale: this.options.scale,\n                        foreignObjectRendering: this.options.foreignObjectRendering,\n                        useCORS: this.options.useCORS,\n                        target: new CanvasRenderer(),\n                        width,\n                        height,\n                        x: 0,\n                        y: 0,\n                        windowWidth: documentElement.ownerDocument.defaultView.innerWidth,\n                        windowHeight: documentElement.ownerDocument.defaultView.innerHeight,\n                        scrollX: documentElement.ownerDocument.defaultView.pageXOffset,\n                        scrollY: documentElement.ownerDocument.defaultView.pageYOffset\n                    },\n                );\n            })\n            .then(\n                (canvas: HTMLCanvasElement) =>\n                    new Promise((resolve, reject) => {\n                        const iframeCanvas = document.createElement('img');\n                        iframeCanvas.onload = () => resolve(canvas);\n                        iframeCanvas.onerror = (event) => {\n                            // Empty iframes may result in empty \"data:,\" URLs, which are invalid from the <img>'s point of view\n                            // and instead of `onload` cause `onerror` and unhandled rejection warnings\n                            // https://github.com/niklasvh/html2canvas/issues/1502\n                            iframeCanvas.src == 'data:,' ? resolve(canvas) : reject(event);\n                        };\n                        iframeCanvas.src = canvas.toDataURL();\n                        if (tempIframe.parentNode && iframe.ownerDocument && iframe.ownerDocument.defaultView) {\n                            tempIframe.parentNode.replaceChild(\n                                copyCSSStyles(\n                                    iframe.ownerDocument.defaultView.getComputedStyle(iframe),\n                                    iframeCanvas\n                                ),\n                                tempIframe\n                            );\n                        }\n                    })\n            );\n        return tempIframe;\n    }\n*/\n    cloneNode(node: Node): Node {\n        if (isTextNode(node)) {\n            return document.createTextNode(node.data);\n        }\n\n        if (!node.ownerDocument) {\n            return node.cloneNode(false);\n        }\n\n        const window = node.ownerDocument.defaultView;\n\n        if (isHTMLElementNode(node) && window) {\n            const clone = this.createElementClone(node);\n\n            const style = window.getComputedStyle(node);\n            const styleBefore = window.getComputedStyle(node, ':before');\n            const styleAfter = window.getComputedStyle(node, ':after');\n\n            if (this.referenceElement === node) {\n                this.clonedReferenceElement = clone;\n            }\n            if (isBodyElement(clone)) {\n                createPseudoHideStyles(clone);\n            }\n\n            const counters = this.counters.parse(new CSSParsedCounterDeclaration(style));\n            const before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);\n\n            for (let child = node.firstChild; child; child = child.nextSibling) {\n                if (\n                    !isElementNode(child) ||\n                    (!isScriptElement(child) &&\n                        !child.hasAttribute(IGNORE_ATTRIBUTE) &&\n                        (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))\n                ) {\n                    if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {\n                        clone.appendChild(this.cloneNode(child));\n                    }\n                }\n            }\n\n            if (before) {\n                clone.insertBefore(before, clone.firstChild);\n            }\n\n            const after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);\n            if (after) {\n                clone.appendChild(after);\n            }\n\n            this.counters.pop(counters);\n\n            if (style && this.options.copyStyles && !isIFrameElement(node)) {\n                copyCSSStyles(style, clone);\n            }\n\n            //this.inlineAllImages(clone);\n\n            if (node.scrollTop !== 0 || node.scrollLeft !== 0) {\n                this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);\n            }\n\n            if (\n                (isTextareaElement(node) || isSelectElement(node)) &&\n                (isTextareaElement(clone) || isSelectElement(clone))\n            ) {\n                clone.value = node.value;\n            }\n\n            return clone;\n        }\n\n        return node.cloneNode(false);\n    }\n\n    resolvePseudoContent(\n        node: Element,\n        clone: Element,\n        style: CSSStyleDeclaration,\n        pseudoElt: PseudoElementType\n    ): HTMLElement | void {\n        if (!style) {\n            return;\n        }\n\n        const value = style.content;\n        const document = clone.ownerDocument;\n        if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {\n            return;\n        }\n\n        this.counters.parse(new CSSParsedCounterDeclaration(style));\n        const declaration = new CSSParsedPseudoDeclaration(style);\n\n        const anonymousReplacedElement = document.createElement('html2canvaspseudoelement');\n        copyCSSStyles(style, anonymousReplacedElement);\n\n        declaration.content.forEach(token => {\n            if (token.type === TokenType.STRING_TOKEN) {\n                anonymousReplacedElement.appendChild(document.createTextNode(token.value));\n            } else if (token.type === TokenType.URL_TOKEN) {\n                const img = document.createElement('img');\n                img.src = token.value;\n                img.style.opacity = '1';\n                anonymousReplacedElement.appendChild(img);\n            } else if (token.type === TokenType.FUNCTION) {\n                if (token.name === 'attr') {\n                    const attr = token.values.filter(isIdentToken);\n                    if (attr.length) {\n                        anonymousReplacedElement.appendChild(\n                            document.createTextNode(node.getAttribute(attr[0].value) || '')\n                        );\n                    }\n                } else if (token.name === 'counter') {\n                    const [counter, counterStyle] = token.values.filter(nonFunctionArgSeparator);\n                    if (counter && isIdentToken(counter)) {\n                        const counterState = this.counters.getCounterValue(counter.value);\n                        const counterType =\n                            counterStyle && isIdentToken(counterStyle)\n                                ? listStyleType.parse(counterStyle.value)\n                                : LIST_STYLE_TYPE.DECIMAL;\n\n                        anonymousReplacedElement.appendChild(\n                            document.createTextNode(createCounterText(counterState, counterType, false))\n                        );\n                    }\n                } else if (token.name === 'counters') {\n                    const [counter, delim, counterStyle] = token.values.filter(nonFunctionArgSeparator);\n                    if (counter && isIdentToken(counter)) {\n                        const counterStates = this.counters.getCounterValues(counter.value);\n                        const counterType =\n                            counterStyle && isIdentToken(counterStyle)\n                                ? listStyleType.parse(counterStyle.value)\n                                : LIST_STYLE_TYPE.DECIMAL;\n                        const separator = delim && delim.type === TokenType.STRING_TOKEN ? delim.value : '';\n                        const text = counterStates\n                            .map(value => createCounterText(value, counterType, false))\n                            .join(separator);\n\n                        anonymousReplacedElement.appendChild(document.createTextNode(text));\n                    }\n                } else {\n                    //   console.log('FUNCTION_TOKEN', token);\n                }\n            } else if (token.type === TokenType.IDENT_TOKEN) {\n                switch (token.value) {\n                    case 'open-quote':\n                        anonymousReplacedElement.appendChild(\n                            document.createTextNode(getQuote(declaration.quotes, this.quoteDepth++, true))\n                        );\n                        break;\n                    case 'close-quote':\n                        anonymousReplacedElement.appendChild(\n                            document.createTextNode(getQuote(declaration.quotes, --this.quoteDepth, false))\n                        );\n                        break;\n                    default:\n                        // safari doesn't parse string tokens correctly because of lack of quotes\n                        anonymousReplacedElement.appendChild(document.createTextNode(token.value));\n                }\n            }\n        });\n\n        anonymousReplacedElement.className = `${PSEUDO_HIDE_ELEMENT_CLASS_BEFORE} ${PSEUDO_HIDE_ELEMENT_CLASS_AFTER}`;\n        clone.className +=\n            pseudoElt === PseudoElementType.BEFORE\n                ? ` ${PSEUDO_HIDE_ELEMENT_CLASS_BEFORE}`\n                : ` ${PSEUDO_HIDE_ELEMENT_CLASS_AFTER}`;\n        return anonymousReplacedElement;\n    }\n\n    static destroy(container: HTMLIFrameElement): boolean {\n        if (container.parentNode) {\n            container.parentNode.removeChild(container);\n            return true;\n        }\n        return false;\n    }\n}\n\nenum PseudoElementType {\n    BEFORE,\n    AFTER\n}\n\nconst createIFrameContainer = (ownerDocument: Document, bounds: Bounds): HTMLIFrameElement => {\n    const cloneIframeContainer = ownerDocument.createElement('iframe');\n\n    cloneIframeContainer.className = 'html2canvas-container';\n    cloneIframeContainer.style.visibility = 'hidden';\n    cloneIframeContainer.style.position = 'fixed';\n    cloneIframeContainer.style.left = '-10000px';\n    cloneIframeContainer.style.top = '0px';\n    cloneIframeContainer.style.border = '0';\n    cloneIframeContainer.width = bounds.width.toString();\n    cloneIframeContainer.height = bounds.height.toString();\n    cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it\n    cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');\n    ownerDocument.body.appendChild(cloneIframeContainer);\n\n    return cloneIframeContainer;\n};\n\nconst iframeLoader = (iframe: HTMLIFrameElement): Promise<HTMLIFrameElement> => {\n    return new Promise((resolve, reject) => {\n        const cloneWindow = iframe.contentWindow;\n\n        if (!cloneWindow) {\n            return reject(`No window assigned for iframe`);\n        }\n\n        const documentClone = cloneWindow.document;\n\n        cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = () => {\n            cloneWindow.onload = iframe.onload = documentClone.onreadystatechange = null;\n            const interval = setInterval(() => {\n                if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {\n                    clearInterval(interval);\n                    resolve(iframe);\n                }\n            }, 50);\n        };\n    });\n};\n\nexport const copyCSSStyles = (style: CSSStyleDeclaration, target: HTMLElement): HTMLElement => {\n    // Edge does not provide value for cssText\n    for (let i = style.length - 1; i >= 0; i--) {\n        const property = style.item(i);\n        // Safari shows pseudoelements if content is set\n        if (property !== 'content') {\n            target.style.setProperty(property, style.getPropertyValue(property));\n        }\n    }\n    return target;\n};\n\nconst serializeDoctype = (doctype?: DocumentType | null): string => {\n    let str = '';\n    if (doctype) {\n        str += '<!DOCTYPE ';\n        if (doctype.name) {\n            str += doctype.name;\n        }\n\n        if (doctype.internalSubset) {\n            str += doctype.internalSubset;\n        }\n\n        if (doctype.publicId) {\n            str += `\"${doctype.publicId}\"`;\n        }\n\n        if (doctype.systemId) {\n            str += `\"${doctype.systemId}\"`;\n        }\n\n        str += '>';\n    }\n\n    return str;\n};\n\nconst restoreOwnerScroll = (ownerDocument: Document | null, x: number, y: number) => {\n    if (\n        ownerDocument &&\n        ownerDocument.defaultView &&\n        (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)\n    ) {\n        ownerDocument.defaultView.scrollTo(x, y);\n    }\n};\n\nconst restoreNodeScroll = ([element, x, y]: [HTMLElement, number, number]) => {\n    element.scrollLeft = x;\n    element.scrollTop = y;\n};\n\nconst PSEUDO_BEFORE = ':before';\nconst PSEUDO_AFTER = ':after';\nconst PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';\nconst PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';\n\nconst PSEUDO_HIDE_ELEMENT_STYLE = `{\n    content: \"\" !important;\n    display: none !important;\n}`;\n\nconst createPseudoHideStyles = (body: HTMLElement) => {\n    createStyles(\n        body,\n        `.${PSEUDO_HIDE_ELEMENT_CLASS_BEFORE}${PSEUDO_BEFORE}${PSEUDO_HIDE_ELEMENT_STYLE}\n         .${PSEUDO_HIDE_ELEMENT_CLASS_AFTER}${PSEUDO_AFTER}${PSEUDO_HIDE_ELEMENT_STYLE}`\n    );\n};\n\nconst createStyles = (body: HTMLElement, styles: string) => {\n    const document = body.ownerDocument;\n    if (document) {\n        const style = document.createElement('style');\n        style.textContent = styles;\n        body.appendChild(style);\n    }\n};\n","import {BezierCurve} from './bezier-curve';\nimport {Vector} from './vector';\nexport enum PathType {\n    VECTOR = 0,\n    BEZIER_CURVE = 1\n}\n\nexport interface IPath {\n    type: PathType;\n    add(deltaX: number, deltaY: number): IPath;\n}\n\nexport const equalPath = (a: Path[], b: Path[]): boolean => {\n    if (a.length === b.length) {\n        return a.some((v, i) => v === b[i]);\n    }\n\n    return false;\n};\n\nexport const transformPath = (path: Path[], deltaX: number, deltaY: number, deltaW: number, deltaH: number): Path[] => {\n    return path.map((point, index) => {\n        switch (index) {\n            case 0:\n                return point.add(deltaX, deltaY);\n            case 1:\n                return point.add(deltaX + deltaW, deltaY);\n            case 2:\n                return point.add(deltaX + deltaW, deltaY + deltaH);\n            case 3:\n                return point.add(deltaX, deltaY + deltaH);\n        }\n        return point;\n    });\n};\n\nexport type Path = Vector | BezierCurve;\n","import {IPath, Path, PathType} from './path';\n\nexport class Vector implements IPath {\n    type: PathType;\n    x: number;\n    y: number;\n\n    constructor(x: number, y: number) {\n        this.type = PathType.VECTOR;\n        this.x = x;\n        this.y = y;\n    }\n\n    add(deltaX: number, deltaY: number): Vector {\n        return new Vector(this.x + deltaX, this.y + deltaY);\n    }\n}\n\nexport const isVector = (path: Path): path is Vector => path.type === PathType.VECTOR;\n","import {Vector} from './vector';\nimport {IPath, PathType, Path} from './path';\n\nconst lerp = (a: Vector, b: Vector, t: number): Vector => {\n    return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);\n};\n\nexport class BezierCurve implements IPath {\n    type: PathType;\n    start: Vector;\n    startControl: Vector;\n    endControl: Vector;\n    end: Vector;\n\n    constructor(start: Vector, startControl: Vector, endControl: Vector, end: Vector) {\n        this.type = PathType.BEZIER_CURVE;\n        this.start = start;\n        this.startControl = startControl;\n        this.endControl = endControl;\n        this.end = end;\n    }\n\n    subdivide(t: number, firstHalf: boolean): BezierCurve {\n        const ab = lerp(this.start, this.startControl, t);\n        const bc = lerp(this.startControl, this.endControl, t);\n        const cd = lerp(this.endControl, this.end, t);\n        const abbc = lerp(ab, bc, t);\n        const bccd = lerp(bc, cd, t);\n        const dest = lerp(abbc, bccd, t);\n        return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);\n    }\n\n    add(deltaX: number, deltaY: number): BezierCurve {\n        return new BezierCurve(\n            this.start.add(deltaX, deltaY),\n            this.startControl.add(deltaX, deltaY),\n            this.endControl.add(deltaX, deltaY),\n            this.end.add(deltaX, deltaY)\n        );\n    }\n\n    reverse(): BezierCurve {\n        return new BezierCurve(this.end, this.endControl, this.startControl, this.start);\n    }\n}\n\nexport const isBezierCurve = (path: Path): path is BezierCurve => path.type === PathType.BEZIER_CURVE;\n","import {ElementContainer} from '../dom/element-container';\nimport {getAbsoluteValue, getAbsoluteValueForTuple} from '../css/types/length-percentage';\nimport {Vector} from './vector';\nimport {BezierCurve} from './bezier-curve';\nimport {Path} from './path';\n\nexport class BoundCurves {\n    readonly topLeftBorderBox: Path;\n    readonly topRightBorderBox: Path;\n    readonly bottomRightBorderBox: Path;\n    readonly bottomLeftBorderBox: Path;\n    readonly topLeftPaddingBox: Path;\n    readonly topRightPaddingBox: Path;\n    readonly bottomRightPaddingBox: Path;\n    readonly bottomLeftPaddingBox: Path;\n    readonly topLeftContentBox: Path;\n    readonly topRightContentBox: Path;\n    readonly bottomRightContentBox: Path;\n    readonly bottomLeftContentBox: Path;\n\n    constructor(element: ElementContainer) {\n        const styles = element.styles;\n        const bounds = element.bounds;\n\n        let [tlh, tlv] = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height);\n        let [trh, trv] = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height);\n        let [brh, brv] = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height);\n        let [blh, blv] = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height);\n\n        const factors = [];\n        factors.push((tlh + trh) / bounds.width);\n        factors.push((blh + brh) / bounds.width);\n        factors.push((tlv + blv) / bounds.height);\n        factors.push((trv + brv) / bounds.height);\n        const maxFactor = Math.max(...factors);\n\n        if (maxFactor > 1) {\n            tlh /= maxFactor;\n            tlv /= maxFactor;\n            trh /= maxFactor;\n            trv /= maxFactor;\n            brh /= maxFactor;\n            brv /= maxFactor;\n            blh /= maxFactor;\n            blv /= maxFactor;\n        }\n\n        const topWidth = bounds.width - trh;\n        const rightHeight = bounds.height - brv;\n        const bottomWidth = bounds.width - brh;\n        const leftHeight = bounds.height - blv;\n\n        const borderTopWidth = styles.borderTopWidth;\n        const borderRightWidth = styles.borderRightWidth;\n        const borderBottomWidth = styles.borderBottomWidth;\n        const borderLeftWidth = styles.borderLeftWidth;\n\n        const paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);\n        const paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);\n        const paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);\n        const paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);\n\n        this.topLeftBorderBox =\n            tlh > 0 || tlv > 0\n                ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)\n                : new Vector(bounds.left, bounds.top);\n        this.topRightBorderBox =\n            trh > 0 || trv > 0\n                ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)\n                : new Vector(bounds.left + bounds.width, bounds.top);\n        this.bottomRightBorderBox =\n            brh > 0 || brv > 0\n                ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)\n                : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);\n        this.bottomLeftBorderBox =\n            blh > 0 || blv > 0\n                ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)\n                : new Vector(bounds.left, bounds.top + bounds.height);\n        this.topLeftPaddingBox =\n            tlh > 0 || tlv > 0\n                ? getCurvePoints(\n                      bounds.left + borderLeftWidth,\n                      bounds.top + borderTopWidth,\n                      Math.max(0, tlh - borderLeftWidth),\n                      Math.max(0, tlv - borderTopWidth),\n                      CORNER.TOP_LEFT\n                  )\n                : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);\n        this.topRightPaddingBox =\n            trh > 0 || trv > 0\n                ? getCurvePoints(\n                      bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth),\n                      bounds.top + borderTopWidth,\n                      topWidth > bounds.width + borderLeftWidth ? 0 : trh - borderLeftWidth,\n                      trv - borderTopWidth,\n                      CORNER.TOP_RIGHT\n                  )\n                : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);\n        this.bottomRightPaddingBox =\n            brh > 0 || brv > 0\n                ? getCurvePoints(\n                      bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth),\n                      bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth),\n                      Math.max(0, brh - borderRightWidth),\n                      brv - borderBottomWidth,\n                      CORNER.BOTTOM_RIGHT\n                  )\n                : new Vector(\n                      bounds.left + bounds.width - borderRightWidth,\n                      bounds.top + bounds.height - borderBottomWidth\n                  );\n        this.bottomLeftPaddingBox =\n            blh > 0 || blv > 0\n                ? getCurvePoints(\n                      bounds.left + borderLeftWidth,\n                      bounds.top + leftHeight,\n                      Math.max(0, blh - borderLeftWidth),\n                      blv - borderBottomWidth,\n                      CORNER.BOTTOM_LEFT\n                  )\n                : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);\n        this.topLeftContentBox =\n            tlh > 0 || tlv > 0\n                ? getCurvePoints(\n                      bounds.left + borderLeftWidth + paddingLeft,\n                      bounds.top + borderTopWidth + paddingTop,\n                      Math.max(0, tlh - (borderLeftWidth + paddingLeft)),\n                      Math.max(0, tlv - (borderTopWidth + paddingTop)),\n                      CORNER.TOP_LEFT\n                  )\n                : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);\n        this.topRightContentBox =\n            trh > 0 || trv > 0\n                ? getCurvePoints(\n                      bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft),\n                      bounds.top + borderTopWidth + paddingTop,\n                      topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft,\n                      trv - (borderTopWidth + paddingTop),\n                      CORNER.TOP_RIGHT\n                  )\n                : new Vector(\n                      bounds.left + bounds.width - (borderRightWidth + paddingRight),\n                      bounds.top + borderTopWidth + paddingTop\n                  );\n        this.bottomRightContentBox =\n            brh > 0 || brv > 0\n                ? getCurvePoints(\n                      bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)),\n                      bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop),\n                      Math.max(0, brh - (borderRightWidth + paddingRight)),\n                      brv - (borderBottomWidth + paddingBottom),\n                      CORNER.BOTTOM_RIGHT\n                  )\n                : new Vector(\n                      bounds.left + bounds.width - (borderRightWidth + paddingRight),\n                      bounds.top + bounds.height - (borderBottomWidth + paddingBottom)\n                  );\n        this.bottomLeftContentBox =\n            blh > 0 || blv > 0\n                ? getCurvePoints(\n                      bounds.left + borderLeftWidth + paddingLeft,\n                      bounds.top + leftHeight,\n                      Math.max(0, blh - (borderLeftWidth + paddingLeft)),\n                      blv - (borderBottomWidth + paddingBottom),\n                      CORNER.BOTTOM_LEFT\n                  )\n                : new Vector(\n                      bounds.left + borderLeftWidth + paddingLeft,\n                      bounds.top + bounds.height - (borderBottomWidth + paddingBottom)\n                  );\n    }\n}\n\nenum CORNER {\n    TOP_LEFT = 0,\n    TOP_RIGHT = 1,\n    BOTTOM_RIGHT = 2,\n    BOTTOM_LEFT = 3\n}\n\nconst getCurvePoints = (x: number, y: number, r1: number, r2: number, position: CORNER): BezierCurve => {\n    const kappa = 4 * ((Math.sqrt(2) - 1) / 3);\n    const ox = r1 * kappa; // control point offset horizontal\n    const oy = r2 * kappa; // control point offset vertical\n    const xm = x + r1; // x-middle\n    const ym = y + r2; // y-middle\n\n    switch (position) {\n        case CORNER.TOP_LEFT:\n            return new BezierCurve(\n                new Vector(x, ym),\n                new Vector(x, ym - oy),\n                new Vector(xm - ox, y),\n                new Vector(xm, y)\n            );\n        case CORNER.TOP_RIGHT:\n            return new BezierCurve(\n                new Vector(x, y),\n                new Vector(x + ox, y),\n                new Vector(xm, ym - oy),\n                new Vector(xm, ym)\n            );\n        case CORNER.BOTTOM_RIGHT:\n            return new BezierCurve(\n                new Vector(xm, y),\n                new Vector(xm, y + oy),\n                new Vector(x + ox, ym),\n                new Vector(x, ym)\n            );\n        case CORNER.BOTTOM_LEFT:\n        default:\n            return new BezierCurve(\n                new Vector(xm, ym),\n                new Vector(xm - ox, ym),\n                new Vector(x, y + oy),\n                new Vector(x, y)\n            );\n    }\n};\n\nexport const calculateBorderBoxPath = (curves: BoundCurves): Path[] => {\n    return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];\n};\n\nexport const calculateContentBoxPath = (curves: BoundCurves): Path[] => {\n    return [\n        curves.topLeftContentBox,\n        curves.topRightContentBox,\n        curves.bottomRightContentBox,\n        curves.bottomLeftContentBox\n    ];\n};\n\nexport const calculatePaddingBoxPath = (curves: BoundCurves): Path[] => {\n    return [\n        curves.topLeftPaddingBox,\n        curves.topRightPaddingBox,\n        curves.bottomRightPaddingBox,\n        curves.bottomLeftPaddingBox\n    ];\n};\n","import {Matrix} from '../css/property-descriptors/transform';\nimport {Path} from './path';\n\nexport const enum EffectType {\n    TRANSFORM = 0,\n    CLIP = 1\n}\n\nexport const enum EffectTarget {\n    BACKGROUND_BORDERS = 1 << 1,\n    CONTENT = 1 << 2\n}\n\nexport interface IElementEffect {\n    readonly type: EffectType;\n    readonly target: number;\n}\n\nexport class TransformEffect implements IElementEffect {\n    readonly type: EffectType;\n    readonly target: number;\n    readonly offsetX: number;\n    readonly offsetY: number;\n    readonly matrix: Matrix;\n\n    constructor(offsetX: number, offsetY: number, matrix: Matrix) {\n        this.type = EffectType.TRANSFORM;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.matrix = matrix;\n        this.target = EffectTarget.BACKGROUND_BORDERS | EffectTarget.CONTENT;\n    }\n}\n\nexport class ClipEffect implements IElementEffect {\n    readonly type: EffectType;\n    readonly target: number;\n    readonly path: Path[];\n\n    constructor(path: Path[], target: EffectTarget) {\n        this.type = EffectType.CLIP;\n        this.target = target;\n        this.path = path;\n    }\n}\n\nexport const isTransformEffect = (effect: IElementEffect): effect is TransformEffect =>\n    effect.type === EffectType.TRANSFORM;\nexport const isClipEffect = (effect: IElementEffect): effect is ClipEffect => effect.type === EffectType.CLIP;\n","import {ElementContainer, FLAGS} from '../dom/element-container';\nimport {contains} from '../core/bitwise';\nimport {BoundCurves, calculateBorderBoxPath, calculatePaddingBoxPath} from './bound-curves';\nimport {ClipEffect, EffectTarget, IElementEffect, TransformEffect} from './effects';\nimport {OVERFLOW} from '../css/property-descriptors/overflow';\nimport {equalPath} from './path';\nimport {DISPLAY} from '../css/property-descriptors/display';\nimport {OLElementContainer} from '../dom/elements/ol-element-container';\nimport {LIElementContainer} from '../dom/elements/li-element-container';\nimport {createCounterText} from '../css/types/functions/counter';\n\nexport class StackingContext {\n    element: ElementPaint;\n    negativeZIndex: StackingContext[];\n    zeroOrAutoZIndexOrTransformedOrOpacity: StackingContext[];\n    positiveZIndex: StackingContext[];\n    nonPositionedFloats: StackingContext[];\n    nonPositionedInlineLevel: StackingContext[];\n    inlineLevel: ElementPaint[];\n    nonInlineLevel: ElementPaint[];\n\n    constructor(container: ElementPaint) {\n        this.element = container;\n        this.inlineLevel = [];\n        this.nonInlineLevel = [];\n        this.negativeZIndex = [];\n        this.zeroOrAutoZIndexOrTransformedOrOpacity = [];\n        this.positiveZIndex = [];\n        this.nonPositionedFloats = [];\n        this.nonPositionedInlineLevel = [];\n    }\n}\n\nexport class ElementPaint {\n    container: ElementContainer;\n    effects: IElementEffect[];\n    curves: BoundCurves;\n    listValue?: string;\n\n    constructor(element: ElementContainer, parentStack: IElementEffect[]) {\n        this.container = element;\n        this.effects = parentStack.slice(0);\n        this.curves = new BoundCurves(element);\n        if (element.styles.transform !== null) {\n            const offsetX = element.bounds.left + element.styles.transformOrigin[0].number;\n            const offsetY = element.bounds.top + element.styles.transformOrigin[1].number;\n            const matrix = element.styles.transform;\n            this.effects.push(new TransformEffect(offsetX, offsetY, matrix));\n        }\n\n        if (element.styles.overflowX !== OVERFLOW.VISIBLE) {\n            const borderBox = calculateBorderBoxPath(this.curves);\n            const paddingBox = calculatePaddingBoxPath(this.curves);\n\n            if (equalPath(borderBox, paddingBox)) {\n                this.effects.push(new ClipEffect(borderBox, EffectTarget.BACKGROUND_BORDERS | EffectTarget.CONTENT));\n            } else {\n                this.effects.push(new ClipEffect(borderBox, EffectTarget.BACKGROUND_BORDERS));\n                this.effects.push(new ClipEffect(paddingBox, EffectTarget.CONTENT));\n            }\n        }\n    }\n\n    getParentEffects(): IElementEffect[] {\n        const effects = this.effects.slice(0);\n        if (this.container.styles.overflowX !== OVERFLOW.VISIBLE) {\n            const borderBox = calculateBorderBoxPath(this.curves);\n            const paddingBox = calculatePaddingBoxPath(this.curves);\n            if (!equalPath(borderBox, paddingBox)) {\n                effects.push(new ClipEffect(paddingBox, EffectTarget.BACKGROUND_BORDERS | EffectTarget.CONTENT));\n            }\n        }\n        return effects;\n    }\n}\n\nconst parseStackTree = (\n    parent: ElementPaint,\n    stackingContext: StackingContext,\n    realStackingContext: StackingContext,\n    listItems: ElementPaint[]\n) => {\n    parent.container.elements.forEach(child => {\n        const treatAsRealStackingContext = contains(child.flags, FLAGS.CREATES_REAL_STACKING_CONTEXT);\n        const createsStackingContext = contains(child.flags, FLAGS.CREATES_STACKING_CONTEXT);\n        const paintContainer = new ElementPaint(child, parent.getParentEffects());\n        if (contains(child.styles.display, DISPLAY.LIST_ITEM)) {\n            listItems.push(paintContainer);\n        }\n\n        const listOwnerItems = contains(child.flags, FLAGS.IS_LIST_OWNER) ? [] : listItems;\n\n        if (treatAsRealStackingContext || createsStackingContext) {\n            const parentStack =\n                treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;\n\n            const stack = new StackingContext(paintContainer);\n\n            if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {\n                const order = child.styles.zIndex.order;\n                if (order < 0) {\n                    let index = 0;\n\n                    parentStack.negativeZIndex.some((current, i) => {\n                        if (order > current.element.container.styles.zIndex.order) {\n                            index = i;\n                            return false;\n                        } else if (index > 0) {\n                            return true;\n                        }\n\n                        return false;\n                    });\n                    parentStack.negativeZIndex.splice(index, 0, stack);\n                } else if (order > 0) {\n                    let index = 0;\n                    parentStack.positiveZIndex.some((current, i) => {\n                        if (order > current.element.container.styles.zIndex.order) {\n                            index = i + 1;\n                            return false;\n                        } else if (index > 0) {\n                            return true;\n                        }\n\n                        return false;\n                    });\n                    parentStack.positiveZIndex.splice(index, 0, stack);\n                } else {\n                    parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);\n                }\n            } else {\n                if (child.styles.isFloating()) {\n                    parentStack.nonPositionedFloats.push(stack);\n                } else {\n                    parentStack.nonPositionedInlineLevel.push(stack);\n                }\n            }\n\n            parseStackTree(\n                paintContainer,\n                stack,\n                treatAsRealStackingContext ? stack : realStackingContext,\n                listOwnerItems\n            );\n        } else {\n            if (child.styles.isInlineLevel()) {\n                stackingContext.inlineLevel.push(paintContainer);\n            } else {\n                stackingContext.nonInlineLevel.push(paintContainer);\n            }\n\n            parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);\n        }\n\n        if (contains(child.flags, FLAGS.IS_LIST_OWNER)) {\n            processListItems(child, listOwnerItems);\n        }\n    });\n};\n\nconst processListItems = (owner: ElementContainer, elements: ElementPaint[]) => {\n    let numbering = owner instanceof OLElementContainer ? owner.start : 1;\n    const reversed = owner instanceof OLElementContainer ? owner.reversed : false;\n    for (let i = 0; i < elements.length; i++) {\n        const item = elements[i];\n        if (\n            item.container instanceof LIElementContainer &&\n            typeof item.container.value === 'number' &&\n            item.container.value !== 0\n        ) {\n            numbering = item.container.value;\n        }\n\n        item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);\n\n        numbering += reversed ? -1 : 1;\n    }\n};\n\nexport const parseStackingContexts = (container: ElementContainer): StackingContext => {\n    const paintContainer = new ElementPaint(container, []);\n    const root = new StackingContext(paintContainer);\n    const listItems: ElementPaint[] = [];\n    parseStackTree(paintContainer, root, root, listItems);\n    processListItems(paintContainer.container, listItems);\n    return root;\n};\n","import {Path} from './path';\nimport {BoundCurves} from './bound-curves';\nimport {isBezierCurve} from './bezier-curve';\n\nexport const parsePathForBorder = (curves: BoundCurves, borderSide: number): Path[] => {\n    switch (borderSide) {\n        case 0:\n            return createPathFromCurves(\n                curves.topLeftBorderBox,\n                curves.topLeftPaddingBox,\n                curves.topRightBorderBox,\n                curves.topRightPaddingBox\n            );\n        case 1:\n            return createPathFromCurves(\n                curves.topRightBorderBox,\n                curves.topRightPaddingBox,\n                curves.bottomRightBorderBox,\n                curves.bottomRightPaddingBox\n            );\n        case 2:\n            return createPathFromCurves(\n                curves.bottomRightBorderBox,\n                curves.bottomRightPaddingBox,\n                curves.bottomLeftBorderBox,\n                curves.bottomLeftPaddingBox\n            );\n        case 3:\n        default:\n            return createPathFromCurves(\n                curves.bottomLeftBorderBox,\n                curves.bottomLeftPaddingBox,\n                curves.topLeftBorderBox,\n                curves.topLeftPaddingBox\n            );\n    }\n};\n\nconst createPathFromCurves = (outer1: Path, inner1: Path, outer2: Path, inner2: Path): Path[] => {\n    const path = [];\n    if (isBezierCurve(outer1)) {\n        path.push(outer1.subdivide(0.5, false));\n    } else {\n        path.push(outer1);\n    }\n\n    if (isBezierCurve(outer2)) {\n        path.push(outer2.subdivide(0.5, true));\n    } else {\n        path.push(outer2);\n    }\n\n    if (isBezierCurve(inner2)) {\n        path.push(inner2.subdivide(0.5, true).reverse());\n    } else {\n        path.push(inner2);\n    }\n\n    if (isBezierCurve(inner1)) {\n        path.push(inner1.subdivide(0.5, false).reverse());\n    } else {\n        path.push(inner1);\n    }\n\n    return path;\n};\n","import {getAbsoluteValue} from '../css/types/length-percentage';\nimport {Bounds} from '../css/layout/bounds';\nimport {ElementContainer} from '../dom/element-container';\n\nexport const paddingBox = (element: ElementContainer): Bounds => {\n    const bounds = element.bounds;\n    const styles = element.styles;\n    return bounds.add(\n        styles.borderLeftWidth,\n        styles.borderTopWidth,\n        -(styles.borderRightWidth + styles.borderLeftWidth),\n        -(styles.borderTopWidth + styles.borderBottomWidth)\n    );\n};\n\nexport const contentBox = (element: ElementContainer): Bounds => {\n    const styles = element.styles;\n    const bounds = element.bounds;\n\n    const paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);\n    const paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);\n    const paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);\n    const paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);\n\n    return bounds.add(\n        paddingLeft + styles.borderLeftWidth,\n        paddingTop + styles.borderTopWidth,\n        -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight),\n        -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom)\n    );\n};\n","import {Bounds} from '../css/layout/bounds';\nimport {BACKGROUND_ORIGIN} from '../css/property-descriptors/background-origin';\nimport {ElementContainer} from '../dom/element-container';\nimport {BACKGROUND_SIZE, BackgroundSizeInfo} from '../css/property-descriptors/background-size';\nimport {Vector} from './vector';\nimport {BACKGROUND_REPEAT} from '../css/property-descriptors/background-repeat';\nimport {getAbsoluteValue, getAbsoluteValueForTuple, isLengthPercentage} from '../css/types/length-percentage';\nimport {CSSValue, isIdentToken} from '../css/syntax/parser';\nimport {contentBox, paddingBox} from './box-sizing';\nimport {Path} from './path';\nimport {BACKGROUND_CLIP} from '../css/property-descriptors/background-clip';\n\nexport const calculateBackgroundPositioningArea = (\n    backgroundOrigin: BACKGROUND_ORIGIN,\n    element: ElementContainer\n): Bounds => {\n    if (backgroundOrigin === BACKGROUND_ORIGIN.BORDER_BOX) {\n        return element.bounds;\n    }\n\n    if (backgroundOrigin === BACKGROUND_ORIGIN.CONTENT_BOX) {\n        return contentBox(element);\n    }\n\n    return paddingBox(element);\n};\n\nexport const calculateBackgroundPaintingArea = (backgroundClip: BACKGROUND_CLIP, element: ElementContainer): Bounds => {\n    if (backgroundClip === BACKGROUND_CLIP.BORDER_BOX) {\n        return element.bounds;\n    }\n\n    if (backgroundClip === BACKGROUND_CLIP.CONTENT_BOX) {\n        return contentBox(element);\n    }\n\n    return paddingBox(element);\n};\n\nexport const calculateBackgroundRendering = (\n    container: ElementContainer,\n    index: number,\n    intrinsicSize: [number | null, number | null, number | null]\n): [Path[], number, number, number, number] => {\n    const backgroundPositioningArea = calculateBackgroundPositioningArea(\n        getBackgroundValueForIndex(container.styles.backgroundOrigin, index),\n        container\n    );\n\n    const backgroundPaintingArea = calculateBackgroundPaintingArea(\n        getBackgroundValueForIndex(container.styles.backgroundClip, index),\n        container\n    );\n\n    const backgroundImageSize = calculateBackgroundSize(\n        getBackgroundValueForIndex(container.styles.backgroundSize, index),\n        intrinsicSize,\n        backgroundPositioningArea\n    );\n\n    const [sizeWidth, sizeHeight] = backgroundImageSize;\n\n    const position = getAbsoluteValueForTuple(\n        getBackgroundValueForIndex(container.styles.backgroundPosition, index),\n        backgroundPositioningArea.width - sizeWidth,\n        backgroundPositioningArea.height - sizeHeight\n    );\n\n    const path = calculateBackgroundRepeatPath(\n        getBackgroundValueForIndex(container.styles.backgroundRepeat, index),\n        position,\n        backgroundImageSize,\n        backgroundPositioningArea,\n        backgroundPaintingArea\n    );\n\n    const offsetX = Math.round(backgroundPositioningArea.left + position[0]);\n    const offsetY = Math.round(backgroundPositioningArea.top + position[1]);\n\n    return [path, offsetX, offsetY, sizeWidth, sizeHeight];\n};\n\nexport const isAuto = (token: CSSValue): boolean => isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;\n\nconst hasIntrinsicValue = (value: number | null): value is number => typeof value === 'number';\n\nexport const calculateBackgroundSize = (\n    size: BackgroundSizeInfo[],\n    [intrinsicWidth, intrinsicHeight, intrinsicProportion]: [number | null, number | null, number | null],\n    bounds: Bounds\n): [number, number] => {\n    const [first, second] = size;\n\n    if (isLengthPercentage(first) && second && isLengthPercentage(second)) {\n        return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];\n    }\n\n    const hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);\n\n    if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {\n        if (hasIntrinsicValue(intrinsicProportion)) {\n            const targetRatio = bounds.width / bounds.height;\n\n            return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)\n                ? [bounds.width, bounds.width / intrinsicProportion]\n                : [bounds.height * intrinsicProportion, bounds.height];\n        }\n\n        return [bounds.width, bounds.height];\n    }\n\n    const hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);\n    const hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);\n    const hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;\n\n    // If the background-size is auto or auto auto:\n    if (isAuto(first) && (!second || isAuto(second))) {\n        // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.\n        if (hasIntrinsicWidth && hasIntrinsicHeight) {\n            return [intrinsicWidth as number, intrinsicHeight as number];\n        }\n\n        // If the image has no intrinsic dimensions and has no intrinsic proportions,\n        // it's rendered at the size of the background positioning area.\n\n        if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {\n            return [bounds.width, bounds.height];\n        }\n\n        // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.\n\n        // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.\n        // The other dimension is computed using the specified dimension and the intrinsic proportions.\n        if (hasIntrinsicDimensions && hasIntrinsicProportion) {\n            const width = hasIntrinsicWidth\n                ? (intrinsicWidth as number)\n                : (intrinsicHeight as number) * (intrinsicProportion as number);\n            const height = hasIntrinsicHeight\n                ? (intrinsicHeight as number)\n                : (intrinsicWidth as number) / (intrinsicProportion as number);\n            return [width, height];\n        }\n\n        // If the image has only one intrinsic dimension but has no intrinsic proportions,\n        // it's rendered using the specified dimension and the other dimension of the background positioning area.\n        const width = hasIntrinsicWidth ? (intrinsicWidth as number) : bounds.width;\n        const height = hasIntrinsicHeight ? (intrinsicHeight as number) : bounds.height;\n        return [width, height];\n    }\n\n    // If the image has intrinsic proportions, it's stretched to the specified dimension.\n    // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.\n    if (hasIntrinsicProportion) {\n        let width = 0;\n        let height = 0;\n        if (isLengthPercentage(first)) {\n            width = getAbsoluteValue(first, bounds.width);\n        } else if (isLengthPercentage(second)) {\n            height = getAbsoluteValue(second, bounds.height);\n        }\n\n        if (isAuto(first)) {\n            width = height * (intrinsicProportion as number);\n        } else if (!second || isAuto(second)) {\n            height = width / (intrinsicProportion as number);\n        }\n\n        return [width, height];\n    }\n\n    // If the image has no intrinsic proportions, it's stretched to the specified dimension.\n    // The unspecified dimension is computed using the image's corresponding intrinsic dimension,\n    // if there is one. If there is no such intrinsic dimension,\n    // it becomes the corresponding dimension of the background positioning area.\n\n    let width = null;\n    let height = null;\n\n    if (isLengthPercentage(first)) {\n        width = getAbsoluteValue(first, bounds.width);\n    } else if (second && isLengthPercentage(second)) {\n        height = getAbsoluteValue(second, bounds.height);\n    }\n\n    if (width !== null && (!second || isAuto(second))) {\n        height =\n            hasIntrinsicWidth && hasIntrinsicHeight\n                ? (width / (intrinsicWidth as number)) * (intrinsicHeight as number)\n                : bounds.height;\n    }\n\n    if (height !== null && isAuto(first)) {\n        width =\n            hasIntrinsicWidth && hasIntrinsicHeight\n                ? (height / (intrinsicHeight as number)) * (intrinsicWidth as number)\n                : bounds.width;\n    }\n\n    if (width !== null && height !== null) {\n        return [width, height];\n    }\n\n    throw new Error(`Unable to calculate background-size for element`);\n};\n\nexport const getBackgroundValueForIndex = <T>(values: T[], index: number): T => {\n    const value = values[index];\n    if (typeof value === 'undefined') {\n        return values[0];\n    }\n\n    return value;\n};\n\nexport const calculateBackgroundRepeatPath = (\n    repeat: BACKGROUND_REPEAT,\n    [x, y]: [number, number],\n    [width, height]: [number, number],\n    backgroundPositioningArea: Bounds,\n    backgroundPaintingArea: Bounds\n) => {\n    switch (repeat) {\n        case BACKGROUND_REPEAT.REPEAT_X:\n            return [\n                new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width),\n                    Math.round(backgroundPositioningArea.top + y)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width),\n                    Math.round(height + backgroundPositioningArea.top + y)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left),\n                    Math.round(height + backgroundPositioningArea.top + y)\n                )\n            ];\n        case BACKGROUND_REPEAT.REPEAT_Y:\n            return [\n                new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x + width),\n                    Math.round(backgroundPositioningArea.top)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x + width),\n                    Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x),\n                    Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)\n                )\n            ];\n        case BACKGROUND_REPEAT.NO_REPEAT:\n            return [\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x),\n                    Math.round(backgroundPositioningArea.top + y)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x + width),\n                    Math.round(backgroundPositioningArea.top + y)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x + width),\n                    Math.round(backgroundPositioningArea.top + y + height)\n                ),\n                new Vector(\n                    Math.round(backgroundPositioningArea.left + x),\n                    Math.round(backgroundPositioningArea.top + y + height)\n                )\n            ];\n        default:\n            return [\n                new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),\n                new Vector(\n                    Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width),\n                    Math.round(backgroundPaintingArea.top)\n                ),\n                new Vector(\n                    Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width),\n                    Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)\n                ),\n                new Vector(\n                    Math.round(backgroundPaintingArea.left),\n                    Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)\n                )\n            ];\n    }\n};\n","export const SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n","import {SMALL_IMAGE} from '../core/util';\nexport interface FontMetric {\n    baseline: number;\n    middle: number;\n}\n\nconst SAMPLE_TEXT = 'Hidden Text';\n\nexport class FontMetrics {\n    private readonly _data: {[key: string]: FontMetric};\n    private readonly _document: Document;\n\n    constructor(document: Document) {\n        this._data = {};\n        this._document = document;\n    }\n\n    private parseMetrics(fontFamily: string, fontSize: string): FontMetric {\n        const container = this._document.createElement('div');\n        const img = this._document.createElement('img');\n        const span = this._document.createElement('span');\n\n        const body = this._document.body as HTMLBodyElement;\n\n        container.style.visibility = 'hidden';\n        container.style.fontFamily = fontFamily;\n        container.style.fontSize = fontSize;\n        container.style.margin = '0';\n        container.style.padding = '0';\n\n        body.appendChild(container);\n\n        img.src = SMALL_IMAGE;\n        img.width = 1;\n        img.height = 1;\n\n        img.style.margin = '0';\n        img.style.padding = '0';\n        img.style.verticalAlign = 'baseline';\n\n        span.style.fontFamily = fontFamily;\n        span.style.fontSize = fontSize;\n        span.style.margin = '0';\n        span.style.padding = '0';\n\n        span.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n        container.appendChild(span);\n        container.appendChild(img);\n        const baseline = img.offsetTop - span.offsetTop + 2;\n\n        container.removeChild(span);\n        container.appendChild(this._document.createTextNode(SAMPLE_TEXT));\n\n        container.style.lineHeight = 'normal';\n        img.style.verticalAlign = 'super';\n\n        const middle = img.offsetTop - container.offsetTop + 2;\n\n        body.removeChild(container);\n\n        return {baseline, middle};\n    }\n    getMetrics(fontFamily: string, fontSize: string): FontMetric {\n        const key = `${fontFamily} ${fontSize}`;\n        if (typeof this._data[key] === 'undefined') {\n            this._data[key] = this.parseMetrics(fontFamily, fontSize);\n        }\n\n        return this._data[key];\n    }\n}\n","import {ElementPaint, parseStackingContexts, StackingContext} from '../stacking-context';\nimport {asString, Color, isTransparent} from '../../css/types/color';\nimport {Logger} from '../../core/logger';\nimport {ElementContainer} from '../../dom/element-container';\nimport {BORDER_STYLE} from '../../css/property-descriptors/border-style';\nimport {CSSParsedDeclaration} from '../../css/index';\nimport {TextContainer} from '../../dom/text-container';\nimport {Path, transformPath} from '../path';\nimport {BACKGROUND_CLIP} from '../../css/property-descriptors/background-clip';\nimport {BoundCurves, calculateBorderBoxPath, calculateContentBoxPath, calculatePaddingBoxPath} from '../bound-curves';\nimport {isBezierCurve} from '../bezier-curve';\nimport {Vector} from '../vector';\nimport {CSSImageType, CSSURLImage, isLinearGradient, isRadialGradient} from '../../css/types/image';\nimport {parsePathForBorder} from '../border';\nimport {Cache} from '../../core/cache-storage';\nimport {calculateBackgroundRendering, getBackgroundValueForIndex} from '../background';\nimport {isDimensionToken} from '../../css/syntax/parser';\nimport {TextBounds} from '../../css/layout/text';\nimport {fromCodePoint, toCodePoints} from 'css-line-break';\nimport {ImageElementContainer} from '../../dom/replaced-elements/image-element-container';\nimport {contentBox} from '../box-sizing';\nimport {CanvasElementContainer} from '../../dom/replaced-elements/canvas-element-container';\nimport {SVGElementContainer} from '../../dom/replaced-elements/svg-element-container';\nimport {ReplacedElementContainer} from '../../dom/replaced-elements/index';\nimport {EffectTarget, IElementEffect, isClipEffect, isTransformEffect} from '../effects';\nimport {contains} from '../../core/bitwise';\nimport {calculateGradientDirection, calculateRadius, processColorStops} from '../../css/types/functions/gradient';\nimport {FIFTY_PERCENT, getAbsoluteValue} from '../../css/types/length-percentage';\nimport {TEXT_DECORATION_LINE} from '../../css/property-descriptors/text-decoration-line';\nimport {FontMetrics} from '../font-metrics';\nimport {DISPLAY} from '../../css/property-descriptors/display';\nimport {Bounds} from '../../css/layout/bounds';\nimport {LIST_STYLE_TYPE} from '../../css/property-descriptors/list-style-type';\nimport {computeLineHeight} from '../../css/property-descriptors/line-height';\nimport {CHECKBOX, INPUT_COLOR, InputElementContainer, RADIO} from '../../dom/replaced-elements/input-element-container';\nimport {TEXT_ALIGN} from '../../css/property-descriptors/text-align';\nimport {TextareaElementContainer} from '../../dom/elements/textarea-element-container';\nimport {SelectElementContainer} from '../../dom/elements/select-element-container';\nimport {IFrameElementContainer} from '../../dom/replaced-elements/iframe-element-container';\nimport {TextShadow} from '../../css/property-descriptors/text-shadow';\n\nexport type RenderConfigurations = RenderOptions & {\n    backgroundColor: Color | null;\n};\n\nexport interface RenderOptions {\n    id: string;\n    scale: number;\n    canvas?: HTMLCanvasElement;\n    x: number;\n    y: number;\n    scrollX: number;\n    scrollY: number;\n    width: number;\n    height: number;\n    windowWidth: number;\n    windowHeight: number;\n    cache: Cache;\n}\n\nconst MASK_OFFSET = 10000;\n\nexport class CanvasRenderer {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    options: RenderConfigurations;\n    private readonly _activeEffects: IElementEffect[] = [];\n    private readonly fontMetrics: FontMetrics;\n\n    constructor(options: RenderConfigurations) {\n        this.canvas = options.canvas ? options.canvas : document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.options = options;\n        if (!options.canvas) {\n            this.canvas.width = Math.floor(options.width * options.scale);\n            this.canvas.height = Math.floor(options.height * options.scale);\n            this.canvas.style.width = `${options.width}px`;\n            this.canvas.style.height = `${options.height}px`;\n        }\n        this.fontMetrics = new FontMetrics(document);\n        this.ctx.scale(this.options.scale, this.options.scale);\n        this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);\n        this.ctx.textBaseline = 'bottom';\n        this._activeEffects = [];\n        Logger.getInstance(options.id).debug(\n            `Canvas renderer initialized (${options.width}x${options.height} at ${options.x},${options.y}) with scale ${\n                options.scale\n            }`\n        );\n    }\n\n    applyEffects(effects: IElementEffect[], target: EffectTarget) {\n        while (this._activeEffects.length) {\n            this.popEffect();\n        }\n\n        effects.filter(effect => contains(effect.target, target)).forEach(effect => this.applyEffect(effect));\n    }\n\n    applyEffect(effect: IElementEffect) {\n        this.ctx.save();\n        if (isTransformEffect(effect)) {\n            this.ctx.translate(effect.offsetX, effect.offsetY);\n            this.ctx.transform(\n                effect.matrix[0],\n                effect.matrix[1],\n                effect.matrix[2],\n                effect.matrix[3],\n                effect.matrix[4],\n                effect.matrix[5]\n            );\n            this.ctx.translate(-effect.offsetX, -effect.offsetY);\n        }\n\n        if (isClipEffect(effect)) {\n            this.path(effect.path);\n            this.ctx.clip();\n        }\n\n        this._activeEffects.push(effect);\n    }\n\n    popEffect() {\n        this._activeEffects.pop();\n        this.ctx.restore();\n    }\n\n    async renderStack(stack: StackingContext) {\n        const styles = stack.element.container.styles;\n        if (styles.isVisible()) {\n            this.ctx.globalAlpha = styles.opacity;\n            await this.renderStackContent(stack);\n        }\n    }\n\n    async renderNode(paint: ElementPaint) {\n        if (paint.container.styles.isVisible()) {\n            await this.renderNodeBackgroundAndBorders(paint);\n            await this.renderNodeContent(paint);\n        }\n    }\n\n    renderTextWithLetterSpacing(text: TextBounds, letterSpacing: number) {\n        if (letterSpacing === 0) {\n            this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);\n        } else {\n            const letters = toCodePoints(text.text).map(i => fromCodePoint(i));\n            letters.reduce((left, letter) => {\n                this.ctx.fillText(letter, left, text.bounds.top + text.bounds.height);\n\n                return left + this.ctx.measureText(letter).width;\n            }, text.bounds.left);\n        }\n    }\n\n    private createFontStyle(styles: CSSParsedDeclaration): string[] {\n        const fontVariant = styles.fontVariant\n            .filter(variant => variant === 'normal' || variant === 'small-caps')\n            .join('');\n        const fontFamily = styles.fontFamily.join(', ');\n        const fontSize = isDimensionToken(styles.fontSize)\n            ? `${styles.fontSize.number}${styles.fontSize.unit}`\n            : `${styles.fontSize.number}px`;\n\n        return [\n            [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),\n            fontFamily,\n            fontSize\n        ];\n    }\n\n    async renderTextNode(text: TextContainer, styles: CSSParsedDeclaration) {\n        const [font, fontFamily, fontSize] = this.createFontStyle(styles);\n\n        this.ctx.font = font;\n\n        text.textBounds.forEach(text => {\n            this.ctx.fillStyle = asString(styles.color);\n            this.renderTextWithLetterSpacing(text, styles.letterSpacing);\n            const textShadows: TextShadow = styles.textShadow;\n\n            if (textShadows.length && text.text.trim().length) {\n                textShadows\n                    .slice(0)\n                    .reverse()\n                    .forEach(textShadow => {\n                        this.ctx.shadowColor = asString(textShadow.color);\n                        this.ctx.shadowOffsetX = textShadow.offsetX.number * this.options.scale;\n                        this.ctx.shadowOffsetY = textShadow.offsetY.number * this.options.scale;\n                        this.ctx.shadowBlur = textShadow.blur.number;\n\n                        this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);\n                    });\n\n                this.ctx.shadowColor = '';\n                this.ctx.shadowOffsetX = 0;\n                this.ctx.shadowOffsetY = 0;\n                this.ctx.shadowBlur = 0;\n            }\n\n            if (styles.textDecorationLine.length) {\n                this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);\n                styles.textDecorationLine.forEach(textDecorationLine => {\n                    switch (textDecorationLine) {\n                        case TEXT_DECORATION_LINE.UNDERLINE:\n                            // Draws a line at the baseline of the font\n                            // TODO As some browsers display the line as more than 1px if the font-size is big,\n                            // need to take that into account both in position and size\n                            const {baseline} = this.fontMetrics.getMetrics(fontFamily, fontSize);\n                            this.ctx.fillRect(\n                                text.bounds.left,\n                                Math.round(text.bounds.top + baseline),\n                                text.bounds.width,\n                                1\n                            );\n\n                            break;\n                        case TEXT_DECORATION_LINE.OVERLINE:\n                            this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);\n                            break;\n                        case TEXT_DECORATION_LINE.LINE_THROUGH:\n                            // TODO try and find exact position for line-through\n                            const {middle} = this.fontMetrics.getMetrics(fontFamily, fontSize);\n                            this.ctx.fillRect(\n                                text.bounds.left,\n                                Math.ceil(text.bounds.top + middle),\n                                text.bounds.width,\n                                1\n                            );\n                            break;\n                    }\n                });\n            }\n        });\n    }\n\n    renderReplacedElement(\n        container: ReplacedElementContainer,\n        curves: BoundCurves,\n        image: HTMLImageElement | HTMLCanvasElement\n    ) {\n        if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {\n            const box = contentBox(container);\n            const path = calculatePaddingBoxPath(curves);\n            this.path(path);\n            this.ctx.save();\n            this.ctx.clip();\n            this.ctx.drawImage(\n                image,\n                0,\n                0,\n                container.intrinsicWidth,\n                container.intrinsicHeight,\n                box.left,\n                box.top,\n                box.width,\n                box.height\n            );\n            this.ctx.restore();\n        }\n    }\n\n    async renderNodeContent(paint: ElementPaint) {\n        this.applyEffects(paint.effects, EffectTarget.CONTENT);\n        const container = paint.container;\n        const curves = paint.curves;\n        const styles = container.styles;\n        for (const child of container.textNodes) {\n            await this.renderTextNode(child, styles);\n        }\n\n        if (container instanceof ImageElementContainer) {\n            try {\n                const image = await this.options.cache.match(container.src);\n                this.renderReplacedElement(container, curves, image);\n            } catch (e) {\n                Logger.getInstance(this.options.id).error(`Error loading image ${container.src}`);\n            }\n        }\n\n        if (container instanceof CanvasElementContainer) {\n            this.renderReplacedElement(container, curves, container.canvas);\n        }\n\n        if (container instanceof SVGElementContainer) {\n            try {\n                const image = await this.options.cache.match(container.svg);\n                this.renderReplacedElement(container, curves, image);\n            } catch (e) {\n                Logger.getInstance(this.options.id).error(`Error loading svg ${container.svg.substring(0, 255)}`);\n            }\n        }\n\n        if (container instanceof IFrameElementContainer && container.tree) {\n            const iframeRenderer = new CanvasRenderer({\n                id: this.options.id,\n                scale: this.options.scale,\n                backgroundColor: container.backgroundColor,\n                x: 0,\n                y: 0,\n                scrollX: 0,\n                scrollY: 0,\n                width: container.width,\n                height: container.height,\n                cache: this.options.cache,\n                windowWidth: container.width,\n                windowHeight: container.height\n            });\n\n            const canvas = await iframeRenderer.render(container.tree);\n            if (container.width && container.height) {\n                this.ctx.drawImage(\n                    canvas,\n                    0,\n                    0,\n                    container.width,\n                    container.height,\n                    container.bounds.left,\n                    container.bounds.top,\n                    container.bounds.width,\n                    container.bounds.height\n                );\n            }\n        }\n\n        if (container instanceof InputElementContainer) {\n            const size = Math.min(container.bounds.width, container.bounds.height);\n\n            if (container.type === CHECKBOX) {\n                if (container.checked) {\n                    this.ctx.save();\n                    this.path([\n                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),\n                        new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),\n                        new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),\n                        new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),\n                        new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),\n                        new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),\n                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)\n                    ]);\n\n                    this.ctx.fillStyle = asString(INPUT_COLOR);\n                    this.ctx.fill();\n                    this.ctx.restore();\n                }\n            } else if (container.type === RADIO) {\n                if (container.checked) {\n                    this.ctx.save();\n                    this.ctx.beginPath();\n                    this.ctx.arc(\n                        container.bounds.left + size / 2,\n                        container.bounds.top + size / 2,\n                        size / 4,\n                        0,\n                        Math.PI * 2,\n                        true\n                    );\n                    this.ctx.fillStyle = asString(INPUT_COLOR);\n                    this.ctx.fill();\n                    this.ctx.restore();\n                }\n            }\n        }\n\n        if (isTextInputElement(container) && container.value.length) {\n            [this.ctx.font] = this.createFontStyle(styles);\n            this.ctx.fillStyle = asString(styles.color);\n\n            this.ctx.textBaseline = 'middle';\n            this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);\n\n            const bounds = contentBox(container);\n\n            let x = 0;\n\n            switch (container.styles.textAlign) {\n                case TEXT_ALIGN.CENTER:\n                    x += bounds.width / 2;\n                    break;\n                case TEXT_ALIGN.RIGHT:\n                    x += bounds.width;\n                    break;\n            }\n\n            const textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);\n\n            this.ctx.save();\n            this.path([\n                new Vector(bounds.left, bounds.top),\n                new Vector(bounds.left + bounds.width, bounds.top),\n                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),\n                new Vector(bounds.left, bounds.top + bounds.height)\n            ]);\n\n            this.ctx.clip();\n            this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing);\n            this.ctx.restore();\n            this.ctx.textBaseline = 'bottom';\n            this.ctx.textAlign = 'left';\n        }\n\n        if (contains(container.styles.display, DISPLAY.LIST_ITEM)) {\n            if (container.styles.listStyleImage !== null) {\n                const img = container.styles.listStyleImage;\n                if (img.type === CSSImageType.URL) {\n                    let image;\n                    const url = (img as CSSURLImage).url;\n                    try {\n                        image = await this.options.cache.match(url);\n                        this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);\n                    } catch (e) {\n                        Logger.getInstance(this.options.id).error(`Error loading list-style-image ${url}`);\n                    }\n                }\n            } else if (paint.listValue && container.styles.listStyleType !== LIST_STYLE_TYPE.NONE) {\n                [this.ctx.font] = this.createFontStyle(styles);\n                this.ctx.fillStyle = asString(styles.color);\n\n                this.ctx.textBaseline = 'middle';\n                this.ctx.textAlign = 'right';\n                const bounds = new Bounds(\n                    container.bounds.left,\n                    container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width),\n                    container.bounds.width,\n                    computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1\n                );\n\n                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing);\n                this.ctx.textBaseline = 'bottom';\n                this.ctx.textAlign = 'left';\n            }\n        }\n    }\n\n    async renderStackContent(stack: StackingContext) {\n        // https://www.w3.org/TR/css-position-3/#painting-order\n        // 1. the background and borders of the element forming the stacking context.\n        await this.renderNodeBackgroundAndBorders(stack.element);\n        // 2. the child stacking contexts with negative stack levels (most negative first).\n        for (const child of stack.negativeZIndex) {\n            await this.renderStack(child);\n        }\n        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:\n        await this.renderNodeContent(stack.element);\n\n        for (const child of stack.nonInlineLevel) {\n            await this.renderNode(child);\n        }\n        // 4. All non-positioned floating descendants, in tree order. For each one of these,\n        // treat the element as if it created a new stacking context, but any positioned descendants and descendants\n        // which actually create a new stacking context should be considered part of the parent stacking context,\n        // not this new one.\n        for (const child of stack.nonPositionedFloats) {\n            await this.renderStack(child);\n        }\n        // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\n        for (const child of stack.nonPositionedInlineLevel) {\n            await this.renderStack(child);\n        }\n        for (const child of stack.inlineLevel) {\n            await this.renderNode(child);\n        }\n        // 6. All positioned, opacity or transform descendants, in tree order that fall into the following categories:\n        //  All positioned descendants with 'z-index: auto' or 'z-index: 0', in tree order.\n        //  For those with 'z-index: auto', treat the element as if it created a new stacking context,\n        //  but any positioned descendants and descendants which actually create a new stacking context should be\n        //  considered part of the parent stacking context, not this new one. For those with 'z-index: 0',\n        //  treat the stacking context generated atomically.\n        //\n        //  All opacity descendants with opacity less than 1\n        //\n        //  All transform descendants with transform other than none\n        for (const child of stack.zeroOrAutoZIndexOrTransformedOrOpacity) {\n            await this.renderStack(child);\n        }\n        // 7. Stacking contexts formed by positioned descendants with z-indices greater than or equal to 1 in z-index\n        // order (smallest first) then tree order.\n        for (const child of stack.positiveZIndex) {\n            await this.renderStack(child);\n        }\n    }\n\n    mask(paths: Path[]) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(0, 0);\n        this.ctx.lineTo(this.canvas.width, 0);\n        this.ctx.lineTo(this.canvas.width, this.canvas.height);\n        this.ctx.lineTo(0, this.canvas.height);\n        this.ctx.lineTo(0, 0);\n        this.formatPath(paths.slice(0).reverse());\n        this.ctx.closePath();\n    }\n\n    path(paths: Path[]) {\n        this.ctx.beginPath();\n        this.formatPath(paths);\n        this.ctx.closePath();\n    }\n\n    formatPath(paths: Path[]) {\n        paths.forEach((point, index) => {\n            const start: Vector = isBezierCurve(point) ? point.start : point;\n            if (index === 0) {\n                this.ctx.moveTo(start.x, start.y);\n            } else {\n                this.ctx.lineTo(start.x, start.y);\n            }\n\n            if (isBezierCurve(point)) {\n                this.ctx.bezierCurveTo(\n                    point.startControl.x,\n                    point.startControl.y,\n                    point.endControl.x,\n                    point.endControl.y,\n                    point.end.x,\n                    point.end.y\n                );\n            }\n        });\n    }\n\n    renderRepeat(path: Path[], pattern: CanvasPattern | CanvasGradient, offsetX: number, offsetY: number) {\n        this.path(path);\n        this.ctx.fillStyle = pattern;\n        this.ctx.translate(offsetX, offsetY);\n        this.ctx.fill();\n        this.ctx.translate(-offsetX, -offsetY);\n    }\n\n    resizeImage(image: HTMLImageElement, width: number, height: number): HTMLCanvasElement | HTMLImageElement {\n        if (image.width === width && image.height === height) {\n            return image;\n        }\n\n        const canvas = (this.canvas.ownerDocument as Document).createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);\n        return canvas;\n    }\n\n    async renderBackgroundImage(container: ElementContainer) {\n        let index = container.styles.backgroundImage.length - 1;\n        for (const backgroundImage of container.styles.backgroundImage.slice(0).reverse()) {\n            if (backgroundImage.type === CSSImageType.URL) {\n                let image;\n                const url = (backgroundImage as CSSURLImage).url;\n                try {\n                    image = await this.options.cache.match(url);\n                } catch (e) {\n                    Logger.getInstance(this.options.id).error(`Error loading background-image ${url}`);\n                }\n\n                if (image) {\n                    const [path, x, y, width, height] = calculateBackgroundRendering(container, index, [\n                        image.width,\n                        image.height,\n                        image.width / image.height\n                    ]);\n                    const pattern = this.ctx.createPattern(\n                        this.resizeImage(image, width, height),\n                        'repeat'\n                    ) as CanvasPattern;\n                    this.renderRepeat(path, pattern, x, y);\n                }\n            } else if (isLinearGradient(backgroundImage)) {\n                const [path, x, y, width, height] = calculateBackgroundRendering(container, index, [null, null, null]);\n                const [lineLength, x0, x1, y0, y1] = calculateGradientDirection(backgroundImage.angle, width, height);\n\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n                const gradient = ctx.createLinearGradient(x0, y0, x1, y1);\n\n                processColorStops(backgroundImage.stops, lineLength).forEach(colorStop =>\n                    gradient.addColorStop(colorStop.stop, asString(colorStop.color))\n                );\n\n                ctx.fillStyle = gradient;\n                ctx.fillRect(0, 0, width, height);\n                if (width > 0 && height > 0) {\n                    const pattern = this.ctx.createPattern(canvas, 'repeat') as CanvasPattern;\n                    this.renderRepeat(path, pattern, x, y);\n                }\n            } else if (isRadialGradient(backgroundImage)) {\n                const [path, left, top, width, height] = calculateBackgroundRendering(container, index, [\n                    null,\n                    null,\n                    null\n                ]);\n                const position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;\n                const x = getAbsoluteValue(position[0], width);\n                const y = getAbsoluteValue(position[position.length - 1], height);\n\n                const [rx, ry] = calculateRadius(backgroundImage, x, y, width, height);\n                if (rx > 0 && rx > 0) {\n                    const radialGradient = this.ctx.createRadialGradient(left + x, top + y, 0, left + x, top + y, rx);\n\n                    processColorStops(backgroundImage.stops, rx * 2).forEach(colorStop =>\n                        radialGradient.addColorStop(colorStop.stop, asString(colorStop.color))\n                    );\n\n                    this.path(path);\n                    this.ctx.fillStyle = radialGradient;\n                    if (rx !== ry) {\n                        // transforms for elliptical radial gradient\n                        const midX = container.bounds.left + 0.5 * container.bounds.width;\n                        const midY = container.bounds.top + 0.5 * container.bounds.height;\n                        const f = ry / rx;\n                        const invF = 1 / f;\n\n                        this.ctx.save();\n                        this.ctx.translate(midX, midY);\n                        this.ctx.transform(1, 0, 0, f, 0, 0);\n                        this.ctx.translate(-midX, -midY);\n\n                        this.ctx.fillRect(left, invF * (top - midY) + midY, width, height * invF);\n                        this.ctx.restore();\n                    } else {\n                        this.ctx.fill();\n                    }\n                }\n            }\n            index--;\n        }\n    }\n\n    async renderBorder(color: Color, side: number, curvePoints: BoundCurves) {\n        this.path(parsePathForBorder(curvePoints, side));\n        this.ctx.fillStyle = asString(color);\n        this.ctx.fill();\n    }\n\n    async renderNodeBackgroundAndBorders(paint: ElementPaint) {\n        this.applyEffects(paint.effects, EffectTarget.BACKGROUND_BORDERS);\n        const styles = paint.container.styles;\n        const hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;\n\n        const borders = [\n            {style: styles.borderTopStyle, color: styles.borderTopColor},\n            {style: styles.borderRightStyle, color: styles.borderRightColor},\n            {style: styles.borderBottomStyle, color: styles.borderBottomColor},\n            {style: styles.borderLeftStyle, color: styles.borderLeftColor}\n        ];\n\n        const backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(\n            getBackgroundValueForIndex(styles.backgroundClip, 0),\n            paint.curves\n        );\n\n        if (hasBackground || styles.boxShadow.length) {\n            this.ctx.save();\n            this.path(backgroundPaintingArea);\n            this.ctx.clip();\n\n            if (!isTransparent(styles.backgroundColor)) {\n                this.ctx.fillStyle = asString(styles.backgroundColor);\n                this.ctx.fill();\n            }\n\n            await this.renderBackgroundImage(paint.container);\n\n            this.ctx.restore();\n\n            styles.boxShadow\n                .slice(0)\n                .reverse()\n                .forEach(shadow => {\n                    this.ctx.save();\n                    const borderBoxArea = calculateBorderBoxPath(paint.curves);\n                    const maskOffset = shadow.inset ? 0 : MASK_OFFSET;\n                    const shadowPaintingArea = transformPath(\n                        borderBoxArea,\n                        -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number,\n                        (shadow.inset ? 1 : -1) * shadow.spread.number,\n                        shadow.spread.number * (shadow.inset ? -2 : 2),\n                        shadow.spread.number * (shadow.inset ? -2 : 2)\n                    );\n\n                    if (shadow.inset) {\n                        this.path(borderBoxArea);\n                        this.ctx.clip();\n                        this.mask(shadowPaintingArea);\n                    } else {\n                        this.mask(borderBoxArea);\n                        this.ctx.clip();\n                        this.path(shadowPaintingArea);\n                    }\n\n                    this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;\n                    this.ctx.shadowOffsetY = shadow.offsetY.number;\n                    this.ctx.shadowColor = asString(shadow.color);\n                    this.ctx.shadowBlur = shadow.blur.number;\n                    this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';\n\n                    this.ctx.fill();\n                    this.ctx.restore();\n                });\n        }\n\n        let side = 0;\n        for (const border of borders) {\n            if (border.style !== BORDER_STYLE.NONE && !isTransparent(border.color)) {\n                await this.renderBorder(border.color, side, paint.curves);\n            }\n            side++;\n        }\n    }\n\n    async render(element: ElementContainer): Promise<HTMLCanvasElement> {\n        if (this.options.backgroundColor) {\n            this.ctx.fillStyle = asString(this.options.backgroundColor);\n            this.ctx.fillRect(\n                this.options.x - this.options.scrollX,\n                this.options.y - this.options.scrollY,\n                this.options.width,\n                this.options.height\n            );\n        }\n\n        const stack = parseStackingContexts(element);\n\n        await this.renderStack(stack);\n        this.applyEffects([], EffectTarget.BACKGROUND_BORDERS);\n        return this.canvas;\n    }\n}\n\nconst isTextInputElement = (\n    container: ElementContainer\n): container is InputElementContainer | TextareaElementContainer | SelectElementContainer => {\n    if (container instanceof TextareaElementContainer) {\n        return true;\n    } else if (container instanceof SelectElementContainer) {\n        return true;\n    } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {\n        return true;\n    }\n    return false;\n};\n\nconst calculateBackgroundCurvedPaintingArea = (clip: BACKGROUND_CLIP, curves: BoundCurves): Path[] => {\n    switch (clip) {\n        case BACKGROUND_CLIP.BORDER_BOX:\n            return calculateBorderBoxPath(curves);\n        case BACKGROUND_CLIP.CONTENT_BOX:\n            return calculateContentBoxPath(curves);\n        case BACKGROUND_CLIP.PADDING_BOX:\n        default:\n            return calculatePaddingBoxPath(curves);\n    }\n};\n\nconst canvasTextAlign = (textAlign: TEXT_ALIGN): CanvasTextAlign => {\n    switch (textAlign) {\n        case TEXT_ALIGN.CENTER:\n            return 'center';\n        case TEXT_ALIGN.RIGHT:\n            return 'right';\n        case TEXT_ALIGN.LEFT:\n        default:\n            return 'left';\n    }\n};\n","import {RenderConfigurations} from './canvas-renderer';\nimport {Logger} from '../../core/logger';\nimport {createForeignObjectSVG} from '../../core/features';\nimport {asString} from '../../css/types/color';\n\nexport class ForeignObjectRenderer {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    options: RenderConfigurations;\n\n    constructor(options: RenderConfigurations) {\n        this.canvas = options.canvas ? options.canvas : document.createElement('canvas');\n        this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.options = options;\n        this.canvas.width = Math.floor(options.width * options.scale);\n        this.canvas.height = Math.floor(options.height * options.scale);\n        this.canvas.style.width = `${options.width}px`;\n        this.canvas.style.height = `${options.height}px`;\n\n        this.ctx.scale(this.options.scale, this.options.scale);\n        this.ctx.translate(-options.x + options.scrollX, -options.y + options.scrollY);\n        Logger.getInstance(options.id).debug(\n            `EXPERIMENTAL ForeignObject renderer initialized (${options.width}x${options.height} at ${options.x},${\n                options.y\n            }) with scale ${options.scale}`\n        );\n    }\n\n    async render(element: HTMLElement) {\n        const svg = createForeignObjectSVG(\n            Math.max(this.options.windowWidth, this.options.width) * this.options.scale,\n            Math.max(this.options.windowHeight, this.options.height) * this.options.scale,\n            this.options.scrollX * this.options.scale,\n            this.options.scrollY * this.options.scale,\n            element\n        );\n\n        const img = await loadSerializedSVG(svg);\n\n        if (this.options.backgroundColor) {\n            this.ctx.fillStyle = asString(this.options.backgroundColor);\n            this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);\n        }\n\n        this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);\n\n        return this.canvas;\n    }\n}\n\nexport const loadSerializedSVG = (svg: Node): Promise<HTMLImageElement> =>\n    new Promise((resolve, reject) => {\n        const img = new Image();\n        img.onload = () => {\n            resolve(img);\n        };\n        img.onerror = reject;\n\n        img.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(new XMLSerializer().serializeToString(svg))}`;\n    });\n","import {Bounds, parseBounds, parseDocumentSize} from './css/layout/bounds';\nimport {color, Color, COLORS, isTransparent} from './css/types/color';\nimport {Parser} from './css/syntax/parser';\nimport {CloneOptions, DocumentCloner} from './dom/document-cloner';\nimport {isBodyElement, isHTMLElement, parseTree} from './dom/node-parser';\nimport {Logger} from './core/logger';\nimport {CacheStorage, ResourceOptions} from './core/cache-storage';\nimport {CanvasRenderer, RenderOptions} from './render/canvas/canvas-renderer';\nimport {ForeignObjectRenderer} from './render/canvas/foreignobject-renderer';\n\nexport type Options = CloneOptions &\n    RenderOptions &\n    ResourceOptions & {\n        backgroundColor: string | null;\n        foreignObjectRendering: boolean;\n        logging: boolean;\n        removeContainer?: boolean;\n    };\n\nconst parseColor = (value: string): Color => color.parse(Parser.create(value).parseComponentValue());\n\nconst html2canvas = (element: HTMLElement, options: Partial<Options> = {}): Promise<HTMLCanvasElement> => {\n    return renderElement(element, options);\n};\n\nexport default html2canvas;\n\nCacheStorage.setContext(window);\n\nconst renderElement = async (element: HTMLElement, opts: Partial<Options>): Promise<HTMLCanvasElement> => {\n    const ownerDocument = element.ownerDocument;\n\n    if (!ownerDocument) {\n        throw new Error(`Element is not attached to a Document`);\n    }\n\n    const defaultView = ownerDocument.defaultView;\n\n    if (!defaultView) {\n        throw new Error(`Document is not attached to a Window`);\n    }\n\n    const instanceName = (Math.round(Math.random() * 1000) + Date.now()).toString(16);\n\n    const {width, height, left, top} =\n        isBodyElement(element) || isHTMLElement(element) ? parseDocumentSize(ownerDocument) : parseBounds(element);\n\n    const defaultResourceOptions = {\n        allowTaint: false,\n        imageTimeout: 15000,\n        proxy: undefined,\n        useCORS: false\n    };\n\n    const resourceOptions: ResourceOptions = {...defaultResourceOptions, ...opts};\n\n    const defaultOptions = {\n        backgroundColor: '#ffffff',\n        cache: opts.cache ? opts.cache : CacheStorage.create(instanceName, resourceOptions),\n        logging: true,\n        removeContainer: true,\n        foreignObjectRendering: false,\n        scale: defaultView.devicePixelRatio || 1,\n        windowWidth: defaultView.innerWidth,\n        windowHeight: defaultView.innerHeight,\n        scrollX: defaultView.pageXOffset,\n        scrollY: defaultView.pageYOffset,\n        x: left,\n        y: top,\n        width: Math.ceil(width),\n        height: Math.ceil(height),\n        id: instanceName\n    };\n\n    const options: Options = {...defaultOptions, ...resourceOptions, ...opts};\n\n    const windowBounds = new Bounds(options.scrollX, options.scrollY, options.windowWidth, options.windowHeight);\n\n    Logger.create({id: instanceName, enabled: options.logging});\n    Logger.getInstance(instanceName).debug(`Starting document clone`);\n    const documentCloner = new DocumentCloner(element, {\n        id: instanceName,\n        onclone: options.onclone,\n        ignoreElements: options.ignoreElements,\n        inlineImages: options.foreignObjectRendering,\n        copyStyles: options.foreignObjectRendering\n    });\n    const clonedElement = documentCloner.clonedReferenceElement;\n    if (!clonedElement) {\n        return Promise.reject(`Unable to find element in cloned iframe`);\n    }\n\n    const container = await documentCloner.toIFrame(ownerDocument, windowBounds);\n\n    // http://www.w3.org/TR/css3-background/#special-backgrounds\n    const documentBackgroundColor = ownerDocument.documentElement\n        ? parseColor(getComputedStyle(ownerDocument.documentElement).backgroundColor as string)\n        : COLORS.TRANSPARENT;\n    const bodyBackgroundColor = ownerDocument.body\n        ? parseColor(getComputedStyle(ownerDocument.body).backgroundColor as string)\n        : COLORS.TRANSPARENT;\n\n    const bgColor = opts.backgroundColor;\n    const defaultBackgroundColor =\n        typeof bgColor === 'string' ? parseColor(bgColor) : bgColor === null ? COLORS.TRANSPARENT : 0xffffffff;\n\n    const backgroundColor =\n        element === ownerDocument.documentElement\n            ? isTransparent(documentBackgroundColor)\n                ? isTransparent(bodyBackgroundColor)\n                    ? defaultBackgroundColor\n                    : bodyBackgroundColor\n                : documentBackgroundColor\n            : defaultBackgroundColor;\n\n    const renderOptions = {\n        id: instanceName,\n        cache: options.cache,\n        canvas: options.canvas,\n        backgroundColor,\n        scale: options.scale,\n        x: options.x,\n        y: options.y,\n        scrollX: options.scrollX,\n        scrollY: options.scrollY,\n        width: options.width,\n        height: options.height,\n        windowWidth: options.windowWidth,\n        windowHeight: options.windowHeight\n    };\n\n    let canvas;\n\n    if (options.foreignObjectRendering) {\n        Logger.getInstance(instanceName).debug(`Document cloned, using foreign object rendering`);\n        const renderer = new ForeignObjectRenderer(renderOptions);\n        canvas = await renderer.render(clonedElement);\n    } else {\n        Logger.getInstance(instanceName).debug(`Document cloned, using computed rendering`);\n\n        CacheStorage.attachInstance(options.cache);\n        Logger.getInstance(instanceName).debug(`Starting DOM parsing`);\n        const root = parseTree(clonedElement);\n        CacheStorage.detachInstance();\n\n        if (backgroundColor === root.styles.backgroundColor) {\n            root.styles.backgroundColor = COLORS.TRANSPARENT;\n        }\n\n        Logger.getInstance(instanceName).debug(`Starting renderer`);\n\n        const renderer = new CanvasRenderer(renderOptions);\n        canvas = await renderer.render(root);\n    }\n\n    if (options.removeContainer === true) {\n        if (!DocumentCloner.destroy(container)) {\n            Logger.getInstance(instanceName).error(`Cannot detach cloned iframe as it is not in the DOM anymore`);\n        }\n    }\n\n    Logger.getInstance(instanceName).debug(`Finished rendering`);\n    Logger.destroy(instanceName);\n    CacheStorage.destroy(instanceName);\n    return canvas;\n};\n","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","var globals = [\"document\", \"window\", \"later\"],\n    globalValues = {};\n\nglobals.forEach(function(g) {\n  if (g in global) globalValues[g] = global[g];\n});\n\nrequire(process.env['LATER_COV'] ? \"./later-cov\" : \"./later\");\n\nmodule.exports = later;\n\nglobals.forEach(function(g) {\n  if (g in globalValues) global[g] = globalValues[g];\n  else delete global[g];\n});","later = function() {\n  \"use strict\";\n  var later = {\n    version: \"1.2.0\"\n  };\n  if (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function(searchElement) {\n      \"use strict\";\n      if (this == null) {\n        throw new TypeError();\n      }\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (len === 0) {\n        return -1;\n      }\n      var n = 0;\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n        if (n != n) {\n          n = 0;\n        } else if (n != 0 && n != Infinity && n != -Infinity) {\n          n = (n > 0 || -1) * Math.floor(Math.abs(n));\n        }\n      }\n      if (n >= len) {\n        return -1;\n      }\n      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n      for (;k < len; k++) {\n        if (k in t && t[k] === searchElement) {\n          return k;\n        }\n      }\n      return -1;\n    };\n  }\n  if (!String.prototype.trim) {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g, \"\");\n    };\n  }\n  later.array = {};\n  later.array.sort = function(arr, zeroIsLast) {\n    arr.sort(function(a, b) {\n      return +a - +b;\n    });\n    if (zeroIsLast && arr[0] === 0) {\n      arr.push(arr.shift());\n    }\n  };\n  later.array.next = function(val, values, extent) {\n    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;\n    for (var i = values.length - 1; i > -1; --i) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {\n        nextIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[nextIdx];\n  };\n  later.array.nextInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next++;\n      if (next > max) {\n        next = min;\n      }\n      i++;\n      if (i === len) {\n        i = 0;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.array.prev = function(val, values, extent) {\n    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;\n    for (var i = 0; i < len; i++) {\n      cur = values[i];\n      if (cur === val) {\n        return cur;\n      }\n      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {\n        prevIdx = i;\n        continue;\n      }\n      break;\n    }\n    return values[prevIdx];\n  };\n  later.array.prevInvalid = function(val, values, extent) {\n    var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n    while (next === (values[i] || zeroVal)) {\n      next--;\n      if (next < min) {\n        next = max;\n      }\n      i--;\n      if (i === -1) {\n        i = len - 1;\n      }\n      if (next === start) {\n        return undefined;\n      }\n    }\n    return next;\n  };\n  later.day = later.D = {\n    name: \"day\",\n    range: 86400,\n    val: function(d) {\n      return d.D || (d.D = later.date.getDate.call(d));\n    },\n    isValid: function(d, val) {\n      return later.D.val(d) === (val || later.D.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.DExtent) return d.DExtent;\n      var month = later.M.val(d), max = later.DAYS_IN_MONTH[month - 1];\n      if (month === 2 && later.dy.extent(d)[1] === 366) {\n        max = max + 1;\n      }\n      return d.DExtent = [ 1, max ];\n    },\n    start: function(d) {\n      return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    end: function(d) {\n      return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));\n    },\n    next: function(d, val) {\n      val = val > later.D.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      val = val > DMax ? 1 : val || DMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), val);\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n      return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);\n    }\n  };\n  later.dayOfWeekCount = later.dc = {\n    name: \"day of week count\",\n    range: 604800,\n    val: function(d) {\n      return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;\n    },\n    extent: function(d) {\n      return d.dcExtent || (d.dcExtent = [ 1, Math.ceil(later.D.extent(d)[1] / 7) ]);\n    },\n    start: function(d) {\n      return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));\n    },\n    end: function(d) {\n      return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.dc.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? 1 : val;\n      var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      if (next.getTime() <= d.getTime()) {\n        month = later.M.next(d, later.M.val(d) + 1);\n        return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n      val = val > dcMax ? dcMax : val || dcMax;\n      return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));\n    }\n  };\n  later.dayOfWeek = later.dw = later.d = {\n    name: \"day of week\",\n    range: 86400,\n    val: function(d) {\n      return d.dw || (d.dw = later.date.getDay.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.dw.val(d) === (val || 7);\n    },\n    extent: function() {\n      return [ 1, 7 ];\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > 7 ? 1 : val || 7;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n    },\n    prev: function(d, val) {\n      val = val > 7 ? 7 : val || 7;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n    }\n  };\n  later.dayOfYear = later.dy = {\n    name: \"day of year\",\n    range: 86400,\n    val: function(d) {\n      return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n    },\n    isValid: function(d, val) {\n      return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n    },\n    extent: function(d) {\n      var year = later.Y.val(d);\n      return d.dyExtent || (d.dyExtent = [ 1, year % 4 ? 365 : 366 ]);\n    },\n    start: function(d) {\n      return later.D.start(d);\n    },\n    end: function(d) {\n      return later.D.end(d);\n    },\n    next: function(d, val) {\n      val = val > later.dy.extent(d)[1] ? 1 : val;\n      var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? 1 : val || dyMax;\n      return later.date.next(later.Y.val(year), later.M.val(year), val);\n    },\n    prev: function(d, val) {\n      var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n      val = val > dyMax ? dyMax : val || dyMax;\n      return later.date.prev(later.Y.val(year), later.M.val(year), val);\n    }\n  };\n  later.hour = later.h = {\n    name: \"hour\",\n    range: 3600,\n    val: function(d) {\n      return d.h || (d.h = later.date.getHour.call(d));\n    },\n    isValid: function(d, val) {\n      return later.h.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 23 ];\n    },\n    start: function(d) {\n      return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    end: function(d) {\n      return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 23 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 23 ? 23 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);\n    }\n  };\n  later.minute = later.m = {\n    name: \"minute\",\n    range: 60,\n    val: function(d) {\n      return d.m || (d.m = later.date.getMin.call(d));\n    },\n    isValid: function(d, val) {\n      return later.m.val(d) === val;\n    },\n    extent: function(d) {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    end: function(d) {\n      return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n    },\n    next: function(d, val) {\n      var m = later.m.val(d), s = later.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);\n    }\n  };\n  later.month = later.M = {\n    name: \"month\",\n    range: 2629740,\n    val: function(d) {\n      return d.M || (d.M = later.date.getMonth.call(d) + 1);\n    },\n    isValid: function(d, val) {\n      return later.M.val(d) === (val || 12);\n    },\n    extent: function() {\n      return [ 1, 12 ];\n    },\n    start: function(d) {\n      return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n    },\n    end: function(d) {\n      return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n    },\n    next: function(d, val) {\n      val = val > 12 ? 1 : val || 12;\n      return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);\n    },\n    prev: function(d, val) {\n      val = val > 12 ? 12 : val || 12;\n      return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);\n    }\n  };\n  later.second = later.s = {\n    name: \"second\",\n    range: 1,\n    val: function(d) {\n      return d.s || (d.s = later.date.getSec.call(d));\n    },\n    isValid: function(d, val) {\n      return later.s.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 59 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      var s = later.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later.SEC);\n      if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n        next = new Date(d.getTime() + (inc + 7200) * later.SEC);\n      }\n      return next;\n    },\n    prev: function(d, val, cache) {\n      val = val > 59 ? 59 : val;\n      return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);\n    }\n  };\n  later.time = later.t = {\n    name: \"time\",\n    range: 1,\n    val: function(d) {\n      return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));\n    },\n    isValid: function(d, val) {\n      return later.t.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 86399 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      val = val > 86399 ? 0 : val;\n      var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);\n      if (!later.date.isUTC && next.getTime() < d.getTime()) {\n        next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);\n      }\n      return next;\n    },\n    prev: function(d, val) {\n      val = val > 86399 ? 86399 : val;\n      return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);\n    }\n  };\n  later.weekOfMonth = later.wm = {\n    name: \"week of month\",\n    range: 604800,\n    val: function(d) {\n      return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n    },\n    isValid: function(d, val) {\n      return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n    },\n    extent: function(d) {\n      return d.wmExtent || (d.wmExtent = [ 1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7 ]);\n    },\n    start: function(d) {\n      return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n    },\n    end: function(d) {\n      return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n    },\n    next: function(d, val) {\n      val = val > later.wm.extent(d)[1] ? 1 : val;\n      var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? 1 : val || wmMax;\n      return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));\n    },\n    prev: function(d, val) {\n      var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n      val = val > wmMax ? wmMax : val || wmMax;\n      return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));\n    }\n  };\n  later.weekOfYear = later.wy = {\n    name: \"week of year (ISO)\",\n    range: 604800,\n    val: function(d) {\n      if (d.wy) return d.wy;\n      var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);\n      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);\n    },\n    isValid: function(d, val) {\n      return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n    },\n    extent: function(d) {\n      if (d.wyExtent) return d.wyExtent;\n      var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));\n      return d.wyExtent = [ 1, dwFirst === 5 || dwLast === 5 ? 53 : 52 ];\n    },\n    start: function(d) {\n      return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));\n    },\n    end: function(d) {\n      return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));\n    },\n    next: function(d, val) {\n      val = val > later.wy.extent(d)[1] ? 1 : val;\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);\n      val = val > wyMax ? 1 : val || wyMax;\n      return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));\n    },\n    prev: function(d, val) {\n      var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n      if (later.wy.val(year) !== 1) {\n        year = later.dw.next(year, 2);\n      }\n      var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);\n      val = val > wyMax ? wyMax : val || wyMax;\n      return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));\n    }\n  };\n  later.year = later.Y = {\n    name: \"year\",\n    range: 31556900,\n    val: function(d) {\n      return d.Y || (d.Y = later.date.getYear.call(d));\n    },\n    isValid: function(d, val) {\n      return later.Y.val(d) === val;\n    },\n    extent: function() {\n      return [ 1970, 2099 ];\n    },\n    start: function(d) {\n      return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n    },\n    end: function(d) {\n      return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n    },\n    next: function(d, val) {\n      return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;\n    }\n  };\n  later.fullDate = later.fd = {\n    name: \"full date\",\n    range: 1,\n    val: function(d) {\n      return d.fd || (d.fd = d.getTime());\n    },\n    isValid: function(d, val) {\n      return later.fd.val(d) === val;\n    },\n    extent: function() {\n      return [ 0, 3250368e7 ];\n    },\n    start: function(d) {\n      return d;\n    },\n    end: function(d) {\n      return d;\n    },\n    next: function(d, val) {\n      return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n    },\n    prev: function(d, val) {\n      return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n    }\n  };\n  later.modifier = {};\n  later.modifier.after = later.modifier.a = function(constraint, values) {\n    var value = values[0];\n    return {\n      name: \"after \" + constraint.name,\n      range: (constraint.extent(new Date())[1] - value) * constraint.range,\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) >= value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        if (val != value) val = constraint.extent(startDate)[0];\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[1] : value - 1;\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.modifier.before = later.modifier.b = function(constraint, values) {\n    var value = values[values.length - 1];\n    return {\n      name: \"before \" + constraint.name,\n      range: constraint.range * (value - 1),\n      val: constraint.val,\n      isValid: function(d, val) {\n        return this.val(d) < value;\n      },\n      extent: constraint.extent,\n      start: constraint.start,\n      end: constraint.end,\n      next: function(startDate, val) {\n        val = val === value ? constraint.extent(startDate)[0] : value;\n        return constraint.next(startDate, val);\n      },\n      prev: function(startDate, val) {\n        val = val === value ? value - 1 : constraint.extent(startDate)[1];\n        return constraint.prev(startDate, val);\n      }\n    };\n  };\n  later.compile = function(schedDef) {\n    var constraints = [], constraintsLen = 0, tickConstraint;\n    for (var key in schedDef) {\n      var nameParts = key.split(\"_\"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n      constraints.push({\n        constraint: constraint,\n        vals: vals\n      });\n      constraintsLen++;\n    }\n    constraints.sort(function(a, b) {\n      var ra = a.constraint.range, rb = b.constraint.range;\n      return rb < ra ? -1 : rb > ra ? 1 : 0;\n    });\n    tickConstraint = constraints[constraintsLen - 1].constraint;\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return a.getTime() > b.getTime();\n      } : function(a, b) {\n        return b.getTime() > a.getTime();\n      };\n    }\n    return {\n      start: function(dir, startDate) {\n        var next = startDate, nextVal = later.array[dir], maxAttempts = 1e3, done;\n        while (maxAttempts-- && !done && next) {\n          done = true;\n          for (var i = 0; i < constraintsLen; i++) {\n            var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);\n            if (!constraint.isValid(next, newVal)) {\n              next = constraint[dir](next, newVal);\n              done = false;\n              break;\n            }\n          }\n        }\n        if (next !== later.NEVER) {\n          next = dir === \"next\" ? tickConstraint.start(next) : tickConstraint.end(next);\n        }\n        return next;\n      },\n      end: function(dir, startDate) {\n        var result, nextVal = later.array[dir + \"Invalid\"], compare = compareFn(dir);\n        for (var i = constraintsLen - 1; i >= 0; i--) {\n          var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;\n          if (newVal !== undefined) {\n            next = constraint[dir](startDate, newVal);\n            if (next && (!result || compare(result, next))) {\n              result = next;\n            }\n          }\n        }\n        return result;\n      },\n      tick: function(dir, date) {\n        return new Date(dir === \"next\" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);\n      },\n      tickStart: function(date) {\n        return tickConstraint.start(date);\n      }\n    };\n  };\n  later.schedule = function(sched) {\n    if (!sched) throw new Error(\"Missing schedule definition.\");\n    if (!sched.schedules) throw new Error(\"Definition must include at least one schedule.\");\n    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n    for (var i = 0; i < schedulesLen; i++) {\n      schedules.push(later.compile(sched.schedules[i]));\n    }\n    for (var j = 0; j < exceptionsLen; j++) {\n      exceptions.push(later.compile(sched.exceptions[j]));\n    }\n    function getInstances(dir, count, startDate, endDate, isRange) {\n      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e3, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === \"next\", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;\n      startDate = startDate ? new Date(startDate) : new Date();\n      if (!startDate || !startDate.getTime()) throw new Error(\"Invalid start date.\");\n      setNextStarts(dir, schedules, schedStarts, startDate);\n      setRangeStarts(dir, exceptions, exceptStarts, startDate);\n      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n        if (endDate && compare(next, endDate)) {\n          break;\n        }\n        if (exceptionsLen) {\n          updateRangeStarts(dir, exceptions, exceptStarts, next);\n          if (end = calcRangeOverlap(dir, exceptStarts, next)) {\n            updateNextStarts(dir, schedules, schedStarts, end);\n            continue;\n          }\n        }\n        if (isRange) {\n          var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n          var r = isForward ? [ new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined ] : [ end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC)) ];\n          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n            lastResult[rEnd] = r[rEnd];\n            loopCount++;\n          } else {\n            lastResult = r;\n            results.push(lastResult);\n          }\n          if (!end) break;\n          updateNextStarts(dir, schedules, schedStarts, end);\n        } else {\n          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));\n          tickStarts(dir, schedules, schedStarts, next);\n        }\n        loopCount--;\n      }\n      for (var i = 0, len = results.length; i < len; i++) {\n        var result = results[i];\n        results[i] = Object.prototype.toString.call(result) === \"[object Array]\" ? [ cleanDate(result[0]), cleanDate(result[1]) ] : cleanDate(result);\n      }\n      return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n    }\n    function cleanDate(d) {\n      if (d instanceof Date && !isNaN(d.valueOf())) {\n        return new Date(d);\n      }\n      return undefined;\n    }\n    function setNextStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        startsArr[i] = schedArr[i].start(dir, startDate);\n      }\n    }\n    function updateNextStarts(dir, schedArr, startsArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && !compare(startsArr[i], startDate)) {\n          startsArr[i] = schedArr[i].start(dir, startDate);\n        }\n      }\n    }\n    function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var nextStart = schedArr[i].start(dir, startDate);\n        if (!nextStart) {\n          rangesArr[i] = later.NEVER;\n        } else {\n          rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n        }\n      }\n    }\n    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n      var compare = compareFn(dir);\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n          var nextStart = schedArr[i].start(dir, startDate);\n          if (!nextStart) {\n            rangesArr[i] = later.NEVER;\n          } else {\n            rangesArr[i] = [ nextStart, schedArr[i].end(dir, nextStart) ];\n          }\n        }\n      }\n    }\n    function tickStarts(dir, schedArr, startsArr, startDate) {\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n        }\n      }\n    }\n    function getStart(schedArr, startsArr, startDate, minEndDate) {\n      var result;\n      for (var i = 0, len = startsArr.length; i < len; i++) {\n        if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n          var start = schedArr[i].tickStart(startDate);\n          if (minEndDate && start < minEndDate) {\n            return minEndDate;\n          }\n          if (!result || start > result) {\n            result = start;\n          }\n        }\n      }\n      return result;\n    }\n    function calcRangeOverlap(dir, rangesArr, startDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = rangesArr.length; i < len; i++) {\n        var range = rangesArr[i];\n        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {\n          if (!result || compare(range[1], result)) {\n            result = range[1];\n          }\n        }\n      }\n      return result;\n    }\n    function calcMaxEndDate(exceptsArr, compare) {\n      var result;\n      for (var i = 0, len = exceptsArr.length; i < len; i++) {\n        if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n          result = exceptsArr[i][0];\n        }\n      }\n      return result;\n    }\n    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n      var compare = compareFn(dir), result;\n      for (var i = 0, len = schedArr.length; i < len; i++) {\n        var start = startsArr[i];\n        if (start && start.getTime() === startDate.getTime()) {\n          var end = schedArr[i].end(dir, start);\n          if (maxEndDate && (!end || compare(end, maxEndDate))) {\n            return maxEndDate;\n          }\n          if (!result || compare(end, result)) {\n            result = end;\n          }\n        }\n      }\n      return result;\n    }\n    function compareFn(dir) {\n      return dir === \"next\" ? function(a, b) {\n        return !b || a.getTime() > b.getTime();\n      } : function(a, b) {\n        return !a || b.getTime() > a.getTime();\n      };\n    }\n    function findNext(arr, compare) {\n      var next = arr[0];\n      for (var i = 1, len = arr.length; i < len; i++) {\n        if (arr[i] && compare(next, arr[i])) {\n          next = arr[i];\n        }\n      }\n      return next;\n    }\n    return {\n      isValid: function(d) {\n        return getInstances(\"next\", 1, d, d) !== later.NEVER;\n      },\n      next: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate);\n      },\n      prev: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate);\n      },\n      nextRange: function(count, startDate, endDate) {\n        return getInstances(\"next\", count || 1, startDate, endDate, true);\n      },\n      prevRange: function(count, startDate, endDate) {\n        return getInstances(\"prev\", count || 1, startDate, endDate, true);\n      }\n    };\n  };\n  later.setTimeout = function(fn, sched) {\n    var s = later.schedule(sched), t;\n    if (fn) {\n      scheduleTimeout();\n    }\n    function scheduleTimeout() {\n      var now = Date.now(), next = s.next(2, now);\n      if (!next[0]) {\n        t = undefined;\n        return;\n      }\n      var diff = next[0].getTime() - now;\n      if (diff < 1e3) {\n        diff = next[1] ? next[1].getTime() - now : 1e3;\n      }\n      if (diff < 2147483647) {\n        t = setTimeout(fn, diff);\n      } else {\n        t = setTimeout(scheduleTimeout, 2147483647);\n      }\n    }\n    return {\n      isDone: function() {\n        return !t;\n      },\n      clear: function() {\n        clearTimeout(t);\n      }\n    };\n  };\n  later.setInterval = function(fn, sched) {\n    if (!fn) {\n      return;\n    }\n    var t = later.setTimeout(scheduleTimeout, sched), done = t.isDone();\n    function scheduleTimeout() {\n      if (!done) {\n        fn();\n        t = later.setTimeout(scheduleTimeout, sched);\n      }\n    }\n    return {\n      isDone: function() {\n        return t.isDone();\n      },\n      clear: function() {\n        done = true;\n        t.clear();\n      }\n    };\n  };\n  later.date = {};\n  later.date.timezone = function(useLocalTime) {\n    later.date.build = useLocalTime ? function(Y, M, D, h, m, s) {\n      return new Date(Y, M, D, h, m, s);\n    } : function(Y, M, D, h, m, s) {\n      return new Date(Date.UTC(Y, M, D, h, m, s));\n    };\n    var get = useLocalTime ? \"get\" : \"getUTC\", d = Date.prototype;\n    later.date.getYear = d[get + \"FullYear\"];\n    later.date.getMonth = d[get + \"Month\"];\n    later.date.getDate = d[get + \"Date\"];\n    later.date.getDay = d[get + \"Day\"];\n    later.date.getHour = d[get + \"Hours\"];\n    later.date.getMin = d[get + \"Minutes\"];\n    later.date.getSec = d[get + \"Seconds\"];\n    later.date.isUTC = !useLocalTime;\n  };\n  later.date.UTC = function() {\n    later.date.timezone(false);\n  };\n  later.date.localTime = function() {\n    later.date.timezone(true);\n  };\n  later.date.UTC();\n  later.SEC = 1e3;\n  later.MIN = later.SEC * 60;\n  later.HOUR = later.MIN * 60;\n  later.DAY = later.HOUR * 24;\n  later.WEEK = later.DAY * 7;\n  later.DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];\n  later.NEVER = 0;\n  later.date.next = function(Y, M, D, h, m, s) {\n    return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);\n  };\n  later.date.nextRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d), max = constraint.extent(d)[1];\n    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);\n  };\n  later.date.prev = function(Y, M, D, h, m, s) {\n    var len = arguments.length;\n    M = len < 2 ? 11 : M - 1;\n    D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;\n    h = len < 4 ? 23 : h;\n    m = len < 5 ? 59 : m;\n    s = len < 6 ? 59 : s;\n    return later.date.build(Y, M, D, h, m, s);\n  };\n  later.date.prevRollover = function(d, val, constraint, period) {\n    var cur = constraint.val(d);\n    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);\n  };\n  later.parse = {};\n  later.parse.cron = function(expr, hasSeconds) {\n    var NAMES = {\n      JAN: 1,\n      FEB: 2,\n      MAR: 3,\n      APR: 4,\n      MAY: 5,\n      JUN: 6,\n      JUL: 7,\n      AUG: 8,\n      SEP: 9,\n      OCT: 10,\n      NOV: 11,\n      DEC: 12,\n      SUN: 1,\n      MON: 2,\n      TUE: 3,\n      WED: 4,\n      THU: 5,\n      FRI: 6,\n      SAT: 7\n    };\n    var REPLACEMENTS = {\n      \"* * * * * *\": \"0/1 * * * * *\",\n      \"@YEARLY\": \"0 0 1 1 *\",\n      \"@ANNUALLY\": \"0 0 1 1 *\",\n      \"@MONTHLY\": \"0 0 1 * *\",\n      \"@WEEKLY\": \"0 0 * * 0\",\n      \"@DAILY\": \"0 0 * * *\",\n      \"@HOURLY\": \"0 * * * *\"\n    };\n    var FIELDS = {\n      s: [ 0, 0, 59 ],\n      m: [ 1, 0, 59 ],\n      h: [ 2, 0, 23 ],\n      D: [ 3, 1, 31 ],\n      M: [ 4, 1, 12 ],\n      Y: [ 6, 1970, 2099 ],\n      d: [ 5, 1, 7, 1 ]\n    };\n    function getValue(value, offset, max) {\n      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);\n    }\n    function cloneSchedule(sched) {\n      var clone = {}, field;\n      for (field in sched) {\n        if (field !== \"dc\" && field !== \"d\") {\n          clone[field] = sched[field].slice(0);\n        }\n      }\n      return clone;\n    }\n    function add(sched, name, min, max, inc) {\n      var i = min;\n      if (!sched[name]) {\n        sched[name] = [];\n      }\n      while (i <= max) {\n        if (sched[name].indexOf(i) < 0) {\n          sched[name].push(i);\n        }\n        i += inc || 1;\n      }\n      sched[name].sort(function(a, b) {\n        return a - b;\n      });\n    }\n    function addHash(schedules, curSched, value, hash) {\n      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {\n        schedules.push(cloneSchedule(curSched));\n        curSched = schedules[schedules.length - 1];\n      }\n      add(curSched, \"d\", value, value);\n      add(curSched, \"dc\", hash, hash);\n    }\n    function addWeekday(s, curSched, value) {\n      var except1 = {}, except2 = {};\n      if (value === 1) {\n        add(curSched, \"D\", 1, 3);\n        add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n        add(except1, \"D\", 2, 2);\n        add(except1, \"d\", NAMES.TUE, NAMES.FRI);\n        add(except2, \"D\", 3, 3);\n        add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n      } else {\n        add(curSched, \"D\", value - 1, value + 1);\n        add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n        add(except1, \"D\", value - 1, value - 1);\n        add(except1, \"d\", NAMES.MON, NAMES.THU);\n        add(except2, \"D\", value + 1, value + 1);\n        add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n      }\n      s.exceptions.push(except1);\n      s.exceptions.push(except2);\n    }\n    function addRange(item, curSched, name, min, max, offset) {\n      var incSplit = item.split(\"/\"), inc = +incSplit[1], range = incSplit[0];\n      if (range !== \"*\" && range !== \"0\") {\n        var rangeSplit = range.split(\"-\");\n        min = getValue(rangeSplit[0], offset, max);\n        max = getValue(rangeSplit[1], offset, max) || max;\n      }\n      add(curSched, name, min, max, inc);\n    }\n    function parse(item, s, name, min, max, offset) {\n      var value, split, schedules = s.schedules, curSched = schedules[schedules.length - 1];\n      if (item === \"L\") {\n        item = min - 1;\n      }\n      if ((value = getValue(item, offset, max)) !== null) {\n        add(curSched, name, value, value);\n      } else if ((value = getValue(item.replace(\"W\", \"\"), offset, max)) !== null) {\n        addWeekday(s, curSched, value);\n      } else if ((value = getValue(item.replace(\"L\", \"\"), offset, max)) !== null) {\n        addHash(schedules, curSched, value, min - 1);\n      } else if ((split = item.split(\"#\")).length === 2) {\n        value = getValue(split[0], offset, max);\n        addHash(schedules, curSched, value, getValue(split[1]));\n      } else {\n        addRange(item, curSched, name, min, max, offset);\n      }\n    }\n    function isHash(item) {\n      return item.indexOf(\"#\") > -1 || item.indexOf(\"L\") > 0;\n    }\n    function itemSorter(a, b) {\n      return isHash(a) && !isHash(b) ? 1 : a - b;\n    }\n    function parseExpr(expr) {\n      var schedule = {\n        schedules: [ {} ],\n        exceptions: []\n      }, components = expr.replace(/(\\s)+/g, \" \").split(\" \"), field, f, component, items;\n      for (field in FIELDS) {\n        f = FIELDS[field];\n        component = components[f[0]];\n        if (component && component !== \"*\" && component !== \"?\") {\n          items = component.split(\",\").sort(itemSorter);\n          var i, length = items.length;\n          for (i = 0; i < length; i++) {\n            parse(items[i], schedule, field, f[1], f[2], f[3]);\n          }\n        }\n      }\n      return schedule;\n    }\n    function prepareExpr(expr) {\n      var prepared = expr.toUpperCase();\n      return REPLACEMENTS[prepared] || prepared;\n    }\n    var e = prepareExpr(expr);\n    return parseExpr(hasSeconds ? e : \"0 \" + e);\n  };\n  later.parse.recur = function() {\n    var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every, modifier, applyMin, applyMax, i, last;\n    function add(name, min, max) {\n      name = modifier ? name + \"_\" + modifier : name;\n      if (!cur) {\n        curArr.push({});\n        cur = curArr[0];\n      }\n      if (!cur[name]) {\n        cur[name] = [];\n      }\n      curName = cur[name];\n      if (every) {\n        values = [];\n        for (i = min; i <= max; i += every) {\n          values.push(i);\n        }\n        last = {\n          n: name,\n          x: every,\n          c: curName.length,\n          m: max\n        };\n      }\n      values = applyMin ? [ min ] : applyMax ? [ max ] : values;\n      var length = values.length;\n      for (i = 0; i < length; i += 1) {\n        var val = values[i];\n        if (curName.indexOf(val) < 0) {\n          curName.push(val);\n        }\n      }\n      values = every = modifier = applyMin = applyMax = 0;\n    }\n    return {\n      schedules: schedules,\n      exceptions: exceptions,\n      on: function() {\n        values = arguments[0] instanceof Array ? arguments[0] : arguments;\n        return this;\n      },\n      every: function(x) {\n        every = x || 1;\n        return this;\n      },\n      after: function(x) {\n        modifier = \"a\";\n        values = [ x ];\n        return this;\n      },\n      before: function(x) {\n        modifier = \"b\";\n        values = [ x ];\n        return this;\n      },\n      first: function() {\n        applyMin = 1;\n        return this;\n      },\n      last: function() {\n        applyMax = 1;\n        return this;\n      },\n      time: function() {\n        for (var i = 0, len = values.length; i < len; i++) {\n          var split = values[i].split(\":\");\n          if (split.length < 3) split.push(0);\n          values[i] = +split[0] * 3600 + +split[1] * 60 + +split[2];\n        }\n        add(\"t\");\n        return this;\n      },\n      second: function() {\n        add(\"s\", 0, 59);\n        return this;\n      },\n      minute: function() {\n        add(\"m\", 0, 59);\n        return this;\n      },\n      hour: function() {\n        add(\"h\", 0, 23);\n        return this;\n      },\n      dayOfMonth: function() {\n        add(\"D\", 1, applyMax ? 0 : 31);\n        return this;\n      },\n      dayOfWeek: function() {\n        add(\"d\", 1, 7);\n        return this;\n      },\n      onWeekend: function() {\n        values = [ 1, 7 ];\n        return this.dayOfWeek();\n      },\n      onWeekday: function() {\n        values = [ 2, 3, 4, 5, 6 ];\n        return this.dayOfWeek();\n      },\n      dayOfWeekCount: function() {\n        add(\"dc\", 1, applyMax ? 0 : 5);\n        return this;\n      },\n      dayOfYear: function() {\n        add(\"dy\", 1, applyMax ? 0 : 366);\n        return this;\n      },\n      weekOfMonth: function() {\n        add(\"wm\", 1, applyMax ? 0 : 5);\n        return this;\n      },\n      weekOfYear: function() {\n        add(\"wy\", 1, applyMax ? 0 : 53);\n        return this;\n      },\n      month: function() {\n        add(\"M\", 1, 12);\n        return this;\n      },\n      year: function() {\n        add(\"Y\", 1970, 2450);\n        return this;\n      },\n      fullDate: function() {\n        for (var i = 0, len = values.length; i < len; i++) {\n          values[i] = values[i].getTime();\n        }\n        add(\"fd\");\n        return this;\n      },\n      customModifier: function(id, vals) {\n        var custom = later.modifier[id];\n        if (!custom) throw new Error(\"Custom modifier \" + id + \" not recognized!\");\n        modifier = id;\n        values = arguments[1] instanceof Array ? arguments[1] : [ arguments[1] ];\n        return this;\n      },\n      customPeriod: function(id) {\n        var custom = later[id];\n        if (!custom) throw new Error(\"Custom time period \" + id + \" not recognized!\");\n        add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);\n        return this;\n      },\n      startingOn: function(start) {\n        return this.between(start, last.m);\n      },\n      between: function(start, end) {\n        cur[last.n] = cur[last.n].splice(0, last.c);\n        every = last.x;\n        add(last.n, start, end);\n        return this;\n      },\n      and: function() {\n        cur = curArr[curArr.push({}) - 1];\n        return this;\n      },\n      except: function() {\n        curArr = exceptions;\n        cur = null;\n        return this;\n      }\n    };\n  };\n  later.parse.text = function(str) {\n    var recur = later.parse.recur, pos = 0, input = \"\", error;\n    var TOKENTYPES = {\n      eof: /^$/,\n      rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,\n      time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,\n      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,\n      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,\n      yearIndex: /^(\\d\\d\\d\\d)\\b/,\n      every: /^every\\b/,\n      after: /^after\\b/,\n      before: /^before\\b/,\n      second: /^(s|sec(ond)?(s)?)\\b/,\n      minute: /^(m|min(ute)?(s)?)\\b/,\n      hour: /^(h|hour(s)?)\\b/,\n      day: /^(day(s)?( of the month)?)\\b/,\n      dayInstance: /^day instance\\b/,\n      dayOfWeek: /^day(s)? of the week\\b/,\n      dayOfYear: /^day(s)? of the year\\b/,\n      weekOfYear: /^week(s)?( of the year)?\\b/,\n      weekOfMonth: /^week(s)? of the month\\b/,\n      weekday: /^weekday\\b/,\n      weekend: /^weekend\\b/,\n      month: /^month(s)?\\b/,\n      year: /^year(s)?\\b/,\n      between: /^between (the)?\\b/,\n      start: /^(start(ing)? (at|on( the)?)?)\\b/,\n      at: /^(at|@)\\b/,\n      and: /^(,|and\\b)/,\n      except: /^(except\\b)/,\n      also: /(also)\\b/,\n      first: /^(first)\\b/,\n      last: /^last\\b/,\n      \"in\": /^in\\b/,\n      of: /^of\\b/,\n      onthe: /^on the\\b/,\n      on: /^on\\b/,\n      through: /(-|^(to|through)\\b)/\n    };\n    var NAMES = {\n      jan: 1,\n      feb: 2,\n      mar: 3,\n      apr: 4,\n      may: 5,\n      jun: 6,\n      jul: 7,\n      aug: 8,\n      sep: 9,\n      oct: 10,\n      nov: 11,\n      dec: 12,\n      sun: 1,\n      mon: 2,\n      tue: 3,\n      wed: 4,\n      thu: 5,\n      fri: 6,\n      sat: 7,\n      \"1st\": 1,\n      fir: 1,\n      \"2nd\": 2,\n      sec: 2,\n      \"3rd\": 3,\n      thi: 3,\n      \"4th\": 4,\n      \"for\": 4\n    };\n    function t(start, end, text, type) {\n      return {\n        startPos: start,\n        endPos: end,\n        text: text,\n        type: type\n      };\n    }\n    function peek(expected) {\n      var scanTokens = expected instanceof Array ? expected : [ expected ], whiteSpace = /\\s+/, token, curInput, m, scanToken, start, len;\n      scanTokens.push(whiteSpace);\n      start = pos;\n      while (!token || token.type === whiteSpace) {\n        len = -1;\n        curInput = input.substring(start);\n        token = t(start, start, input.split(whiteSpace)[0]);\n        var i, length = scanTokens.length;\n        for (i = 0; i < length; i++) {\n          scanToken = scanTokens[i];\n          m = scanToken.exec(curInput);\n          if (m && m.index === 0 && m[0].length > len) {\n            len = m[0].length;\n            token = t(start, start + len, curInput.substring(0, len), scanToken);\n          }\n        }\n        if (token.type === whiteSpace) {\n          start = token.endPos;\n        }\n      }\n      return token;\n    }\n    function scan(expectedToken) {\n      var token = peek(expectedToken);\n      pos = token.endPos;\n      return token;\n    }\n    function parseThroughExpr(tokenType) {\n      var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];\n      for (var i = start; i <= end; i++) {\n        nums.push(i);\n      }\n      return nums;\n    }\n    function parseRanges(tokenType) {\n      var nums = parseThroughExpr(tokenType);\n      while (checkAndParse(TOKENTYPES.and)) {\n        nums = nums.concat(parseThroughExpr(tokenType));\n      }\n      return nums;\n    }\n    function parseEvery(r) {\n      var num, period, start, end;\n      if (checkAndParse(TOKENTYPES.weekend)) {\n        r.on(NAMES.sun, NAMES.sat).dayOfWeek();\n      } else if (checkAndParse(TOKENTYPES.weekday)) {\n        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();\n      } else {\n        num = parseTokenValue(TOKENTYPES.rank);\n        r.every(num);\n        period = parseTimePeriod(r);\n        if (checkAndParse(TOKENTYPES.start)) {\n          num = parseTokenValue(TOKENTYPES.rank);\n          r.startingOn(num);\n          parseToken(period.type);\n        } else if (checkAndParse(TOKENTYPES.between)) {\n          start = parseTokenValue(TOKENTYPES.rank);\n          if (checkAndParse(TOKENTYPES.and)) {\n            end = parseTokenValue(TOKENTYPES.rank);\n            r.between(start, end);\n          }\n        }\n      }\n    }\n    function parseOnThe(r) {\n      if (checkAndParse(TOKENTYPES.first)) {\n        r.first();\n      } else if (checkAndParse(TOKENTYPES.last)) {\n        r.last();\n      } else {\n        r.on(parseRanges(TOKENTYPES.rank));\n      }\n      parseTimePeriod(r);\n    }\n    function parseScheduleExpr(str) {\n      pos = 0;\n      input = str;\n      error = -1;\n      var r = recur();\n      while (pos < input.length && error < 0) {\n        var token = parseToken([ TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also ]);\n        switch (token.type) {\n         case TOKENTYPES.every:\n          parseEvery(r);\n          break;\n\n         case TOKENTYPES.after:\n          if (peek(TOKENTYPES.time).type !== undefined) {\n            r.after(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          } else {\n            r.after(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n\n         case TOKENTYPES.before:\n          if (peek(TOKENTYPES.time).type !== undefined) {\n            r.before(parseTokenValue(TOKENTYPES.time));\n            r.time();\n          } else {\n            r.before(parseTokenValue(TOKENTYPES.rank));\n            parseTimePeriod(r);\n          }\n          break;\n\n         case TOKENTYPES.onthe:\n          parseOnThe(r);\n          break;\n\n         case TOKENTYPES.on:\n          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();\n          break;\n\n         case TOKENTYPES.of:\n          r.on(parseRanges(TOKENTYPES.monthName)).month();\n          break;\n\n         case TOKENTYPES[\"in\"]:\n          r.on(parseRanges(TOKENTYPES.yearIndex)).year();\n          break;\n\n         case TOKENTYPES.at:\n          r.on(parseTokenValue(TOKENTYPES.time)).time();\n          while (checkAndParse(TOKENTYPES.and)) {\n            r.on(parseTokenValue(TOKENTYPES.time)).time();\n          }\n          break;\n\n         case TOKENTYPES.and:\n          break;\n\n         case TOKENTYPES.also:\n          r.and();\n          break;\n\n         case TOKENTYPES.except:\n          r.except();\n          break;\n\n         default:\n          error = pos;\n        }\n      }\n      return {\n        schedules: r.schedules,\n        exceptions: r.exceptions,\n        error: error\n      };\n    }\n    function parseTimePeriod(r) {\n      var timePeriod = parseToken([ TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear ]);\n      switch (timePeriod.type) {\n       case TOKENTYPES.second:\n        r.second();\n        break;\n\n       case TOKENTYPES.minute:\n        r.minute();\n        break;\n\n       case TOKENTYPES.hour:\n        r.hour();\n        break;\n\n       case TOKENTYPES.dayOfYear:\n        r.dayOfYear();\n        break;\n\n       case TOKENTYPES.dayOfWeek:\n        r.dayOfWeek();\n        break;\n\n       case TOKENTYPES.dayInstance:\n        r.dayOfWeekCount();\n        break;\n\n       case TOKENTYPES.day:\n        r.dayOfMonth();\n        break;\n\n       case TOKENTYPES.weekOfMonth:\n        r.weekOfMonth();\n        break;\n\n       case TOKENTYPES.weekOfYear:\n        r.weekOfYear();\n        break;\n\n       case TOKENTYPES.month:\n        r.month();\n        break;\n\n       case TOKENTYPES.year:\n        r.year();\n        break;\n\n       default:\n        error = pos;\n      }\n      return timePeriod;\n    }\n    function checkAndParse(tokenType) {\n      var found = peek(tokenType).type === tokenType;\n      if (found) {\n        scan(tokenType);\n      }\n      return found;\n    }\n    function parseToken(tokenType) {\n      var t = scan(tokenType);\n      if (t.type) {\n        t.text = convertString(t.text, tokenType);\n      } else {\n        error = pos;\n      }\n      return t;\n    }\n    function parseTokenValue(tokenType) {\n      return parseToken(tokenType).text;\n    }\n    function convertString(str, tokenType) {\n      var output = str;\n      switch (tokenType) {\n       case TOKENTYPES.time:\n        var parts = str.split(/(:|am|pm)/), hour = parts[3] === \"pm\" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min = parts[2].trim();\n        output = (hour.length === 1 ? \"0\" : \"\") + hour + \":\" + min;\n        break;\n\n       case TOKENTYPES.rank:\n        output = parseInt(/^\\d+/.exec(str)[0], 10);\n        break;\n\n       case TOKENTYPES.monthName:\n       case TOKENTYPES.dayName:\n        output = NAMES[str.substring(0, 3)];\n        break;\n      }\n      return output;\n    }\n    return parseScheduleExpr(str.toLowerCase());\n  };\n  return later;\n}();","export default \"// Generated by CoffeeScript 1.10.0\\n(function() {\\n  var JSOG, JSOG_OBJECT_ID, hasCustomJsonificaiton, isArray, nextId;\\n\\n  JSOG = {};\\n\\n  nextId = 0;\\n\\n  isArray = Array.isArray || function(obj) {\\n    return Object.prototype.toString.call(obj) === '[object Array]';\\n  };\\n\\n  hasCustomJsonificaiton = function(obj) {\\n    return obj.toJSON != null;\\n  };\\n\\n  JSOG_OBJECT_ID = '__jsogObjectId';\\n\\n  JSOG.encode = function(original, replacer, idProperty, refProperty) {\\n    if (replacer === undefined){\\n      replacer = function(key, value){\\n        return value;\\n      }\\n    }\\n    var doEncode, idOf, sofar;\\n    if (idProperty == null) {\\n      idProperty = '@id';\\n    }\\n    if (refProperty == null) {\\n      refProperty = '@ref';\\n    }\\n    sofar = {};\\n    idOf = function(obj) {\\n      if (!obj[JSOG_OBJECT_ID]) {\\n        obj[JSOG_OBJECT_ID] = \\\"\\\" + (nextId++);\\n      }\\n      return obj[JSOG_OBJECT_ID];\\n    };\\n    doEncode = function(original, replacer) {\\n      var encodeArray, encodeObject;\\n      encodeObject = function(original, replacer) {\\n        var id, key, obj1, obj2, result, value;\\n        id = idOf(original);\\n        if (sofar[id]) {\\n          return (\\n            obj1 = {},\\n            obj1[\\\"\\\" + refProperty] = id,\\n            obj1\\n          );\\n        }\\n        result = sofar[id] = (\\n          obj2 = {},\\n          obj2[\\\"\\\" + idProperty] = id,\\n          obj2\\n        );\\n        for (key in original) {\\n          value = replacer(key, original[key]);\\n          if (key !== JSOG_OBJECT_ID) {\\n            result[key] = doEncode(value, replacer);\\n          }\\n        }\\n        return result;\\n      };\\n      encodeArray = function(original, replacer) {\\n        var val;\\n        return (function() {\\n          var i, len, results;\\n          results = [];\\n          for (i = 0, len = original.length; i < len; i++) {\\n            val = original[i];\\n            results.push(doEncode(val, replacer));\\n          }\\n          return results;\\n        })();\\n      };\\n      if (original == null) {\\n        return original;\\n      } else if (hasCustomJsonificaiton(original)) {\\n        return original;\\n      } else if (isArray(original)) {\\n        return encodeArray(original, replacer);\\n      } else if (typeof original === 'object') {\\n        return encodeObject(original, replacer);\\n      } else {\\n        return original;\\n      }\\n    };\\n    return doEncode(original, replacer);\\n  };\\n\\n  JSOG.decode = function(encoded, idProperty, refProperty) {\\n    var doDecode, found;\\n    if (idProperty == null) {\\n      idProperty = '@id';\\n    }\\n    if (refProperty == null) {\\n      refProperty = '@ref';\\n    }\\n    found = {};\\n    doDecode = function(encoded) {\\n      var decodeArray, decodeObject;\\n      decodeObject = function(encoded) {\\n        var id, key, ref, result, value;\\n        ref = encoded[refProperty];\\n        if (ref != null) {\\n          ref = ref.toString();\\n        }\\n        if (ref != null) {\\n          return found[ref];\\n        }\\n        result = {};\\n        id = encoded[idProperty];\\n        if (id != null) {\\n          id = id.toString();\\n        }\\n        if (id) {\\n          found[id] = result;\\n        }\\n        for (key in encoded) {\\n          value = encoded[key];\\n          if (key !== idProperty) {\\n            result[key] = doDecode(value);\\n          }\\n        }\\n        return result;\\n      };\\n      decodeArray = function(encoded) {\\n        var value;\\n        return (function() {\\n          var i, len, results;\\n          results = [];\\n          for (i = 0, len = encoded.length; i < len; i++) {\\n            value = encoded[i];\\n            results.push(doDecode(value));\\n          }\\n          return results;\\n        })();\\n      };\\n      if (encoded == null) {\\n        return encoded;\\n      } else if (isArray(encoded)) {\\n        return decodeArray(encoded);\\n      } else if (typeof encoded === 'object') {\\n        return decodeObject(encoded);\\n      } else {\\n        return encoded;\\n      }\\n    };\\n    return doDecode(encoded);\\n  };\\n\\n  JSOG.stringify = function(obj, replacer) {\\n    return JSON.stringify(JSOG.encode(obj, replacer));\\n  };\\n\\n  JSOG.parse = function(str) {\\n    return JSOG.decode(JSON.parse(str));\\n  };\\n\\n  if ((typeof module !== \\\"undefined\\\" && module !== null) && module.exports) {\\n    module.exports = JSOG;\\n  }\\n\\n  if (typeof window !== \\\"undefined\\\" && window !== null) {\\n    window.JSOG = JSOG;\\n  }\\n\\n  if (typeof define === 'function' && define.amd) {\\n    define('JSOG', [], function() {\\n      return JSOG;\\n    });\\n  }\\n\\n  return JSOG;\\n\\n}).call(this);\\n\";","export default \"/*! jquery-dateFormat 18-05-2015 */\\nvar DateFormat={};!function(a){var b=[\\\"Sunday\\\",\\\"Monday\\\",\\\"Tuesday\\\",\\\"Wednesday\\\",\\\"Thursday\\\",\\\"Friday\\\",\\\"Saturday\\\"],c=[\\\"Sun\\\",\\\"Mon\\\",\\\"Tue\\\",\\\"Wed\\\",\\\"Thu\\\",\\\"Fri\\\",\\\"Sat\\\"],d=[\\\"Jan\\\",\\\"Feb\\\",\\\"Mar\\\",\\\"Apr\\\",\\\"May\\\",\\\"Jun\\\",\\\"Jul\\\",\\\"Aug\\\",\\\"Sep\\\",\\\"Oct\\\",\\\"Nov\\\",\\\"Dec\\\"],e=[\\\"January\\\",\\\"February\\\",\\\"March\\\",\\\"April\\\",\\\"May\\\",\\\"June\\\",\\\"July\\\",\\\"August\\\",\\\"September\\\",\\\"October\\\",\\\"November\\\",\\\"December\\\"],f={Jan:\\\"01\\\",Feb:\\\"02\\\",Mar:\\\"03\\\",Apr:\\\"04\\\",May:\\\"05\\\",Jun:\\\"06\\\",Jul:\\\"07\\\",Aug:\\\"08\\\",Sep:\\\"09\\\",Oct:\\\"10\\\",Nov:\\\"11\\\",Dec:\\\"12\\\"},g=/\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.?\\\\d{0,3}[Z\\\\-+]?(\\\\d{2}:?\\\\d{2})?/;a.format=function(){function a(a){return b[parseInt(a,10)]||a}function h(a){return c[parseInt(a,10)]||a}function i(a){var b=parseInt(a,10)-1;return d[b]||a}function j(a){var b=parseInt(a,10)-1;return e[b]||a}function k(a){return f[a]||a}function l(a){var b,c,d,e,f,g=a,h=\\\"\\\";return-1!==g.indexOf(\\\".\\\")&&(e=g.split(\\\".\\\"),g=e[0],h=e[e.length-1]),f=g.split(\\\":\\\"),3===f.length?(b=f[0],c=f[1],d=f[2].replace(/\\\\s.+/,\\\"\\\").replace(/[a-z]/gi,\\\"\\\"),g=g.replace(/\\\\s.+/,\\\"\\\").replace(/[a-z]/gi,\\\"\\\"),{time:g,hour:b,minute:c,second:d,millis:h}):{time:\\\"\\\",hour:\\\"\\\",minute:\\\"\\\",second:\\\"\\\",millis:\\\"\\\"}}function m(a,b){for(var c=b-String(a).length,d=0;c>d;d++)a=\\\"0\\\"+a;return a}return{parseDate:function(a){var b,c,d={date:null,year:null,month:null,dayOfMonth:null,dayOfWeek:null,time:null};if(\\\"number\\\"==typeof a)return this.parseDate(new Date(a));if(\\\"function\\\"==typeof a.getFullYear)d.year=String(a.getFullYear()),d.month=String(a.getMonth()+1),d.dayOfMonth=String(a.getDate()),d.time=l(a.toTimeString()+\\\".\\\"+a.getMilliseconds());else if(-1!=a.search(g))b=a.split(/[T\\\\+-]/),d.year=b[0],d.month=b[1],d.dayOfMonth=b[2],d.time=l(b[3].split(\\\".\\\")[0]);else switch(b=a.split(\\\" \\\"),6===b.length&&isNaN(b[5])&&(b[b.length]=\\\"()\\\"),b.length){case 6:d.year=b[5],d.month=k(b[1]),d.dayOfMonth=b[2],d.time=l(b[3]);break;case 2:c=b[0].split(\\\"-\\\"),d.year=c[0],d.month=c[1],d.dayOfMonth=c[2],d.time=l(b[1]);break;case 7:case 9:case 10:d.year=b[3],d.month=k(b[1]),d.dayOfMonth=b[2],d.time=l(b[4]);break;case 1:c=b[0].split(\\\"\\\"),d.year=c[0]+c[1]+c[2]+c[3],d.month=c[5]+c[6],d.dayOfMonth=c[8]+c[9],d.time=l(c[13]+c[14]+c[15]+c[16]+c[17]+c[18]+c[19]+c[20]);break;default:return null}return d.date=d.time?new Date(d.year,d.month-1,d.dayOfMonth,d.time.hour,d.time.minute,d.time.second,d.time.millis):new Date(d.year,d.month-1,d.dayOfMonth),d.dayOfWeek=String(d.date.getDay()),d},date:function(b,c){try{var d=this.parseDate(b);if(null===d)return b;for(var e,f=d.year,g=d.month,k=d.dayOfMonth,l=d.dayOfWeek,n=d.time,o=\\\"\\\",p=\\\"\\\",q=\\\"\\\",r=!1,s=0;s<c.length;s++){var t=c.charAt(s),u=c.charAt(s+1);if(r)\\\"'\\\"==t?(p+=\\\"\\\"===o?\\\"'\\\":o,o=\\\"\\\",r=!1):o+=t;else switch(o+=t,q=\\\"\\\",o){case\\\"ddd\\\":p+=a(l),o=\\\"\\\";break;case\\\"dd\\\":if(\\\"d\\\"===u)break;p+=m(k,2),o=\\\"\\\";break;case\\\"d\\\":if(\\\"d\\\"===u)break;p+=parseInt(k,10),o=\\\"\\\";break;case\\\"D\\\":k=1==k||21==k||31==k?parseInt(k,10)+\\\"st\\\":2==k||22==k?parseInt(k,10)+\\\"nd\\\":3==k||23==k?parseInt(k,10)+\\\"rd\\\":parseInt(k,10)+\\\"th\\\",p+=k,o=\\\"\\\";break;case\\\"MMMM\\\":p+=j(g),o=\\\"\\\";break;case\\\"MMM\\\":if(\\\"M\\\"===u)break;p+=i(g),o=\\\"\\\";break;case\\\"MM\\\":if(\\\"M\\\"===u)break;p+=m(g,2),o=\\\"\\\";break;case\\\"M\\\":if(\\\"M\\\"===u)break;p+=parseInt(g,10),o=\\\"\\\";break;case\\\"y\\\":case\\\"yyy\\\":if(\\\"y\\\"===u)break;p+=o,o=\\\"\\\";break;case\\\"yy\\\":if(\\\"y\\\"===u)break;p+=String(f).slice(-2),o=\\\"\\\";break;case\\\"yyyy\\\":p+=f,o=\\\"\\\";break;case\\\"HH\\\":p+=m(n.hour,2),o=\\\"\\\";break;case\\\"H\\\":if(\\\"H\\\"===u)break;p+=parseInt(n.hour,10),o=\\\"\\\";break;case\\\"hh\\\":e=0===parseInt(n.hour,10)?12:n.hour<13?n.hour:n.hour-12,p+=m(e,2),o=\\\"\\\";break;case\\\"h\\\":if(\\\"h\\\"===u)break;e=0===parseInt(n.hour,10)?12:n.hour<13?n.hour:n.hour-12,p+=parseInt(e,10),o=\\\"\\\";break;case\\\"mm\\\":p+=m(n.minute,2),o=\\\"\\\";break;case\\\"m\\\":if(\\\"m\\\"===u)break;p+=n.minute,o=\\\"\\\";break;case\\\"ss\\\":p+=m(n.second.substring(0,2),2),o=\\\"\\\";break;case\\\"s\\\":if(\\\"s\\\"===u)break;p+=n.second,o=\\\"\\\";break;case\\\"S\\\":case\\\"SS\\\":if(\\\"S\\\"===u)break;p+=o,o=\\\"\\\";break;case\\\"SSS\\\":var v=\\\"000\\\"+n.millis.substring(0,3);p+=v.substring(v.length-3),o=\\\"\\\";break;case\\\"a\\\":p+=n.hour>=12?\\\"PM\\\":\\\"AM\\\",o=\\\"\\\";break;case\\\"p\\\":p+=n.hour>=12?\\\"p.m.\\\":\\\"a.m.\\\",o=\\\"\\\";break;case\\\"E\\\":p+=h(l),o=\\\"\\\";break;case\\\"'\\\":o=\\\"\\\",r=!0;break;default:p+=t,o=\\\"\\\"}}return p+=q}catch(w){return console&&console.log&&console.log(w),b}},prettyDate:function(a){var b,c,d;return(\\\"string\\\"==typeof a||\\\"number\\\"==typeof a)&&(b=new Date(a)),\\\"object\\\"==typeof a&&(b=new Date(a.toString())),c=((new Date).getTime()-b.getTime())/1e3,d=Math.floor(c/86400),isNaN(d)||0>d?void 0:60>c?\\\"just now\\\":120>c?\\\"1 minute ago\\\":3600>c?Math.floor(c/60)+\\\" minutes ago\\\":7200>c?\\\"1 hour ago\\\":86400>c?Math.floor(c/3600)+\\\" hours ago\\\":1===d?\\\"Yesterday\\\":7>d?d+\\\" days ago\\\":31>d?Math.ceil(d/7)+\\\" weeks ago\\\":d>=31?\\\"more than 5 weeks ago\\\":void 0},toBrowserTimeZone:function(a,b){return this.date(new Date(a),b||\\\"MM/dd/yyyy HH:mm:ss\\\")}}}()}(DateFormat),function(a){a.format=DateFormat.format}(jQuery);\";","export default \"/*! jQuery UI - v1.10.3 - 2013-05-03\\n* http://jqueryui.com\\n* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js\\n* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */\\n(function( $, undefined ) {\\n\\nvar uuid = 0,\\n\\truniqueId = /^ui-id-\\\\d+$/;\\n\\n// $.ui might exist from components with no dependencies, e.g., $.ui.position\\n$.ui = $.ui || {};\\n\\n$.extend( $.ui, {\\n\\tversion: \\\"1.10.3\\\",\\n\\n\\tkeyCode: {\\n\\t\\tBACKSPACE: 8,\\n\\t\\tCOMMA: 188,\\n\\t\\tDELETE: 46,\\n\\t\\tDOWN: 40,\\n\\t\\tEND: 35,\\n\\t\\tENTER: 13,\\n\\t\\tESCAPE: 27,\\n\\t\\tHOME: 36,\\n\\t\\tLEFT: 37,\\n\\t\\tNUMPAD_ADD: 107,\\n\\t\\tNUMPAD_DECIMAL: 110,\\n\\t\\tNUMPAD_DIVIDE: 111,\\n\\t\\tNUMPAD_ENTER: 108,\\n\\t\\tNUMPAD_MULTIPLY: 106,\\n\\t\\tNUMPAD_SUBTRACT: 109,\\n\\t\\tPAGE_DOWN: 34,\\n\\t\\tPAGE_UP: 33,\\n\\t\\tPERIOD: 190,\\n\\t\\tRIGHT: 39,\\n\\t\\tSPACE: 32,\\n\\t\\tTAB: 9,\\n\\t\\tUP: 38\\n\\t}\\n});\\n\\n// plugins\\n$.fn.extend({\\n\\tfocus: (function( orig ) {\\n\\t\\treturn function( delay, fn ) {\\n\\t\\t\\treturn typeof delay === \\\"number\\\" ?\\n\\t\\t\\t\\tthis.each(function() {\\n\\t\\t\\t\\t\\tvar elem = this;\\n\\t\\t\\t\\t\\tsetTimeout(function() {\\n\\t\\t\\t\\t\\t\\t$( elem ).focus();\\n\\t\\t\\t\\t\\t\\tif ( fn ) {\\n\\t\\t\\t\\t\\t\\t\\tfn.call( elem );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, delay );\\n\\t\\t\\t\\t}) :\\n\\t\\t\\t\\torig.apply( this, arguments );\\n\\t\\t};\\n\\t})( $.fn.focus ),\\n\\n\\tscrollParent: function() {\\n\\t\\tvar scrollParent;\\n\\t\\tif (($.ui.ie && (/(static|relative)/).test(this.css(\\\"position\\\"))) || (/absolute/).test(this.css(\\\"position\\\"))) {\\n\\t\\t\\tscrollParent = this.parents().filter(function() {\\n\\t\\t\\t\\treturn (/(relative|absolute|fixed)/).test($.css(this,\\\"position\\\")) && (/(auto|scroll)/).test($.css(this,\\\"overflow\\\")+$.css(this,\\\"overflow-y\\\")+$.css(this,\\\"overflow-x\\\"));\\n\\t\\t\\t}).eq(0);\\n\\t\\t} else {\\n\\t\\t\\tscrollParent = this.parents().filter(function() {\\n\\t\\t\\t\\treturn (/(auto|scroll)/).test($.css(this,\\\"overflow\\\")+$.css(this,\\\"overflow-y\\\")+$.css(this,\\\"overflow-x\\\"));\\n\\t\\t\\t}).eq(0);\\n\\t\\t}\\n\\n\\t\\treturn (/fixed/).test(this.css(\\\"position\\\")) || !scrollParent.length ? $(document) : scrollParent;\\n\\t},\\n\\n\\tzIndex: function( zIndex ) {\\n\\t\\tif ( zIndex !== undefined ) {\\n\\t\\t\\treturn this.css( \\\"zIndex\\\", zIndex );\\n\\t\\t}\\n\\n\\t\\tif ( this.length ) {\\n\\t\\t\\tvar elem = $( this[ 0 ] ), position, value;\\n\\t\\t\\twhile ( elem.length && elem[ 0 ] !== document ) {\\n\\t\\t\\t\\t// Ignore z-index if position is set to a value where z-index is ignored by the browser\\n\\t\\t\\t\\t// This makes behavior of this function consistent across browsers\\n\\t\\t\\t\\t// WebKit always returns auto if the element is positioned\\n\\t\\t\\t\\tposition = elem.css( \\\"position\\\" );\\n\\t\\t\\t\\tif ( position === \\\"absolute\\\" || position === \\\"relative\\\" || position === \\\"fixed\\\" ) {\\n\\t\\t\\t\\t\\t// IE returns 0 when zIndex is not specified\\n\\t\\t\\t\\t\\t// other browsers return a string\\n\\t\\t\\t\\t\\t// we ignore the case of nested elements with an explicit value of 0\\n\\t\\t\\t\\t\\t// <div style=\\\"z-index: -10;\\\"><div style=\\\"z-index: 0;\\\"></div></div>\\n\\t\\t\\t\\t\\tvalue = parseInt( elem.css( \\\"zIndex\\\" ), 10 );\\n\\t\\t\\t\\t\\tif ( !isNaN( value ) && value !== 0 ) {\\n\\t\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telem = elem.parent();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn 0;\\n\\t},\\n\\n\\tuniqueId: function() {\\n\\t\\treturn this.each(function() {\\n\\t\\t\\tif ( !this.id ) {\\n\\t\\t\\t\\tthis.id = \\\"ui-id-\\\" + (++uuid);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\tremoveUniqueId: function() {\\n\\t\\treturn this.each(function() {\\n\\t\\t\\tif ( runiqueId.test( this.id ) ) {\\n\\t\\t\\t\\t$( this ).removeAttr( \\\"id\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n});\\n\\n// selectors\\nfunction focusable( element, isTabIndexNotNaN ) {\\n\\tvar map, mapName, img,\\n\\t\\tnodeName = element.nodeName.toLowerCase();\\n\\tif ( \\\"area\\\" === nodeName ) {\\n\\t\\tmap = element.parentNode;\\n\\t\\tmapName = map.name;\\n\\t\\tif ( !element.href || !mapName || map.nodeName.toLowerCase() !== \\\"map\\\" ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\timg = $( \\\"img[usemap=#\\\" + mapName + \\\"]\\\" )[0];\\n\\t\\treturn !!img && visible( img );\\n\\t}\\n\\treturn ( /input|select|textarea|button|object/.test( nodeName ) ?\\n\\t\\t!element.disabled :\\n\\t\\t\\\"a\\\" === nodeName ?\\n\\t\\t\\telement.href || isTabIndexNotNaN :\\n\\t\\t\\tisTabIndexNotNaN) &&\\n\\t\\t// the element and all of its ancestors must be visible\\n\\t\\tvisible( element );\\n}\\n\\nfunction visible( element ) {\\n\\treturn $.expr.filters.visible( element ) &&\\n\\t\\t!$( element ).parents().addBack().filter(function() {\\n\\t\\t\\treturn $.css( this, \\\"visibility\\\" ) === \\\"hidden\\\";\\n\\t\\t}).length;\\n}\\n\\n$.extend( $.expr[ \\\":\\\" ], {\\n\\tdata: $.expr.createPseudo ?\\n\\t\\t$.expr.createPseudo(function( dataName ) {\\n\\t\\t\\treturn function( elem ) {\\n\\t\\t\\t\\treturn !!$.data( elem, dataName );\\n\\t\\t\\t};\\n\\t\\t}) :\\n\\t\\t// support: jQuery <1.8\\n\\t\\tfunction( elem, i, match ) {\\n\\t\\t\\treturn !!$.data( elem, match[ 3 ] );\\n\\t\\t},\\n\\n\\tfocusable: function( element ) {\\n\\t\\treturn focusable( element, !isNaN( $.attr( element, \\\"tabindex\\\" ) ) );\\n\\t},\\n\\n\\ttabbable: function( element ) {\\n\\t\\tvar tabIndex = $.attr( element, \\\"tabindex\\\" ),\\n\\t\\t\\tisTabIndexNaN = isNaN( tabIndex );\\n\\t\\treturn ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );\\n\\t}\\n});\\n\\n// support: jQuery <1.8\\nif ( !$( \\\"<a>\\\" ).outerWidth( 1 ).jquery ) {\\n\\t$.each( [ \\\"Width\\\", \\\"Height\\\" ], function( i, name ) {\\n\\t\\tvar side = name === \\\"Width\\\" ? [ \\\"Left\\\", \\\"Right\\\" ] : [ \\\"Top\\\", \\\"Bottom\\\" ],\\n\\t\\t\\ttype = name.toLowerCase(),\\n\\t\\t\\torig = {\\n\\t\\t\\t\\tinnerWidth: $.fn.innerWidth,\\n\\t\\t\\t\\tinnerHeight: $.fn.innerHeight,\\n\\t\\t\\t\\touterWidth: $.fn.outerWidth,\\n\\t\\t\\t\\touterHeight: $.fn.outerHeight\\n\\t\\t\\t};\\n\\n\\t\\tfunction reduce( elem, size, border, margin ) {\\n\\t\\t\\t$.each( side, function() {\\n\\t\\t\\t\\tsize -= parseFloat( $.css( elem, \\\"padding\\\" + this ) ) || 0;\\n\\t\\t\\t\\tif ( border ) {\\n\\t\\t\\t\\t\\tsize -= parseFloat( $.css( elem, \\\"border\\\" + this + \\\"Width\\\" ) ) || 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( margin ) {\\n\\t\\t\\t\\t\\tsize -= parseFloat( $.css( elem, \\\"margin\\\" + this ) ) || 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn size;\\n\\t\\t}\\n\\n\\t\\t$.fn[ \\\"inner\\\" + name ] = function( size ) {\\n\\t\\t\\tif ( size === undefined ) {\\n\\t\\t\\t\\treturn orig[ \\\"inner\\\" + name ].call( this );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.each(function() {\\n\\t\\t\\t\\t$( this ).css( type, reduce( this, size ) + \\\"px\\\" );\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t\\t$.fn[ \\\"outer\\\" + name] = function( size, margin ) {\\n\\t\\t\\tif ( typeof size !== \\\"number\\\" ) {\\n\\t\\t\\t\\treturn orig[ \\\"outer\\\" + name ].call( this, size );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.each(function() {\\n\\t\\t\\t\\t$( this).css( type, reduce( this, size, true, margin ) + \\\"px\\\" );\\n\\t\\t\\t});\\n\\t\\t};\\n\\t});\\n}\\n\\n// support: jQuery <1.8\\nif ( !$.fn.addBack ) {\\n\\t$.fn.addBack = function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t};\\n}\\n\\n// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)\\nif ( $( \\\"<a>\\\" ).data( \\\"a-b\\\", \\\"a\\\" ).removeData( \\\"a-b\\\" ).data( \\\"a-b\\\" ) ) {\\n\\t$.fn.removeData = (function( removeData ) {\\n\\t\\treturn function( key ) {\\n\\t\\t\\tif ( arguments.length ) {\\n\\t\\t\\t\\treturn removeData.call( this, $.camelCase( key ) );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn removeData.call( this );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t})( $.fn.removeData );\\n}\\n\\n\\n\\n\\n\\n// deprecated\\n$.ui.ie = !!/msie [\\\\w.]+/.exec( navigator.userAgent.toLowerCase() );\\n\\n$.support.selectstart = \\\"onselectstart\\\" in document.createElement( \\\"div\\\" );\\n$.fn.extend({\\n\\tdisableSelection: function() {\\n\\t\\treturn this.bind( ( $.support.selectstart ? \\\"selectstart\\\" : \\\"mousedown\\\" ) +\\n\\t\\t\\t\\\".ui-disableSelection\\\", function( event ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t});\\n\\t},\\n\\n\\tenableSelection: function() {\\n\\t\\treturn this.unbind( \\\".ui-disableSelection\\\" );\\n\\t}\\n});\\n\\n$.extend( $.ui, {\\n\\t// $.ui.plugin is deprecated. Use $.widget() extensions instead.\\n\\tplugin: {\\n\\t\\tadd: function( module, option, set ) {\\n\\t\\t\\tvar i,\\n\\t\\t\\t\\tproto = $.ui[ module ].prototype;\\n\\t\\t\\tfor ( i in set ) {\\n\\t\\t\\t\\tproto.plugins[ i ] = proto.plugins[ i ] || [];\\n\\t\\t\\t\\tproto.plugins[ i ].push( [ option, set[ i ] ] );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tcall: function( instance, name, args ) {\\n\\t\\t\\tvar i,\\n\\t\\t\\t\\tset = instance.plugins[ name ];\\n\\t\\t\\tif ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( i = 0; i < set.length; i++ ) {\\n\\t\\t\\t\\tif ( instance.options[ set[ i ][ 0 ] ] ) {\\n\\t\\t\\t\\t\\tset[ i ][ 1 ].apply( instance.element, args );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// only used by resizable\\n\\thasScroll: function( el, a ) {\\n\\n\\t\\t//If overflow is hidden, the element might have extra content, but the user wants to hide it\\n\\t\\tif ( $( el ).css( \\\"overflow\\\" ) === \\\"hidden\\\") {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tvar scroll = ( a && a === \\\"left\\\" ) ? \\\"scrollLeft\\\" : \\\"scrollTop\\\",\\n\\t\\t\\thas = false;\\n\\n\\t\\tif ( el[ scroll ] > 0 ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// TODO: determine which cases actually cause this to happen\\n\\t\\t// if the element doesn't have the scroll set, see if it's possible to\\n\\t\\t// set the scroll\\n\\t\\tel[ scroll ] = 1;\\n\\t\\thas = ( el[ scroll ] > 0 );\\n\\t\\tel[ scroll ] = 0;\\n\\t\\treturn has;\\n\\t}\\n});\\n\\n})( jQuery );\\n\\n(function( $, undefined ) {\\n\\nvar uuid = 0,\\n\\tslice = Array.prototype.slice,\\n\\t_cleanData = $.cleanData;\\n$.cleanData = function( elems ) {\\n\\tfor ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {\\n\\t\\ttry {\\n\\t\\t\\t$( elem ).triggerHandler( \\\"remove\\\" );\\n\\t\\t// http://bugs.jquery.com/ticket/8235\\n\\t\\t} catch( e ) {}\\n\\t}\\n\\t_cleanData( elems );\\n};\\n\\n$.widget = function( name, base, prototype ) {\\n\\tvar fullName, existingConstructor, constructor, basePrototype,\\n\\t\\t// proxiedPrototype allows the provided prototype to remain unmodified\\n\\t\\t// so that it can be used as a mixin for multiple widgets (#8876)\\n\\t\\tproxiedPrototype = {},\\n\\t\\tnamespace = name.split( \\\".\\\" )[ 0 ];\\n\\n\\tname = name.split( \\\".\\\" )[ 1 ];\\n\\tfullName = namespace + \\\"-\\\" + name;\\n\\n\\tif ( !prototype ) {\\n\\t\\tprototype = base;\\n\\t\\tbase = $.Widget;\\n\\t}\\n\\n\\t// create selector for plugin\\n\\t$.expr[ \\\":\\\" ][ fullName.toLowerCase() ] = function( elem ) {\\n\\t\\treturn !!$.data( elem, fullName );\\n\\t};\\n\\n\\t$[ namespace ] = $[ namespace ] || {};\\n\\texistingConstructor = $[ namespace ][ name ];\\n\\tconstructor = $[ namespace ][ name ] = function( options, element ) {\\n\\t\\t// allow instantiation without \\\"new\\\" keyword\\n\\t\\tif ( !this._createWidget ) {\\n\\t\\t\\treturn new constructor( options, element );\\n\\t\\t}\\n\\n\\t\\t// allow instantiation without initializing for simple inheritance\\n\\t\\t// must use \\\"new\\\" keyword (the code above always passes args)\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\tthis._createWidget( options, element );\\n\\t\\t}\\n\\t};\\n\\t// extend with the existing constructor to carry over any static properties\\n\\t$.extend( constructor, existingConstructor, {\\n\\t\\tversion: prototype.version,\\n\\t\\t// copy the object used to create the prototype in case we need to\\n\\t\\t// redefine the widget later\\n\\t\\t_proto: $.extend( {}, prototype ),\\n\\t\\t// track widgets that inherit from this widget in case this widget is\\n\\t\\t// redefined after a widget inherits from it\\n\\t\\t_childConstructors: []\\n\\t});\\n\\n\\tbasePrototype = new base();\\n\\t// we need to make the options hash a property directly on the new instance\\n\\t// otherwise we'll modify the options hash on the prototype that we're\\n\\t// inheriting from\\n\\tbasePrototype.options = $.widget.extend( {}, basePrototype.options );\\n\\t$.each( prototype, function( prop, value ) {\\n\\t\\tif ( !$.isFunction( value ) ) {\\n\\t\\t\\tproxiedPrototype[ prop ] = value;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tproxiedPrototype[ prop ] = (function() {\\n\\t\\t\\tvar _super = function() {\\n\\t\\t\\t\\t\\treturn base.prototype[ prop ].apply( this, arguments );\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t_superApply = function( args ) {\\n\\t\\t\\t\\t\\treturn base.prototype[ prop ].apply( this, args );\\n\\t\\t\\t\\t};\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\tvar __super = this._super,\\n\\t\\t\\t\\t\\t__superApply = this._superApply,\\n\\t\\t\\t\\t\\treturnValue;\\n\\n\\t\\t\\t\\tthis._super = _super;\\n\\t\\t\\t\\tthis._superApply = _superApply;\\n\\n\\t\\t\\t\\treturnValue = value.apply( this, arguments );\\n\\n\\t\\t\\t\\tthis._super = __super;\\n\\t\\t\\t\\tthis._superApply = __superApply;\\n\\n\\t\\t\\t\\treturn returnValue;\\n\\t\\t\\t};\\n\\t\\t})();\\n\\t});\\n\\tconstructor.prototype = $.widget.extend( basePrototype, {\\n\\t\\t// TODO: remove support for widgetEventPrefix\\n\\t\\t// always use the name + a colon as the prefix, e.g., draggable:start\\n\\t\\t// don't prefix for widgets that aren't DOM-based\\n\\t\\twidgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name\\n\\t}, proxiedPrototype, {\\n\\t\\tconstructor: constructor,\\n\\t\\tnamespace: namespace,\\n\\t\\twidgetName: name,\\n\\t\\twidgetFullName: fullName\\n\\t});\\n\\n\\t// If this widget is being redefined then we need to find all widgets that\\n\\t// are inheriting from it and redefine all of them so that they inherit from\\n\\t// the new version of this widget. We're essentially trying to replace one\\n\\t// level in the prototype chain.\\n\\tif ( existingConstructor ) {\\n\\t\\t$.each( existingConstructor._childConstructors, function( i, child ) {\\n\\t\\t\\tvar childPrototype = child.prototype;\\n\\n\\t\\t\\t// redefine the child widget using the same prototype that was\\n\\t\\t\\t// originally used, but inherit from the new version of the base\\n\\t\\t\\t$.widget( childPrototype.namespace + \\\".\\\" + childPrototype.widgetName, constructor, child._proto );\\n\\t\\t});\\n\\t\\t// remove the list of existing child constructors from the old constructor\\n\\t\\t// so the old child constructors can be garbage collected\\n\\t\\tdelete existingConstructor._childConstructors;\\n\\t} else {\\n\\t\\tbase._childConstructors.push( constructor );\\n\\t}\\n\\n\\t$.widget.bridge( name, constructor );\\n};\\n\\n$.widget.extend = function( target ) {\\n\\tvar input = slice.call( arguments, 1 ),\\n\\t\\tinputIndex = 0,\\n\\t\\tinputLength = input.length,\\n\\t\\tkey,\\n\\t\\tvalue;\\n\\tfor ( ; inputIndex < inputLength; inputIndex++ ) {\\n\\t\\tfor ( key in input[ inputIndex ] ) {\\n\\t\\t\\tvalue = input[ inputIndex ][ key ];\\n\\t\\t\\tif ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {\\n\\t\\t\\t\\t// Clone objects\\n\\t\\t\\t\\tif ( $.isPlainObject( value ) ) {\\n\\t\\t\\t\\t\\ttarget[ key ] = $.isPlainObject( target[ key ] ) ?\\n\\t\\t\\t\\t\\t\\t$.widget.extend( {}, target[ key ], value ) :\\n\\t\\t\\t\\t\\t\\t// Don't extend strings, arrays, etc. with objects\\n\\t\\t\\t\\t\\t\\t$.widget.extend( {}, value );\\n\\t\\t\\t\\t// Copy everything else by reference\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttarget[ key ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn target;\\n};\\n\\n$.widget.bridge = function( name, object ) {\\n\\tvar fullName = object.prototype.widgetFullName || name;\\n\\t$.fn[ name ] = function( options ) {\\n\\t\\tvar isMethodCall = typeof options === \\\"string\\\",\\n\\t\\t\\targs = slice.call( arguments, 1 ),\\n\\t\\t\\treturnValue = this;\\n\\n\\t\\t// allow multiple hashes to be passed on init\\n\\t\\toptions = !isMethodCall && args.length ?\\n\\t\\t\\t$.widget.extend.apply( null, [ options ].concat(args) ) :\\n\\t\\t\\toptions;\\n\\n\\t\\tif ( isMethodCall ) {\\n\\t\\t\\tthis.each(function() {\\n\\t\\t\\t\\tvar methodValue,\\n\\t\\t\\t\\t\\tinstance = $.data( this, fullName );\\n\\t\\t\\t\\tif ( !instance ) {\\n\\t\\t\\t\\t\\treturn $.error( \\\"cannot call methods on \\\" + name + \\\" prior to initialization; \\\" +\\n\\t\\t\\t\\t\\t\\t\\\"attempted to call method '\\\" + options + \\\"'\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === \\\"_\\\" ) {\\n\\t\\t\\t\\t\\treturn $.error( \\\"no such method '\\\" + options + \\\"' for \\\" + name + \\\" widget instance\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmethodValue = instance[ options ].apply( instance, args );\\n\\t\\t\\t\\tif ( methodValue !== instance && methodValue !== undefined ) {\\n\\t\\t\\t\\t\\treturnValue = methodValue && methodValue.jquery ?\\n\\t\\t\\t\\t\\t\\treturnValue.pushStack( methodValue.get() ) :\\n\\t\\t\\t\\t\\t\\tmethodValue;\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.each(function() {\\n\\t\\t\\t\\tvar instance = $.data( this, fullName );\\n\\t\\t\\t\\tif ( instance ) {\\n\\t\\t\\t\\t\\tinstance.option( options || {} )._init();\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$.data( this, fullName, new object( options, this ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn returnValue;\\n\\t};\\n};\\n\\n$.Widget = function( /* options, element */ ) {};\\n$.Widget._childConstructors = [];\\n\\n$.Widget.prototype = {\\n\\twidgetName: \\\"widget\\\",\\n\\twidgetEventPrefix: \\\"\\\",\\n\\tdefaultElement: \\\"<div>\\\",\\n\\toptions: {\\n\\t\\tdisabled: false,\\n\\n\\t\\t// callbacks\\n\\t\\tcreate: null\\n\\t},\\n\\t_createWidget: function( options, element ) {\\n\\t\\telement = $( element || this.defaultElement || this )[ 0 ];\\n\\t\\tthis.element = $( element );\\n\\t\\tthis.uuid = uuid++;\\n\\t\\tthis.eventNamespace = \\\".\\\" + this.widgetName + this.uuid;\\n\\t\\tthis.options = $.widget.extend( {},\\n\\t\\t\\tthis.options,\\n\\t\\t\\tthis._getCreateOptions(),\\n\\t\\t\\toptions );\\n\\n\\t\\tthis.bindings = $();\\n\\t\\tthis.hoverable = $();\\n\\t\\tthis.focusable = $();\\n\\n\\t\\tif ( element !== this ) {\\n\\t\\t\\t$.data( element, this.widgetFullName, this );\\n\\t\\t\\tthis._on( true, this.element, {\\n\\t\\t\\t\\tremove: function( event ) {\\n\\t\\t\\t\\t\\tif ( event.target === element ) {\\n\\t\\t\\t\\t\\t\\tthis.destroy();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tthis.document = $( element.style ?\\n\\t\\t\\t\\t// element within the document\\n\\t\\t\\t\\telement.ownerDocument :\\n\\t\\t\\t\\t// element is window or document\\n\\t\\t\\t\\telement.document || element );\\n\\t\\t\\tthis.window = $( this.document[0].defaultView || this.document[0].parentWindow );\\n\\t\\t}\\n\\n\\t\\tthis._create();\\n\\t\\tthis._trigger( \\\"create\\\", null, this._getCreateEventData() );\\n\\t\\tthis._init();\\n\\t},\\n\\t_getCreateOptions: $.noop,\\n\\t_getCreateEventData: $.noop,\\n\\t_create: $.noop,\\n\\t_init: $.noop,\\n\\n\\tdestroy: function() {\\n\\t\\tthis._destroy();\\n\\t\\t// we can probably remove the unbind calls in 2.0\\n\\t\\t// all event bindings should go through this._on()\\n\\t\\tthis.element\\n\\t\\t\\t.unbind( this.eventNamespace )\\n\\t\\t\\t// 1.9 BC for #7810\\n\\t\\t\\t// TODO remove dual storage\\n\\t\\t\\t.removeData( this.widgetName )\\n\\t\\t\\t.removeData( this.widgetFullName )\\n\\t\\t\\t// support: jquery <1.6.3\\n\\t\\t\\t// http://bugs.jquery.com/ticket/9413\\n\\t\\t\\t.removeData( $.camelCase( this.widgetFullName ) );\\n\\t\\tthis.widget()\\n\\t\\t\\t.unbind( this.eventNamespace )\\n\\t\\t\\t.removeAttr( \\\"aria-disabled\\\" )\\n\\t\\t\\t.removeClass(\\n\\t\\t\\t\\tthis.widgetFullName + \\\"-disabled \\\" +\\n\\t\\t\\t\\t\\\"ui-state-disabled\\\" );\\n\\n\\t\\t// clean up events and states\\n\\t\\tthis.bindings.unbind( this.eventNamespace );\\n\\t\\tthis.hoverable.removeClass( \\\"ui-state-hover\\\" );\\n\\t\\tthis.focusable.removeClass( \\\"ui-state-focus\\\" );\\n\\t},\\n\\t_destroy: $.noop,\\n\\n\\twidget: function() {\\n\\t\\treturn this.element;\\n\\t},\\n\\n\\toption: function( key, value ) {\\n\\t\\tvar options = key,\\n\\t\\t\\tparts,\\n\\t\\t\\tcurOption,\\n\\t\\t\\ti;\\n\\n\\t\\tif ( arguments.length === 0 ) {\\n\\t\\t\\t// don't return a reference to the internal hash\\n\\t\\t\\treturn $.widget.extend( {}, this.options );\\n\\t\\t}\\n\\n\\t\\tif ( typeof key === \\\"string\\\" ) {\\n\\t\\t\\t// handle nested keys, e.g., \\\"foo.bar\\\" => { foo: { bar: ___ } }\\n\\t\\t\\toptions = {};\\n\\t\\t\\tparts = key.split( \\\".\\\" );\\n\\t\\t\\tkey = parts.shift();\\n\\t\\t\\tif ( parts.length ) {\\n\\t\\t\\t\\tcurOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );\\n\\t\\t\\t\\tfor ( i = 0; i < parts.length - 1; i++ ) {\\n\\t\\t\\t\\t\\tcurOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};\\n\\t\\t\\t\\t\\tcurOption = curOption[ parts[ i ] ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tkey = parts.pop();\\n\\t\\t\\t\\tif ( value === undefined ) {\\n\\t\\t\\t\\t\\treturn curOption[ key ] === undefined ? null : curOption[ key ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurOption[ key ] = value;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( value === undefined ) {\\n\\t\\t\\t\\t\\treturn this.options[ key ] === undefined ? null : this.options[ key ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptions[ key ] = value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis._setOptions( options );\\n\\n\\t\\treturn this;\\n\\t},\\n\\t_setOptions: function( options ) {\\n\\t\\tvar key;\\n\\n\\t\\tfor ( key in options ) {\\n\\t\\t\\tthis._setOption( key, options[ key ] );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\t_setOption: function( key, value ) {\\n\\t\\tthis.options[ key ] = value;\\n\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tthis.widget()\\n\\t\\t\\t\\t.toggleClass( this.widgetFullName + \\\"-disabled ui-state-disabled\\\", !!value )\\n\\t\\t\\t\\t.attr( \\\"aria-disabled\\\", value );\\n\\t\\t\\tthis.hoverable.removeClass( \\\"ui-state-hover\\\" );\\n\\t\\t\\tthis.focusable.removeClass( \\\"ui-state-focus\\\" );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\tenable: function() {\\n\\t\\treturn this._setOption( \\\"disabled\\\", false );\\n\\t},\\n\\tdisable: function() {\\n\\t\\treturn this._setOption( \\\"disabled\\\", true );\\n\\t},\\n\\n\\t_on: function( suppressDisabledCheck, element, handlers ) {\\n\\t\\tvar delegateElement,\\n\\t\\t\\tinstance = this;\\n\\n\\t\\t// no suppressDisabledCheck flag, shuffle arguments\\n\\t\\tif ( typeof suppressDisabledCheck !== \\\"boolean\\\" ) {\\n\\t\\t\\thandlers = element;\\n\\t\\t\\telement = suppressDisabledCheck;\\n\\t\\t\\tsuppressDisabledCheck = false;\\n\\t\\t}\\n\\n\\t\\t// no element argument, shuffle and use this.element\\n\\t\\tif ( !handlers ) {\\n\\t\\t\\thandlers = element;\\n\\t\\t\\telement = this.element;\\n\\t\\t\\tdelegateElement = this.widget();\\n\\t\\t} else {\\n\\t\\t\\t// accept selectors, DOM elements\\n\\t\\t\\telement = delegateElement = $( element );\\n\\t\\t\\tthis.bindings = this.bindings.add( element );\\n\\t\\t}\\n\\n\\t\\t$.each( handlers, function( event, handler ) {\\n\\t\\t\\tfunction handlerProxy() {\\n\\t\\t\\t\\t// allow widgets to customize the disabled handling\\n\\t\\t\\t\\t// - disabled as an array instead of boolean\\n\\t\\t\\t\\t// - disabled class as method for disabling individual parts\\n\\t\\t\\t\\tif ( !suppressDisabledCheck &&\\n\\t\\t\\t\\t\\t\\t( instance.options.disabled === true ||\\n\\t\\t\\t\\t\\t\\t\\t$( this ).hasClass( \\\"ui-state-disabled\\\" ) ) ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ( typeof handler === \\\"string\\\" ? instance[ handler ] : handler )\\n\\t\\t\\t\\t\\t.apply( instance, arguments );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// copy the guid so direct unbinding works\\n\\t\\t\\tif ( typeof handler !== \\\"string\\\" ) {\\n\\t\\t\\t\\thandlerProxy.guid = handler.guid =\\n\\t\\t\\t\\t\\thandler.guid || handlerProxy.guid || $.guid++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar match = event.match( /^(\\\\w+)\\\\s*(.*)$/ ),\\n\\t\\t\\t\\teventName = match[1] + instance.eventNamespace,\\n\\t\\t\\t\\tselector = match[2];\\n\\t\\t\\tif ( selector ) {\\n\\t\\t\\t\\tdelegateElement.delegate( selector, eventName, handlerProxy );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\telement.bind( eventName, handlerProxy );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_off: function( element, eventName ) {\\n\\t\\teventName = (eventName || \\\"\\\").split( \\\" \\\" ).join( this.eventNamespace + \\\" \\\" ) + this.eventNamespace;\\n\\t\\telement.unbind( eventName ).undelegate( eventName );\\n\\t},\\n\\n\\t_delay: function( handler, delay ) {\\n\\t\\tfunction handlerProxy() {\\n\\t\\t\\treturn ( typeof handler === \\\"string\\\" ? instance[ handler ] : handler )\\n\\t\\t\\t\\t.apply( instance, arguments );\\n\\t\\t}\\n\\t\\tvar instance = this;\\n\\t\\treturn setTimeout( handlerProxy, delay || 0 );\\n\\t},\\n\\n\\t_hoverable: function( element ) {\\n\\t\\tthis.hoverable = this.hoverable.add( element );\\n\\t\\tthis._on( element, {\\n\\t\\t\\tmouseenter: function( event ) {\\n\\t\\t\\t\\t$( event.currentTarget ).addClass( \\\"ui-state-hover\\\" );\\n\\t\\t\\t},\\n\\t\\t\\tmouseleave: function( event ) {\\n\\t\\t\\t\\t$( event.currentTarget ).removeClass( \\\"ui-state-hover\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_focusable: function( element ) {\\n\\t\\tthis.focusable = this.focusable.add( element );\\n\\t\\tthis._on( element, {\\n\\t\\t\\tfocusin: function( event ) {\\n\\t\\t\\t\\t$( event.currentTarget ).addClass( \\\"ui-state-focus\\\" );\\n\\t\\t\\t},\\n\\t\\t\\tfocusout: function( event ) {\\n\\t\\t\\t\\t$( event.currentTarget ).removeClass( \\\"ui-state-focus\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_trigger: function( type, event, data ) {\\n\\t\\tvar prop, orig,\\n\\t\\t\\tcallback = this.options[ type ];\\n\\n\\t\\tdata = data || {};\\n\\t\\tevent = $.Event( event );\\n\\t\\tevent.type = ( type === this.widgetEventPrefix ?\\n\\t\\t\\ttype :\\n\\t\\t\\tthis.widgetEventPrefix + type ).toLowerCase();\\n\\t\\t// the original event may come from any element\\n\\t\\t// so we need to reset the target on the new event\\n\\t\\tevent.target = this.element[ 0 ];\\n\\n\\t\\t// copy original event properties over to the new event\\n\\t\\torig = event.originalEvent;\\n\\t\\tif ( orig ) {\\n\\t\\t\\tfor ( prop in orig ) {\\n\\t\\t\\t\\tif ( !( prop in event ) ) {\\n\\t\\t\\t\\t\\tevent[ prop ] = orig[ prop ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.element.trigger( event, data );\\n\\t\\treturn !( $.isFunction( callback ) &&\\n\\t\\t\\tcallback.apply( this.element[0], [ event ].concat( data ) ) === false ||\\n\\t\\t\\tevent.isDefaultPrevented() );\\n\\t}\\n};\\n\\n$.each( { show: \\\"fadeIn\\\", hide: \\\"fadeOut\\\" }, function( method, defaultEffect ) {\\n\\t$.Widget.prototype[ \\\"_\\\" + method ] = function( element, options, callback ) {\\n\\t\\tif ( typeof options === \\\"string\\\" ) {\\n\\t\\t\\toptions = { effect: options };\\n\\t\\t}\\n\\t\\tvar hasOptions,\\n\\t\\t\\teffectName = !options ?\\n\\t\\t\\t\\tmethod :\\n\\t\\t\\t\\toptions === true || typeof options === \\\"number\\\" ?\\n\\t\\t\\t\\t\\tdefaultEffect :\\n\\t\\t\\t\\t\\toptions.effect || defaultEffect;\\n\\t\\toptions = options || {};\\n\\t\\tif ( typeof options === \\\"number\\\" ) {\\n\\t\\t\\toptions = { duration: options };\\n\\t\\t}\\n\\t\\thasOptions = !$.isEmptyObject( options );\\n\\t\\toptions.complete = callback;\\n\\t\\tif ( options.delay ) {\\n\\t\\t\\telement.delay( options.delay );\\n\\t\\t}\\n\\t\\tif ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {\\n\\t\\t\\telement[ method ]( options );\\n\\t\\t} else if ( effectName !== method && element[ effectName ] ) {\\n\\t\\t\\telement[ effectName ]( options.duration, options.easing, callback );\\n\\t\\t} else {\\n\\t\\t\\telement.queue(function( next ) {\\n\\t\\t\\t\\t$( this )[ method ]();\\n\\t\\t\\t\\tif ( callback ) {\\n\\t\\t\\t\\t\\tcallback.call( element[ 0 ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnext();\\n\\t\\t\\t});\\n\\t\\t}\\n\\t};\\n});\\n\\n})( jQuery );\\n\\n(function( $, undefined ) {\\n\\nvar mouseHandled = false;\\n$( document ).mouseup( function() {\\n\\tmouseHandled = false;\\n});\\n\\n$.widget(\\\"ui.mouse\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tcancel: \\\"input,textarea,button,select,option\\\",\\n\\t\\tdistance: 1,\\n\\t\\tdelay: 0\\n\\t},\\n\\t_mouseInit: function() {\\n\\t\\tvar that = this;\\n\\n\\t\\tthis.element\\n\\t\\t\\t.bind(\\\"mousedown.\\\"+this.widgetName, function(event) {\\n\\t\\t\\t\\treturn that._mouseDown(event);\\n\\t\\t\\t})\\n\\t\\t\\t.bind(\\\"click.\\\"+this.widgetName, function(event) {\\n\\t\\t\\t\\tif (true === $.data(event.target, that.widgetName + \\\".preventClickEvent\\\")) {\\n\\t\\t\\t\\t\\t$.removeData(event.target, that.widgetName + \\\".preventClickEvent\\\");\\n\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\tthis.started = false;\\n\\t},\\n\\n\\t// TODO: make sure destroying one instance of mouse doesn't mess with\\n\\t// other instances of mouse\\n\\t_mouseDestroy: function() {\\n\\t\\tthis.element.unbind(\\\".\\\"+this.widgetName);\\n\\t\\tif ( this._mouseMoveDelegate ) {\\n\\t\\t\\t$(document)\\n\\t\\t\\t\\t.unbind(\\\"mousemove.\\\"+this.widgetName, this._mouseMoveDelegate)\\n\\t\\t\\t\\t.unbind(\\\"mouseup.\\\"+this.widgetName, this._mouseUpDelegate);\\n\\t\\t}\\n\\t},\\n\\n\\t_mouseDown: function(event) {\\n\\t\\t// don't let more than one widget handle mouseStart\\n\\t\\tif( mouseHandled ) { return; }\\n\\n\\t\\t// we may have missed mouseup (out of window)\\n\\t\\t(this._mouseStarted && this._mouseUp(event));\\n\\n\\t\\tthis._mouseDownEvent = event;\\n\\n\\t\\tvar that = this,\\n\\t\\t\\tbtnIsLeft = (event.which === 1),\\n\\t\\t\\t// event.target.nodeName works around a bug in IE 8 with\\n\\t\\t\\t// disabled inputs (#7620)\\n\\t\\t\\telIsCancel = (typeof this.options.cancel === \\\"string\\\" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);\\n\\t\\tif (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tthis.mouseDelayMet = !this.options.delay;\\n\\t\\tif (!this.mouseDelayMet) {\\n\\t\\t\\tthis._mouseDelayTimer = setTimeout(function() {\\n\\t\\t\\t\\tthat.mouseDelayMet = true;\\n\\t\\t\\t}, this.options.delay);\\n\\t\\t}\\n\\n\\t\\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\\n\\t\\t\\tthis._mouseStarted = (this._mouseStart(event) !== false);\\n\\t\\t\\tif (!this._mouseStarted) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Click event may never have fired (Gecko & Opera)\\n\\t\\tif (true === $.data(event.target, this.widgetName + \\\".preventClickEvent\\\")) {\\n\\t\\t\\t$.removeData(event.target, this.widgetName + \\\".preventClickEvent\\\");\\n\\t\\t}\\n\\n\\t\\t// these delegates are required to keep context\\n\\t\\tthis._mouseMoveDelegate = function(event) {\\n\\t\\t\\treturn that._mouseMove(event);\\n\\t\\t};\\n\\t\\tthis._mouseUpDelegate = function(event) {\\n\\t\\t\\treturn that._mouseUp(event);\\n\\t\\t};\\n\\t\\t$(document)\\n\\t\\t\\t.bind(\\\"mousemove.\\\"+this.widgetName, this._mouseMoveDelegate)\\n\\t\\t\\t.bind(\\\"mouseup.\\\"+this.widgetName, this._mouseUpDelegate);\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tmouseHandled = true;\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_mouseMove: function(event) {\\n\\t\\t// IE mouseup check - mouseup happened when mouse was out of window\\n\\t\\tif ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {\\n\\t\\t\\treturn this._mouseUp(event);\\n\\t\\t}\\n\\n\\t\\tif (this._mouseStarted) {\\n\\t\\t\\tthis._mouseDrag(event);\\n\\t\\t\\treturn event.preventDefault();\\n\\t\\t}\\n\\n\\t\\tif (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {\\n\\t\\t\\tthis._mouseStarted =\\n\\t\\t\\t\\t(this._mouseStart(this._mouseDownEvent, event) !== false);\\n\\t\\t\\t(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));\\n\\t\\t}\\n\\n\\t\\treturn !this._mouseStarted;\\n\\t},\\n\\n\\t_mouseUp: function(event) {\\n\\t\\t$(document)\\n\\t\\t\\t.unbind(\\\"mousemove.\\\"+this.widgetName, this._mouseMoveDelegate)\\n\\t\\t\\t.unbind(\\\"mouseup.\\\"+this.widgetName, this._mouseUpDelegate);\\n\\n\\t\\tif (this._mouseStarted) {\\n\\t\\t\\tthis._mouseStarted = false;\\n\\n\\t\\t\\tif (event.target === this._mouseDownEvent.target) {\\n\\t\\t\\t\\t$.data(event.target, this.widgetName + \\\".preventClickEvent\\\", true);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._mouseStop(event);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseDistanceMet: function(event) {\\n\\t\\treturn (Math.max(\\n\\t\\t\\t\\tMath.abs(this._mouseDownEvent.pageX - event.pageX),\\n\\t\\t\\t\\tMath.abs(this._mouseDownEvent.pageY - event.pageY)\\n\\t\\t\\t) >= this.options.distance\\n\\t\\t);\\n\\t},\\n\\n\\t_mouseDelayMet: function(/* event */) {\\n\\t\\treturn this.mouseDelayMet;\\n\\t},\\n\\n\\t// These are placeholder methods, to be overriden by extending plugin\\n\\t_mouseStart: function(/* event */) {},\\n\\t_mouseDrag: function(/* event */) {},\\n\\t_mouseStop: function(/* event */) {},\\n\\t_mouseCapture: function(/* event */) { return true; }\\n});\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.widget(\\\"ui.draggable\\\", $.ui.mouse, {\\n\\tversion: \\\"1.10.3\\\",\\n\\twidgetEventPrefix: \\\"drag\\\",\\n\\toptions: {\\n\\t\\taddClasses: true,\\n\\t\\tappendTo: \\\"parent\\\",\\n\\t\\taxis: false,\\n\\t\\tconnectToSortable: false,\\n\\t\\tcontainment: false,\\n\\t\\tcursor: \\\"auto\\\",\\n\\t\\tcursorAt: false,\\n\\t\\tgrid: false,\\n\\t\\thandle: false,\\n\\t\\thelper: \\\"original\\\",\\n\\t\\tiframeFix: false,\\n\\t\\topacity: false,\\n\\t\\trefreshPositions: false,\\n\\t\\trevert: false,\\n\\t\\trevertDuration: 500,\\n\\t\\tscope: \\\"default\\\",\\n\\t\\tscroll: true,\\n\\t\\tscrollSensitivity: 20,\\n\\t\\tscrollSpeed: 20,\\n\\t\\tsnap: false,\\n\\t\\tsnapMode: \\\"both\\\",\\n\\t\\tsnapTolerance: 20,\\n\\t\\tstack: false,\\n\\t\\tzIndex: false,\\n\\n\\t\\t// callbacks\\n\\t\\tdrag: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null\\n\\t},\\n\\t_create: function() {\\n\\n\\t\\tif (this.options.helper === \\\"original\\\" && !(/^(?:r|a|f)/).test(this.element.css(\\\"position\\\"))) {\\n\\t\\t\\tthis.element[0].style.position = \\\"relative\\\";\\n\\t\\t}\\n\\t\\tif (this.options.addClasses){\\n\\t\\t\\tthis.element.addClass(\\\"ui-draggable\\\");\\n\\t\\t}\\n\\t\\tif (this.options.disabled){\\n\\t\\t\\tthis.element.addClass(\\\"ui-draggable-disabled\\\");\\n\\t\\t}\\n\\n\\t\\tthis._mouseInit();\\n\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element.removeClass( \\\"ui-draggable ui-draggable-dragging ui-draggable-disabled\\\" );\\n\\t\\tthis._mouseDestroy();\\n\\t},\\n\\n\\t_mouseCapture: function(event) {\\n\\n\\t\\tvar o = this.options;\\n\\n\\t\\t// among others, prevent a drag on a resizable-handle\\n\\t\\tif (this.helper || o.disabled || $(event.target).closest(\\\".ui-resizable-handle\\\").length > 0) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Quit if we're not on a valid handle\\n\\t\\tthis.handle = this._getHandle(event);\\n\\t\\tif (!this.handle) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t$(o.iframeFix === true ? \\\"iframe\\\" : o.iframeFix).each(function() {\\n\\t\\t\\t$(\\\"<div class='ui-draggable-iframeFix' style='background: #fff;'></div>\\\")\\n\\t\\t\\t.css({\\n\\t\\t\\t\\twidth: this.offsetWidth+\\\"px\\\", height: this.offsetHeight+\\\"px\\\",\\n\\t\\t\\t\\tposition: \\\"absolute\\\", opacity: \\\"0.001\\\", zIndex: 1000\\n\\t\\t\\t})\\n\\t\\t\\t.css($(this).offset())\\n\\t\\t\\t.appendTo(\\\"body\\\");\\n\\t\\t});\\n\\n\\t\\treturn true;\\n\\n\\t},\\n\\n\\t_mouseStart: function(event) {\\n\\n\\t\\tvar o = this.options;\\n\\n\\t\\t//Create and append the visible helper\\n\\t\\tthis.helper = this._createHelper(event);\\n\\n\\t\\tthis.helper.addClass(\\\"ui-draggable-dragging\\\");\\n\\n\\t\\t//Cache the helper size\\n\\t\\tthis._cacheHelperProportions();\\n\\n\\t\\t//If ddmanager is used for droppables, set the global draggable\\n\\t\\tif($.ui.ddmanager) {\\n\\t\\t\\t$.ui.ddmanager.current = this;\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * - Position generation -\\n\\t\\t * This block generates everything position related - it's the core of draggables.\\n\\t\\t */\\n\\n\\t\\t//Cache the margins of the original element\\n\\t\\tthis._cacheMargins();\\n\\n\\t\\t//Store the helper's css position\\n\\t\\tthis.cssPosition = this.helper.css( \\\"position\\\" );\\n\\t\\tthis.scrollParent = this.helper.scrollParent();\\n\\t\\tthis.offsetParent = this.helper.offsetParent();\\n\\t\\tthis.offsetParentCssPosition = this.offsetParent.css( \\\"position\\\" );\\n\\n\\t\\t//The element's absolute position on the page minus margins\\n\\t\\tthis.offset = this.positionAbs = this.element.offset();\\n\\t\\tthis.offset = {\\n\\t\\t\\ttop: this.offset.top - this.margins.top,\\n\\t\\t\\tleft: this.offset.left - this.margins.left\\n\\t\\t};\\n\\n\\t\\t//Reset scroll cache\\n\\t\\tthis.offset.scroll = false;\\n\\n\\t\\t$.extend(this.offset, {\\n\\t\\t\\tclick: { //Where the click happened, relative to the element\\n\\t\\t\\t\\tleft: event.pageX - this.offset.left,\\n\\t\\t\\t\\ttop: event.pageY - this.offset.top\\n\\t\\t\\t},\\n\\t\\t\\tparent: this._getParentOffset(),\\n\\t\\t\\trelative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\\n\\t\\t});\\n\\n\\t\\t//Generate the original position\\n\\t\\tthis.originalPosition = this.position = this._generatePosition(event);\\n\\t\\tthis.originalPageX = event.pageX;\\n\\t\\tthis.originalPageY = event.pageY;\\n\\n\\t\\t//Adjust the mouse offset relative to the helper if \\\"cursorAt\\\" is supplied\\n\\t\\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\\n\\n\\t\\t//Set a containment if given in the options\\n\\t\\tthis._setContainment();\\n\\n\\t\\t//Trigger event + callbacks\\n\\t\\tif(this._trigger(\\\"start\\\", event) === false) {\\n\\t\\t\\tthis._clear();\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//Recache the helper size\\n\\t\\tthis._cacheHelperProportions();\\n\\n\\t\\t//Prepare the droppable offsets\\n\\t\\tif ($.ui.ddmanager && !o.dropBehaviour) {\\n\\t\\t\\t$.ui.ddmanager.prepareOffsets(this, event);\\n\\t\\t}\\n\\n\\n\\t\\tthis._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position\\n\\n\\t\\t//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)\\n\\t\\tif ( $.ui.ddmanager ) {\\n\\t\\t\\t$.ui.ddmanager.dragStart(this, event);\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_mouseDrag: function(event, noPropagation) {\\n\\t\\t// reset any necessary cached properties (see #5009)\\n\\t\\tif ( this.offsetParentCssPosition === \\\"fixed\\\" ) {\\n\\t\\t\\tthis.offset.parent = this._getParentOffset();\\n\\t\\t}\\n\\n\\t\\t//Compute the helpers position\\n\\t\\tthis.position = this._generatePosition(event);\\n\\t\\tthis.positionAbs = this._convertPositionTo(\\\"absolute\\\");\\n\\n\\t\\t//Call plugins and callbacks and use the resulting position if something is returned\\n\\t\\tif (!noPropagation) {\\n\\t\\t\\tvar ui = this._uiHash();\\n\\t\\t\\tif(this._trigger(\\\"drag\\\", event, ui) === false) {\\n\\t\\t\\t\\tthis._mouseUp({});\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tthis.position = ui.position;\\n\\t\\t}\\n\\n\\t\\tif(!this.options.axis || this.options.axis !== \\\"y\\\") {\\n\\t\\t\\tthis.helper[0].style.left = this.position.left+\\\"px\\\";\\n\\t\\t}\\n\\t\\tif(!this.options.axis || this.options.axis !== \\\"x\\\") {\\n\\t\\t\\tthis.helper[0].style.top = this.position.top+\\\"px\\\";\\n\\t\\t}\\n\\t\\tif($.ui.ddmanager) {\\n\\t\\t\\t$.ui.ddmanager.drag(this, event);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseStop: function(event) {\\n\\n\\t\\t//If we are using droppables, inform the manager about the drop\\n\\t\\tvar that = this,\\n\\t\\t\\tdropped = false;\\n\\t\\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\\n\\t\\t\\tdropped = $.ui.ddmanager.drop(this, event);\\n\\t\\t}\\n\\n\\t\\t//if a drop comes from outside (a sortable)\\n\\t\\tif(this.dropped) {\\n\\t\\t\\tdropped = this.dropped;\\n\\t\\t\\tthis.dropped = false;\\n\\t\\t}\\n\\n\\t\\t//if the original element is no longer in the DOM don't bother to continue (see #8269)\\n\\t\\tif ( this.options.helper === \\\"original\\\" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif((this.options.revert === \\\"invalid\\\" && !dropped) || (this.options.revert === \\\"valid\\\" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {\\n\\t\\t\\t$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {\\n\\t\\t\\t\\tif(that._trigger(\\\"stop\\\", event) !== false) {\\n\\t\\t\\t\\t\\tthat._clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tif(this._trigger(\\\"stop\\\", event) !== false) {\\n\\t\\t\\t\\tthis._clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseUp: function(event) {\\n\\t\\t//Remove frame helpers\\n\\t\\t$(\\\"div.ui-draggable-iframeFix\\\").each(function() {\\n\\t\\t\\tthis.parentNode.removeChild(this);\\n\\t\\t});\\n\\n\\t\\t//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)\\n\\t\\tif( $.ui.ddmanager ) {\\n\\t\\t\\t$.ui.ddmanager.dragStop(this, event);\\n\\t\\t}\\n\\n\\t\\treturn $.ui.mouse.prototype._mouseUp.call(this, event);\\n\\t},\\n\\n\\tcancel: function() {\\n\\n\\t\\tif(this.helper.is(\\\".ui-draggable-dragging\\\")) {\\n\\t\\t\\tthis._mouseUp({});\\n\\t\\t} else {\\n\\t\\t\\tthis._clear();\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\t_getHandle: function(event) {\\n\\t\\treturn this.options.handle ?\\n\\t\\t\\t!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :\\n\\t\\t\\ttrue;\\n\\t},\\n\\n\\t_createHelper: function(event) {\\n\\n\\t\\tvar o = this.options,\\n\\t\\t\\thelper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === \\\"clone\\\" ? this.element.clone().removeAttr(\\\"id\\\") : this.element);\\n\\n\\t\\tif(!helper.parents(\\\"body\\\").length) {\\n\\t\\t\\thelper.appendTo((o.appendTo === \\\"parent\\\" ? this.element[0].parentNode : o.appendTo));\\n\\t\\t}\\n\\n\\t\\tif(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css(\\\"position\\\"))) {\\n\\t\\t\\thelper.css(\\\"position\\\", \\\"absolute\\\");\\n\\t\\t}\\n\\n\\t\\treturn helper;\\n\\n\\t},\\n\\n\\t_adjustOffsetFromHelper: function(obj) {\\n\\t\\tif (typeof obj === \\\"string\\\") {\\n\\t\\t\\tobj = obj.split(\\\" \\\");\\n\\t\\t}\\n\\t\\tif ($.isArray(obj)) {\\n\\t\\t\\tobj = {left: +obj[0], top: +obj[1] || 0};\\n\\t\\t}\\n\\t\\tif (\\\"left\\\" in obj) {\\n\\t\\t\\tthis.offset.click.left = obj.left + this.margins.left;\\n\\t\\t}\\n\\t\\tif (\\\"right\\\" in obj) {\\n\\t\\t\\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\\n\\t\\t}\\n\\t\\tif (\\\"top\\\" in obj) {\\n\\t\\t\\tthis.offset.click.top = obj.top + this.margins.top;\\n\\t\\t}\\n\\t\\tif (\\\"bottom\\\" in obj) {\\n\\t\\t\\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\\n\\t\\t}\\n\\t},\\n\\n\\t_getParentOffset: function() {\\n\\n\\t\\t//Get the offsetParent and cache its position\\n\\t\\tvar po = this.offsetParent.offset();\\n\\n\\t\\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\\n\\t\\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\\n\\t\\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\\n\\t\\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\\n\\t\\tif(this.cssPosition === \\\"absolute\\\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\\n\\t\\t\\tpo.left += this.scrollParent.scrollLeft();\\n\\t\\t\\tpo.top += this.scrollParent.scrollTop();\\n\\t\\t}\\n\\n\\t\\t//This needs to be actually done for all browsers, since pageX/pageY includes this information\\n\\t\\t//Ugly IE fix\\n\\t\\tif((this.offsetParent[0] === document.body) ||\\n\\t\\t\\t(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \\\"html\\\" && $.ui.ie)) {\\n\\t\\t\\tpo = { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: po.top + (parseInt(this.offsetParent.css(\\\"borderTopWidth\\\"),10) || 0),\\n\\t\\t\\tleft: po.left + (parseInt(this.offsetParent.css(\\\"borderLeftWidth\\\"),10) || 0)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_getRelativeOffset: function() {\\n\\n\\t\\tif(this.cssPosition === \\\"relative\\\") {\\n\\t\\t\\tvar p = this.element.position();\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttop: p.top - (parseInt(this.helper.css(\\\"top\\\"),10) || 0) + this.scrollParent.scrollTop(),\\n\\t\\t\\t\\tleft: p.left - (parseInt(this.helper.css(\\\"left\\\"),10) || 0) + this.scrollParent.scrollLeft()\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_cacheMargins: function() {\\n\\t\\tthis.margins = {\\n\\t\\t\\tleft: (parseInt(this.element.css(\\\"marginLeft\\\"),10) || 0),\\n\\t\\t\\ttop: (parseInt(this.element.css(\\\"marginTop\\\"),10) || 0),\\n\\t\\t\\tright: (parseInt(this.element.css(\\\"marginRight\\\"),10) || 0),\\n\\t\\t\\tbottom: (parseInt(this.element.css(\\\"marginBottom\\\"),10) || 0)\\n\\t\\t};\\n\\t},\\n\\n\\t_cacheHelperProportions: function() {\\n\\t\\tthis.helperProportions = {\\n\\t\\t\\twidth: this.helper.outerWidth(),\\n\\t\\t\\theight: this.helper.outerHeight()\\n\\t\\t};\\n\\t},\\n\\n\\t_setContainment: function() {\\n\\n\\t\\tvar over, c, ce,\\n\\t\\t\\to = this.options;\\n\\n\\t\\tif ( !o.containment ) {\\n\\t\\t\\tthis.containment = null;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( o.containment === \\\"window\\\" ) {\\n\\t\\t\\tthis.containment = [\\n\\t\\t\\t\\t$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,\\n\\t\\t\\t\\t$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,\\n\\t\\t\\t\\t$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,\\n\\t\\t\\t\\t$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\\n\\t\\t\\t];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( o.containment === \\\"document\\\") {\\n\\t\\t\\tthis.containment = [\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t0,\\n\\t\\t\\t\\t$( document ).width() - this.helperProportions.width - this.margins.left,\\n\\t\\t\\t\\t( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top\\n\\t\\t\\t];\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( o.containment.constructor === Array ) {\\n\\t\\t\\tthis.containment = o.containment;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( o.containment === \\\"parent\\\" ) {\\n\\t\\t\\to.containment = this.helper[ 0 ].parentNode;\\n\\t\\t}\\n\\n\\t\\tc = $( o.containment );\\n\\t\\tce = c[ 0 ];\\n\\n\\t\\tif( !ce ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tover = c.css( \\\"overflow\\\" ) !== \\\"hidden\\\";\\n\\n\\t\\tthis.containment = [\\n\\t\\t\\t( parseInt( c.css( \\\"borderLeftWidth\\\" ), 10 ) || 0 ) + ( parseInt( c.css( \\\"paddingLeft\\\" ), 10 ) || 0 ),\\n\\t\\t\\t( parseInt( c.css( \\\"borderTopWidth\\\" ), 10 ) || 0 ) + ( parseInt( c.css( \\\"paddingTop\\\" ), 10 ) || 0 ) ,\\n\\t\\t\\t( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( \\\"borderRightWidth\\\" ), 10 ) || 0 ) - ( parseInt( c.css( \\\"paddingRight\\\" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,\\n\\t\\t\\t( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( \\\"borderBottomWidth\\\" ), 10 ) || 0 ) - ( parseInt( c.css( \\\"paddingBottom\\\" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom\\n\\t\\t];\\n\\t\\tthis.relative_container = c;\\n\\t},\\n\\n\\t_convertPositionTo: function(d, pos) {\\n\\n\\t\\tif(!pos) {\\n\\t\\t\\tpos = this.position;\\n\\t\\t}\\n\\n\\t\\tvar mod = d === \\\"absolute\\\" ? 1 : -1,\\n\\t\\t\\tscroll = this.cssPosition === \\\"absolute\\\" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;\\n\\n\\t\\t//Cache the scroll\\n\\t\\tif (!this.offset.scroll) {\\n\\t\\t\\tthis.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: (\\n\\t\\t\\t\\tpos.top\\t+\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.relative.top * mod +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.top * mod -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )\\n\\t\\t\\t),\\n\\t\\t\\tleft: (\\n\\t\\t\\t\\tpos.left +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.relative.left * mod +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.left * mod\\t-\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )\\n\\t\\t\\t)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_generatePosition: function(event) {\\n\\n\\t\\tvar containment, co, top, left,\\n\\t\\t\\to = this.options,\\n\\t\\t\\tscroll = this.cssPosition === \\\"absolute\\\" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,\\n\\t\\t\\tpageX = event.pageX,\\n\\t\\t\\tpageY = event.pageY;\\n\\n\\t\\t//Cache the scroll\\n\\t\\tif (!this.offset.scroll) {\\n\\t\\t\\tthis.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * - Position constraining -\\n\\t\\t * Constrain the position to a mix of grid, containment.\\n\\t\\t */\\n\\n\\t\\t// If we are not dragging yet, we won't check for options\\n\\t\\tif ( this.originalPosition ) {\\n\\t\\t\\tif ( this.containment ) {\\n\\t\\t\\t\\tif ( this.relative_container ){\\n\\t\\t\\t\\t\\tco = this.relative_container.offset();\\n\\t\\t\\t\\t\\tcontainment = [\\n\\t\\t\\t\\t\\t\\tthis.containment[ 0 ] + co.left,\\n\\t\\t\\t\\t\\t\\tthis.containment[ 1 ] + co.top,\\n\\t\\t\\t\\t\\t\\tthis.containment[ 2 ] + co.left,\\n\\t\\t\\t\\t\\t\\tthis.containment[ 3 ] + co.top\\n\\t\\t\\t\\t\\t];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tcontainment = this.containment;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(event.pageX - this.offset.click.left < containment[0]) {\\n\\t\\t\\t\\t\\tpageX = containment[0] + this.offset.click.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageY - this.offset.click.top < containment[1]) {\\n\\t\\t\\t\\t\\tpageY = containment[1] + this.offset.click.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageX - this.offset.click.left > containment[2]) {\\n\\t\\t\\t\\t\\tpageX = containment[2] + this.offset.click.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageY - this.offset.click.top > containment[3]) {\\n\\t\\t\\t\\t\\tpageY = containment[3] + this.offset.click.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(o.grid) {\\n\\t\\t\\t\\t//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)\\n\\t\\t\\t\\ttop = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;\\n\\t\\t\\t\\tpageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\\n\\n\\t\\t\\t\\tleft = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;\\n\\t\\t\\t\\tpageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: (\\n\\t\\t\\t\\tpageY -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.click.top\\t-\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Click offset (relative to the element)\\n\\t\\t\\t\\tthis.offset.relative.top -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.top +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )\\n\\t\\t\\t),\\n\\t\\t\\tleft: (\\n\\t\\t\\t\\tpageX -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.click.left -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Click offset (relative to the element)\\n\\t\\t\\t\\tthis.offset.relative.left -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.left +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )\\n\\t\\t\\t)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_clear: function() {\\n\\t\\tthis.helper.removeClass(\\\"ui-draggable-dragging\\\");\\n\\t\\tif(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {\\n\\t\\t\\tthis.helper.remove();\\n\\t\\t}\\n\\t\\tthis.helper = null;\\n\\t\\tthis.cancelHelperRemoval = false;\\n\\t},\\n\\n\\t// From now on bulk stuff - mainly helpers\\n\\n\\t_trigger: function(type, event, ui) {\\n\\t\\tui = ui || this._uiHash();\\n\\t\\t$.ui.plugin.call(this, type, [event, ui]);\\n\\t\\t//The absolute position has to be recalculated after plugins\\n\\t\\tif(type === \\\"drag\\\") {\\n\\t\\t\\tthis.positionAbs = this._convertPositionTo(\\\"absolute\\\");\\n\\t\\t}\\n\\t\\treturn $.Widget.prototype._trigger.call(this, type, event, ui);\\n\\t},\\n\\n\\tplugins: {},\\n\\n\\t_uiHash: function() {\\n\\t\\treturn {\\n\\t\\t\\thelper: this.helper,\\n\\t\\t\\tposition: this.position,\\n\\t\\t\\toriginalPosition: this.originalPosition,\\n\\t\\t\\toffset: this.positionAbs\\n\\t\\t};\\n\\t}\\n\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"connectToSortable\\\", {\\n\\tstart: function(event, ui) {\\n\\n\\t\\tvar inst = $(this).data(\\\"ui-draggable\\\"), o = inst.options,\\n\\t\\t\\tuiSortable = $.extend({}, ui, { item: inst.element });\\n\\t\\tinst.sortables = [];\\n\\t\\t$(o.connectToSortable).each(function() {\\n\\t\\t\\tvar sortable = $.data(this, \\\"ui-sortable\\\");\\n\\t\\t\\tif (sortable && !sortable.options.disabled) {\\n\\t\\t\\t\\tinst.sortables.push({\\n\\t\\t\\t\\t\\tinstance: sortable,\\n\\t\\t\\t\\t\\tshouldRevert: sortable.options.revert\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tsortable.refreshPositions();\\t// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).\\n\\t\\t\\t\\tsortable._trigger(\\\"activate\\\", event, uiSortable);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t},\\n\\tstop: function(event, ui) {\\n\\n\\t\\t//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper\\n\\t\\tvar inst = $(this).data(\\\"ui-draggable\\\"),\\n\\t\\t\\tuiSortable = $.extend({}, ui, { item: inst.element });\\n\\n\\t\\t$.each(inst.sortables, function() {\\n\\t\\t\\tif(this.instance.isOver) {\\n\\n\\t\\t\\t\\tthis.instance.isOver = 0;\\n\\n\\t\\t\\t\\tinst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance\\n\\t\\t\\t\\tthis.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)\\n\\n\\t\\t\\t\\t//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: \\\"valid/invalid\\\"\\n\\t\\t\\t\\tif(this.shouldRevert) {\\n\\t\\t\\t\\t\\tthis.instance.options.revert = this.shouldRevert;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Trigger the stop of the sortable\\n\\t\\t\\t\\tthis.instance._mouseStop(event);\\n\\n\\t\\t\\t\\tthis.instance.options.helper = this.instance.options._helper;\\n\\n\\t\\t\\t\\t//If the helper has been the original item, restore properties in the sortable\\n\\t\\t\\t\\tif(inst.options.helper === \\\"original\\\") {\\n\\t\\t\\t\\t\\tthis.instance.currentItem.css({ top: \\\"auto\\\", left: \\\"auto\\\" });\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance\\n\\t\\t\\t\\tthis.instance._trigger(\\\"deactivate\\\", event, uiSortable);\\n\\t\\t\\t}\\n\\n\\t\\t});\\n\\n\\t},\\n\\tdrag: function(event, ui) {\\n\\n\\t\\tvar inst = $(this).data(\\\"ui-draggable\\\"), that = this;\\n\\n\\t\\t$.each(inst.sortables, function() {\\n\\n\\t\\t\\tvar innermostIntersecting = false,\\n\\t\\t\\t\\tthisSortable = this;\\n\\n\\t\\t\\t//Copy over some variables to allow calling the sortable's native _intersectsWith\\n\\t\\t\\tthis.instance.positionAbs = inst.positionAbs;\\n\\t\\t\\tthis.instance.helperProportions = inst.helperProportions;\\n\\t\\t\\tthis.instance.offset.click = inst.offset.click;\\n\\n\\t\\t\\tif(this.instance._intersectsWith(this.instance.containerCache)) {\\n\\t\\t\\t\\tinnermostIntersecting = true;\\n\\t\\t\\t\\t$.each(inst.sortables, function () {\\n\\t\\t\\t\\t\\tthis.instance.positionAbs = inst.positionAbs;\\n\\t\\t\\t\\t\\tthis.instance.helperProportions = inst.helperProportions;\\n\\t\\t\\t\\t\\tthis.instance.offset.click = inst.offset.click;\\n\\t\\t\\t\\t\\tif (this !== thisSortable &&\\n\\t\\t\\t\\t\\t\\tthis.instance._intersectsWith(this.instance.containerCache) &&\\n\\t\\t\\t\\t\\t\\t$.contains(thisSortable.instance.element[0], this.instance.element[0])\\n\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\tinnermostIntersecting = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn innermostIntersecting;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tif(innermostIntersecting) {\\n\\t\\t\\t\\t//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once\\n\\t\\t\\t\\tif(!this.instance.isOver) {\\n\\n\\t\\t\\t\\t\\tthis.instance.isOver = 1;\\n\\t\\t\\t\\t\\t//Now we fake the start of dragging for the sortable instance,\\n\\t\\t\\t\\t\\t//by cloning the list group item, appending it to the sortable and using it as inst.currentItem\\n\\t\\t\\t\\t\\t//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)\\n\\t\\t\\t\\t\\tthis.instance.currentItem = $(that).clone().removeAttr(\\\"id\\\").appendTo(this.instance.element).data(\\\"ui-sortable-item\\\", true);\\n\\t\\t\\t\\t\\tthis.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it\\n\\t\\t\\t\\t\\tthis.instance.options.helper = function() { return ui.helper[0]; };\\n\\n\\t\\t\\t\\t\\tevent.target = this.instance.currentItem[0];\\n\\t\\t\\t\\t\\tthis.instance._mouseCapture(event, true);\\n\\t\\t\\t\\t\\tthis.instance._mouseStart(event, true, true);\\n\\n\\t\\t\\t\\t\\t//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes\\n\\t\\t\\t\\t\\tthis.instance.offset.click.top = inst.offset.click.top;\\n\\t\\t\\t\\t\\tthis.instance.offset.click.left = inst.offset.click.left;\\n\\t\\t\\t\\t\\tthis.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;\\n\\t\\t\\t\\t\\tthis.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;\\n\\n\\t\\t\\t\\t\\tinst._trigger(\\\"toSortable\\\", event);\\n\\t\\t\\t\\t\\tinst.dropped = this.instance.element; //draggable revert needs that\\n\\t\\t\\t\\t\\t//hack so receive/update callbacks work (mostly)\\n\\t\\t\\t\\t\\tinst.currentItem = inst.element;\\n\\t\\t\\t\\t\\tthis.instance.fromOutside = inst;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable\\n\\t\\t\\t\\tif(this.instance.currentItem) {\\n\\t\\t\\t\\t\\tthis.instance._mouseDrag(event);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t//If it doesn't intersect with the sortable, and it intersected before,\\n\\t\\t\\t\\t//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval\\n\\t\\t\\t\\tif(this.instance.isOver) {\\n\\n\\t\\t\\t\\t\\tthis.instance.isOver = 0;\\n\\t\\t\\t\\t\\tthis.instance.cancelHelperRemoval = true;\\n\\n\\t\\t\\t\\t\\t//Prevent reverting on this forced stop\\n\\t\\t\\t\\t\\tthis.instance.options.revert = false;\\n\\n\\t\\t\\t\\t\\t// The out event needs to be triggered independently\\n\\t\\t\\t\\t\\tthis.instance._trigger(\\\"out\\\", event, this.instance._uiHash(this.instance));\\n\\n\\t\\t\\t\\t\\tthis.instance._mouseStop(event, true);\\n\\t\\t\\t\\t\\tthis.instance.options.helper = this.instance.options._helper;\\n\\n\\t\\t\\t\\t\\t//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size\\n\\t\\t\\t\\t\\tthis.instance.currentItem.remove();\\n\\t\\t\\t\\t\\tif(this.instance.placeholder) {\\n\\t\\t\\t\\t\\t\\tthis.instance.placeholder.remove();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tinst._trigger(\\\"fromSortable\\\", event);\\n\\t\\t\\t\\t\\tinst.dropped = false; //draggable revert needs that\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t});\\n\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"cursor\\\", {\\n\\tstart: function() {\\n\\t\\tvar t = $(\\\"body\\\"), o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif (t.css(\\\"cursor\\\")) {\\n\\t\\t\\to._cursor = t.css(\\\"cursor\\\");\\n\\t\\t}\\n\\t\\tt.css(\\\"cursor\\\", o.cursor);\\n\\t},\\n\\tstop: function() {\\n\\t\\tvar o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif (o._cursor) {\\n\\t\\t\\t$(\\\"body\\\").css(\\\"cursor\\\", o._cursor);\\n\\t\\t}\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"opacity\\\", {\\n\\tstart: function(event, ui) {\\n\\t\\tvar t = $(ui.helper), o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif(t.css(\\\"opacity\\\")) {\\n\\t\\t\\to._opacity = t.css(\\\"opacity\\\");\\n\\t\\t}\\n\\t\\tt.css(\\\"opacity\\\", o.opacity);\\n\\t},\\n\\tstop: function(event, ui) {\\n\\t\\tvar o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif(o._opacity) {\\n\\t\\t\\t$(ui.helper).css(\\\"opacity\\\", o._opacity);\\n\\t\\t}\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"scroll\\\", {\\n\\tstart: function() {\\n\\t\\tvar i = $(this).data(\\\"ui-draggable\\\");\\n\\t\\tif(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== \\\"HTML\\\") {\\n\\t\\t\\ti.overflowOffset = i.scrollParent.offset();\\n\\t\\t}\\n\\t},\\n\\tdrag: function( event ) {\\n\\n\\t\\tvar i = $(this).data(\\\"ui-draggable\\\"), o = i.options, scrolled = false;\\n\\n\\t\\tif(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== \\\"HTML\\\") {\\n\\n\\t\\t\\tif(!o.axis || o.axis !== \\\"x\\\") {\\n\\t\\t\\t\\tif((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\ti.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;\\n\\t\\t\\t\\t} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\ti.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!o.axis || o.axis !== \\\"y\\\") {\\n\\t\\t\\t\\tif((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\ti.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;\\n\\t\\t\\t\\t} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\ti.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tif(!o.axis || o.axis !== \\\"x\\\") {\\n\\t\\t\\t\\tif(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\\n\\t\\t\\t\\t} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!o.axis || o.axis !== \\\"y\\\") {\\n\\t\\t\\t\\tif(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\\n\\t\\t\\t\\t} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\\n\\t\\t\\t$.ui.ddmanager.prepareOffsets(i, event);\\n\\t\\t}\\n\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"snap\\\", {\\n\\tstart: function() {\\n\\n\\t\\tvar i = $(this).data(\\\"ui-draggable\\\"),\\n\\t\\t\\to = i.options;\\n\\n\\t\\ti.snapElements = [];\\n\\n\\t\\t$(o.snap.constructor !== String ? ( o.snap.items || \\\":data(ui-draggable)\\\" ) : o.snap).each(function() {\\n\\t\\t\\tvar $t = $(this),\\n\\t\\t\\t\\t$o = $t.offset();\\n\\t\\t\\tif(this !== i.element[0]) {\\n\\t\\t\\t\\ti.snapElements.push({\\n\\t\\t\\t\\t\\titem: this,\\n\\t\\t\\t\\t\\twidth: $t.outerWidth(), height: $t.outerHeight(),\\n\\t\\t\\t\\t\\ttop: $o.top, left: $o.left\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t},\\n\\tdrag: function(event, ui) {\\n\\n\\t\\tvar ts, bs, ls, rs, l, r, t, b, i, first,\\n\\t\\t\\tinst = $(this).data(\\\"ui-draggable\\\"),\\n\\t\\t\\to = inst.options,\\n\\t\\t\\td = o.snapTolerance,\\n\\t\\t\\tx1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,\\n\\t\\t\\ty1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;\\n\\n\\t\\tfor (i = inst.snapElements.length - 1; i >= 0; i--){\\n\\n\\t\\t\\tl = inst.snapElements[i].left;\\n\\t\\t\\tr = l + inst.snapElements[i].width;\\n\\t\\t\\tt = inst.snapElements[i].top;\\n\\t\\t\\tb = t + inst.snapElements[i].height;\\n\\n\\t\\t\\tif ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {\\n\\t\\t\\t\\tif(inst.snapElements[i].snapping) {\\n\\t\\t\\t\\t\\t(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tinst.snapElements[i].snapping = false;\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(o.snapMode !== \\\"inner\\\") {\\n\\t\\t\\t\\tts = Math.abs(t - y2) <= d;\\n\\t\\t\\t\\tbs = Math.abs(b - y1) <= d;\\n\\t\\t\\t\\tls = Math.abs(l - x2) <= d;\\n\\t\\t\\t\\trs = Math.abs(r - x1) <= d;\\n\\t\\t\\t\\tif(ts) {\\n\\t\\t\\t\\t\\tui.position.top = inst._convertPositionTo(\\\"relative\\\", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(bs) {\\n\\t\\t\\t\\t\\tui.position.top = inst._convertPositionTo(\\\"relative\\\", { top: b, left: 0 }).top - inst.margins.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ls) {\\n\\t\\t\\t\\t\\tui.position.left = inst._convertPositionTo(\\\"relative\\\", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(rs) {\\n\\t\\t\\t\\t\\tui.position.left = inst._convertPositionTo(\\\"relative\\\", { top: 0, left: r }).left - inst.margins.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfirst = (ts || bs || ls || rs);\\n\\n\\t\\t\\tif(o.snapMode !== \\\"outer\\\") {\\n\\t\\t\\t\\tts = Math.abs(t - y1) <= d;\\n\\t\\t\\t\\tbs = Math.abs(b - y2) <= d;\\n\\t\\t\\t\\tls = Math.abs(l - x1) <= d;\\n\\t\\t\\t\\trs = Math.abs(r - x2) <= d;\\n\\t\\t\\t\\tif(ts) {\\n\\t\\t\\t\\t\\tui.position.top = inst._convertPositionTo(\\\"relative\\\", { top: t, left: 0 }).top - inst.margins.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(bs) {\\n\\t\\t\\t\\t\\tui.position.top = inst._convertPositionTo(\\\"relative\\\", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ls) {\\n\\t\\t\\t\\t\\tui.position.left = inst._convertPositionTo(\\\"relative\\\", { top: 0, left: l }).left - inst.margins.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(rs) {\\n\\t\\t\\t\\t\\tui.position.left = inst._convertPositionTo(\\\"relative\\\", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {\\n\\t\\t\\t\\t(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));\\n\\t\\t\\t}\\n\\t\\t\\tinst.snapElements[i].snapping = (ts || bs || ls || rs || first);\\n\\n\\t\\t}\\n\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"stack\\\", {\\n\\tstart: function() {\\n\\t\\tvar min,\\n\\t\\t\\to = this.data(\\\"ui-draggable\\\").options,\\n\\t\\t\\tgroup = $.makeArray($(o.stack)).sort(function(a,b) {\\n\\t\\t\\t\\treturn (parseInt($(a).css(\\\"zIndex\\\"),10) || 0) - (parseInt($(b).css(\\\"zIndex\\\"),10) || 0);\\n\\t\\t\\t});\\n\\n\\t\\tif (!group.length) { return; }\\n\\n\\t\\tmin = parseInt($(group[0]).css(\\\"zIndex\\\"), 10) || 0;\\n\\t\\t$(group).each(function(i) {\\n\\t\\t\\t$(this).css(\\\"zIndex\\\", min + i);\\n\\t\\t});\\n\\t\\tthis.css(\\\"zIndex\\\", (min + group.length));\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"draggable\\\", \\\"zIndex\\\", {\\n\\tstart: function(event, ui) {\\n\\t\\tvar t = $(ui.helper), o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif(t.css(\\\"zIndex\\\")) {\\n\\t\\t\\to._zIndex = t.css(\\\"zIndex\\\");\\n\\t\\t}\\n\\t\\tt.css(\\\"zIndex\\\", o.zIndex);\\n\\t},\\n\\tstop: function(event, ui) {\\n\\t\\tvar o = $(this).data(\\\"ui-draggable\\\").options;\\n\\t\\tif(o._zIndex) {\\n\\t\\t\\t$(ui.helper).css(\\\"zIndex\\\", o._zIndex);\\n\\t\\t}\\n\\t}\\n});\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\nfunction isOverAxis( x, reference, size ) {\\n\\treturn ( x > reference ) && ( x < ( reference + size ) );\\n}\\n\\n$.widget(\\\"ui.droppable\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\twidgetEventPrefix: \\\"drop\\\",\\n\\toptions: {\\n\\t\\taccept: \\\"*\\\",\\n\\t\\tactiveClass: false,\\n\\t\\taddClasses: true,\\n\\t\\tgreedy: false,\\n\\t\\thoverClass: false,\\n\\t\\tscope: \\\"default\\\",\\n\\t\\ttolerance: \\\"intersect\\\",\\n\\n\\t\\t// callbacks\\n\\t\\tactivate: null,\\n\\t\\tdeactivate: null,\\n\\t\\tdrop: null,\\n\\t\\tout: null,\\n\\t\\tover: null\\n\\t},\\n\\t_create: function() {\\n\\n\\t\\tvar o = this.options,\\n\\t\\t\\taccept = o.accept;\\n\\n\\t\\tthis.isover = false;\\n\\t\\tthis.isout = true;\\n\\n\\t\\tthis.accept = $.isFunction(accept) ? accept : function(d) {\\n\\t\\t\\treturn d.is(accept);\\n\\t\\t};\\n\\n\\t\\t//Store the droppable's proportions\\n\\t\\tthis.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };\\n\\n\\t\\t// Add the reference and positions to the manager\\n\\t\\t$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];\\n\\t\\t$.ui.ddmanager.droppables[o.scope].push(this);\\n\\n\\t\\t(o.addClasses && this.element.addClass(\\\"ui-droppable\\\"));\\n\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tvar i = 0,\\n\\t\\t\\tdrop = $.ui.ddmanager.droppables[this.options.scope];\\n\\n\\t\\tfor ( ; i < drop.length; i++ ) {\\n\\t\\t\\tif ( drop[i] === this ) {\\n\\t\\t\\t\\tdrop.splice(i, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.element.removeClass(\\\"ui-droppable ui-droppable-disabled\\\");\\n\\t},\\n\\n\\t_setOption: function(key, value) {\\n\\n\\t\\tif(key === \\\"accept\\\") {\\n\\t\\t\\tthis.accept = $.isFunction(value) ? value : function(d) {\\n\\t\\t\\t\\treturn d.is(value);\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\t$.Widget.prototype._setOption.apply(this, arguments);\\n\\t},\\n\\n\\t_activate: function(event) {\\n\\t\\tvar draggable = $.ui.ddmanager.current;\\n\\t\\tif(this.options.activeClass) {\\n\\t\\t\\tthis.element.addClass(this.options.activeClass);\\n\\t\\t}\\n\\t\\tif(draggable){\\n\\t\\t\\tthis._trigger(\\\"activate\\\", event, this.ui(draggable));\\n\\t\\t}\\n\\t},\\n\\n\\t_deactivate: function(event) {\\n\\t\\tvar draggable = $.ui.ddmanager.current;\\n\\t\\tif(this.options.activeClass) {\\n\\t\\t\\tthis.element.removeClass(this.options.activeClass);\\n\\t\\t}\\n\\t\\tif(draggable){\\n\\t\\t\\tthis._trigger(\\\"deactivate\\\", event, this.ui(draggable));\\n\\t\\t}\\n\\t},\\n\\n\\t_over: function(event) {\\n\\n\\t\\tvar draggable = $.ui.ddmanager.current;\\n\\n\\t\\t// Bail if draggable and droppable are same element\\n\\t\\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\\n\\t\\t\\tif(this.options.hoverClass) {\\n\\t\\t\\t\\tthis.element.addClass(this.options.hoverClass);\\n\\t\\t\\t}\\n\\t\\t\\tthis._trigger(\\\"over\\\", event, this.ui(draggable));\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_out: function(event) {\\n\\n\\t\\tvar draggable = $.ui.ddmanager.current;\\n\\n\\t\\t// Bail if draggable and droppable are same element\\n\\t\\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\\n\\t\\t\\tif(this.options.hoverClass) {\\n\\t\\t\\t\\tthis.element.removeClass(this.options.hoverClass);\\n\\t\\t\\t}\\n\\t\\t\\tthis._trigger(\\\"out\\\", event, this.ui(draggable));\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_drop: function(event,custom) {\\n\\n\\t\\tvar draggable = custom || $.ui.ddmanager.current,\\n\\t\\t\\tchildrenIntersection = false;\\n\\n\\t\\t// Bail if draggable and droppable are same element\\n\\t\\tif (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.element.find(\\\":data(ui-droppable)\\\").not(\\\".ui-draggable-dragging\\\").each(function() {\\n\\t\\t\\tvar inst = $.data(this, \\\"ui-droppable\\\");\\n\\t\\t\\tif(\\n\\t\\t\\t\\tinst.options.greedy &&\\n\\t\\t\\t\\t!inst.options.disabled &&\\n\\t\\t\\t\\tinst.options.scope === draggable.options.scope &&\\n\\t\\t\\t\\tinst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) &&\\n\\t\\t\\t\\t$.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)\\n\\t\\t\\t) { childrenIntersection = true; return false; }\\n\\t\\t});\\n\\t\\tif(childrenIntersection) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\\n\\t\\t\\tif(this.options.activeClass) {\\n\\t\\t\\t\\tthis.element.removeClass(this.options.activeClass);\\n\\t\\t\\t}\\n\\t\\t\\tif(this.options.hoverClass) {\\n\\t\\t\\t\\tthis.element.removeClass(this.options.hoverClass);\\n\\t\\t\\t}\\n\\t\\t\\tthis._trigger(\\\"drop\\\", event, this.ui(draggable));\\n\\t\\t\\treturn this.element;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\n\\t},\\n\\n\\tui: function(c) {\\n\\t\\treturn {\\n\\t\\t\\tdraggable: (c.currentItem || c.element),\\n\\t\\t\\thelper: c.helper,\\n\\t\\t\\tposition: c.position,\\n\\t\\t\\toffset: c.positionAbs\\n\\t\\t};\\n\\t}\\n\\n});\\n\\n$.ui.intersect = function(draggable, droppable, toleranceMode) {\\n\\n\\tif (!droppable.offset) {\\n\\t\\treturn false;\\n\\t}\\n\\n\\tvar draggableLeft, draggableTop,\\n\\t\\tx1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,\\n\\t\\ty1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height,\\n\\t\\tl = droppable.offset.left, r = l + droppable.proportions.width,\\n\\t\\tt = droppable.offset.top, b = t + droppable.proportions.height;\\n\\n\\tswitch (toleranceMode) {\\n\\t\\tcase \\\"fit\\\":\\n\\t\\t\\treturn (l <= x1 && x2 <= r && t <= y1 && y2 <= b);\\n\\t\\tcase \\\"intersect\\\":\\n\\t\\t\\treturn (l < x1 + (draggable.helperProportions.width / 2) && // Right Half\\n\\t\\t\\t\\tx2 - (draggable.helperProportions.width / 2) < r && // Left Half\\n\\t\\t\\t\\tt < y1 + (draggable.helperProportions.height / 2) && // Bottom Half\\n\\t\\t\\t\\ty2 - (draggable.helperProportions.height / 2) < b ); // Top Half\\n\\t\\tcase \\\"pointer\\\":\\n\\t\\t\\tdraggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left);\\n\\t\\t\\tdraggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top);\\n\\t\\t\\treturn isOverAxis( draggableTop, t, droppable.proportions.height ) && isOverAxis( draggableLeft, l, droppable.proportions.width );\\n\\t\\tcase \\\"touch\\\":\\n\\t\\t\\treturn (\\n\\t\\t\\t\\t(y1 >= t && y1 <= b) ||\\t// Top edge touching\\n\\t\\t\\t\\t(y2 >= t && y2 <= b) ||\\t// Bottom edge touching\\n\\t\\t\\t\\t(y1 < t && y2 > b)\\t\\t// Surrounded vertically\\n\\t\\t\\t) && (\\n\\t\\t\\t\\t(x1 >= l && x1 <= r) ||\\t// Left edge touching\\n\\t\\t\\t\\t(x2 >= l && x2 <= r) ||\\t// Right edge touching\\n\\t\\t\\t\\t(x1 < l && x2 > r)\\t\\t// Surrounded horizontally\\n\\t\\t\\t);\\n\\t\\tdefault:\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n};\\n\\n/*\\n\\tThis manager tracks offsets of draggables and droppables\\n*/\\n$.ui.ddmanager = {\\n\\tcurrent: null,\\n\\tdroppables: { \\\"default\\\": [] },\\n\\tprepareOffsets: function(t, event) {\\n\\n\\t\\tvar i, j,\\n\\t\\t\\tm = $.ui.ddmanager.droppables[t.options.scope] || [],\\n\\t\\t\\ttype = event ? event.type : null, // workaround for #2317\\n\\t\\t\\tlist = (t.currentItem || t.element).find(\\\":data(ui-droppable)\\\").addBack();\\n\\n\\t\\tdroppablesLoop: for (i = 0; i < m.length; i++) {\\n\\n\\t\\t\\t//No disabled and non-accepted\\n\\t\\t\\tif(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Filter out elements in the current dragged item\\n\\t\\t\\tfor (j=0; j < list.length; j++) {\\n\\t\\t\\t\\tif(list[j] === m[i].element[0]) {\\n\\t\\t\\t\\t\\tm[i].proportions.height = 0;\\n\\t\\t\\t\\t\\tcontinue droppablesLoop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tm[i].visible = m[i].element.css(\\\"display\\\") !== \\\"none\\\";\\n\\t\\t\\tif(!m[i].visible) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Activate the droppable if used directly from draggables\\n\\t\\t\\tif(type === \\\"mousedown\\\") {\\n\\t\\t\\t\\tm[i]._activate.call(m[i], event);\\n\\t\\t\\t}\\n\\n\\t\\t\\tm[i].offset = m[i].element.offset();\\n\\t\\t\\tm[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };\\n\\n\\t\\t}\\n\\n\\t},\\n\\tdrop: function(draggable, event) {\\n\\n\\t\\tvar dropped = false;\\n\\t\\t// Create a copy of the droppables in case the list changes during the drop (#9116)\\n\\t\\t$.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {\\n\\n\\t\\t\\tif(!this.options) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {\\n\\t\\t\\t\\tdropped = this._drop.call(this, event) || dropped;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {\\n\\t\\t\\t\\tthis.isout = true;\\n\\t\\t\\t\\tthis.isover = false;\\n\\t\\t\\t\\tthis._deactivate.call(this, event);\\n\\t\\t\\t}\\n\\n\\t\\t});\\n\\t\\treturn dropped;\\n\\n\\t},\\n\\tdragStart: function( draggable, event ) {\\n\\t\\t//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)\\n\\t\\tdraggable.element.parentsUntil( \\\"body\\\" ).bind( \\\"scroll.droppable\\\", function() {\\n\\t\\t\\tif( !draggable.options.refreshPositions ) {\\n\\t\\t\\t\\t$.ui.ddmanager.prepareOffsets( draggable, event );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\tdrag: function(draggable, event) {\\n\\n\\t\\t//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.\\n\\t\\tif(draggable.options.refreshPositions) {\\n\\t\\t\\t$.ui.ddmanager.prepareOffsets(draggable, event);\\n\\t\\t}\\n\\n\\t\\t//Run through all droppables and check their positions based on specific tolerance options\\n\\t\\t$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {\\n\\n\\t\\t\\tif(this.options.disabled || this.greedyChild || !this.visible) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar parentInstance, scope, parent,\\n\\t\\t\\t\\tintersects = $.ui.intersect(draggable, this, this.options.tolerance),\\n\\t\\t\\t\\tc = !intersects && this.isover ? \\\"isout\\\" : (intersects && !this.isover ? \\\"isover\\\" : null);\\n\\t\\t\\tif(!c) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (this.options.greedy) {\\n\\t\\t\\t\\t// find droppable parents with same scope\\n\\t\\t\\t\\tscope = this.options.scope;\\n\\t\\t\\t\\tparent = this.element.parents(\\\":data(ui-droppable)\\\").filter(function () {\\n\\t\\t\\t\\t\\treturn $.data(this, \\\"ui-droppable\\\").options.scope === scope;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tif (parent.length) {\\n\\t\\t\\t\\t\\tparentInstance = $.data(parent[0], \\\"ui-droppable\\\");\\n\\t\\t\\t\\t\\tparentInstance.greedyChild = (c === \\\"isover\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// we just moved into a greedy child\\n\\t\\t\\tif (parentInstance && c === \\\"isover\\\") {\\n\\t\\t\\t\\tparentInstance.isover = false;\\n\\t\\t\\t\\tparentInstance.isout = true;\\n\\t\\t\\t\\tparentInstance._out.call(parentInstance, event);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis[c] = true;\\n\\t\\t\\tthis[c === \\\"isout\\\" ? \\\"isover\\\" : \\\"isout\\\"] = false;\\n\\t\\t\\tthis[c === \\\"isover\\\" ? \\\"_over\\\" : \\\"_out\\\"].call(this, event);\\n\\n\\t\\t\\t// we just moved out of a greedy child\\n\\t\\t\\tif (parentInstance && c === \\\"isout\\\") {\\n\\t\\t\\t\\tparentInstance.isout = false;\\n\\t\\t\\t\\tparentInstance.isover = true;\\n\\t\\t\\t\\tparentInstance._over.call(parentInstance, event);\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t},\\n\\tdragStop: function( draggable, event ) {\\n\\t\\tdraggable.element.parentsUntil( \\\"body\\\" ).unbind( \\\"scroll.droppable\\\" );\\n\\t\\t//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)\\n\\t\\tif( !draggable.options.refreshPositions ) {\\n\\t\\t\\t$.ui.ddmanager.prepareOffsets( draggable, event );\\n\\t\\t}\\n\\t}\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\nfunction num(v) {\\n\\treturn parseInt(v, 10) || 0;\\n}\\n\\nfunction isNumber(value) {\\n\\treturn !isNaN(parseInt(value, 10));\\n}\\n\\n$.widget(\\\"ui.resizable\\\", $.ui.mouse, {\\n\\tversion: \\\"1.10.3\\\",\\n\\twidgetEventPrefix: \\\"resize\\\",\\n\\toptions: {\\n\\t\\talsoResize: false,\\n\\t\\tanimate: false,\\n\\t\\tanimateDuration: \\\"slow\\\",\\n\\t\\tanimateEasing: \\\"swing\\\",\\n\\t\\taspectRatio: false,\\n\\t\\tautoHide: false,\\n\\t\\tcontainment: false,\\n\\t\\tghost: false,\\n\\t\\tgrid: false,\\n\\t\\thandles: \\\"e,s,se\\\",\\n\\t\\thelper: false,\\n\\t\\tmaxHeight: null,\\n\\t\\tmaxWidth: null,\\n\\t\\tminHeight: 10,\\n\\t\\tminWidth: 10,\\n\\t\\t// See #7960\\n\\t\\tzIndex: 90,\\n\\n\\t\\t// callbacks\\n\\t\\tresize: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null\\n\\t},\\n\\t_create: function() {\\n\\n\\t\\tvar n, i, handle, axis, hname,\\n\\t\\t\\tthat = this,\\n\\t\\t\\to = this.options;\\n\\t\\tthis.element.addClass(\\\"ui-resizable\\\");\\n\\n\\t\\t$.extend(this, {\\n\\t\\t\\t_aspectRatio: !!(o.aspectRatio),\\n\\t\\t\\taspectRatio: o.aspectRatio,\\n\\t\\t\\toriginalElement: this.element,\\n\\t\\t\\t_proportionallyResizeElements: [],\\n\\t\\t\\t_helper: o.helper || o.ghost || o.animate ? o.helper || \\\"ui-resizable-helper\\\" : null\\n\\t\\t});\\n\\n\\t\\t//Wrap the element if it cannot hold child nodes\\n\\t\\tif(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {\\n\\n\\t\\t\\t//Create a wrapper element and set the wrapper to the new current internal element\\n\\t\\t\\tthis.element.wrap(\\n\\t\\t\\t\\t$(\\\"<div class='ui-wrapper' style='overflow: hidden;'></div>\\\").css({\\n\\t\\t\\t\\t\\tposition: this.element.css(\\\"position\\\"),\\n\\t\\t\\t\\t\\twidth: this.element.outerWidth(),\\n\\t\\t\\t\\t\\theight: this.element.outerHeight(),\\n\\t\\t\\t\\t\\ttop: this.element.css(\\\"top\\\"),\\n\\t\\t\\t\\t\\tleft: this.element.css(\\\"left\\\")\\n\\t\\t\\t\\t})\\n\\t\\t\\t);\\n\\n\\t\\t\\t//Overwrite the original this.element\\n\\t\\t\\tthis.element = this.element.parent().data(\\n\\t\\t\\t\\t\\\"ui-resizable\\\", this.element.data(\\\"ui-resizable\\\")\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.elementIsWrapper = true;\\n\\n\\t\\t\\t//Move margins to the wrapper\\n\\t\\t\\tthis.element.css({ marginLeft: this.originalElement.css(\\\"marginLeft\\\"), marginTop: this.originalElement.css(\\\"marginTop\\\"), marginRight: this.originalElement.css(\\\"marginRight\\\"), marginBottom: this.originalElement.css(\\\"marginBottom\\\") });\\n\\t\\t\\tthis.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});\\n\\n\\t\\t\\t//Prevent Safari textarea resize\\n\\t\\t\\tthis.originalResizeStyle = this.originalElement.css(\\\"resize\\\");\\n\\t\\t\\tthis.originalElement.css(\\\"resize\\\", \\\"none\\\");\\n\\n\\t\\t\\t//Push the actual element to our proportionallyResize internal array\\n\\t\\t\\tthis._proportionallyResizeElements.push(this.originalElement.css({ position: \\\"static\\\", zoom: 1, display: \\\"block\\\" }));\\n\\n\\t\\t\\t// avoid IE jump (hard set the margin)\\n\\t\\t\\tthis.originalElement.css({ margin: this.originalElement.css(\\\"margin\\\") });\\n\\n\\t\\t\\t// fix handlers offset\\n\\t\\t\\tthis._proportionallyResize();\\n\\n\\t\\t}\\n\\n\\t\\tthis.handles = o.handles || (!$(\\\".ui-resizable-handle\\\", this.element).length ? \\\"e,s,se\\\" : { n: \\\".ui-resizable-n\\\", e: \\\".ui-resizable-e\\\", s: \\\".ui-resizable-s\\\", w: \\\".ui-resizable-w\\\", se: \\\".ui-resizable-se\\\", sw: \\\".ui-resizable-sw\\\", ne: \\\".ui-resizable-ne\\\", nw: \\\".ui-resizable-nw\\\" });\\n\\t\\tif(this.handles.constructor === String) {\\n\\n\\t\\t\\tif ( this.handles === \\\"all\\\") {\\n\\t\\t\\t\\tthis.handles = \\\"n,e,s,w,se,sw,ne,nw\\\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tn = this.handles.split(\\\",\\\");\\n\\t\\t\\tthis.handles = {};\\n\\n\\t\\t\\tfor(i = 0; i < n.length; i++) {\\n\\n\\t\\t\\t\\thandle = $.trim(n[i]);\\n\\t\\t\\t\\thname = \\\"ui-resizable-\\\"+handle;\\n\\t\\t\\t\\taxis = $(\\\"<div class='ui-resizable-handle \\\" + hname + \\\"'></div>\\\");\\n\\n\\t\\t\\t\\t// Apply zIndex to all handles - see #7960\\n\\t\\t\\t\\taxis.css({ zIndex: o.zIndex });\\n\\n\\t\\t\\t\\t//TODO : What's going on here?\\n\\t\\t\\t\\tif (\\\"se\\\" === handle) {\\n\\t\\t\\t\\t\\taxis.addClass(\\\"ui-icon ui-icon-gripsmall-diagonal-se\\\");\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Insert into internal handles object and append to element\\n\\t\\t\\t\\tthis.handles[handle] = \\\".ui-resizable-\\\"+handle;\\n\\t\\t\\t\\tthis.element.append(axis);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis._renderAxis = function(target) {\\n\\n\\t\\t\\tvar i, axis, padPos, padWrapper;\\n\\n\\t\\t\\ttarget = target || this.element;\\n\\n\\t\\t\\tfor(i in this.handles) {\\n\\n\\t\\t\\t\\tif(this.handles[i].constructor === String) {\\n\\t\\t\\t\\t\\tthis.handles[i] = $(this.handles[i], this.element).show();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)\\n\\t\\t\\t\\tif (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {\\n\\n\\t\\t\\t\\t\\taxis = $(this.handles[i], this.element);\\n\\n\\t\\t\\t\\t\\t//Checking the correct pad and border\\n\\t\\t\\t\\t\\tpadWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();\\n\\n\\t\\t\\t\\t\\t//The padding type i have to apply...\\n\\t\\t\\t\\t\\tpadPos = [ \\\"padding\\\",\\n\\t\\t\\t\\t\\t\\t/ne|nw|n/.test(i) ? \\\"Top\\\" :\\n\\t\\t\\t\\t\\t\\t/se|sw|s/.test(i) ? \\\"Bottom\\\" :\\n\\t\\t\\t\\t\\t\\t/^e$/.test(i) ? \\\"Right\\\" : \\\"Left\\\" ].join(\\\"\\\");\\n\\n\\t\\t\\t\\t\\ttarget.css(padPos, padWrapper);\\n\\n\\t\\t\\t\\t\\tthis._proportionallyResize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//TODO: What's that good for? There's not anything to be executed left\\n\\t\\t\\t\\tif(!$(this.handles[i]).length) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\t//TODO: make renderAxis a prototype function\\n\\t\\tthis._renderAxis(this.element);\\n\\n\\t\\tthis._handles = $(\\\".ui-resizable-handle\\\", this.element)\\n\\t\\t\\t.disableSelection();\\n\\n\\t\\t//Matching axis name\\n\\t\\tthis._handles.mouseover(function() {\\n\\t\\t\\tif (!that.resizing) {\\n\\t\\t\\t\\tif (this.className) {\\n\\t\\t\\t\\t\\taxis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//Axis, default = se\\n\\t\\t\\t\\tthat.axis = axis && axis[1] ? axis[1] : \\\"se\\\";\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t//If we want to auto hide the elements\\n\\t\\tif (o.autoHide) {\\n\\t\\t\\tthis._handles.hide();\\n\\t\\t\\t$(this.element)\\n\\t\\t\\t\\t.addClass(\\\"ui-resizable-autohide\\\")\\n\\t\\t\\t\\t.mouseenter(function() {\\n\\t\\t\\t\\t\\tif (o.disabled) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$(this).removeClass(\\\"ui-resizable-autohide\\\");\\n\\t\\t\\t\\t\\tthat._handles.show();\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.mouseleave(function(){\\n\\t\\t\\t\\t\\tif (o.disabled) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!that.resizing) {\\n\\t\\t\\t\\t\\t\\t$(this).addClass(\\\"ui-resizable-autohide\\\");\\n\\t\\t\\t\\t\\t\\tthat._handles.hide();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\t//Initialize the mouse interaction\\n\\t\\tthis._mouseInit();\\n\\n\\t},\\n\\n\\t_destroy: function() {\\n\\n\\t\\tthis._mouseDestroy();\\n\\n\\t\\tvar wrapper,\\n\\t\\t\\t_destroy = function(exp) {\\n\\t\\t\\t\\t$(exp).removeClass(\\\"ui-resizable ui-resizable-disabled ui-resizable-resizing\\\")\\n\\t\\t\\t\\t\\t.removeData(\\\"resizable\\\").removeData(\\\"ui-resizable\\\").unbind(\\\".resizable\\\").find(\\\".ui-resizable-handle\\\").remove();\\n\\t\\t\\t};\\n\\n\\t\\t//TODO: Unwrap at same DOM position\\n\\t\\tif (this.elementIsWrapper) {\\n\\t\\t\\t_destroy(this.element);\\n\\t\\t\\twrapper = this.element;\\n\\t\\t\\tthis.originalElement.css({\\n\\t\\t\\t\\tposition: wrapper.css(\\\"position\\\"),\\n\\t\\t\\t\\twidth: wrapper.outerWidth(),\\n\\t\\t\\t\\theight: wrapper.outerHeight(),\\n\\t\\t\\t\\ttop: wrapper.css(\\\"top\\\"),\\n\\t\\t\\t\\tleft: wrapper.css(\\\"left\\\")\\n\\t\\t\\t}).insertAfter( wrapper );\\n\\t\\t\\twrapper.remove();\\n\\t\\t}\\n\\n\\t\\tthis.originalElement.css(\\\"resize\\\", this.originalResizeStyle);\\n\\t\\t_destroy(this.originalElement);\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t_mouseCapture: function(event) {\\n\\t\\tvar i, handle,\\n\\t\\t\\tcapture = false;\\n\\n\\t\\tfor (i in this.handles) {\\n\\t\\t\\thandle = $(this.handles[i])[0];\\n\\t\\t\\tif (handle === event.target || $.contains(handle, event.target)) {\\n\\t\\t\\t\\tcapture = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn !this.options.disabled && capture;\\n\\t},\\n\\n\\t_mouseStart: function(event) {\\n\\n\\t\\tvar curleft, curtop, cursor,\\n\\t\\t\\to = this.options,\\n\\t\\t\\tiniPos = this.element.position(),\\n\\t\\t\\tel = this.element;\\n\\n\\t\\tthis.resizing = true;\\n\\n\\t\\t// bugfix for http://dev.jquery.com/ticket/1749\\n\\t\\tif ( (/absolute/).test( el.css(\\\"position\\\") ) ) {\\n\\t\\t\\tel.css({ position: \\\"absolute\\\", top: el.css(\\\"top\\\"), left: el.css(\\\"left\\\") });\\n\\t\\t} else if (el.is(\\\".ui-draggable\\\")) {\\n\\t\\t\\tel.css({ position: \\\"absolute\\\", top: iniPos.top, left: iniPos.left });\\n\\t\\t}\\n\\n\\t\\tthis._renderProxy();\\n\\n\\t\\tcurleft = num(this.helper.css(\\\"left\\\"));\\n\\t\\tcurtop = num(this.helper.css(\\\"top\\\"));\\n\\n\\t\\tif (o.containment) {\\n\\t\\t\\tcurleft += $(o.containment).scrollLeft() || 0;\\n\\t\\t\\tcurtop += $(o.containment).scrollTop() || 0;\\n\\t\\t}\\n\\n\\t\\t//Store needed variables\\n\\t\\tthis.offset = this.helper.offset();\\n\\t\\tthis.position = { left: curleft, top: curtop };\\n\\t\\tthis.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };\\n\\t\\tthis.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };\\n\\t\\tthis.originalPosition = { left: curleft, top: curtop };\\n\\t\\tthis.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };\\n\\t\\tthis.originalMousePosition = { left: event.pageX, top: event.pageY };\\n\\n\\t\\t//Aspect Ratio\\n\\t\\tthis.aspectRatio = (typeof o.aspectRatio === \\\"number\\\") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);\\n\\n\\t\\tcursor = $(\\\".ui-resizable-\\\" + this.axis).css(\\\"cursor\\\");\\n\\t\\t$(\\\"body\\\").css(\\\"cursor\\\", cursor === \\\"auto\\\" ? this.axis + \\\"-resize\\\" : cursor);\\n\\n\\t\\tel.addClass(\\\"ui-resizable-resizing\\\");\\n\\t\\tthis._propagate(\\\"start\\\", event);\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_mouseDrag: function(event) {\\n\\n\\t\\t//Increase performance, avoid regex\\n\\t\\tvar data,\\n\\t\\t\\tel = this.helper, props = {},\\n\\t\\t\\tsmp = this.originalMousePosition,\\n\\t\\t\\ta = this.axis,\\n\\t\\t\\tprevTop = this.position.top,\\n\\t\\t\\tprevLeft = this.position.left,\\n\\t\\t\\tprevWidth = this.size.width,\\n\\t\\t\\tprevHeight = this.size.height,\\n\\t\\t\\tdx = (event.pageX-smp.left)||0,\\n\\t\\t\\tdy = (event.pageY-smp.top)||0,\\n\\t\\t\\ttrigger = this._change[a];\\n\\n\\t\\tif (!trigger) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// Calculate the attrs that will be change\\n\\t\\tdata = trigger.apply(this, [event, dx, dy]);\\n\\n\\t\\t// Put this in the mouseDrag handler since the user can start pressing shift while resizing\\n\\t\\tthis._updateVirtualBoundaries(event.shiftKey);\\n\\t\\tif (this._aspectRatio || event.shiftKey) {\\n\\t\\t\\tdata = this._updateRatio(data, event);\\n\\t\\t}\\n\\n\\t\\tdata = this._respectSize(data, event);\\n\\n\\t\\tthis._updateCache(data);\\n\\n\\t\\t// plugins callbacks need to be called first\\n\\t\\tthis._propagate(\\\"resize\\\", event);\\n\\n\\t\\tif (this.position.top !== prevTop) {\\n\\t\\t\\tprops.top = this.position.top + \\\"px\\\";\\n\\t\\t}\\n\\t\\tif (this.position.left !== prevLeft) {\\n\\t\\t\\tprops.left = this.position.left + \\\"px\\\";\\n\\t\\t}\\n\\t\\tif (this.size.width !== prevWidth) {\\n\\t\\t\\tprops.width = this.size.width + \\\"px\\\";\\n\\t\\t}\\n\\t\\tif (this.size.height !== prevHeight) {\\n\\t\\t\\tprops.height = this.size.height + \\\"px\\\";\\n\\t\\t}\\n\\t\\tel.css(props);\\n\\n\\t\\tif (!this._helper && this._proportionallyResizeElements.length) {\\n\\t\\t\\tthis._proportionallyResize();\\n\\t\\t}\\n\\n\\t\\t// Call the user callback if the element was resized\\n\\t\\tif ( ! $.isEmptyObject(props) ) {\\n\\t\\t\\tthis._trigger(\\\"resize\\\", event, this.ui());\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseStop: function(event) {\\n\\n\\t\\tthis.resizing = false;\\n\\t\\tvar pr, ista, soffseth, soffsetw, s, left, top,\\n\\t\\t\\to = this.options, that = this;\\n\\n\\t\\tif(this._helper) {\\n\\n\\t\\t\\tpr = this._proportionallyResizeElements;\\n\\t\\t\\tista = pr.length && (/textarea/i).test(pr[0].nodeName);\\n\\t\\t\\tsoffseth = ista && $.ui.hasScroll(pr[0], \\\"left\\\") /* TODO - jump height */ ? 0 : that.sizeDiff.height;\\n\\t\\t\\tsoffsetw = ista ? 0 : that.sizeDiff.width;\\n\\n\\t\\t\\ts = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };\\n\\t\\t\\tleft = (parseInt(that.element.css(\\\"left\\\"), 10) + (that.position.left - that.originalPosition.left)) || null;\\n\\t\\t\\ttop = (parseInt(that.element.css(\\\"top\\\"), 10) + (that.position.top - that.originalPosition.top)) || null;\\n\\n\\t\\t\\tif (!o.animate) {\\n\\t\\t\\t\\tthis.element.css($.extend(s, { top: top, left: left }));\\n\\t\\t\\t}\\n\\n\\t\\t\\tthat.helper.height(that.size.height);\\n\\t\\t\\tthat.helper.width(that.size.width);\\n\\n\\t\\t\\tif (this._helper && !o.animate) {\\n\\t\\t\\t\\tthis._proportionallyResize();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t$(\\\"body\\\").css(\\\"cursor\\\", \\\"auto\\\");\\n\\n\\t\\tthis.element.removeClass(\\\"ui-resizable-resizing\\\");\\n\\n\\t\\tthis._propagate(\\\"stop\\\", event);\\n\\n\\t\\tif (this._helper) {\\n\\t\\t\\tthis.helper.remove();\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\n\\t},\\n\\n\\t_updateVirtualBoundaries: function(forceAspectRatio) {\\n\\t\\tvar pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,\\n\\t\\t\\to = this.options;\\n\\n\\t\\tb = {\\n\\t\\t\\tminWidth: isNumber(o.minWidth) ? o.minWidth : 0,\\n\\t\\t\\tmaxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,\\n\\t\\t\\tminHeight: isNumber(o.minHeight) ? o.minHeight : 0,\\n\\t\\t\\tmaxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity\\n\\t\\t};\\n\\n\\t\\tif(this._aspectRatio || forceAspectRatio) {\\n\\t\\t\\t// We want to create an enclosing box whose aspect ration is the requested one\\n\\t\\t\\t// First, compute the \\\"projected\\\" size for each dimension based on the aspect ratio and other dimension\\n\\t\\t\\tpMinWidth = b.minHeight * this.aspectRatio;\\n\\t\\t\\tpMinHeight = b.minWidth / this.aspectRatio;\\n\\t\\t\\tpMaxWidth = b.maxHeight * this.aspectRatio;\\n\\t\\t\\tpMaxHeight = b.maxWidth / this.aspectRatio;\\n\\n\\t\\t\\tif(pMinWidth > b.minWidth) {\\n\\t\\t\\t\\tb.minWidth = pMinWidth;\\n\\t\\t\\t}\\n\\t\\t\\tif(pMinHeight > b.minHeight) {\\n\\t\\t\\t\\tb.minHeight = pMinHeight;\\n\\t\\t\\t}\\n\\t\\t\\tif(pMaxWidth < b.maxWidth) {\\n\\t\\t\\t\\tb.maxWidth = pMaxWidth;\\n\\t\\t\\t}\\n\\t\\t\\tif(pMaxHeight < b.maxHeight) {\\n\\t\\t\\t\\tb.maxHeight = pMaxHeight;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis._vBoundaries = b;\\n\\t},\\n\\n\\t_updateCache: function(data) {\\n\\t\\tthis.offset = this.helper.offset();\\n\\t\\tif (isNumber(data.left)) {\\n\\t\\t\\tthis.position.left = data.left;\\n\\t\\t}\\n\\t\\tif (isNumber(data.top)) {\\n\\t\\t\\tthis.position.top = data.top;\\n\\t\\t}\\n\\t\\tif (isNumber(data.height)) {\\n\\t\\t\\tthis.size.height = data.height;\\n\\t\\t}\\n\\t\\tif (isNumber(data.width)) {\\n\\t\\t\\tthis.size.width = data.width;\\n\\t\\t}\\n\\t},\\n\\n\\t_updateRatio: function( data ) {\\n\\n\\t\\tvar cpos = this.position,\\n\\t\\t\\tcsize = this.size,\\n\\t\\t\\ta = this.axis;\\n\\n\\t\\tif (isNumber(data.height)) {\\n\\t\\t\\tdata.width = (data.height * this.aspectRatio);\\n\\t\\t} else if (isNumber(data.width)) {\\n\\t\\t\\tdata.height = (data.width / this.aspectRatio);\\n\\t\\t}\\n\\n\\t\\tif (a === \\\"sw\\\") {\\n\\t\\t\\tdata.left = cpos.left + (csize.width - data.width);\\n\\t\\t\\tdata.top = null;\\n\\t\\t}\\n\\t\\tif (a === \\\"nw\\\") {\\n\\t\\t\\tdata.top = cpos.top + (csize.height - data.height);\\n\\t\\t\\tdata.left = cpos.left + (csize.width - data.width);\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\t},\\n\\n\\t_respectSize: function( data ) {\\n\\n\\t\\tvar o = this._vBoundaries,\\n\\t\\t\\ta = this.axis,\\n\\t\\t\\tismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),\\n\\t\\t\\tisminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),\\n\\t\\t\\tdw = this.originalPosition.left + this.originalSize.width,\\n\\t\\t\\tdh = this.position.top + this.size.height,\\n\\t\\t\\tcw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);\\n\\t\\tif (isminw) {\\n\\t\\t\\tdata.width = o.minWidth;\\n\\t\\t}\\n\\t\\tif (isminh) {\\n\\t\\t\\tdata.height = o.minHeight;\\n\\t\\t}\\n\\t\\tif (ismaxw) {\\n\\t\\t\\tdata.width = o.maxWidth;\\n\\t\\t}\\n\\t\\tif (ismaxh) {\\n\\t\\t\\tdata.height = o.maxHeight;\\n\\t\\t}\\n\\n\\t\\tif (isminw && cw) {\\n\\t\\t\\tdata.left = dw - o.minWidth;\\n\\t\\t}\\n\\t\\tif (ismaxw && cw) {\\n\\t\\t\\tdata.left = dw - o.maxWidth;\\n\\t\\t}\\n\\t\\tif (isminh && ch) {\\n\\t\\t\\tdata.top = dh - o.minHeight;\\n\\t\\t}\\n\\t\\tif (ismaxh && ch) {\\n\\t\\t\\tdata.top = dh - o.maxHeight;\\n\\t\\t}\\n\\n\\t\\t// fixing jump error on top/left - bug #2330\\n\\t\\tif (!data.width && !data.height && !data.left && data.top) {\\n\\t\\t\\tdata.top = null;\\n\\t\\t} else if (!data.width && !data.height && !data.top && data.left) {\\n\\t\\t\\tdata.left = null;\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\t},\\n\\n\\t_proportionallyResize: function() {\\n\\n\\t\\tif (!this._proportionallyResizeElements.length) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar i, j, borders, paddings, prel,\\n\\t\\t\\telement = this.helper || this.element;\\n\\n\\t\\tfor ( i=0; i < this._proportionallyResizeElements.length; i++) {\\n\\n\\t\\t\\tprel = this._proportionallyResizeElements[i];\\n\\n\\t\\t\\tif (!this.borderDif) {\\n\\t\\t\\t\\tthis.borderDif = [];\\n\\t\\t\\t\\tborders = [prel.css(\\\"borderTopWidth\\\"), prel.css(\\\"borderRightWidth\\\"), prel.css(\\\"borderBottomWidth\\\"), prel.css(\\\"borderLeftWidth\\\")];\\n\\t\\t\\t\\tpaddings = [prel.css(\\\"paddingTop\\\"), prel.css(\\\"paddingRight\\\"), prel.css(\\\"paddingBottom\\\"), prel.css(\\\"paddingLeft\\\")];\\n\\n\\t\\t\\t\\tfor ( j = 0; j < borders.length; j++ ) {\\n\\t\\t\\t\\t\\tthis.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tprel.css({\\n\\t\\t\\t\\theight: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,\\n\\t\\t\\t\\twidth: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0\\n\\t\\t\\t});\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_renderProxy: function() {\\n\\n\\t\\tvar el = this.element, o = this.options;\\n\\t\\tthis.elementOffset = el.offset();\\n\\n\\t\\tif(this._helper) {\\n\\n\\t\\t\\tthis.helper = this.helper || $(\\\"<div style='overflow:hidden;'></div>\\\");\\n\\n\\t\\t\\tthis.helper.addClass(this._helper).css({\\n\\t\\t\\t\\twidth: this.element.outerWidth() - 1,\\n\\t\\t\\t\\theight: this.element.outerHeight() - 1,\\n\\t\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\t\\tleft: this.elementOffset.left +\\\"px\\\",\\n\\t\\t\\t\\ttop: this.elementOffset.top +\\\"px\\\",\\n\\t\\t\\t\\tzIndex: ++o.zIndex //TODO: Don't modify option\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.helper\\n\\t\\t\\t\\t.appendTo(\\\"body\\\")\\n\\t\\t\\t\\t.disableSelection();\\n\\n\\t\\t} else {\\n\\t\\t\\tthis.helper = this.element;\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_change: {\\n\\t\\te: function(event, dx) {\\n\\t\\t\\treturn { width: this.originalSize.width + dx };\\n\\t\\t},\\n\\t\\tw: function(event, dx) {\\n\\t\\t\\tvar cs = this.originalSize, sp = this.originalPosition;\\n\\t\\t\\treturn { left: sp.left + dx, width: cs.width - dx };\\n\\t\\t},\\n\\t\\tn: function(event, dx, dy) {\\n\\t\\t\\tvar cs = this.originalSize, sp = this.originalPosition;\\n\\t\\t\\treturn { top: sp.top + dy, height: cs.height - dy };\\n\\t\\t},\\n\\t\\ts: function(event, dx, dy) {\\n\\t\\t\\treturn { height: this.originalSize.height + dy };\\n\\t\\t},\\n\\t\\tse: function(event, dx, dy) {\\n\\t\\t\\treturn $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\\n\\t\\t},\\n\\t\\tsw: function(event, dx, dy) {\\n\\t\\t\\treturn $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\\n\\t\\t},\\n\\t\\tne: function(event, dx, dy) {\\n\\t\\t\\treturn $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));\\n\\t\\t},\\n\\t\\tnw: function(event, dx, dy) {\\n\\t\\t\\treturn $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));\\n\\t\\t}\\n\\t},\\n\\n\\t_propagate: function(n, event) {\\n\\t\\t$.ui.plugin.call(this, n, [event, this.ui()]);\\n\\t\\t(n !== \\\"resize\\\" && this._trigger(n, event, this.ui()));\\n\\t},\\n\\n\\tplugins: {},\\n\\n\\tui: function() {\\n\\t\\treturn {\\n\\t\\t\\toriginalElement: this.originalElement,\\n\\t\\t\\telement: this.element,\\n\\t\\t\\thelper: this.helper,\\n\\t\\t\\tposition: this.position,\\n\\t\\t\\tsize: this.size,\\n\\t\\t\\toriginalSize: this.originalSize,\\n\\t\\t\\toriginalPosition: this.originalPosition\\n\\t\\t};\\n\\t}\\n\\n});\\n\\n/*\\n * Resizable Extensions\\n */\\n\\n$.ui.plugin.add(\\\"resizable\\\", \\\"animate\\\", {\\n\\n\\tstop: function( event ) {\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tpr = that._proportionallyResizeElements,\\n\\t\\t\\tista = pr.length && (/textarea/i).test(pr[0].nodeName),\\n\\t\\t\\tsoffseth = ista && $.ui.hasScroll(pr[0], \\\"left\\\") /* TODO - jump height */ ? 0 : that.sizeDiff.height,\\n\\t\\t\\tsoffsetw = ista ? 0 : that.sizeDiff.width,\\n\\t\\t\\tstyle = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },\\n\\t\\t\\tleft = (parseInt(that.element.css(\\\"left\\\"), 10) + (that.position.left - that.originalPosition.left)) || null,\\n\\t\\t\\ttop = (parseInt(that.element.css(\\\"top\\\"), 10) + (that.position.top - that.originalPosition.top)) || null;\\n\\n\\t\\tthat.element.animate(\\n\\t\\t\\t$.extend(style, top && left ? { top: top, left: left } : {}), {\\n\\t\\t\\t\\tduration: o.animateDuration,\\n\\t\\t\\t\\teasing: o.animateEasing,\\n\\t\\t\\t\\tstep: function() {\\n\\n\\t\\t\\t\\t\\tvar data = {\\n\\t\\t\\t\\t\\t\\twidth: parseInt(that.element.css(\\\"width\\\"), 10),\\n\\t\\t\\t\\t\\t\\theight: parseInt(that.element.css(\\\"height\\\"), 10),\\n\\t\\t\\t\\t\\t\\ttop: parseInt(that.element.css(\\\"top\\\"), 10),\\n\\t\\t\\t\\t\\t\\tleft: parseInt(that.element.css(\\\"left\\\"), 10)\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tif (pr && pr.length) {\\n\\t\\t\\t\\t\\t\\t$(pr[0]).css({ width: data.width, height: data.height });\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// propagating resize, and updating values for each animation step\\n\\t\\t\\t\\t\\tthat._updateCache(data);\\n\\t\\t\\t\\t\\tthat._propagate(\\\"resize\\\", event);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t);\\n\\t}\\n\\n});\\n\\n$.ui.plugin.add(\\\"resizable\\\", \\\"containment\\\", {\\n\\n\\tstart: function() {\\n\\t\\tvar element, p, co, ch, cw, width, height,\\n\\t\\t\\tthat = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tel = that.element,\\n\\t\\t\\toc = o.containment,\\n\\t\\t\\tce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;\\n\\n\\t\\tif (!ce) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthat.containerElement = $(ce);\\n\\n\\t\\tif (/document/.test(oc) || oc === document) {\\n\\t\\t\\tthat.containerOffset = { left: 0, top: 0 };\\n\\t\\t\\tthat.containerPosition = { left: 0, top: 0 };\\n\\n\\t\\t\\tthat.parentData = {\\n\\t\\t\\t\\telement: $(document), left: 0, top: 0,\\n\\t\\t\\t\\twidth: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t// i'm a node, so compute top, left, right, bottom\\n\\t\\telse {\\n\\t\\t\\telement = $(ce);\\n\\t\\t\\tp = [];\\n\\t\\t\\t$([ \\\"Top\\\", \\\"Right\\\", \\\"Left\\\", \\\"Bottom\\\" ]).each(function(i, name) { p[i] = num(element.css(\\\"padding\\\" + name)); });\\n\\n\\t\\t\\tthat.containerOffset = element.offset();\\n\\t\\t\\tthat.containerPosition = element.position();\\n\\t\\t\\tthat.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };\\n\\n\\t\\t\\tco = that.containerOffset;\\n\\t\\t\\tch = that.containerSize.height;\\n\\t\\t\\tcw = that.containerSize.width;\\n\\t\\t\\twidth = ($.ui.hasScroll(ce, \\\"left\\\") ? ce.scrollWidth : cw );\\n\\t\\t\\theight = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);\\n\\n\\t\\t\\tthat.parentData = {\\n\\t\\t\\t\\telement: ce, left: co.left, top: co.top, width: width, height: height\\n\\t\\t\\t};\\n\\t\\t}\\n\\t},\\n\\n\\tresize: function( event ) {\\n\\t\\tvar woset, hoset, isParent, isOffsetRelative,\\n\\t\\t\\tthat = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tco = that.containerOffset, cp = that.position,\\n\\t\\t\\tpRatio = that._aspectRatio || event.shiftKey,\\n\\t\\t\\tcop = { top:0, left:0 }, ce = that.containerElement;\\n\\n\\t\\tif (ce[0] !== document && (/static/).test(ce.css(\\\"position\\\"))) {\\n\\t\\t\\tcop = co;\\n\\t\\t}\\n\\n\\t\\tif (cp.left < (that._helper ? co.left : 0)) {\\n\\t\\t\\tthat.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));\\n\\t\\t\\tif (pRatio) {\\n\\t\\t\\t\\tthat.size.height = that.size.width / that.aspectRatio;\\n\\t\\t\\t}\\n\\t\\t\\tthat.position.left = o.helper ? co.left : 0;\\n\\t\\t}\\n\\n\\t\\tif (cp.top < (that._helper ? co.top : 0)) {\\n\\t\\t\\tthat.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);\\n\\t\\t\\tif (pRatio) {\\n\\t\\t\\t\\tthat.size.width = that.size.height * that.aspectRatio;\\n\\t\\t\\t}\\n\\t\\t\\tthat.position.top = that._helper ? co.top : 0;\\n\\t\\t}\\n\\n\\t\\tthat.offset.left = that.parentData.left+that.position.left;\\n\\t\\tthat.offset.top = that.parentData.top+that.position.top;\\n\\n\\t\\twoset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );\\n\\t\\thoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );\\n\\n\\t\\tisParent = that.containerElement.get(0) === that.element.parent().get(0);\\n\\t\\tisOffsetRelative = /relative|absolute/.test(that.containerElement.css(\\\"position\\\"));\\n\\n\\t\\tif(isParent && isOffsetRelative) {\\n\\t\\t\\twoset -= that.parentData.left;\\n\\t\\t}\\n\\n\\t\\tif (woset + that.size.width >= that.parentData.width) {\\n\\t\\t\\tthat.size.width = that.parentData.width - woset;\\n\\t\\t\\tif (pRatio) {\\n\\t\\t\\t\\tthat.size.height = that.size.width / that.aspectRatio;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (hoset + that.size.height >= that.parentData.height) {\\n\\t\\t\\tthat.size.height = that.parentData.height - hoset;\\n\\t\\t\\tif (pRatio) {\\n\\t\\t\\t\\tthat.size.width = that.size.height * that.aspectRatio;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tstop: function(){\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tco = that.containerOffset,\\n\\t\\t\\tcop = that.containerPosition,\\n\\t\\t\\tce = that.containerElement,\\n\\t\\t\\thelper = $(that.helper),\\n\\t\\t\\tho = helper.offset(),\\n\\t\\t\\tw = helper.outerWidth() - that.sizeDiff.width,\\n\\t\\t\\th = helper.outerHeight() - that.sizeDiff.height;\\n\\n\\t\\tif (that._helper && !o.animate && (/relative/).test(ce.css(\\\"position\\\"))) {\\n\\t\\t\\t$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });\\n\\t\\t}\\n\\n\\t\\tif (that._helper && !o.animate && (/static/).test(ce.css(\\\"position\\\"))) {\\n\\t\\t\\t$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });\\n\\t\\t}\\n\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"resizable\\\", \\\"alsoResize\\\", {\\n\\n\\tstart: function () {\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\t_store = function (exp) {\\n\\t\\t\\t\\t$(exp).each(function() {\\n\\t\\t\\t\\t\\tvar el = $(this);\\n\\t\\t\\t\\t\\tel.data(\\\"ui-resizable-alsoresize\\\", {\\n\\t\\t\\t\\t\\t\\twidth: parseInt(el.width(), 10), height: parseInt(el.height(), 10),\\n\\t\\t\\t\\t\\t\\tleft: parseInt(el.css(\\\"left\\\"), 10), top: parseInt(el.css(\\\"top\\\"), 10)\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t});\\n\\t\\t\\t};\\n\\n\\t\\tif (typeof(o.alsoResize) === \\\"object\\\" && !o.alsoResize.parentNode) {\\n\\t\\t\\tif (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }\\n\\t\\t\\telse { $.each(o.alsoResize, function (exp) { _store(exp); }); }\\n\\t\\t}else{\\n\\t\\t\\t_store(o.alsoResize);\\n\\t\\t}\\n\\t},\\n\\n\\tresize: function (event, ui) {\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tos = that.originalSize,\\n\\t\\t\\top = that.originalPosition,\\n\\t\\t\\tdelta = {\\n\\t\\t\\t\\theight: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,\\n\\t\\t\\t\\ttop: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0\\n\\t\\t\\t},\\n\\n\\t\\t\\t_alsoResize = function (exp, c) {\\n\\t\\t\\t\\t$(exp).each(function() {\\n\\t\\t\\t\\t\\tvar el = $(this), start = $(this).data(\\\"ui-resizable-alsoresize\\\"), style = {},\\n\\t\\t\\t\\t\\t\\tcss = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [\\\"width\\\", \\\"height\\\"] : [\\\"width\\\", \\\"height\\\", \\\"top\\\", \\\"left\\\"];\\n\\n\\t\\t\\t\\t\\t$.each(css, function (i, prop) {\\n\\t\\t\\t\\t\\t\\tvar sum = (start[prop]||0) + (delta[prop]||0);\\n\\t\\t\\t\\t\\t\\tif (sum && sum >= 0) {\\n\\t\\t\\t\\t\\t\\t\\tstyle[prop] = sum || null;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\tel.css(style);\\n\\t\\t\\t\\t});\\n\\t\\t\\t};\\n\\n\\t\\tif (typeof(o.alsoResize) === \\\"object\\\" && !o.alsoResize.nodeType) {\\n\\t\\t\\t$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });\\n\\t\\t}else{\\n\\t\\t\\t_alsoResize(o.alsoResize);\\n\\t\\t}\\n\\t},\\n\\n\\tstop: function () {\\n\\t\\t$(this).removeData(\\\"resizable-alsoresize\\\");\\n\\t}\\n});\\n\\n$.ui.plugin.add(\\\"resizable\\\", \\\"ghost\\\", {\\n\\n\\tstart: function() {\\n\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"), o = that.options, cs = that.size;\\n\\n\\t\\tthat.ghost = that.originalElement.clone();\\n\\t\\tthat.ghost\\n\\t\\t\\t.css({ opacity: 0.25, display: \\\"block\\\", position: \\\"relative\\\", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })\\n\\t\\t\\t.addClass(\\\"ui-resizable-ghost\\\")\\n\\t\\t\\t.addClass(typeof o.ghost === \\\"string\\\" ? o.ghost : \\\"\\\");\\n\\n\\t\\tthat.ghost.appendTo(that.helper);\\n\\n\\t},\\n\\n\\tresize: function(){\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\");\\n\\t\\tif (that.ghost) {\\n\\t\\t\\tthat.ghost.css({ position: \\\"relative\\\", height: that.size.height, width: that.size.width });\\n\\t\\t}\\n\\t},\\n\\n\\tstop: function() {\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\");\\n\\t\\tif (that.ghost && that.helper) {\\n\\t\\t\\tthat.helper.get(0).removeChild(that.ghost.get(0));\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n$.ui.plugin.add(\\\"resizable\\\", \\\"grid\\\", {\\n\\n\\tresize: function() {\\n\\t\\tvar that = $(this).data(\\\"ui-resizable\\\"),\\n\\t\\t\\to = that.options,\\n\\t\\t\\tcs = that.size,\\n\\t\\t\\tos = that.originalSize,\\n\\t\\t\\top = that.originalPosition,\\n\\t\\t\\ta = that.axis,\\n\\t\\t\\tgrid = typeof o.grid === \\\"number\\\" ? [o.grid, o.grid] : o.grid,\\n\\t\\t\\tgridX = (grid[0]||1),\\n\\t\\t\\tgridY = (grid[1]||1),\\n\\t\\t\\tox = Math.round((cs.width - os.width) / gridX) * gridX,\\n\\t\\t\\toy = Math.round((cs.height - os.height) / gridY) * gridY,\\n\\t\\t\\tnewWidth = os.width + ox,\\n\\t\\t\\tnewHeight = os.height + oy,\\n\\t\\t\\tisMaxWidth = o.maxWidth && (o.maxWidth < newWidth),\\n\\t\\t\\tisMaxHeight = o.maxHeight && (o.maxHeight < newHeight),\\n\\t\\t\\tisMinWidth = o.minWidth && (o.minWidth > newWidth),\\n\\t\\t\\tisMinHeight = o.minHeight && (o.minHeight > newHeight);\\n\\n\\t\\to.grid = grid;\\n\\n\\t\\tif (isMinWidth) {\\n\\t\\t\\tnewWidth = newWidth + gridX;\\n\\t\\t}\\n\\t\\tif (isMinHeight) {\\n\\t\\t\\tnewHeight = newHeight + gridY;\\n\\t\\t}\\n\\t\\tif (isMaxWidth) {\\n\\t\\t\\tnewWidth = newWidth - gridX;\\n\\t\\t}\\n\\t\\tif (isMaxHeight) {\\n\\t\\t\\tnewHeight = newHeight - gridY;\\n\\t\\t}\\n\\n\\t\\tif (/^(se|s|e)$/.test(a)) {\\n\\t\\t\\tthat.size.width = newWidth;\\n\\t\\t\\tthat.size.height = newHeight;\\n\\t\\t} else if (/^(ne)$/.test(a)) {\\n\\t\\t\\tthat.size.width = newWidth;\\n\\t\\t\\tthat.size.height = newHeight;\\n\\t\\t\\tthat.position.top = op.top - oy;\\n\\t\\t} else if (/^(sw)$/.test(a)) {\\n\\t\\t\\tthat.size.width = newWidth;\\n\\t\\t\\tthat.size.height = newHeight;\\n\\t\\t\\tthat.position.left = op.left - ox;\\n\\t\\t} else {\\n\\t\\t\\tthat.size.width = newWidth;\\n\\t\\t\\tthat.size.height = newHeight;\\n\\t\\t\\tthat.position.top = op.top - oy;\\n\\t\\t\\tthat.position.left = op.left - ox;\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.widget(\\\"ui.selectable\\\", $.ui.mouse, {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tappendTo: \\\"body\\\",\\n\\t\\tautoRefresh: true,\\n\\t\\tdistance: 0,\\n\\t\\tfilter: \\\"*\\\",\\n\\t\\ttolerance: \\\"touch\\\",\\n\\n\\t\\t// callbacks\\n\\t\\tselected: null,\\n\\t\\tselecting: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null,\\n\\t\\tunselected: null,\\n\\t\\tunselecting: null\\n\\t},\\n\\t_create: function() {\\n\\t\\tvar selectees,\\n\\t\\t\\tthat = this;\\n\\n\\t\\tthis.element.addClass(\\\"ui-selectable\\\");\\n\\n\\t\\tthis.dragged = false;\\n\\n\\t\\t// cache selectee children based on filter\\n\\t\\tthis.refresh = function() {\\n\\t\\t\\tselectees = $(that.options.filter, that.element[0]);\\n\\t\\t\\tselectees.addClass(\\\"ui-selectee\\\");\\n\\t\\t\\tselectees.each(function() {\\n\\t\\t\\t\\tvar $this = $(this),\\n\\t\\t\\t\\t\\tpos = $this.offset();\\n\\t\\t\\t\\t$.data(this, \\\"selectable-item\\\", {\\n\\t\\t\\t\\t\\telement: this,\\n\\t\\t\\t\\t\\t$element: $this,\\n\\t\\t\\t\\t\\tleft: pos.left,\\n\\t\\t\\t\\t\\ttop: pos.top,\\n\\t\\t\\t\\t\\tright: pos.left + $this.outerWidth(),\\n\\t\\t\\t\\t\\tbottom: pos.top + $this.outerHeight(),\\n\\t\\t\\t\\t\\tstartselected: false,\\n\\t\\t\\t\\t\\tselected: $this.hasClass(\\\"ui-selected\\\"),\\n\\t\\t\\t\\t\\tselecting: $this.hasClass(\\\"ui-selecting\\\"),\\n\\t\\t\\t\\t\\tunselecting: $this.hasClass(\\\"ui-unselecting\\\")\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t};\\n\\t\\tthis.refresh();\\n\\n\\t\\tthis.selectees = selectees.addClass(\\\"ui-selectee\\\");\\n\\n\\t\\tthis._mouseInit();\\n\\n\\t\\tthis.helper = $(\\\"<div class='ui-selectable-helper'></div>\\\");\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.selectees\\n\\t\\t\\t.removeClass(\\\"ui-selectee\\\")\\n\\t\\t\\t.removeData(\\\"selectable-item\\\");\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass(\\\"ui-selectable ui-selectable-disabled\\\");\\n\\t\\tthis._mouseDestroy();\\n\\t},\\n\\n\\t_mouseStart: function(event) {\\n\\t\\tvar that = this,\\n\\t\\t\\toptions = this.options;\\n\\n\\t\\tthis.opos = [event.pageX, event.pageY];\\n\\n\\t\\tif (this.options.disabled) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.selectees = $(options.filter, this.element[0]);\\n\\n\\t\\tthis._trigger(\\\"start\\\", event);\\n\\n\\t\\t$(options.appendTo).append(this.helper);\\n\\t\\t// position helper (lasso)\\n\\t\\tthis.helper.css({\\n\\t\\t\\t\\\"left\\\": event.pageX,\\n\\t\\t\\t\\\"top\\\": event.pageY,\\n\\t\\t\\t\\\"width\\\": 0,\\n\\t\\t\\t\\\"height\\\": 0\\n\\t\\t});\\n\\n\\t\\tif (options.autoRefresh) {\\n\\t\\t\\tthis.refresh();\\n\\t\\t}\\n\\n\\t\\tthis.selectees.filter(\\\".ui-selected\\\").each(function() {\\n\\t\\t\\tvar selectee = $.data(this, \\\"selectable-item\\\");\\n\\t\\t\\tselectee.startselected = true;\\n\\t\\t\\tif (!event.metaKey && !event.ctrlKey) {\\n\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-selected\\\");\\n\\t\\t\\t\\tselectee.selected = false;\\n\\t\\t\\t\\tselectee.$element.addClass(\\\"ui-unselecting\\\");\\n\\t\\t\\t\\tselectee.unselecting = true;\\n\\t\\t\\t\\t// selectable UNSELECTING callback\\n\\t\\t\\t\\tthat._trigger(\\\"unselecting\\\", event, {\\n\\t\\t\\t\\t\\tunselecting: selectee.element\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t$(event.target).parents().addBack().each(function() {\\n\\t\\t\\tvar doSelect,\\n\\t\\t\\t\\tselectee = $.data(this, \\\"selectable-item\\\");\\n\\t\\t\\tif (selectee) {\\n\\t\\t\\t\\tdoSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass(\\\"ui-selected\\\");\\n\\t\\t\\t\\tselectee.$element\\n\\t\\t\\t\\t\\t.removeClass(doSelect ? \\\"ui-unselecting\\\" : \\\"ui-selected\\\")\\n\\t\\t\\t\\t\\t.addClass(doSelect ? \\\"ui-selecting\\\" : \\\"ui-unselecting\\\");\\n\\t\\t\\t\\tselectee.unselecting = !doSelect;\\n\\t\\t\\t\\tselectee.selecting = doSelect;\\n\\t\\t\\t\\tselectee.selected = doSelect;\\n\\t\\t\\t\\t// selectable (UN)SELECTING callback\\n\\t\\t\\t\\tif (doSelect) {\\n\\t\\t\\t\\t\\tthat._trigger(\\\"selecting\\\", event, {\\n\\t\\t\\t\\t\\t\\tselecting: selectee.element\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthat._trigger(\\\"unselecting\\\", event, {\\n\\t\\t\\t\\t\\t\\tunselecting: selectee.element\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t},\\n\\n\\t_mouseDrag: function(event) {\\n\\n\\t\\tthis.dragged = true;\\n\\n\\t\\tif (this.options.disabled) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar tmp,\\n\\t\\t\\tthat = this,\\n\\t\\t\\toptions = this.options,\\n\\t\\t\\tx1 = this.opos[0],\\n\\t\\t\\ty1 = this.opos[1],\\n\\t\\t\\tx2 = event.pageX,\\n\\t\\t\\ty2 = event.pageY;\\n\\n\\t\\tif (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }\\n\\t\\tif (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }\\n\\t\\tthis.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});\\n\\n\\t\\tthis.selectees.each(function() {\\n\\t\\t\\tvar selectee = $.data(this, \\\"selectable-item\\\"),\\n\\t\\t\\t\\thit = false;\\n\\n\\t\\t\\t//prevent helper from being selected if appendTo: selectable\\n\\t\\t\\tif (!selectee || selectee.element === that.element[0]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (options.tolerance === \\\"touch\\\") {\\n\\t\\t\\t\\thit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );\\n\\t\\t\\t} else if (options.tolerance === \\\"fit\\\") {\\n\\t\\t\\t\\thit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (hit) {\\n\\t\\t\\t\\t// SELECT\\n\\t\\t\\t\\tif (selectee.selected) {\\n\\t\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-selected\\\");\\n\\t\\t\\t\\t\\tselectee.selected = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (selectee.unselecting) {\\n\\t\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-unselecting\\\");\\n\\t\\t\\t\\t\\tselectee.unselecting = false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!selectee.selecting) {\\n\\t\\t\\t\\t\\tselectee.$element.addClass(\\\"ui-selecting\\\");\\n\\t\\t\\t\\t\\tselectee.selecting = true;\\n\\t\\t\\t\\t\\t// selectable SELECTING callback\\n\\t\\t\\t\\t\\tthat._trigger(\\\"selecting\\\", event, {\\n\\t\\t\\t\\t\\t\\tselecting: selectee.element\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// UNSELECT\\n\\t\\t\\t\\tif (selectee.selecting) {\\n\\t\\t\\t\\t\\tif ((event.metaKey || event.ctrlKey) && selectee.startselected) {\\n\\t\\t\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-selecting\\\");\\n\\t\\t\\t\\t\\t\\tselectee.selecting = false;\\n\\t\\t\\t\\t\\t\\tselectee.$element.addClass(\\\"ui-selected\\\");\\n\\t\\t\\t\\t\\t\\tselectee.selected = true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-selecting\\\");\\n\\t\\t\\t\\t\\t\\tselectee.selecting = false;\\n\\t\\t\\t\\t\\t\\tif (selectee.startselected) {\\n\\t\\t\\t\\t\\t\\t\\tselectee.$element.addClass(\\\"ui-unselecting\\\");\\n\\t\\t\\t\\t\\t\\t\\tselectee.unselecting = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// selectable UNSELECTING callback\\n\\t\\t\\t\\t\\t\\tthat._trigger(\\\"unselecting\\\", event, {\\n\\t\\t\\t\\t\\t\\t\\tunselecting: selectee.element\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (selectee.selected) {\\n\\t\\t\\t\\t\\tif (!event.metaKey && !event.ctrlKey && !selectee.startselected) {\\n\\t\\t\\t\\t\\t\\tselectee.$element.removeClass(\\\"ui-selected\\\");\\n\\t\\t\\t\\t\\t\\tselectee.selected = false;\\n\\n\\t\\t\\t\\t\\t\\tselectee.$element.addClass(\\\"ui-unselecting\\\");\\n\\t\\t\\t\\t\\t\\tselectee.unselecting = true;\\n\\t\\t\\t\\t\\t\\t// selectable UNSELECTING callback\\n\\t\\t\\t\\t\\t\\tthat._trigger(\\\"unselecting\\\", event, {\\n\\t\\t\\t\\t\\t\\t\\tunselecting: selectee.element\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseStop: function(event) {\\n\\t\\tvar that = this;\\n\\n\\t\\tthis.dragged = false;\\n\\n\\t\\t$(\\\".ui-unselecting\\\", this.element[0]).each(function() {\\n\\t\\t\\tvar selectee = $.data(this, \\\"selectable-item\\\");\\n\\t\\t\\tselectee.$element.removeClass(\\\"ui-unselecting\\\");\\n\\t\\t\\tselectee.unselecting = false;\\n\\t\\t\\tselectee.startselected = false;\\n\\t\\t\\tthat._trigger(\\\"unselected\\\", event, {\\n\\t\\t\\t\\tunselected: selectee.element\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\t$(\\\".ui-selecting\\\", this.element[0]).each(function() {\\n\\t\\t\\tvar selectee = $.data(this, \\\"selectable-item\\\");\\n\\t\\t\\tselectee.$element.removeClass(\\\"ui-selecting\\\").addClass(\\\"ui-selected\\\");\\n\\t\\t\\tselectee.selecting = false;\\n\\t\\t\\tselectee.selected = true;\\n\\t\\t\\tselectee.startselected = true;\\n\\t\\t\\tthat._trigger(\\\"selected\\\", event, {\\n\\t\\t\\t\\tselected: selectee.element\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\tthis._trigger(\\\"stop\\\", event);\\n\\n\\t\\tthis.helper.remove();\\n\\n\\t\\treturn false;\\n\\t}\\n\\n});\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n/*jshint loopfunc: true */\\n\\nfunction isOverAxis( x, reference, size ) {\\n\\treturn ( x > reference ) && ( x < ( reference + size ) );\\n}\\n\\nfunction isFloating(item) {\\n\\treturn (/left|right/).test(item.css(\\\"float\\\")) || (/inline|table-cell/).test(item.css(\\\"display\\\"));\\n}\\n\\n$.widget(\\\"ui.sortable\\\", $.ui.mouse, {\\n\\tversion: \\\"1.10.3\\\",\\n\\twidgetEventPrefix: \\\"sort\\\",\\n\\tready: false,\\n\\toptions: {\\n\\t\\tappendTo: \\\"parent\\\",\\n\\t\\taxis: false,\\n\\t\\tconnectWith: false,\\n\\t\\tcontainment: false,\\n\\t\\tcursor: \\\"auto\\\",\\n\\t\\tcursorAt: false,\\n\\t\\tdropOnEmpty: true,\\n\\t\\tforcePlaceholderSize: false,\\n\\t\\tforceHelperSize: false,\\n\\t\\tgrid: false,\\n\\t\\thandle: false,\\n\\t\\thelper: \\\"original\\\",\\n\\t\\titems: \\\"> *\\\",\\n\\t\\topacity: false,\\n\\t\\tplaceholder: false,\\n\\t\\trevert: false,\\n\\t\\tscroll: true,\\n\\t\\tscrollSensitivity: 20,\\n\\t\\tscrollSpeed: 20,\\n\\t\\tscope: \\\"default\\\",\\n\\t\\ttolerance: \\\"intersect\\\",\\n\\t\\tzIndex: 1000,\\n\\n\\t\\t// callbacks\\n\\t\\tactivate: null,\\n\\t\\tbeforeStop: null,\\n\\t\\tchange: null,\\n\\t\\tdeactivate: null,\\n\\t\\tout: null,\\n\\t\\tover: null,\\n\\t\\treceive: null,\\n\\t\\tremove: null,\\n\\t\\tsort: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null,\\n\\t\\tupdate: null\\n\\t},\\n\\t_create: function() {\\n\\n\\t\\tvar o = this.options;\\n\\t\\tthis.containerCache = {};\\n\\t\\tthis.element.addClass(\\\"ui-sortable\\\");\\n\\n\\t\\t//Get the items\\n\\t\\tthis.refresh();\\n\\n\\t\\t//Let's determine if the items are being displayed horizontally\\n\\t\\tthis.floating = this.items.length ? o.axis === \\\"x\\\" || isFloating(this.items[0].item) : false;\\n\\n\\t\\t//Let's determine the parent's offset\\n\\t\\tthis.offset = this.element.offset();\\n\\n\\t\\t//Initialize mouse events for interaction\\n\\t\\tthis._mouseInit();\\n\\n\\t\\t//We're ready to go\\n\\t\\tthis.ready = true;\\n\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass(\\\"ui-sortable ui-sortable-disabled\\\");\\n\\t\\tthis._mouseDestroy();\\n\\n\\t\\tfor ( var i = this.items.length - 1; i >= 0; i-- ) {\\n\\t\\t\\tthis.items[i].item.removeData(this.widgetName + \\\"-item\\\");\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t_setOption: function(key, value){\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tthis.options[ key ] = value;\\n\\n\\t\\t\\tthis.widget().toggleClass( \\\"ui-sortable-disabled\\\", !!value );\\n\\t\\t} else {\\n\\t\\t\\t// Don't call widget base _setOption for disable as it adds ui-state-disabled class\\n\\t\\t\\t$.Widget.prototype._setOption.apply(this, arguments);\\n\\t\\t}\\n\\t},\\n\\n\\t_mouseCapture: function(event, overrideHandle) {\\n\\t\\tvar currentItem = null,\\n\\t\\t\\tvalidHandle = false,\\n\\t\\t\\tthat = this;\\n\\n\\t\\tif (this.reverting) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(this.options.disabled || this.options.type === \\\"static\\\") {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t//We have to refresh the items data once first\\n\\t\\tthis._refreshItems(event);\\n\\n\\t\\t//Find out if the clicked node (or one of its parents) is a actual item in this.items\\n\\t\\t$(event.target).parents().each(function() {\\n\\t\\t\\tif($.data(this, that.widgetName + \\\"-item\\\") === that) {\\n\\t\\t\\t\\tcurrentItem = $(this);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tif($.data(event.target, that.widgetName + \\\"-item\\\") === that) {\\n\\t\\t\\tcurrentItem = $(event.target);\\n\\t\\t}\\n\\n\\t\\tif(!currentItem) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif(this.options.handle && !overrideHandle) {\\n\\t\\t\\t$(this.options.handle, currentItem).find(\\\"*\\\").addBack().each(function() {\\n\\t\\t\\t\\tif(this === event.target) {\\n\\t\\t\\t\\t\\tvalidHandle = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tif(!validHandle) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.currentItem = currentItem;\\n\\t\\tthis._removeCurrentsFromItems();\\n\\t\\treturn true;\\n\\n\\t},\\n\\n\\t_mouseStart: function(event, overrideHandle, noActivation) {\\n\\n\\t\\tvar i, body,\\n\\t\\t\\to = this.options;\\n\\n\\t\\tthis.currentContainer = this;\\n\\n\\t\\t//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture\\n\\t\\tthis.refreshPositions();\\n\\n\\t\\t//Create and append the visible helper\\n\\t\\tthis.helper = this._createHelper(event);\\n\\n\\t\\t//Cache the helper size\\n\\t\\tthis._cacheHelperProportions();\\n\\n\\t\\t/*\\n\\t\\t * - Position generation -\\n\\t\\t * This block generates everything position related - it's the core of draggables.\\n\\t\\t */\\n\\n\\t\\t//Cache the margins of the original element\\n\\t\\tthis._cacheMargins();\\n\\n\\t\\t//Get the next scrolling parent\\n\\t\\tthis.scrollParent = this.helper.scrollParent();\\n\\n\\t\\t//The element's absolute position on the page minus margins\\n\\t\\tthis.offset = this.currentItem.offset();\\n\\t\\tthis.offset = {\\n\\t\\t\\ttop: this.offset.top - this.margins.top,\\n\\t\\t\\tleft: this.offset.left - this.margins.left\\n\\t\\t};\\n\\n\\t\\t$.extend(this.offset, {\\n\\t\\t\\tclick: { //Where the click happened, relative to the element\\n\\t\\t\\t\\tleft: event.pageX - this.offset.left,\\n\\t\\t\\t\\ttop: event.pageY - this.offset.top\\n\\t\\t\\t},\\n\\t\\t\\tparent: this._getParentOffset(),\\n\\t\\t\\trelative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper\\n\\t\\t});\\n\\n\\t\\t// Only after we got the offset, we can change the helper's position to absolute\\n\\t\\t// TODO: Still need to figure out a way to make relative sorting possible\\n\\t\\tthis.helper.css(\\\"position\\\", \\\"absolute\\\");\\n\\t\\tthis.cssPosition = this.helper.css(\\\"position\\\");\\n\\n\\t\\t//Generate the original position\\n\\t\\tthis.originalPosition = this._generatePosition(event);\\n\\t\\tthis.originalPageX = event.pageX;\\n\\t\\tthis.originalPageY = event.pageY;\\n\\n\\t\\t//Adjust the mouse offset relative to the helper if \\\"cursorAt\\\" is supplied\\n\\t\\t(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));\\n\\n\\t\\t//Cache the former DOM position\\n\\t\\tthis.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };\\n\\n\\t\\t//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way\\n\\t\\tif(this.helper[0] !== this.currentItem[0]) {\\n\\t\\t\\tthis.currentItem.hide();\\n\\t\\t}\\n\\n\\t\\t//Create the placeholder\\n\\t\\tthis._createPlaceholder();\\n\\n\\t\\t//Set a containment if given in the options\\n\\t\\tif(o.containment) {\\n\\t\\t\\tthis._setContainment();\\n\\t\\t}\\n\\n\\t\\tif( o.cursor && o.cursor !== \\\"auto\\\" ) { // cursor option\\n\\t\\t\\tbody = this.document.find( \\\"body\\\" );\\n\\n\\t\\t\\t// support: IE\\n\\t\\t\\tthis.storedCursor = body.css( \\\"cursor\\\" );\\n\\t\\t\\tbody.css( \\\"cursor\\\", o.cursor );\\n\\n\\t\\t\\tthis.storedStylesheet = $( \\\"<style>*{ cursor: \\\"+o.cursor+\\\" !important; }</style>\\\" ).appendTo( body );\\n\\t\\t}\\n\\n\\t\\tif(o.opacity) { // opacity option\\n\\t\\t\\tif (this.helper.css(\\\"opacity\\\")) {\\n\\t\\t\\t\\tthis._storedOpacity = this.helper.css(\\\"opacity\\\");\\n\\t\\t\\t}\\n\\t\\t\\tthis.helper.css(\\\"opacity\\\", o.opacity);\\n\\t\\t}\\n\\n\\t\\tif(o.zIndex) { // zIndex option\\n\\t\\t\\tif (this.helper.css(\\\"zIndex\\\")) {\\n\\t\\t\\t\\tthis._storedZIndex = this.helper.css(\\\"zIndex\\\");\\n\\t\\t\\t}\\n\\t\\t\\tthis.helper.css(\\\"zIndex\\\", o.zIndex);\\n\\t\\t}\\n\\n\\t\\t//Prepare scrolling\\n\\t\\tif(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \\\"HTML\\\") {\\n\\t\\t\\tthis.overflowOffset = this.scrollParent.offset();\\n\\t\\t}\\n\\n\\t\\t//Call callbacks\\n\\t\\tthis._trigger(\\\"start\\\", event, this._uiHash());\\n\\n\\t\\t//Recache the helper size\\n\\t\\tif(!this._preserveHelperProportions) {\\n\\t\\t\\tthis._cacheHelperProportions();\\n\\t\\t}\\n\\n\\n\\t\\t//Post \\\"activate\\\" events to possible containers\\n\\t\\tif( !noActivation ) {\\n\\t\\t\\tfor ( i = this.containers.length - 1; i >= 0; i-- ) {\\n\\t\\t\\t\\tthis.containers[ i ]._trigger( \\\"activate\\\", event, this._uiHash( this ) );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//Prepare possible droppables\\n\\t\\tif($.ui.ddmanager) {\\n\\t\\t\\t$.ui.ddmanager.current = this;\\n\\t\\t}\\n\\n\\t\\tif ($.ui.ddmanager && !o.dropBehaviour) {\\n\\t\\t\\t$.ui.ddmanager.prepareOffsets(this, event);\\n\\t\\t}\\n\\n\\t\\tthis.dragging = true;\\n\\n\\t\\tthis.helper.addClass(\\\"ui-sortable-helper\\\");\\n\\t\\tthis._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position\\n\\t\\treturn true;\\n\\n\\t},\\n\\n\\t_mouseDrag: function(event) {\\n\\t\\tvar i, item, itemElement, intersection,\\n\\t\\t\\to = this.options,\\n\\t\\t\\tscrolled = false;\\n\\n\\t\\t//Compute the helpers position\\n\\t\\tthis.position = this._generatePosition(event);\\n\\t\\tthis.positionAbs = this._convertPositionTo(\\\"absolute\\\");\\n\\n\\t\\tif (!this.lastPositionAbs) {\\n\\t\\t\\tthis.lastPositionAbs = this.positionAbs;\\n\\t\\t}\\n\\n\\t\\t//Do scrolling\\n\\t\\tif(this.options.scroll) {\\n\\t\\t\\tif(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== \\\"HTML\\\") {\\n\\n\\t\\t\\t\\tif((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;\\n\\t\\t\\t\\t} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tthis.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;\\n\\t\\t\\t\\t} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tthis.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);\\n\\t\\t\\t\\t} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);\\n\\t\\t\\t\\t} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {\\n\\t\\t\\t\\t\\tscrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {\\n\\t\\t\\t\\t$.ui.ddmanager.prepareOffsets(this, event);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//Regenerate the absolute position used for position checks\\n\\t\\tthis.positionAbs = this._convertPositionTo(\\\"absolute\\\");\\n\\n\\t\\t//Set the helper position\\n\\t\\tif(!this.options.axis || this.options.axis !== \\\"y\\\") {\\n\\t\\t\\tthis.helper[0].style.left = this.position.left+\\\"px\\\";\\n\\t\\t}\\n\\t\\tif(!this.options.axis || this.options.axis !== \\\"x\\\") {\\n\\t\\t\\tthis.helper[0].style.top = this.position.top+\\\"px\\\";\\n\\t\\t}\\n\\n\\t\\t//Rearrange\\n\\t\\tfor (i = this.items.length - 1; i >= 0; i--) {\\n\\n\\t\\t\\t//Cache variables and intersection, continue if no intersection\\n\\t\\t\\titem = this.items[i];\\n\\t\\t\\titemElement = item.item[0];\\n\\t\\t\\tintersection = this._intersectsWithPointer(item);\\n\\t\\t\\tif (!intersection) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Only put the placeholder inside the current Container, skip all\\n\\t\\t\\t// items form other containers. This works because when moving\\n\\t\\t\\t// an item from one container to another the\\n\\t\\t\\t// currentContainer is switched before the placeholder is moved.\\n\\t\\t\\t//\\n\\t\\t\\t// Without this moving items in \\\"sub-sortables\\\" can cause the placeholder to jitter\\n\\t\\t\\t// beetween the outer and inner container.\\n\\t\\t\\tif (item.instance !== this.currentContainer) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// cannot intersect with itself\\n\\t\\t\\t// no useless actions that have been done before\\n\\t\\t\\t// no action if the item moved is the parent of the item checked\\n\\t\\t\\tif (itemElement !== this.currentItem[0] &&\\n\\t\\t\\t\\tthis.placeholder[intersection === 1 ? \\\"next\\\" : \\\"prev\\\"]()[0] !== itemElement &&\\n\\t\\t\\t\\t!$.contains(this.placeholder[0], itemElement) &&\\n\\t\\t\\t\\t(this.options.type === \\\"semi-dynamic\\\" ? !$.contains(this.element[0], itemElement) : true)\\n\\t\\t\\t) {\\n\\n\\t\\t\\t\\tthis.direction = intersection === 1 ? \\\"down\\\" : \\\"up\\\";\\n\\n\\t\\t\\t\\tif (this.options.tolerance === \\\"pointer\\\" || this._intersectsWithSides(item)) {\\n\\t\\t\\t\\t\\tthis._rearrange(event, item);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._trigger(\\\"change\\\", event, this._uiHash());\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//Post events to containers\\n\\t\\tthis._contactContainers(event);\\n\\n\\t\\t//Interconnect with droppables\\n\\t\\tif($.ui.ddmanager) {\\n\\t\\t\\t$.ui.ddmanager.drag(this, event);\\n\\t\\t}\\n\\n\\t\\t//Call callbacks\\n\\t\\tthis._trigger(\\\"sort\\\", event, this._uiHash());\\n\\n\\t\\tthis.lastPositionAbs = this.positionAbs;\\n\\t\\treturn false;\\n\\n\\t},\\n\\n\\t_mouseStop: function(event, noPropagation) {\\n\\n\\t\\tif(!event) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t//If we are using droppables, inform the manager about the drop\\n\\t\\tif ($.ui.ddmanager && !this.options.dropBehaviour) {\\n\\t\\t\\t$.ui.ddmanager.drop(this, event);\\n\\t\\t}\\n\\n\\t\\tif(this.options.revert) {\\n\\t\\t\\tvar that = this,\\n\\t\\t\\t\\tcur = this.placeholder.offset(),\\n\\t\\t\\t\\taxis = this.options.axis,\\n\\t\\t\\t\\tanimation = {};\\n\\n\\t\\t\\tif ( !axis || axis === \\\"x\\\" ) {\\n\\t\\t\\t\\tanimation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);\\n\\t\\t\\t}\\n\\t\\t\\tif ( !axis || axis === \\\"y\\\" ) {\\n\\t\\t\\t\\tanimation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);\\n\\t\\t\\t}\\n\\t\\t\\tthis.reverting = true;\\n\\t\\t\\t$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {\\n\\t\\t\\t\\tthat._clear(event);\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis._clear(event, noPropagation);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\n\\t},\\n\\n\\tcancel: function() {\\n\\n\\t\\tif(this.dragging) {\\n\\n\\t\\t\\tthis._mouseUp({ target: null });\\n\\n\\t\\t\\tif(this.options.helper === \\\"original\\\") {\\n\\t\\t\\t\\tthis.currentItem.css(this._storedCSS).removeClass(\\\"ui-sortable-helper\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.currentItem.show();\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Post deactivating events to containers\\n\\t\\t\\tfor (var i = this.containers.length - 1; i >= 0; i--){\\n\\t\\t\\t\\tthis.containers[i]._trigger(\\\"deactivate\\\", null, this._uiHash(this));\\n\\t\\t\\t\\tif(this.containers[i].containerCache.over) {\\n\\t\\t\\t\\t\\tthis.containers[i]._trigger(\\\"out\\\", null, this._uiHash(this));\\n\\t\\t\\t\\t\\tthis.containers[i].containerCache.over = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif (this.placeholder) {\\n\\t\\t\\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\\n\\t\\t\\tif(this.placeholder[0].parentNode) {\\n\\t\\t\\t\\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\\n\\t\\t\\t}\\n\\t\\t\\tif(this.options.helper !== \\\"original\\\" && this.helper && this.helper[0].parentNode) {\\n\\t\\t\\t\\tthis.helper.remove();\\n\\t\\t\\t}\\n\\n\\t\\t\\t$.extend(this, {\\n\\t\\t\\t\\thelper: null,\\n\\t\\t\\t\\tdragging: false,\\n\\t\\t\\t\\treverting: false,\\n\\t\\t\\t\\t_noFinalSort: null\\n\\t\\t\\t});\\n\\n\\t\\t\\tif(this.domPosition.prev) {\\n\\t\\t\\t\\t$(this.domPosition.prev).after(this.currentItem);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$(this.domPosition.parent).prepend(this.currentItem);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t},\\n\\n\\tserialize: function(o) {\\n\\n\\t\\tvar items = this._getItemsAsjQuery(o && o.connected),\\n\\t\\t\\tstr = [];\\n\\t\\to = o || {};\\n\\n\\t\\t$(items).each(function() {\\n\\t\\t\\tvar res = ($(o.item || this).attr(o.attribute || \\\"id\\\") || \\\"\\\").match(o.expression || (/(.+)[\\\\-=_](.+)/));\\n\\t\\t\\tif (res) {\\n\\t\\t\\t\\tstr.push((o.key || res[1]+\\\"[]\\\")+\\\"=\\\"+(o.key && o.expression ? res[1] : res[2]));\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tif(!str.length && o.key) {\\n\\t\\t\\tstr.push(o.key + \\\"=\\\");\\n\\t\\t}\\n\\n\\t\\treturn str.join(\\\"&\\\");\\n\\n\\t},\\n\\n\\ttoArray: function(o) {\\n\\n\\t\\tvar items = this._getItemsAsjQuery(o && o.connected),\\n\\t\\t\\tret = [];\\n\\n\\t\\to = o || {};\\n\\n\\t\\titems.each(function() { ret.push($(o.item || this).attr(o.attribute || \\\"id\\\") || \\\"\\\"); });\\n\\t\\treturn ret;\\n\\n\\t},\\n\\n\\t/* Be careful with the following core functions */\\n\\t_intersectsWith: function(item) {\\n\\n\\t\\tvar x1 = this.positionAbs.left,\\n\\t\\t\\tx2 = x1 + this.helperProportions.width,\\n\\t\\t\\ty1 = this.positionAbs.top,\\n\\t\\t\\ty2 = y1 + this.helperProportions.height,\\n\\t\\t\\tl = item.left,\\n\\t\\t\\tr = l + item.width,\\n\\t\\t\\tt = item.top,\\n\\t\\t\\tb = t + item.height,\\n\\t\\t\\tdyClick = this.offset.click.top,\\n\\t\\t\\tdxClick = this.offset.click.left,\\n\\t\\t\\tisOverElementHeight = ( this.options.axis === \\\"x\\\" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),\\n\\t\\t\\tisOverElementWidth = ( this.options.axis === \\\"y\\\" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),\\n\\t\\t\\tisOverElement = isOverElementHeight && isOverElementWidth;\\n\\n\\t\\tif ( this.options.tolerance === \\\"pointer\\\" ||\\n\\t\\t\\tthis.options.forcePointerForContainers ||\\n\\t\\t\\t(this.options.tolerance !== \\\"pointer\\\" && this.helperProportions[this.floating ? \\\"width\\\" : \\\"height\\\"] > item[this.floating ? \\\"width\\\" : \\\"height\\\"])\\n\\t\\t) {\\n\\t\\t\\treturn isOverElement;\\n\\t\\t} else {\\n\\n\\t\\t\\treturn (l < x1 + (this.helperProportions.width / 2) && // Right Half\\n\\t\\t\\t\\tx2 - (this.helperProportions.width / 2) < r && // Left Half\\n\\t\\t\\t\\tt < y1 + (this.helperProportions.height / 2) && // Bottom Half\\n\\t\\t\\t\\ty2 - (this.helperProportions.height / 2) < b ); // Top Half\\n\\n\\t\\t}\\n\\t},\\n\\n\\t_intersectsWithPointer: function(item) {\\n\\n\\t\\tvar isOverElementHeight = (this.options.axis === \\\"x\\\") || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),\\n\\t\\t\\tisOverElementWidth = (this.options.axis === \\\"y\\\") || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),\\n\\t\\t\\tisOverElement = isOverElementHeight && isOverElementWidth,\\n\\t\\t\\tverticalDirection = this._getDragVerticalDirection(),\\n\\t\\t\\thorizontalDirection = this._getDragHorizontalDirection();\\n\\n\\t\\tif (!isOverElement) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\treturn this.floating ?\\n\\t\\t\\t( ((horizontalDirection && horizontalDirection === \\\"right\\\") || verticalDirection === \\\"down\\\") ? 2 : 1 )\\n\\t\\t\\t: ( verticalDirection && (verticalDirection === \\\"down\\\" ? 2 : 1) );\\n\\n\\t},\\n\\n\\t_intersectsWithSides: function(item) {\\n\\n\\t\\tvar isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),\\n\\t\\t\\tisOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),\\n\\t\\t\\tverticalDirection = this._getDragVerticalDirection(),\\n\\t\\t\\thorizontalDirection = this._getDragHorizontalDirection();\\n\\n\\t\\tif (this.floating && horizontalDirection) {\\n\\t\\t\\treturn ((horizontalDirection === \\\"right\\\" && isOverRightHalf) || (horizontalDirection === \\\"left\\\" && !isOverRightHalf));\\n\\t\\t} else {\\n\\t\\t\\treturn verticalDirection && ((verticalDirection === \\\"down\\\" && isOverBottomHalf) || (verticalDirection === \\\"up\\\" && !isOverBottomHalf));\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_getDragVerticalDirection: function() {\\n\\t\\tvar delta = this.positionAbs.top - this.lastPositionAbs.top;\\n\\t\\treturn delta !== 0 && (delta > 0 ? \\\"down\\\" : \\\"up\\\");\\n\\t},\\n\\n\\t_getDragHorizontalDirection: function() {\\n\\t\\tvar delta = this.positionAbs.left - this.lastPositionAbs.left;\\n\\t\\treturn delta !== 0 && (delta > 0 ? \\\"right\\\" : \\\"left\\\");\\n\\t},\\n\\n\\trefresh: function(event) {\\n\\t\\tthis._refreshItems(event);\\n\\t\\tthis.refreshPositions();\\n\\t\\treturn this;\\n\\t},\\n\\n\\t_connectWith: function() {\\n\\t\\tvar options = this.options;\\n\\t\\treturn options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;\\n\\t},\\n\\n\\t_getItemsAsjQuery: function(connected) {\\n\\n\\t\\tvar i, j, cur, inst,\\n\\t\\t\\titems = [],\\n\\t\\t\\tqueries = [],\\n\\t\\t\\tconnectWith = this._connectWith();\\n\\n\\t\\tif(connectWith && connected) {\\n\\t\\t\\tfor (i = connectWith.length - 1; i >= 0; i--){\\n\\t\\t\\t\\tcur = $(connectWith[i]);\\n\\t\\t\\t\\tfor ( j = cur.length - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tinst = $.data(cur[j], this.widgetFullName);\\n\\t\\t\\t\\t\\tif(inst && inst !== this && !inst.options.disabled) {\\n\\t\\t\\t\\t\\t\\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(\\\".ui-sortable-helper\\\").not(\\\".ui-sortable-placeholder\\\"), inst]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tqueries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(\\\".ui-sortable-helper\\\").not(\\\".ui-sortable-placeholder\\\"), this]);\\n\\n\\t\\tfor (i = queries.length - 1; i >= 0; i--){\\n\\t\\t\\tqueries[i][0].each(function() {\\n\\t\\t\\t\\titems.push(this);\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\treturn $(items);\\n\\n\\t},\\n\\n\\t_removeCurrentsFromItems: function() {\\n\\n\\t\\tvar list = this.currentItem.find(\\\":data(\\\" + this.widgetName + \\\"-item)\\\");\\n\\n\\t\\tthis.items = $.grep(this.items, function (item) {\\n\\t\\t\\tfor (var j=0; j < list.length; j++) {\\n\\t\\t\\t\\tif(list[j] === item.item[0]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t});\\n\\n\\t},\\n\\n\\t_refreshItems: function(event) {\\n\\n\\t\\tthis.items = [];\\n\\t\\tthis.containers = [this];\\n\\n\\t\\tvar i, j, cur, inst, targetData, _queries, item, queriesLength,\\n\\t\\t\\titems = this.items,\\n\\t\\t\\tqueries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],\\n\\t\\t\\tconnectWith = this._connectWith();\\n\\n\\t\\tif(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down\\n\\t\\t\\tfor (i = connectWith.length - 1; i >= 0; i--){\\n\\t\\t\\t\\tcur = $(connectWith[i]);\\n\\t\\t\\t\\tfor (j = cur.length - 1; j >= 0; j--){\\n\\t\\t\\t\\t\\tinst = $.data(cur[j], this.widgetFullName);\\n\\t\\t\\t\\t\\tif(inst && inst !== this && !inst.options.disabled) {\\n\\t\\t\\t\\t\\t\\tqueries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);\\n\\t\\t\\t\\t\\t\\tthis.containers.push(inst);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (i = queries.length - 1; i >= 0; i--) {\\n\\t\\t\\ttargetData = queries[i][1];\\n\\t\\t\\t_queries = queries[i][0];\\n\\n\\t\\t\\tfor (j=0, queriesLength = _queries.length; j < queriesLength; j++) {\\n\\t\\t\\t\\titem = $(_queries[j]);\\n\\n\\t\\t\\t\\titem.data(this.widgetName + \\\"-item\\\", targetData); // Data for target checking (mouse manager)\\n\\n\\t\\t\\t\\titems.push({\\n\\t\\t\\t\\t\\titem: item,\\n\\t\\t\\t\\t\\tinstance: targetData,\\n\\t\\t\\t\\t\\twidth: 0, height: 0,\\n\\t\\t\\t\\t\\tleft: 0, top: 0\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t},\\n\\n\\trefreshPositions: function(fast) {\\n\\n\\t\\t//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change\\n\\t\\tif(this.offsetParent && this.helper) {\\n\\t\\t\\tthis.offset.parent = this._getParentOffset();\\n\\t\\t}\\n\\n\\t\\tvar i, item, t, p;\\n\\n\\t\\tfor (i = this.items.length - 1; i >= 0; i--){\\n\\t\\t\\titem = this.items[i];\\n\\n\\t\\t\\t//We ignore calculating positions of all connected containers when we're not over them\\n\\t\\t\\tif(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tt = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;\\n\\n\\t\\t\\tif (!fast) {\\n\\t\\t\\t\\titem.width = t.outerWidth();\\n\\t\\t\\t\\titem.height = t.outerHeight();\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = t.offset();\\n\\t\\t\\titem.left = p.left;\\n\\t\\t\\titem.top = p.top;\\n\\t\\t}\\n\\n\\t\\tif(this.options.custom && this.options.custom.refreshContainers) {\\n\\t\\t\\tthis.options.custom.refreshContainers.call(this);\\n\\t\\t} else {\\n\\t\\t\\tfor (i = this.containers.length - 1; i >= 0; i--){\\n\\t\\t\\t\\tp = this.containers[i].element.offset();\\n\\t\\t\\t\\tthis.containers[i].containerCache.left = p.left;\\n\\t\\t\\t\\tthis.containers[i].containerCache.top = p.top;\\n\\t\\t\\t\\tthis.containers[i].containerCache.width\\t= this.containers[i].element.outerWidth();\\n\\t\\t\\t\\tthis.containers[i].containerCache.height = this.containers[i].element.outerHeight();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t},\\n\\n\\t_createPlaceholder: function(that) {\\n\\t\\tthat = that || this;\\n\\t\\tvar className,\\n\\t\\t\\to = that.options;\\n\\n\\t\\tif(!o.placeholder || o.placeholder.constructor === String) {\\n\\t\\t\\tclassName = o.placeholder;\\n\\t\\t\\to.placeholder = {\\n\\t\\t\\t\\telement: function() {\\n\\n\\t\\t\\t\\t\\tvar nodeName = that.currentItem[0].nodeName.toLowerCase(),\\n\\t\\t\\t\\t\\t\\telement = $( \\\"<\\\" + nodeName + \\\">\\\", that.document[0] )\\n\\t\\t\\t\\t\\t\\t\\t.addClass(className || that.currentItem[0].className+\\\" ui-sortable-placeholder\\\")\\n\\t\\t\\t\\t\\t\\t\\t.removeClass(\\\"ui-sortable-helper\\\");\\n\\n\\t\\t\\t\\t\\tif ( nodeName === \\\"tr\\\" ) {\\n\\t\\t\\t\\t\\t\\tthat.currentItem.children().each(function() {\\n\\t\\t\\t\\t\\t\\t\\t$( \\\"<td>&#160;</td>\\\", that.document[0] )\\n\\t\\t\\t\\t\\t\\t\\t\\t.attr( \\\"colspan\\\", $( this ).attr( \\\"colspan\\\" ) || 1 )\\n\\t\\t\\t\\t\\t\\t\\t\\t.appendTo( element );\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t} else if ( nodeName === \\\"img\\\" ) {\\n\\t\\t\\t\\t\\t\\telement.attr( \\\"src\\\", that.currentItem.attr( \\\"src\\\" ) );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( !className ) {\\n\\t\\t\\t\\t\\t\\telement.css( \\\"visibility\\\", \\\"hidden\\\" );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn element;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tupdate: function(container, p) {\\n\\n\\t\\t\\t\\t\\t// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that\\n\\t\\t\\t\\t\\t// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified\\n\\t\\t\\t\\t\\tif(className && !o.forcePlaceholderSize) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item\\n\\t\\t\\t\\t\\tif(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(\\\"paddingTop\\\")||0, 10) - parseInt(that.currentItem.css(\\\"paddingBottom\\\")||0, 10)); }\\n\\t\\t\\t\\t\\tif(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(\\\"paddingLeft\\\")||0, 10) - parseInt(that.currentItem.css(\\\"paddingRight\\\")||0, 10)); }\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\t//Create the placeholder\\n\\t\\tthat.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));\\n\\n\\t\\t//Append it after the actual current item\\n\\t\\tthat.currentItem.after(that.placeholder);\\n\\n\\t\\t//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)\\n\\t\\to.placeholder.update(that, that.placeholder);\\n\\n\\t},\\n\\n\\t_contactContainers: function(event) {\\n\\t\\tvar i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating,\\n\\t\\t\\tinnermostContainer = null,\\n\\t\\t\\tinnermostIndex = null;\\n\\n\\t\\t// get innermost container that intersects with item\\n\\t\\tfor (i = this.containers.length - 1; i >= 0; i--) {\\n\\n\\t\\t\\t// never consider a container that's located within the item itself\\n\\t\\t\\tif($.contains(this.currentItem[0], this.containers[i].element[0])) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(this._intersectsWith(this.containers[i].containerCache)) {\\n\\n\\t\\t\\t\\t// if we've already found a container and it's more \\\"inner\\\" than this, then continue\\n\\t\\t\\t\\tif(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinnermostContainer = this.containers[i];\\n\\t\\t\\t\\tinnermostIndex = i;\\n\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// container doesn't intersect. trigger \\\"out\\\" event if necessary\\n\\t\\t\\t\\tif(this.containers[i].containerCache.over) {\\n\\t\\t\\t\\t\\tthis.containers[i]._trigger(\\\"out\\\", event, this._uiHash(this));\\n\\t\\t\\t\\t\\tthis.containers[i].containerCache.over = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// if no intersecting containers found, return\\n\\t\\tif(!innermostContainer) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// move the item into the container if it's not there already\\n\\t\\tif(this.containers.length === 1) {\\n\\t\\t\\tif (!this.containers[innermostIndex].containerCache.over) {\\n\\t\\t\\t\\tthis.containers[innermostIndex]._trigger(\\\"over\\\", event, this._uiHash(this));\\n\\t\\t\\t\\tthis.containers[innermostIndex].containerCache.over = 1;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\n\\t\\t\\t//When entering a new container, we will find the item with the least distance and append our item near it\\n\\t\\t\\tdist = 10000;\\n\\t\\t\\titemWithLeastDistance = null;\\n\\t\\t\\tfloating = innermostContainer.floating || isFloating(this.currentItem);\\n\\t\\t\\tposProperty = floating ? \\\"left\\\" : \\\"top\\\";\\n\\t\\t\\tsizeProperty = floating ? \\\"width\\\" : \\\"height\\\";\\n\\t\\t\\tbase = this.positionAbs[posProperty] + this.offset.click[posProperty];\\n\\t\\t\\tfor (j = this.items.length - 1; j >= 0; j--) {\\n\\t\\t\\t\\tif(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(this.items[j].item[0] === this.currentItem[0]) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcur = this.items[j].item.offset()[posProperty];\\n\\t\\t\\t\\tnearBottom = false;\\n\\t\\t\\t\\tif(Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)){\\n\\t\\t\\t\\t\\tnearBottom = true;\\n\\t\\t\\t\\t\\tcur += this.items[j][sizeProperty];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(Math.abs(cur - base) < dist) {\\n\\t\\t\\t\\t\\tdist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];\\n\\t\\t\\t\\t\\tthis.direction = nearBottom ? \\\"up\\\": \\\"down\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Check if dropOnEmpty is enabled\\n\\t\\t\\tif(!itemWithLeastDistance && !this.options.dropOnEmpty) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(this.currentContainer === this.containers[innermostIndex]) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\titemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);\\n\\t\\t\\tthis._trigger(\\\"change\\\", event, this._uiHash());\\n\\t\\t\\tthis.containers[innermostIndex]._trigger(\\\"change\\\", event, this._uiHash(this));\\n\\t\\t\\tthis.currentContainer = this.containers[innermostIndex];\\n\\n\\t\\t\\t//Update the placeholder\\n\\t\\t\\tthis.options.placeholder.update(this.currentContainer, this.placeholder);\\n\\n\\t\\t\\tthis.containers[innermostIndex]._trigger(\\\"over\\\", event, this._uiHash(this));\\n\\t\\t\\tthis.containers[innermostIndex].containerCache.over = 1;\\n\\t\\t}\\n\\n\\n\\t},\\n\\n\\t_createHelper: function(event) {\\n\\n\\t\\tvar o = this.options,\\n\\t\\t\\thelper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === \\\"clone\\\" ? this.currentItem.clone() : this.currentItem);\\n\\n\\t\\t//Add the helper to the DOM if that didn't happen already\\n\\t\\tif(!helper.parents(\\\"body\\\").length) {\\n\\t\\t\\t$(o.appendTo !== \\\"parent\\\" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);\\n\\t\\t}\\n\\n\\t\\tif(helper[0] === this.currentItem[0]) {\\n\\t\\t\\tthis._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(\\\"position\\\"), top: this.currentItem.css(\\\"top\\\"), left: this.currentItem.css(\\\"left\\\") };\\n\\t\\t}\\n\\n\\t\\tif(!helper[0].style.width || o.forceHelperSize) {\\n\\t\\t\\thelper.width(this.currentItem.width());\\n\\t\\t}\\n\\t\\tif(!helper[0].style.height || o.forceHelperSize) {\\n\\t\\t\\thelper.height(this.currentItem.height());\\n\\t\\t}\\n\\n\\t\\treturn helper;\\n\\n\\t},\\n\\n\\t_adjustOffsetFromHelper: function(obj) {\\n\\t\\tif (typeof obj === \\\"string\\\") {\\n\\t\\t\\tobj = obj.split(\\\" \\\");\\n\\t\\t}\\n\\t\\tif ($.isArray(obj)) {\\n\\t\\t\\tobj = {left: +obj[0], top: +obj[1] || 0};\\n\\t\\t}\\n\\t\\tif (\\\"left\\\" in obj) {\\n\\t\\t\\tthis.offset.click.left = obj.left + this.margins.left;\\n\\t\\t}\\n\\t\\tif (\\\"right\\\" in obj) {\\n\\t\\t\\tthis.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;\\n\\t\\t}\\n\\t\\tif (\\\"top\\\" in obj) {\\n\\t\\t\\tthis.offset.click.top = obj.top + this.margins.top;\\n\\t\\t}\\n\\t\\tif (\\\"bottom\\\" in obj) {\\n\\t\\t\\tthis.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;\\n\\t\\t}\\n\\t},\\n\\n\\t_getParentOffset: function() {\\n\\n\\n\\t\\t//Get the offsetParent and cache its position\\n\\t\\tthis.offsetParent = this.helper.offsetParent();\\n\\t\\tvar po = this.offsetParent.offset();\\n\\n\\t\\t// This is a special case where we need to modify a offset calculated on start, since the following happened:\\n\\t\\t// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent\\n\\t\\t// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that\\n\\t\\t//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag\\n\\t\\tif(this.cssPosition === \\\"absolute\\\" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {\\n\\t\\t\\tpo.left += this.scrollParent.scrollLeft();\\n\\t\\t\\tpo.top += this.scrollParent.scrollTop();\\n\\t\\t}\\n\\n\\t\\t// This needs to be actually done for all browsers, since pageX/pageY includes this information\\n\\t\\t// with an ugly IE fix\\n\\t\\tif( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === \\\"html\\\" && $.ui.ie)) {\\n\\t\\t\\tpo = { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: po.top + (parseInt(this.offsetParent.css(\\\"borderTopWidth\\\"),10) || 0),\\n\\t\\t\\tleft: po.left + (parseInt(this.offsetParent.css(\\\"borderLeftWidth\\\"),10) || 0)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_getRelativeOffset: function() {\\n\\n\\t\\tif(this.cssPosition === \\\"relative\\\") {\\n\\t\\t\\tvar p = this.currentItem.position();\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttop: p.top - (parseInt(this.helper.css(\\\"top\\\"),10) || 0) + this.scrollParent.scrollTop(),\\n\\t\\t\\t\\tleft: p.left - (parseInt(this.helper.css(\\\"left\\\"),10) || 0) + this.scrollParent.scrollLeft()\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\treturn { top: 0, left: 0 };\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_cacheMargins: function() {\\n\\t\\tthis.margins = {\\n\\t\\t\\tleft: (parseInt(this.currentItem.css(\\\"marginLeft\\\"),10) || 0),\\n\\t\\t\\ttop: (parseInt(this.currentItem.css(\\\"marginTop\\\"),10) || 0)\\n\\t\\t};\\n\\t},\\n\\n\\t_cacheHelperProportions: function() {\\n\\t\\tthis.helperProportions = {\\n\\t\\t\\twidth: this.helper.outerWidth(),\\n\\t\\t\\theight: this.helper.outerHeight()\\n\\t\\t};\\n\\t},\\n\\n\\t_setContainment: function() {\\n\\n\\t\\tvar ce, co, over,\\n\\t\\t\\to = this.options;\\n\\t\\tif(o.containment === \\\"parent\\\") {\\n\\t\\t\\to.containment = this.helper[0].parentNode;\\n\\t\\t}\\n\\t\\tif(o.containment === \\\"document\\\" || o.containment === \\\"window\\\") {\\n\\t\\t\\tthis.containment = [\\n\\t\\t\\t\\t0 - this.offset.relative.left - this.offset.parent.left,\\n\\t\\t\\t\\t0 - this.offset.relative.top - this.offset.parent.top,\\n\\t\\t\\t\\t$(o.containment === \\\"document\\\" ? document : window).width() - this.helperProportions.width - this.margins.left,\\n\\t\\t\\t\\t($(o.containment === \\\"document\\\" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t\\tif(!(/^(document|window|parent)$/).test(o.containment)) {\\n\\t\\t\\tce = $(o.containment)[0];\\n\\t\\t\\tco = $(o.containment).offset();\\n\\t\\t\\tover = ($(ce).css(\\\"overflow\\\") !== \\\"hidden\\\");\\n\\n\\t\\t\\tthis.containment = [\\n\\t\\t\\t\\tco.left + (parseInt($(ce).css(\\\"borderLeftWidth\\\"),10) || 0) + (parseInt($(ce).css(\\\"paddingLeft\\\"),10) || 0) - this.margins.left,\\n\\t\\t\\t\\tco.top + (parseInt($(ce).css(\\\"borderTopWidth\\\"),10) || 0) + (parseInt($(ce).css(\\\"paddingTop\\\"),10) || 0) - this.margins.top,\\n\\t\\t\\t\\tco.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(\\\"borderLeftWidth\\\"),10) || 0) - (parseInt($(ce).css(\\\"paddingRight\\\"),10) || 0) - this.helperProportions.width - this.margins.left,\\n\\t\\t\\t\\tco.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(\\\"borderTopWidth\\\"),10) || 0) - (parseInt($(ce).css(\\\"paddingBottom\\\"),10) || 0) - this.helperProportions.height - this.margins.top\\n\\t\\t\\t];\\n\\t\\t}\\n\\n\\t},\\n\\n\\t_convertPositionTo: function(d, pos) {\\n\\n\\t\\tif(!pos) {\\n\\t\\t\\tpos = this.position;\\n\\t\\t}\\n\\t\\tvar mod = d === \\\"absolute\\\" ? 1 : -1,\\n\\t\\t\\tscroll = this.cssPosition === \\\"absolute\\\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,\\n\\t\\t\\tscrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: (\\n\\t\\t\\t\\tpos.top\\t+\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.relative.top * mod +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.top * mod -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)\\n\\t\\t\\t),\\n\\t\\t\\tleft: (\\n\\t\\t\\t\\tpos.left +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.relative.left * mod +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.left * mod\\t-\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)\\n\\t\\t\\t)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_generatePosition: function(event) {\\n\\n\\t\\tvar top, left,\\n\\t\\t\\to = this.options,\\n\\t\\t\\tpageX = event.pageX,\\n\\t\\t\\tpageY = event.pageY,\\n\\t\\t\\tscroll = this.cssPosition === \\\"absolute\\\" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);\\n\\n\\t\\t// This is another very weird special case that only happens for relative elements:\\n\\t\\t// 1. If the css position is relative\\n\\t\\t// 2. and the scroll parent is the document or similar to the offset parent\\n\\t\\t// we have to refresh the relative offset during the scroll so there are no jumps\\n\\t\\tif(this.cssPosition === \\\"relative\\\" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {\\n\\t\\t\\tthis.offset.relative = this._getRelativeOffset();\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * - Position constraining -\\n\\t\\t * Constrain the position to a mix of grid, containment.\\n\\t\\t */\\n\\n\\t\\tif(this.originalPosition) { //If we are not dragging yet, we won't check for options\\n\\n\\t\\t\\tif(this.containment) {\\n\\t\\t\\t\\tif(event.pageX - this.offset.click.left < this.containment[0]) {\\n\\t\\t\\t\\t\\tpageX = this.containment[0] + this.offset.click.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageY - this.offset.click.top < this.containment[1]) {\\n\\t\\t\\t\\t\\tpageY = this.containment[1] + this.offset.click.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageX - this.offset.click.left > this.containment[2]) {\\n\\t\\t\\t\\t\\tpageX = this.containment[2] + this.offset.click.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(event.pageY - this.offset.click.top > this.containment[3]) {\\n\\t\\t\\t\\t\\tpageY = this.containment[3] + this.offset.click.top;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(o.grid) {\\n\\t\\t\\t\\ttop = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];\\n\\t\\t\\t\\tpageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;\\n\\n\\t\\t\\t\\tleft = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];\\n\\t\\t\\t\\tpageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\ttop: (\\n\\t\\t\\t\\tpageY -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.click.top -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Click offset (relative to the element)\\n\\t\\t\\t\\tthis.offset.relative.top\\t-\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.top +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))\\n\\t\\t\\t),\\n\\t\\t\\tleft: (\\n\\t\\t\\t\\tpageX -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The absolute mouse position\\n\\t\\t\\t\\tthis.offset.click.left -\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Click offset (relative to the element)\\n\\t\\t\\t\\tthis.offset.relative.left\\t-\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Only for relative positioned nodes: Relative offset from element to offset parent\\n\\t\\t\\t\\tthis.offset.parent.left +\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// The offsetParent's offset without borders (offset + border)\\n\\t\\t\\t\\t( ( this.cssPosition === \\\"fixed\\\" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))\\n\\t\\t\\t)\\n\\t\\t};\\n\\n\\t},\\n\\n\\t_rearrange: function(event, i, a, hardRefresh) {\\n\\n\\t\\ta ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === \\\"down\\\" ? i.item[0] : i.item[0].nextSibling));\\n\\n\\t\\t//Various things done here to improve the performance:\\n\\t\\t// 1. we create a setTimeout, that calls refreshPositions\\n\\t\\t// 2. on the instance, we have a counter variable, that get's higher after every append\\n\\t\\t// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same\\n\\t\\t// 4. this lets only the last addition to the timeout stack through\\n\\t\\tthis.counter = this.counter ? ++this.counter : 1;\\n\\t\\tvar counter = this.counter;\\n\\n\\t\\tthis._delay(function() {\\n\\t\\t\\tif(counter === this.counter) {\\n\\t\\t\\t\\tthis.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t},\\n\\n\\t_clear: function(event, noPropagation) {\\n\\n\\t\\tthis.reverting = false;\\n\\t\\t// We delay all events that have to be triggered to after the point where the placeholder has been removed and\\n\\t\\t// everything else normalized again\\n\\t\\tvar i,\\n\\t\\t\\tdelayedTriggers = [];\\n\\n\\t\\t// We first have to update the dom position of the actual currentItem\\n\\t\\t// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)\\n\\t\\tif(!this._noFinalSort && this.currentItem.parent().length) {\\n\\t\\t\\tthis.placeholder.before(this.currentItem);\\n\\t\\t}\\n\\t\\tthis._noFinalSort = null;\\n\\n\\t\\tif(this.helper[0] === this.currentItem[0]) {\\n\\t\\t\\tfor(i in this._storedCSS) {\\n\\t\\t\\t\\tif(this._storedCSS[i] === \\\"auto\\\" || this._storedCSS[i] === \\\"static\\\") {\\n\\t\\t\\t\\t\\tthis._storedCSS[i] = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis.currentItem.css(this._storedCSS).removeClass(\\\"ui-sortable-helper\\\");\\n\\t\\t} else {\\n\\t\\t\\tthis.currentItem.show();\\n\\t\\t}\\n\\n\\t\\tif(this.fromOutside && !noPropagation) {\\n\\t\\t\\tdelayedTriggers.push(function(event) { this._trigger(\\\"receive\\\", event, this._uiHash(this.fromOutside)); });\\n\\t\\t}\\n\\t\\tif((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(\\\".ui-sortable-helper\\\")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {\\n\\t\\t\\tdelayedTriggers.push(function(event) { this._trigger(\\\"update\\\", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed\\n\\t\\t}\\n\\n\\t\\t// Check if the items Container has Changed and trigger appropriate\\n\\t\\t// events.\\n\\t\\tif (this !== this.currentContainer) {\\n\\t\\t\\tif(!noPropagation) {\\n\\t\\t\\t\\tdelayedTriggers.push(function(event) { this._trigger(\\\"remove\\\", event, this._uiHash()); });\\n\\t\\t\\t\\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\\\"receive\\\", event, this._uiHash(this)); };  }).call(this, this.currentContainer));\\n\\t\\t\\t\\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\\\"update\\\", event, this._uiHash(this));  }; }).call(this, this.currentContainer));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\t//Post events to containers\\n\\t\\tfor (i = this.containers.length - 1; i >= 0; i--){\\n\\t\\t\\tif(!noPropagation) {\\n\\t\\t\\t\\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\\\"deactivate\\\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\\n\\t\\t\\t}\\n\\t\\t\\tif(this.containers[i].containerCache.over) {\\n\\t\\t\\t\\tdelayedTriggers.push((function(c) { return function(event) { c._trigger(\\\"out\\\", event, this._uiHash(this)); };  }).call(this, this.containers[i]));\\n\\t\\t\\t\\tthis.containers[i].containerCache.over = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t//Do what was originally in plugins\\n\\t\\tif ( this.storedCursor ) {\\n\\t\\t\\tthis.document.find( \\\"body\\\" ).css( \\\"cursor\\\", this.storedCursor );\\n\\t\\t\\tthis.storedStylesheet.remove();\\n\\t\\t}\\n\\t\\tif(this._storedOpacity) {\\n\\t\\t\\tthis.helper.css(\\\"opacity\\\", this._storedOpacity);\\n\\t\\t}\\n\\t\\tif(this._storedZIndex) {\\n\\t\\t\\tthis.helper.css(\\\"zIndex\\\", this._storedZIndex === \\\"auto\\\" ? \\\"\\\" : this._storedZIndex);\\n\\t\\t}\\n\\n\\t\\tthis.dragging = false;\\n\\t\\tif(this.cancelHelperRemoval) {\\n\\t\\t\\tif(!noPropagation) {\\n\\t\\t\\t\\tthis._trigger(\\\"beforeStop\\\", event, this._uiHash());\\n\\t\\t\\t\\tfor (i=0; i < delayedTriggers.length; i++) {\\n\\t\\t\\t\\t\\tdelayedTriggers[i].call(this, event);\\n\\t\\t\\t\\t} //Trigger all delayed events\\n\\t\\t\\t\\tthis._trigger(\\\"stop\\\", event, this._uiHash());\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.fromOutside = false;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif(!noPropagation) {\\n\\t\\t\\tthis._trigger(\\\"beforeStop\\\", event, this._uiHash());\\n\\t\\t}\\n\\n\\t\\t//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!\\n\\t\\tthis.placeholder[0].parentNode.removeChild(this.placeholder[0]);\\n\\n\\t\\tif(this.helper[0] !== this.currentItem[0]) {\\n\\t\\t\\tthis.helper.remove();\\n\\t\\t}\\n\\t\\tthis.helper = null;\\n\\n\\t\\tif(!noPropagation) {\\n\\t\\t\\tfor (i=0; i < delayedTriggers.length; i++) {\\n\\t\\t\\t\\tdelayedTriggers[i].call(this, event);\\n\\t\\t\\t} //Trigger all delayed events\\n\\t\\t\\tthis._trigger(\\\"stop\\\", event, this._uiHash());\\n\\t\\t}\\n\\n\\t\\tthis.fromOutside = false;\\n\\t\\treturn true;\\n\\n\\t},\\n\\n\\t_trigger: function() {\\n\\t\\tif ($.Widget.prototype._trigger.apply(this, arguments) === false) {\\n\\t\\t\\tthis.cancel();\\n\\t\\t}\\n\\t},\\n\\n\\t_uiHash: function(_inst) {\\n\\t\\tvar inst = _inst || this;\\n\\t\\treturn {\\n\\t\\t\\thelper: inst.helper,\\n\\t\\t\\tplaceholder: inst.placeholder || $([]),\\n\\t\\t\\tposition: inst.position,\\n\\t\\t\\toriginalPosition: inst.originalPosition,\\n\\t\\t\\toffset: inst.positionAbs,\\n\\t\\t\\titem: inst.currentItem,\\n\\t\\t\\tsender: _inst ? _inst.element : null\\n\\t\\t};\\n\\t}\\n\\n});\\n\\n})(jQuery);\\n\\n(function($, undefined) {\\n\\nvar dataSpace = \\\"ui-effects-\\\";\\n\\n$.effects = {\\n\\teffect: {}\\n};\\n\\n/*!\\n * jQuery Color Animations v2.1.2\\n * https://github.com/jquery/jquery-color\\n *\\n * Copyright 2013 jQuery Foundation and other contributors\\n * Released under the MIT license.\\n * http://jquery.org/license\\n *\\n * Date: Wed Jan 16 08:47:09 2013 -0600\\n */\\n(function( jQuery, undefined ) {\\n\\n\\tvar stepHooks = \\\"backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor\\\",\\n\\n\\t// plusequals test for += 100 -= 100\\n\\trplusequals = /^([\\\\-+])=\\\\s*(\\\\d+\\\\.?\\\\d*)/,\\n\\t// a set of RE's that can match strings and generate color tuples.\\n\\tstringParsers = [{\\n\\t\\t\\tre: /rgba?\\\\(\\\\s*(\\\\d{1,3})\\\\s*,\\\\s*(\\\\d{1,3})\\\\s*,\\\\s*(\\\\d{1,3})\\\\s*(?:,\\\\s*(\\\\d?(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)/,\\n\\t\\t\\tparse: function( execResult ) {\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\texecResult[ 1 ],\\n\\t\\t\\t\\t\\texecResult[ 2 ],\\n\\t\\t\\t\\t\\texecResult[ 3 ],\\n\\t\\t\\t\\t\\texecResult[ 4 ]\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}, {\\n\\t\\t\\tre: /rgba?\\\\(\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\%\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\%\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\%\\\\s*(?:,\\\\s*(\\\\d?(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)/,\\n\\t\\t\\tparse: function( execResult ) {\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\texecResult[ 1 ] * 2.55,\\n\\t\\t\\t\\t\\texecResult[ 2 ] * 2.55,\\n\\t\\t\\t\\t\\texecResult[ 3 ] * 2.55,\\n\\t\\t\\t\\t\\texecResult[ 4 ]\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}, {\\n\\t\\t\\t// this regex ignores A-F because it's compared against an already lowercased string\\n\\t\\t\\tre: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,\\n\\t\\t\\tparse: function( execResult ) {\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tparseInt( execResult[ 1 ], 16 ),\\n\\t\\t\\t\\t\\tparseInt( execResult[ 2 ], 16 ),\\n\\t\\t\\t\\t\\tparseInt( execResult[ 3 ], 16 )\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}, {\\n\\t\\t\\t// this regex ignores A-F because it's compared against an already lowercased string\\n\\t\\t\\tre: /#([a-f0-9])([a-f0-9])([a-f0-9])/,\\n\\t\\t\\tparse: function( execResult ) {\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tparseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),\\n\\t\\t\\t\\t\\tparseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),\\n\\t\\t\\t\\t\\tparseInt( execResult[ 3 ] + execResult[ 3 ], 16 )\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}, {\\n\\t\\t\\tre: /hsla?\\\\(\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\%\\\\s*,\\\\s*(\\\\d+(?:\\\\.\\\\d+)?)\\\\%\\\\s*(?:,\\\\s*(\\\\d?(?:\\\\.\\\\d+)?)\\\\s*)?\\\\)/,\\n\\t\\t\\tspace: \\\"hsla\\\",\\n\\t\\t\\tparse: function( execResult ) {\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\texecResult[ 1 ],\\n\\t\\t\\t\\t\\texecResult[ 2 ] / 100,\\n\\t\\t\\t\\t\\texecResult[ 3 ] / 100,\\n\\t\\t\\t\\t\\texecResult[ 4 ]\\n\\t\\t\\t\\t];\\n\\t\\t\\t}\\n\\t\\t}],\\n\\n\\t// jQuery.Color( )\\n\\tcolor = jQuery.Color = function( color, green, blue, alpha ) {\\n\\t\\treturn new jQuery.Color.fn.parse( color, green, blue, alpha );\\n\\t},\\n\\tspaces = {\\n\\t\\trgba: {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tred: {\\n\\t\\t\\t\\t\\tidx: 0,\\n\\t\\t\\t\\t\\ttype: \\\"byte\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tgreen: {\\n\\t\\t\\t\\t\\tidx: 1,\\n\\t\\t\\t\\t\\ttype: \\\"byte\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tblue: {\\n\\t\\t\\t\\t\\tidx: 2,\\n\\t\\t\\t\\t\\ttype: \\\"byte\\\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\thsla: {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\thue: {\\n\\t\\t\\t\\t\\tidx: 0,\\n\\t\\t\\t\\t\\ttype: \\\"degrees\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tsaturation: {\\n\\t\\t\\t\\t\\tidx: 1,\\n\\t\\t\\t\\t\\ttype: \\\"percent\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlightness: {\\n\\t\\t\\t\\t\\tidx: 2,\\n\\t\\t\\t\\t\\ttype: \\\"percent\\\"\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tpropTypes = {\\n\\t\\t\\\"byte\\\": {\\n\\t\\t\\tfloor: true,\\n\\t\\t\\tmax: 255\\n\\t\\t},\\n\\t\\t\\\"percent\\\": {\\n\\t\\t\\tmax: 1\\n\\t\\t},\\n\\t\\t\\\"degrees\\\": {\\n\\t\\t\\tmod: 360,\\n\\t\\t\\tfloor: true\\n\\t\\t}\\n\\t},\\n\\tsupport = color.support = {},\\n\\n\\t// element for support tests\\n\\tsupportElem = jQuery( \\\"<p>\\\" )[ 0 ],\\n\\n\\t// colors = jQuery.Color.names\\n\\tcolors,\\n\\n\\t// local aliases of functions called often\\n\\teach = jQuery.each;\\n\\n// determine rgba support immediately\\nsupportElem.style.cssText = \\\"background-color:rgba(1,1,1,.5)\\\";\\nsupport.rgba = supportElem.style.backgroundColor.indexOf( \\\"rgba\\\" ) > -1;\\n\\n// define cache name and alpha properties\\n// for rgba and hsla spaces\\neach( spaces, function( spaceName, space ) {\\n\\tspace.cache = \\\"_\\\" + spaceName;\\n\\tspace.props.alpha = {\\n\\t\\tidx: 3,\\n\\t\\ttype: \\\"percent\\\",\\n\\t\\tdef: 1\\n\\t};\\n});\\n\\nfunction clamp( value, prop, allowEmpty ) {\\n\\tvar type = propTypes[ prop.type ] || {};\\n\\n\\tif ( value == null ) {\\n\\t\\treturn (allowEmpty || !prop.def) ? null : prop.def;\\n\\t}\\n\\n\\t// ~~ is an short way of doing floor for positive numbers\\n\\tvalue = type.floor ? ~~value : parseFloat( value );\\n\\n\\t// IE will pass in empty strings as value for alpha,\\n\\t// which will hit this case\\n\\tif ( isNaN( value ) ) {\\n\\t\\treturn prop.def;\\n\\t}\\n\\n\\tif ( type.mod ) {\\n\\t\\t// we add mod before modding to make sure that negatives values\\n\\t\\t// get converted properly: -10 -> 350\\n\\t\\treturn (value + type.mod) % type.mod;\\n\\t}\\n\\n\\t// for now all property types without mod have min and max\\n\\treturn 0 > value ? 0 : type.max < value ? type.max : value;\\n}\\n\\nfunction stringParse( string ) {\\n\\tvar inst = color(),\\n\\t\\trgba = inst._rgba = [];\\n\\n\\tstring = string.toLowerCase();\\n\\n\\teach( stringParsers, function( i, parser ) {\\n\\t\\tvar parsed,\\n\\t\\t\\tmatch = parser.re.exec( string ),\\n\\t\\t\\tvalues = match && parser.parse( match ),\\n\\t\\t\\tspaceName = parser.space || \\\"rgba\\\";\\n\\n\\t\\tif ( values ) {\\n\\t\\t\\tparsed = inst[ spaceName ]( values );\\n\\n\\t\\t\\t// if this was an rgba parse the assignment might happen twice\\n\\t\\t\\t// oh well....\\n\\t\\t\\tinst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];\\n\\t\\t\\trgba = inst._rgba = parsed._rgba;\\n\\n\\t\\t\\t// exit each( stringParsers ) here because we matched\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t});\\n\\n\\t// Found a stringParser that handled it\\n\\tif ( rgba.length ) {\\n\\n\\t\\t// if this came from a parsed string, force \\\"transparent\\\" when alpha is 0\\n\\t\\t// chrome, (and maybe others) return \\\"transparent\\\" as rgba(0,0,0,0)\\n\\t\\tif ( rgba.join() === \\\"0,0,0,0\\\" ) {\\n\\t\\t\\tjQuery.extend( rgba, colors.transparent );\\n\\t\\t}\\n\\t\\treturn inst;\\n\\t}\\n\\n\\t// named colors\\n\\treturn colors[ string ];\\n}\\n\\ncolor.fn = jQuery.extend( color.prototype, {\\n\\tparse: function( red, green, blue, alpha ) {\\n\\t\\tif ( red === undefined ) {\\n\\t\\t\\tthis._rgba = [ null, null, null, null ];\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tif ( red.jquery || red.nodeType ) {\\n\\t\\t\\tred = jQuery( red ).css( green );\\n\\t\\t\\tgreen = undefined;\\n\\t\\t}\\n\\n\\t\\tvar inst = this,\\n\\t\\t\\ttype = jQuery.type( red ),\\n\\t\\t\\trgba = this._rgba = [];\\n\\n\\t\\t// more than 1 argument specified - assume ( red, green, blue, alpha )\\n\\t\\tif ( green !== undefined ) {\\n\\t\\t\\tred = [ red, green, blue, alpha ];\\n\\t\\t\\ttype = \\\"array\\\";\\n\\t\\t}\\n\\n\\t\\tif ( type === \\\"string\\\" ) {\\n\\t\\t\\treturn this.parse( stringParse( red ) || colors._default );\\n\\t\\t}\\n\\n\\t\\tif ( type === \\\"array\\\" ) {\\n\\t\\t\\teach( spaces.rgba.props, function( key, prop ) {\\n\\t\\t\\t\\trgba[ prop.idx ] = clamp( red[ prop.idx ], prop );\\n\\t\\t\\t});\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\tif ( type === \\\"object\\\" ) {\\n\\t\\t\\tif ( red instanceof color ) {\\n\\t\\t\\t\\teach( spaces, function( spaceName, space ) {\\n\\t\\t\\t\\t\\tif ( red[ space.cache ] ) {\\n\\t\\t\\t\\t\\t\\tinst[ space.cache ] = red[ space.cache ].slice();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\teach( spaces, function( spaceName, space ) {\\n\\t\\t\\t\\t\\tvar cache = space.cache;\\n\\t\\t\\t\\t\\teach( space.props, function( key, prop ) {\\n\\n\\t\\t\\t\\t\\t\\t// if the cache doesn't exist, and we know how to convert\\n\\t\\t\\t\\t\\t\\tif ( !inst[ cache ] && space.to ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// if the value was null, we don't need to copy it\\n\\t\\t\\t\\t\\t\\t\\t// if the key was alpha, we don't need to copy it either\\n\\t\\t\\t\\t\\t\\t\\tif ( key === \\\"alpha\\\" || red[ key ] == null ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tinst[ cache ] = space.to( inst._rgba );\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// this is the only case where we allow nulls for ALL properties.\\n\\t\\t\\t\\t\\t\\t// call clamp with alwaysAllowEmpty\\n\\t\\t\\t\\t\\t\\tinst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t// everything defined but alpha?\\n\\t\\t\\t\\t\\tif ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {\\n\\t\\t\\t\\t\\t\\t// use the default of 1\\n\\t\\t\\t\\t\\t\\tinst[ cache ][ 3 ] = 1;\\n\\t\\t\\t\\t\\t\\tif ( space.from ) {\\n\\t\\t\\t\\t\\t\\t\\tinst._rgba = space.from( inst[ cache ] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t},\\n\\tis: function( compare ) {\\n\\t\\tvar is = color( compare ),\\n\\t\\t\\tsame = true,\\n\\t\\t\\tinst = this;\\n\\n\\t\\teach( spaces, function( _, space ) {\\n\\t\\t\\tvar localCache,\\n\\t\\t\\t\\tisCache = is[ space.cache ];\\n\\t\\t\\tif (isCache) {\\n\\t\\t\\t\\tlocalCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];\\n\\t\\t\\t\\teach( space.props, function( _, prop ) {\\n\\t\\t\\t\\t\\tif ( isCache[ prop.idx ] != null ) {\\n\\t\\t\\t\\t\\t\\tsame = ( isCache[ prop.idx ] === localCache[ prop.idx ] );\\n\\t\\t\\t\\t\\t\\treturn same;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn same;\\n\\t\\t});\\n\\t\\treturn same;\\n\\t},\\n\\t_space: function() {\\n\\t\\tvar used = [],\\n\\t\\t\\tinst = this;\\n\\t\\teach( spaces, function( spaceName, space ) {\\n\\t\\t\\tif ( inst[ space.cache ] ) {\\n\\t\\t\\t\\tused.push( spaceName );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn used.pop();\\n\\t},\\n\\ttransition: function( other, distance ) {\\n\\t\\tvar end = color( other ),\\n\\t\\t\\tspaceName = end._space(),\\n\\t\\t\\tspace = spaces[ spaceName ],\\n\\t\\t\\tstartColor = this.alpha() === 0 ? color( \\\"transparent\\\" ) : this,\\n\\t\\t\\tstart = startColor[ space.cache ] || space.to( startColor._rgba ),\\n\\t\\t\\tresult = start.slice();\\n\\n\\t\\tend = end[ space.cache ];\\n\\t\\teach( space.props, function( key, prop ) {\\n\\t\\t\\tvar index = prop.idx,\\n\\t\\t\\t\\tstartValue = start[ index ],\\n\\t\\t\\t\\tendValue = end[ index ],\\n\\t\\t\\t\\ttype = propTypes[ prop.type ] || {};\\n\\n\\t\\t\\t// if null, don't override start value\\n\\t\\t\\tif ( endValue === null ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// if null - use end\\n\\t\\t\\tif ( startValue === null ) {\\n\\t\\t\\t\\tresult[ index ] = endValue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( type.mod ) {\\n\\t\\t\\t\\t\\tif ( endValue - startValue > type.mod / 2 ) {\\n\\t\\t\\t\\t\\t\\tstartValue += type.mod;\\n\\t\\t\\t\\t\\t} else if ( startValue - endValue > type.mod / 2 ) {\\n\\t\\t\\t\\t\\t\\tstartValue -= type.mod;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn this[ spaceName ]( result );\\n\\t},\\n\\tblend: function( opaque ) {\\n\\t\\t// if we are already opaque - return ourself\\n\\t\\tif ( this._rgba[ 3 ] === 1 ) {\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\tvar rgb = this._rgba.slice(),\\n\\t\\t\\ta = rgb.pop(),\\n\\t\\t\\tblend = color( opaque )._rgba;\\n\\n\\t\\treturn color( jQuery.map( rgb, function( v, i ) {\\n\\t\\t\\treturn ( 1 - a ) * blend[ i ] + a * v;\\n\\t\\t}));\\n\\t},\\n\\ttoRgbaString: function() {\\n\\t\\tvar prefix = \\\"rgba(\\\",\\n\\t\\t\\trgba = jQuery.map( this._rgba, function( v, i ) {\\n\\t\\t\\t\\treturn v == null ? ( i > 2 ? 1 : 0 ) : v;\\n\\t\\t\\t});\\n\\n\\t\\tif ( rgba[ 3 ] === 1 ) {\\n\\t\\t\\trgba.pop();\\n\\t\\t\\tprefix = \\\"rgb(\\\";\\n\\t\\t}\\n\\n\\t\\treturn prefix + rgba.join() + \\\")\\\";\\n\\t},\\n\\ttoHslaString: function() {\\n\\t\\tvar prefix = \\\"hsla(\\\",\\n\\t\\t\\thsla = jQuery.map( this.hsla(), function( v, i ) {\\n\\t\\t\\t\\tif ( v == null ) {\\n\\t\\t\\t\\t\\tv = i > 2 ? 1 : 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// catch 1 and 2\\n\\t\\t\\t\\tif ( i && i < 3 ) {\\n\\t\\t\\t\\t\\tv = Math.round( v * 100 ) + \\\"%\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn v;\\n\\t\\t\\t});\\n\\n\\t\\tif ( hsla[ 3 ] === 1 ) {\\n\\t\\t\\thsla.pop();\\n\\t\\t\\tprefix = \\\"hsl(\\\";\\n\\t\\t}\\n\\t\\treturn prefix + hsla.join() + \\\")\\\";\\n\\t},\\n\\ttoHexString: function( includeAlpha ) {\\n\\t\\tvar rgba = this._rgba.slice(),\\n\\t\\t\\talpha = rgba.pop();\\n\\n\\t\\tif ( includeAlpha ) {\\n\\t\\t\\trgba.push( ~~( alpha * 255 ) );\\n\\t\\t}\\n\\n\\t\\treturn \\\"#\\\" + jQuery.map( rgba, function( v ) {\\n\\n\\t\\t\\t// default to 0 when nulls exist\\n\\t\\t\\tv = ( v || 0 ).toString( 16 );\\n\\t\\t\\treturn v.length === 1 ? \\\"0\\\" + v : v;\\n\\t\\t}).join(\\\"\\\");\\n\\t},\\n\\ttoString: function() {\\n\\t\\treturn this._rgba[ 3 ] === 0 ? \\\"transparent\\\" : this.toRgbaString();\\n\\t}\\n});\\ncolor.fn.parse.prototype = color.fn;\\n\\n// hsla conversions adapted from:\\n// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021\\n\\nfunction hue2rgb( p, q, h ) {\\n\\th = ( h + 1 ) % 1;\\n\\tif ( h * 6 < 1 ) {\\n\\t\\treturn p + (q - p) * h * 6;\\n\\t}\\n\\tif ( h * 2 < 1) {\\n\\t\\treturn q;\\n\\t}\\n\\tif ( h * 3 < 2 ) {\\n\\t\\treturn p + (q - p) * ((2/3) - h) * 6;\\n\\t}\\n\\treturn p;\\n}\\n\\nspaces.hsla.to = function ( rgba ) {\\n\\tif ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {\\n\\t\\treturn [ null, null, null, rgba[ 3 ] ];\\n\\t}\\n\\tvar r = rgba[ 0 ] / 255,\\n\\t\\tg = rgba[ 1 ] / 255,\\n\\t\\tb = rgba[ 2 ] / 255,\\n\\t\\ta = rgba[ 3 ],\\n\\t\\tmax = Math.max( r, g, b ),\\n\\t\\tmin = Math.min( r, g, b ),\\n\\t\\tdiff = max - min,\\n\\t\\tadd = max + min,\\n\\t\\tl = add * 0.5,\\n\\t\\th, s;\\n\\n\\tif ( min === max ) {\\n\\t\\th = 0;\\n\\t} else if ( r === max ) {\\n\\t\\th = ( 60 * ( g - b ) / diff ) + 360;\\n\\t} else if ( g === max ) {\\n\\t\\th = ( 60 * ( b - r ) / diff ) + 120;\\n\\t} else {\\n\\t\\th = ( 60 * ( r - g ) / diff ) + 240;\\n\\t}\\n\\n\\t// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%\\n\\t// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)\\n\\tif ( diff === 0 ) {\\n\\t\\ts = 0;\\n\\t} else if ( l <= 0.5 ) {\\n\\t\\ts = diff / add;\\n\\t} else {\\n\\t\\ts = diff / ( 2 - add );\\n\\t}\\n\\treturn [ Math.round(h) % 360, s, l, a == null ? 1 : a ];\\n};\\n\\nspaces.hsla.from = function ( hsla ) {\\n\\tif ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {\\n\\t\\treturn [ null, null, null, hsla[ 3 ] ];\\n\\t}\\n\\tvar h = hsla[ 0 ] / 360,\\n\\t\\ts = hsla[ 1 ],\\n\\t\\tl = hsla[ 2 ],\\n\\t\\ta = hsla[ 3 ],\\n\\t\\tq = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,\\n\\t\\tp = 2 * l - q;\\n\\n\\treturn [\\n\\t\\tMath.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),\\n\\t\\tMath.round( hue2rgb( p, q, h ) * 255 ),\\n\\t\\tMath.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),\\n\\t\\ta\\n\\t];\\n};\\n\\n\\neach( spaces, function( spaceName, space ) {\\n\\tvar props = space.props,\\n\\t\\tcache = space.cache,\\n\\t\\tto = space.to,\\n\\t\\tfrom = space.from;\\n\\n\\t// makes rgba() and hsla()\\n\\tcolor.fn[ spaceName ] = function( value ) {\\n\\n\\t\\t// generate a cache for this space if it doesn't exist\\n\\t\\tif ( to && !this[ cache ] ) {\\n\\t\\t\\tthis[ cache ] = to( this._rgba );\\n\\t\\t}\\n\\t\\tif ( value === undefined ) {\\n\\t\\t\\treturn this[ cache ].slice();\\n\\t\\t}\\n\\n\\t\\tvar ret,\\n\\t\\t\\ttype = jQuery.type( value ),\\n\\t\\t\\tarr = ( type === \\\"array\\\" || type === \\\"object\\\" ) ? value : arguments,\\n\\t\\t\\tlocal = this[ cache ].slice();\\n\\n\\t\\teach( props, function( key, prop ) {\\n\\t\\t\\tvar val = arr[ type === \\\"object\\\" ? key : prop.idx ];\\n\\t\\t\\tif ( val == null ) {\\n\\t\\t\\t\\tval = local[ prop.idx ];\\n\\t\\t\\t}\\n\\t\\t\\tlocal[ prop.idx ] = clamp( val, prop );\\n\\t\\t});\\n\\n\\t\\tif ( from ) {\\n\\t\\t\\tret = color( from( local ) );\\n\\t\\t\\tret[ cache ] = local;\\n\\t\\t\\treturn ret;\\n\\t\\t} else {\\n\\t\\t\\treturn color( local );\\n\\t\\t}\\n\\t};\\n\\n\\t// makes red() green() blue() alpha() hue() saturation() lightness()\\n\\teach( props, function( key, prop ) {\\n\\t\\t// alpha is included in more than one space\\n\\t\\tif ( color.fn[ key ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tcolor.fn[ key ] = function( value ) {\\n\\t\\t\\tvar vtype = jQuery.type( value ),\\n\\t\\t\\t\\tfn = ( key === \\\"alpha\\\" ? ( this._hsla ? \\\"hsla\\\" : \\\"rgba\\\" ) : spaceName ),\\n\\t\\t\\t\\tlocal = this[ fn ](),\\n\\t\\t\\t\\tcur = local[ prop.idx ],\\n\\t\\t\\t\\tmatch;\\n\\n\\t\\t\\tif ( vtype === \\\"undefined\\\" ) {\\n\\t\\t\\t\\treturn cur;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( vtype === \\\"function\\\" ) {\\n\\t\\t\\t\\tvalue = value.call( this, cur );\\n\\t\\t\\t\\tvtype = jQuery.type( value );\\n\\t\\t\\t}\\n\\t\\t\\tif ( value == null && prop.empty ) {\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t\\tif ( vtype === \\\"string\\\" ) {\\n\\t\\t\\t\\tmatch = rplusequals.exec( value );\\n\\t\\t\\t\\tif ( match ) {\\n\\t\\t\\t\\t\\tvalue = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === \\\"+\\\" ? 1 : -1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tlocal[ prop.idx ] = value;\\n\\t\\t\\treturn this[ fn ]( local );\\n\\t\\t};\\n\\t});\\n});\\n\\n// add cssHook and .fx.step function for each named hook.\\n// accept a space separated string of properties\\ncolor.hook = function( hook ) {\\n\\tvar hooks = hook.split( \\\" \\\" );\\n\\teach( hooks, function( i, hook ) {\\n\\t\\tjQuery.cssHooks[ hook ] = {\\n\\t\\t\\tset: function( elem, value ) {\\n\\t\\t\\t\\tvar parsed, curElem,\\n\\t\\t\\t\\t\\tbackgroundColor = \\\"\\\";\\n\\n\\t\\t\\t\\tif ( value !== \\\"transparent\\\" && ( jQuery.type( value ) !== \\\"string\\\" || ( parsed = stringParse( value ) ) ) ) {\\n\\t\\t\\t\\t\\tvalue = color( parsed || value );\\n\\t\\t\\t\\t\\tif ( !support.rgba && value._rgba[ 3 ] !== 1 ) {\\n\\t\\t\\t\\t\\t\\tcurElem = hook === \\\"backgroundColor\\\" ? elem.parentNode : elem;\\n\\t\\t\\t\\t\\t\\twhile (\\n\\t\\t\\t\\t\\t\\t\\t(backgroundColor === \\\"\\\" || backgroundColor === \\\"transparent\\\") &&\\n\\t\\t\\t\\t\\t\\t\\tcurElem && curElem.style\\n\\t\\t\\t\\t\\t\\t) {\\n\\t\\t\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\t\\t\\tbackgroundColor = jQuery.css( curElem, \\\"backgroundColor\\\" );\\n\\t\\t\\t\\t\\t\\t\\t\\tcurElem = curElem.parentNode;\\n\\t\\t\\t\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvalue = value.blend( backgroundColor && backgroundColor !== \\\"transparent\\\" ?\\n\\t\\t\\t\\t\\t\\t\\tbackgroundColor :\\n\\t\\t\\t\\t\\t\\t\\t\\\"_default\\\" );\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvalue = value.toRgbaString();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\telem.style[ hook ] = value;\\n\\t\\t\\t\\t} catch( e ) {\\n\\t\\t\\t\\t\\t// wrapped to prevent IE from throwing errors on \\\"invalid\\\" values like 'auto' or 'inherit'\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tjQuery.fx.step[ hook ] = function( fx ) {\\n\\t\\t\\tif ( !fx.colorInit ) {\\n\\t\\t\\t\\tfx.start = color( fx.elem, hook );\\n\\t\\t\\t\\tfx.end = color( fx.end );\\n\\t\\t\\t\\tfx.colorInit = true;\\n\\t\\t\\t}\\n\\t\\t\\tjQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );\\n\\t\\t};\\n\\t});\\n\\n};\\n\\ncolor.hook( stepHooks );\\n\\njQuery.cssHooks.borderColor = {\\n\\texpand: function( value ) {\\n\\t\\tvar expanded = {};\\n\\n\\t\\teach( [ \\\"Top\\\", \\\"Right\\\", \\\"Bottom\\\", \\\"Left\\\" ], function( i, part ) {\\n\\t\\t\\texpanded[ \\\"border\\\" + part + \\\"Color\\\" ] = value;\\n\\t\\t});\\n\\t\\treturn expanded;\\n\\t}\\n};\\n\\n// Basic color names only.\\n// Usage of any of the other color names requires adding yourself or including\\n// jquery.color.svg-names.js.\\ncolors = jQuery.Color.names = {\\n\\t// 4.1. Basic color keywords\\n\\taqua: \\\"#00ffff\\\",\\n\\tblack: \\\"#000000\\\",\\n\\tblue: \\\"#0000ff\\\",\\n\\tfuchsia: \\\"#ff00ff\\\",\\n\\tgray: \\\"#808080\\\",\\n\\tgreen: \\\"#008000\\\",\\n\\tlime: \\\"#00ff00\\\",\\n\\tmaroon: \\\"#800000\\\",\\n\\tnavy: \\\"#000080\\\",\\n\\tolive: \\\"#808000\\\",\\n\\tpurple: \\\"#800080\\\",\\n\\tred: \\\"#ff0000\\\",\\n\\tsilver: \\\"#c0c0c0\\\",\\n\\tteal: \\\"#008080\\\",\\n\\twhite: \\\"#ffffff\\\",\\n\\tyellow: \\\"#ffff00\\\",\\n\\n\\t// 4.2.3. \\\"transparent\\\" color keyword\\n\\ttransparent: [ null, null, null, 0 ],\\n\\n\\t_default: \\\"#ffffff\\\"\\n};\\n\\n})( jQuery );\\n\\n\\n/******************************************************************************/\\n/****************************** CLASS ANIMATIONS ******************************/\\n/******************************************************************************/\\n(function() {\\n\\nvar classAnimationActions = [ \\\"add\\\", \\\"remove\\\", \\\"toggle\\\" ],\\n\\tshorthandStyles = {\\n\\t\\tborder: 1,\\n\\t\\tborderBottom: 1,\\n\\t\\tborderColor: 1,\\n\\t\\tborderLeft: 1,\\n\\t\\tborderRight: 1,\\n\\t\\tborderTop: 1,\\n\\t\\tborderWidth: 1,\\n\\t\\tmargin: 1,\\n\\t\\tpadding: 1\\n\\t};\\n\\n$.each([ \\\"borderLeftStyle\\\", \\\"borderRightStyle\\\", \\\"borderBottomStyle\\\", \\\"borderTopStyle\\\" ], function( _, prop ) {\\n\\t$.fx.step[ prop ] = function( fx ) {\\n\\t\\tif ( fx.end !== \\\"none\\\" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {\\n\\t\\t\\tjQuery.style( fx.elem, prop, fx.end );\\n\\t\\t\\tfx.setAttr = true;\\n\\t\\t}\\n\\t};\\n});\\n\\nfunction getElementStyles( elem ) {\\n\\tvar key, len,\\n\\t\\tstyle = elem.ownerDocument.defaultView ?\\n\\t\\t\\telem.ownerDocument.defaultView.getComputedStyle( elem, null ) :\\n\\t\\t\\telem.currentStyle,\\n\\t\\tstyles = {};\\n\\n\\tif ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {\\n\\t\\tlen = style.length;\\n\\t\\twhile ( len-- ) {\\n\\t\\t\\tkey = style[ len ];\\n\\t\\t\\tif ( typeof style[ key ] === \\\"string\\\" ) {\\n\\t\\t\\t\\tstyles[ $.camelCase( key ) ] = style[ key ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t// support: Opera, IE <9\\n\\t} else {\\n\\t\\tfor ( key in style ) {\\n\\t\\t\\tif ( typeof style[ key ] === \\\"string\\\" ) {\\n\\t\\t\\t\\tstyles[ key ] = style[ key ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn styles;\\n}\\n\\n\\nfunction styleDifference( oldStyle, newStyle ) {\\n\\tvar diff = {},\\n\\t\\tname, value;\\n\\n\\tfor ( name in newStyle ) {\\n\\t\\tvalue = newStyle[ name ];\\n\\t\\tif ( oldStyle[ name ] !== value ) {\\n\\t\\t\\tif ( !shorthandStyles[ name ] ) {\\n\\t\\t\\t\\tif ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {\\n\\t\\t\\t\\t\\tdiff[ name ] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn diff;\\n}\\n\\n// support: jQuery <1.8\\nif ( !$.fn.addBack ) {\\n\\t$.fn.addBack = function( selector ) {\\n\\t\\treturn this.add( selector == null ?\\n\\t\\t\\tthis.prevObject : this.prevObject.filter( selector )\\n\\t\\t);\\n\\t};\\n}\\n\\n$.effects.animateClass = function( value, duration, easing, callback ) {\\n\\tvar o = $.speed( duration, easing, callback );\\n\\n\\treturn this.queue( function() {\\n\\t\\tvar animated = $( this ),\\n\\t\\t\\tbaseClass = animated.attr( \\\"class\\\" ) || \\\"\\\",\\n\\t\\t\\tapplyClassChange,\\n\\t\\t\\tallAnimations = o.children ? animated.find( \\\"*\\\" ).addBack() : animated;\\n\\n\\t\\t// map the animated objects to store the original styles.\\n\\t\\tallAnimations = allAnimations.map(function() {\\n\\t\\t\\tvar el = $( this );\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tel: el,\\n\\t\\t\\t\\tstart: getElementStyles( this )\\n\\t\\t\\t};\\n\\t\\t});\\n\\n\\t\\t// apply class change\\n\\t\\tapplyClassChange = function() {\\n\\t\\t\\t$.each( classAnimationActions, function(i, action) {\\n\\t\\t\\t\\tif ( value[ action ] ) {\\n\\t\\t\\t\\t\\tanimated[ action + \\\"Class\\\" ]( value[ action ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t};\\n\\t\\tapplyClassChange();\\n\\n\\t\\t// map all animated objects again - calculate new styles and diff\\n\\t\\tallAnimations = allAnimations.map(function() {\\n\\t\\t\\tthis.end = getElementStyles( this.el[ 0 ] );\\n\\t\\t\\tthis.diff = styleDifference( this.start, this.end );\\n\\t\\t\\treturn this;\\n\\t\\t});\\n\\n\\t\\t// apply original class\\n\\t\\tanimated.attr( \\\"class\\\", baseClass );\\n\\n\\t\\t// map all animated objects again - this time collecting a promise\\n\\t\\tallAnimations = allAnimations.map(function() {\\n\\t\\t\\tvar styleInfo = this,\\n\\t\\t\\t\\tdfd = $.Deferred(),\\n\\t\\t\\t\\topts = $.extend({}, o, {\\n\\t\\t\\t\\t\\tqueue: false,\\n\\t\\t\\t\\t\\tcomplete: function() {\\n\\t\\t\\t\\t\\t\\tdfd.resolve( styleInfo );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\tthis.el.animate( this.diff, opts );\\n\\t\\t\\treturn dfd.promise();\\n\\t\\t});\\n\\n\\t\\t// once all animations have completed:\\n\\t\\t$.when.apply( $, allAnimations.get() ).done(function() {\\n\\n\\t\\t\\t// set the final class\\n\\t\\t\\tapplyClassChange();\\n\\n\\t\\t\\t// for each animated element,\\n\\t\\t\\t// clear all css properties that were animated\\n\\t\\t\\t$.each( arguments, function() {\\n\\t\\t\\t\\tvar el = this.el;\\n\\t\\t\\t\\t$.each( this.diff, function(key) {\\n\\t\\t\\t\\t\\tel.css( key, \\\"\\\" );\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\n\\t\\t\\t// this is guarnteed to be there if you use jQuery.speed()\\n\\t\\t\\t// it also handles dequeuing the next anim...\\n\\t\\t\\to.complete.call( animated[ 0 ] );\\n\\t\\t});\\n\\t});\\n};\\n\\n$.fn.extend({\\n\\taddClass: (function( orig ) {\\n\\t\\treturn function( classNames, speed, easing, callback ) {\\n\\t\\t\\treturn speed ?\\n\\t\\t\\t\\t$.effects.animateClass.call( this,\\n\\t\\t\\t\\t\\t{ add: classNames }, speed, easing, callback ) :\\n\\t\\t\\t\\torig.apply( this, arguments );\\n\\t\\t};\\n\\t})( $.fn.addClass ),\\n\\n\\tremoveClass: (function( orig ) {\\n\\t\\treturn function( classNames, speed, easing, callback ) {\\n\\t\\t\\treturn arguments.length > 1 ?\\n\\t\\t\\t\\t$.effects.animateClass.call( this,\\n\\t\\t\\t\\t\\t{ remove: classNames }, speed, easing, callback ) :\\n\\t\\t\\t\\torig.apply( this, arguments );\\n\\t\\t};\\n\\t})( $.fn.removeClass ),\\n\\n\\ttoggleClass: (function( orig ) {\\n\\t\\treturn function( classNames, force, speed, easing, callback ) {\\n\\t\\t\\tif ( typeof force === \\\"boolean\\\" || force === undefined ) {\\n\\t\\t\\t\\tif ( !speed ) {\\n\\t\\t\\t\\t\\t// without speed parameter\\n\\t\\t\\t\\t\\treturn orig.apply( this, arguments );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn $.effects.animateClass.call( this,\\n\\t\\t\\t\\t\\t\\t(force ? { add: classNames } : { remove: classNames }),\\n\\t\\t\\t\\t\\t\\tspeed, easing, callback );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// without force parameter\\n\\t\\t\\t\\treturn $.effects.animateClass.call( this,\\n\\t\\t\\t\\t\\t{ toggle: classNames }, force, speed, easing );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t})( $.fn.toggleClass ),\\n\\n\\tswitchClass: function( remove, add, speed, easing, callback) {\\n\\t\\treturn $.effects.animateClass.call( this, {\\n\\t\\t\\tadd: add,\\n\\t\\t\\tremove: remove\\n\\t\\t}, speed, easing, callback );\\n\\t}\\n});\\n\\n})();\\n\\n/******************************************************************************/\\n/*********************************** EFFECTS **********************************/\\n/******************************************************************************/\\n\\n(function() {\\n\\n$.extend( $.effects, {\\n\\tversion: \\\"1.10.3\\\",\\n\\n\\t// Saves a set of properties in a data storage\\n\\tsave: function( element, set ) {\\n\\t\\tfor( var i=0; i < set.length; i++ ) {\\n\\t\\t\\tif ( set[ i ] !== null ) {\\n\\t\\t\\t\\telement.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t// Restores a set of previously saved properties from a data storage\\n\\trestore: function( element, set ) {\\n\\t\\tvar val, i;\\n\\t\\tfor( i=0; i < set.length; i++ ) {\\n\\t\\t\\tif ( set[ i ] !== null ) {\\n\\t\\t\\t\\tval = element.data( dataSpace + set[ i ] );\\n\\t\\t\\t\\t// support: jQuery 1.6.2\\n\\t\\t\\t\\t// http://bugs.jquery.com/ticket/9917\\n\\t\\t\\t\\t// jQuery 1.6.2 incorrectly returns undefined for any falsy value.\\n\\t\\t\\t\\t// We can't differentiate between \\\"\\\" and 0 here, so we just assume\\n\\t\\t\\t\\t// empty string since it's likely to be a more common value...\\n\\t\\t\\t\\tif ( val === undefined ) {\\n\\t\\t\\t\\t\\tval = \\\"\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telement.css( set[ i ], val );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tsetMode: function( el, mode ) {\\n\\t\\tif (mode === \\\"toggle\\\") {\\n\\t\\t\\tmode = el.is( \\\":hidden\\\" ) ? \\\"show\\\" : \\\"hide\\\";\\n\\t\\t}\\n\\t\\treturn mode;\\n\\t},\\n\\n\\t// Translates a [top,left] array into a baseline value\\n\\t// this should be a little more flexible in the future to handle a string & hash\\n\\tgetBaseline: function( origin, original ) {\\n\\t\\tvar y, x;\\n\\t\\tswitch ( origin[ 0 ] ) {\\n\\t\\t\\tcase \\\"top\\\": y = 0; break;\\n\\t\\t\\tcase \\\"middle\\\": y = 0.5; break;\\n\\t\\t\\tcase \\\"bottom\\\": y = 1; break;\\n\\t\\t\\tdefault: y = origin[ 0 ] / original.height;\\n\\t\\t}\\n\\t\\tswitch ( origin[ 1 ] ) {\\n\\t\\t\\tcase \\\"left\\\": x = 0; break;\\n\\t\\t\\tcase \\\"center\\\": x = 0.5; break;\\n\\t\\t\\tcase \\\"right\\\": x = 1; break;\\n\\t\\t\\tdefault: x = origin[ 1 ] / original.width;\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\tx: x,\\n\\t\\t\\ty: y\\n\\t\\t};\\n\\t},\\n\\n\\t// Wraps the element around a wrapper that copies position properties\\n\\tcreateWrapper: function( element ) {\\n\\n\\t\\t// if the element is already wrapped, return it\\n\\t\\tif ( element.parent().is( \\\".ui-effects-wrapper\\\" )) {\\n\\t\\t\\treturn element.parent();\\n\\t\\t}\\n\\n\\t\\t// wrap the element\\n\\t\\tvar props = {\\n\\t\\t\\t\\twidth: element.outerWidth(true),\\n\\t\\t\\t\\theight: element.outerHeight(true),\\n\\t\\t\\t\\t\\\"float\\\": element.css( \\\"float\\\" )\\n\\t\\t\\t},\\n\\t\\t\\twrapper = $( \\\"<div></div>\\\" )\\n\\t\\t\\t\\t.addClass( \\\"ui-effects-wrapper\\\" )\\n\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\tfontSize: \\\"100%\\\",\\n\\t\\t\\t\\t\\tbackground: \\\"transparent\\\",\\n\\t\\t\\t\\t\\tborder: \\\"none\\\",\\n\\t\\t\\t\\t\\tmargin: 0,\\n\\t\\t\\t\\t\\tpadding: 0\\n\\t\\t\\t\\t}),\\n\\t\\t\\t// Store the size in case width/height are defined in % - Fixes #5245\\n\\t\\t\\tsize = {\\n\\t\\t\\t\\twidth: element.width(),\\n\\t\\t\\t\\theight: element.height()\\n\\t\\t\\t},\\n\\t\\t\\tactive = document.activeElement;\\n\\n\\t\\t// support: Firefox\\n\\t\\t// Firefox incorrectly exposes anonymous content\\n\\t\\t// https://bugzilla.mozilla.org/show_bug.cgi?id=561664\\n\\t\\ttry {\\n\\t\\t\\tactive.id;\\n\\t\\t} catch( e ) {\\n\\t\\t\\tactive = document.body;\\n\\t\\t}\\n\\n\\t\\telement.wrap( wrapper );\\n\\n\\t\\t// Fixes #7595 - Elements lose focus when wrapped.\\n\\t\\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\\n\\t\\t\\t$( active ).focus();\\n\\t\\t}\\n\\n\\t\\twrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element\\n\\n\\t\\t// transfer positioning properties to the wrapper\\n\\t\\tif ( element.css( \\\"position\\\" ) === \\\"static\\\" ) {\\n\\t\\t\\twrapper.css({ position: \\\"relative\\\" });\\n\\t\\t\\telement.css({ position: \\\"relative\\\" });\\n\\t\\t} else {\\n\\t\\t\\t$.extend( props, {\\n\\t\\t\\t\\tposition: element.css( \\\"position\\\" ),\\n\\t\\t\\t\\tzIndex: element.css( \\\"z-index\\\" )\\n\\t\\t\\t});\\n\\t\\t\\t$.each([ \\\"top\\\", \\\"left\\\", \\\"bottom\\\", \\\"right\\\" ], function(i, pos) {\\n\\t\\t\\t\\tprops[ pos ] = element.css( pos );\\n\\t\\t\\t\\tif ( isNaN( parseInt( props[ pos ], 10 ) ) ) {\\n\\t\\t\\t\\t\\tprops[ pos ] = \\\"auto\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\telement.css({\\n\\t\\t\\t\\tposition: \\\"relative\\\",\\n\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\tright: \\\"auto\\\",\\n\\t\\t\\t\\tbottom: \\\"auto\\\"\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\telement.css(size);\\n\\n\\t\\treturn wrapper.css( props ).show();\\n\\t},\\n\\n\\tremoveWrapper: function( element ) {\\n\\t\\tvar active = document.activeElement;\\n\\n\\t\\tif ( element.parent().is( \\\".ui-effects-wrapper\\\" ) ) {\\n\\t\\t\\telement.parent().replaceWith( element );\\n\\n\\t\\t\\t// Fixes #7595 - Elements lose focus when wrapped.\\n\\t\\t\\tif ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {\\n\\t\\t\\t\\t$( active ).focus();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\t\\treturn element;\\n\\t},\\n\\n\\tsetTransition: function( element, list, factor, value ) {\\n\\t\\tvalue = value || {};\\n\\t\\t$.each( list, function( i, x ) {\\n\\t\\t\\tvar unit = element.cssUnit( x );\\n\\t\\t\\tif ( unit[ 0 ] > 0 ) {\\n\\t\\t\\t\\tvalue[ x ] = unit[ 0 ] * factor + unit[ 1 ];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn value;\\n\\t}\\n});\\n\\n// return an effect options object for the given parameters:\\nfunction _normalizeArguments( effect, options, speed, callback ) {\\n\\n\\t// allow passing all options as the first parameter\\n\\tif ( $.isPlainObject( effect ) ) {\\n\\t\\toptions = effect;\\n\\t\\teffect = effect.effect;\\n\\t}\\n\\n\\t// convert to an object\\n\\teffect = { effect: effect };\\n\\n\\t// catch (effect, null, ...)\\n\\tif ( options == null ) {\\n\\t\\toptions = {};\\n\\t}\\n\\n\\t// catch (effect, callback)\\n\\tif ( $.isFunction( options ) ) {\\n\\t\\tcallback = options;\\n\\t\\tspeed = null;\\n\\t\\toptions = {};\\n\\t}\\n\\n\\t// catch (effect, speed, ?)\\n\\tif ( typeof options === \\\"number\\\" || $.fx.speeds[ options ] ) {\\n\\t\\tcallback = speed;\\n\\t\\tspeed = options;\\n\\t\\toptions = {};\\n\\t}\\n\\n\\t// catch (effect, options, callback)\\n\\tif ( $.isFunction( speed ) ) {\\n\\t\\tcallback = speed;\\n\\t\\tspeed = null;\\n\\t}\\n\\n\\t// add options to effect\\n\\tif ( options ) {\\n\\t\\t$.extend( effect, options );\\n\\t}\\n\\n\\tspeed = speed || options.duration;\\n\\teffect.duration = $.fx.off ? 0 :\\n\\t\\ttypeof speed === \\\"number\\\" ? speed :\\n\\t\\tspeed in $.fx.speeds ? $.fx.speeds[ speed ] :\\n\\t\\t$.fx.speeds._default;\\n\\n\\teffect.complete = callback || options.complete;\\n\\n\\treturn effect;\\n}\\n\\nfunction standardAnimationOption( option ) {\\n\\t// Valid standard speeds (nothing, number, named speed)\\n\\tif ( !option || typeof option === \\\"number\\\" || $.fx.speeds[ option ] ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Invalid strings - treat as \\\"normal\\\" speed\\n\\tif ( typeof option === \\\"string\\\" && !$.effects.effect[ option ] ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Complete callback\\n\\tif ( $.isFunction( option ) ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Options hash (but not naming an effect)\\n\\tif ( typeof option === \\\"object\\\" && !option.effect ) {\\n\\t\\treturn true;\\n\\t}\\n\\n\\t// Didn't match any standard API\\n\\treturn false;\\n}\\n\\n$.fn.extend({\\n\\teffect: function( /* effect, options, speed, callback */ ) {\\n\\t\\tvar args = _normalizeArguments.apply( this, arguments ),\\n\\t\\t\\tmode = args.mode,\\n\\t\\t\\tqueue = args.queue,\\n\\t\\t\\teffectMethod = $.effects.effect[ args.effect ];\\n\\n\\t\\tif ( $.fx.off || !effectMethod ) {\\n\\t\\t\\t// delegate to the original method (e.g., .show()) if possible\\n\\t\\t\\tif ( mode ) {\\n\\t\\t\\t\\treturn this[ mode ]( args.duration, args.complete );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn this.each( function() {\\n\\t\\t\\t\\t\\tif ( args.complete ) {\\n\\t\\t\\t\\t\\t\\targs.complete.call( this );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfunction run( next ) {\\n\\t\\t\\tvar elem = $( this ),\\n\\t\\t\\t\\tcomplete = args.complete,\\n\\t\\t\\t\\tmode = args.mode;\\n\\n\\t\\t\\tfunction done() {\\n\\t\\t\\t\\tif ( $.isFunction( complete ) ) {\\n\\t\\t\\t\\t\\tcomplete.call( elem[0] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( $.isFunction( next ) ) {\\n\\t\\t\\t\\t\\tnext();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If the element already has the correct final state, delegate to\\n\\t\\t\\t// the core methods so the internal tracking of \\\"olddisplay\\\" works.\\n\\t\\t\\tif ( elem.is( \\\":hidden\\\" ) ? mode === \\\"hide\\\" : mode === \\\"show\\\" ) {\\n\\t\\t\\t\\telem[ mode ]();\\n\\t\\t\\t\\tdone();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\teffectMethod.call( elem[0], args, done );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn queue === false ? this.each( run ) : this.queue( queue || \\\"fx\\\", run );\\n\\t},\\n\\n\\tshow: (function( orig ) {\\n\\t\\treturn function( option ) {\\n\\t\\t\\tif ( standardAnimationOption( option ) ) {\\n\\t\\t\\t\\treturn orig.apply( this, arguments );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar args = _normalizeArguments.apply( this, arguments );\\n\\t\\t\\t\\targs.mode = \\\"show\\\";\\n\\t\\t\\t\\treturn this.effect.call( this, args );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t})( $.fn.show ),\\n\\n\\thide: (function( orig ) {\\n\\t\\treturn function( option ) {\\n\\t\\t\\tif ( standardAnimationOption( option ) ) {\\n\\t\\t\\t\\treturn orig.apply( this, arguments );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar args = _normalizeArguments.apply( this, arguments );\\n\\t\\t\\t\\targs.mode = \\\"hide\\\";\\n\\t\\t\\t\\treturn this.effect.call( this, args );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t})( $.fn.hide ),\\n\\n\\ttoggle: (function( orig ) {\\n\\t\\treturn function( option ) {\\n\\t\\t\\tif ( standardAnimationOption( option ) || typeof option === \\\"boolean\\\" ) {\\n\\t\\t\\t\\treturn orig.apply( this, arguments );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar args = _normalizeArguments.apply( this, arguments );\\n\\t\\t\\t\\targs.mode = \\\"toggle\\\";\\n\\t\\t\\t\\treturn this.effect.call( this, args );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t})( $.fn.toggle ),\\n\\n\\t// helper functions\\n\\tcssUnit: function(key) {\\n\\t\\tvar style = this.css( key ),\\n\\t\\t\\tval = [];\\n\\n\\t\\t$.each( [ \\\"em\\\", \\\"px\\\", \\\"%\\\", \\\"pt\\\" ], function( i, unit ) {\\n\\t\\t\\tif ( style.indexOf( unit ) > 0 ) {\\n\\t\\t\\t\\tval = [ parseFloat( style ), unit ];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn val;\\n\\t}\\n});\\n\\n})();\\n\\n/******************************************************************************/\\n/*********************************** EASING ***********************************/\\n/******************************************************************************/\\n\\n(function() {\\n\\n// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)\\n\\nvar baseEasings = {};\\n\\n$.each( [ \\\"Quad\\\", \\\"Cubic\\\", \\\"Quart\\\", \\\"Quint\\\", \\\"Expo\\\" ], function( i, name ) {\\n\\tbaseEasings[ name ] = function( p ) {\\n\\t\\treturn Math.pow( p, i + 2 );\\n\\t};\\n});\\n\\n$.extend( baseEasings, {\\n\\tSine: function ( p ) {\\n\\t\\treturn 1 - Math.cos( p * Math.PI / 2 );\\n\\t},\\n\\tCirc: function ( p ) {\\n\\t\\treturn 1 - Math.sqrt( 1 - p * p );\\n\\t},\\n\\tElastic: function( p ) {\\n\\t\\treturn p === 0 || p === 1 ? p :\\n\\t\\t\\t-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );\\n\\t},\\n\\tBack: function( p ) {\\n\\t\\treturn p * p * ( 3 * p - 2 );\\n\\t},\\n\\tBounce: function ( p ) {\\n\\t\\tvar pow2,\\n\\t\\t\\tbounce = 4;\\n\\n\\t\\twhile ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}\\n\\t\\treturn 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );\\n\\t}\\n});\\n\\n$.each( baseEasings, function( name, easeIn ) {\\n\\t$.easing[ \\\"easeIn\\\" + name ] = easeIn;\\n\\t$.easing[ \\\"easeOut\\\" + name ] = function( p ) {\\n\\t\\treturn 1 - easeIn( 1 - p );\\n\\t};\\n\\t$.easing[ \\\"easeInOut\\\" + name ] = function( p ) {\\n\\t\\treturn p < 0.5 ?\\n\\t\\t\\teaseIn( p * 2 ) / 2 :\\n\\t\\t\\t1 - easeIn( p * -2 + 2 ) / 2;\\n\\t};\\n});\\n\\n})();\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\nvar uid = 0,\\n\\thideProps = {},\\n\\tshowProps = {};\\n\\nhideProps.height = hideProps.paddingTop = hideProps.paddingBottom =\\n\\thideProps.borderTopWidth = hideProps.borderBottomWidth = \\\"hide\\\";\\nshowProps.height = showProps.paddingTop = showProps.paddingBottom =\\n\\tshowProps.borderTopWidth = showProps.borderBottomWidth = \\\"show\\\";\\n\\n$.widget( \\\"ui.accordion\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tactive: 0,\\n\\t\\tanimate: {},\\n\\t\\tcollapsible: false,\\n\\t\\tevent: \\\"click\\\",\\n\\t\\theader: \\\"> li > :first-child,> :not(li):even\\\",\\n\\t\\theightStyle: \\\"auto\\\",\\n\\t\\ticons: {\\n\\t\\t\\tactiveHeader: \\\"ui-icon-triangle-1-s\\\",\\n\\t\\t\\theader: \\\"ui-icon-triangle-1-e\\\"\\n\\t\\t},\\n\\n\\t\\t// callbacks\\n\\t\\tactivate: null,\\n\\t\\tbeforeActivate: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tvar options = this.options;\\n\\t\\tthis.prevShow = this.prevHide = $();\\n\\t\\tthis.element.addClass( \\\"ui-accordion ui-widget ui-helper-reset\\\" )\\n\\t\\t\\t// ARIA\\n\\t\\t\\t.attr( \\\"role\\\", \\\"tablist\\\" );\\n\\n\\t\\t// don't allow collapsible: false and active: false / null\\n\\t\\tif ( !options.collapsible && (options.active === false || options.active == null) ) {\\n\\t\\t\\toptions.active = 0;\\n\\t\\t}\\n\\n\\t\\tthis._processPanels();\\n\\t\\t// handle negative values\\n\\t\\tif ( options.active < 0 ) {\\n\\t\\t\\toptions.active += this.headers.length;\\n\\t\\t}\\n\\t\\tthis._refresh();\\n\\t},\\n\\n\\t_getCreateEventData: function() {\\n\\t\\treturn {\\n\\t\\t\\theader: this.active,\\n\\t\\t\\tpanel: !this.active.length ? $() : this.active.next(),\\n\\t\\t\\tcontent: !this.active.length ? $() : this.active.next()\\n\\t\\t};\\n\\t},\\n\\n\\t_createIcons: function() {\\n\\t\\tvar icons = this.options.icons;\\n\\t\\tif ( icons ) {\\n\\t\\t\\t$( \\\"<span>\\\" )\\n\\t\\t\\t\\t.addClass( \\\"ui-accordion-header-icon ui-icon \\\" + icons.header )\\n\\t\\t\\t\\t.prependTo( this.headers );\\n\\t\\t\\tthis.active.children( \\\".ui-accordion-header-icon\\\" )\\n\\t\\t\\t\\t.removeClass( icons.header )\\n\\t\\t\\t\\t.addClass( icons.activeHeader );\\n\\t\\t\\tthis.headers.addClass( \\\"ui-accordion-icons\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\t_destroyIcons: function() {\\n\\t\\tthis.headers\\n\\t\\t\\t.removeClass( \\\"ui-accordion-icons\\\" )\\n\\t\\t\\t.children( \\\".ui-accordion-header-icon\\\" )\\n\\t\\t\\t\\t.remove();\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tvar contents;\\n\\n\\t\\t// clean up main element\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-accordion ui-widget ui-helper-reset\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" );\\n\\n\\t\\t// clean up headers\\n\\t\\tthis.headers\\n\\t\\t\\t.removeClass( \\\"ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-selected\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-controls\\\" )\\n\\t\\t\\t.removeAttr( \\\"tabIndex\\\" )\\n\\t\\t\\t.each(function() {\\n\\t\\t\\t\\tif ( /^ui-accordion/.test( this.id ) ) {\\n\\t\\t\\t\\t\\tthis.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\tthis._destroyIcons();\\n\\n\\t\\t// clean up content panels\\n\\t\\tcontents = this.headers.next()\\n\\t\\t\\t.css( \\\"display\\\", \\\"\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-expanded\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-hidden\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-labelledby\\\" )\\n\\t\\t\\t.removeClass( \\\"ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled\\\" )\\n\\t\\t\\t.each(function() {\\n\\t\\t\\t\\tif ( /^ui-accordion/.test( this.id ) ) {\\n\\t\\t\\t\\t\\tthis.removeAttribute( \\\"id\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\tif ( this.options.heightStyle !== \\\"content\\\" ) {\\n\\t\\t\\tcontents.css( \\\"height\\\", \\\"\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"active\\\" ) {\\n\\t\\t\\t// _activate() will handle invalid values and update this.options\\n\\t\\t\\tthis._activate( value );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"event\\\" ) {\\n\\t\\t\\tif ( this.options.event ) {\\n\\t\\t\\t\\tthis._off( this.headers, this.options.event );\\n\\t\\t\\t}\\n\\t\\t\\tthis._setupEvents( value );\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\n\\t\\t// setting collapsible: false while collapsed; open first panel\\n\\t\\tif ( key === \\\"collapsible\\\" && !value && this.options.active === false ) {\\n\\t\\t\\tthis._activate( 0 );\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"icons\\\" ) {\\n\\t\\t\\tthis._destroyIcons();\\n\\t\\t\\tif ( value ) {\\n\\t\\t\\t\\tthis._createIcons();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// #5332 - opacity doesn't cascade to positioned elements in IE\\n\\t\\t// so we need to add the disabled class to the headers and panels\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tthis.headers.add( this.headers.next() )\\n\\t\\t\\t\\t.toggleClass( \\\"ui-state-disabled\\\", !!value );\\n\\t\\t}\\n\\t},\\n\\n\\t_keydown: function( event ) {\\n\\t\\t/*jshint maxcomplexity:15*/\\n\\t\\tif ( event.altKey || event.ctrlKey ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar keyCode = $.ui.keyCode,\\n\\t\\t\\tlength = this.headers.length,\\n\\t\\t\\tcurrentIndex = this.headers.index( event.target ),\\n\\t\\t\\ttoFocus = false;\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\t\\t\\tcase keyCode.RIGHT:\\n\\t\\t\\tcase keyCode.DOWN:\\n\\t\\t\\t\\ttoFocus = this.headers[ ( currentIndex + 1 ) % length ];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase keyCode.LEFT:\\n\\t\\t\\tcase keyCode.UP:\\n\\t\\t\\t\\ttoFocus = this.headers[ ( currentIndex - 1 + length ) % length ];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase keyCode.SPACE:\\n\\t\\t\\tcase keyCode.ENTER:\\n\\t\\t\\t\\tthis._eventHandler( event );\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase keyCode.HOME:\\n\\t\\t\\t\\ttoFocus = this.headers[ 0 ];\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase keyCode.END:\\n\\t\\t\\t\\ttoFocus = this.headers[ length - 1 ];\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\n\\t\\tif ( toFocus ) {\\n\\t\\t\\t$( event.target ).attr( \\\"tabIndex\\\", -1 );\\n\\t\\t\\t$( toFocus ).attr( \\\"tabIndex\\\", 0 );\\n\\t\\t\\ttoFocus.focus();\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t}\\n\\t},\\n\\n\\t_panelKeyDown : function( event ) {\\n\\t\\tif ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {\\n\\t\\t\\t$( event.currentTarget ).prev().focus();\\n\\t\\t}\\n\\t},\\n\\n\\trefresh: function() {\\n\\t\\tvar options = this.options;\\n\\t\\tthis._processPanels();\\n\\n\\t\\t// was collapsed or no panel\\n\\t\\tif ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {\\n\\t\\t\\toptions.active = false;\\n\\t\\t\\tthis.active = $();\\n\\t\\t// active false only when collapsible is true\\n\\t\\t} else if ( options.active === false ) {\\n\\t\\t\\tthis._activate( 0 );\\n\\t\\t// was active, but active panel is gone\\n\\t\\t} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\\n\\t\\t\\t// all remaining panel are disabled\\n\\t\\t\\tif ( this.headers.length === this.headers.find(\\\".ui-state-disabled\\\").length ) {\\n\\t\\t\\t\\toptions.active = false;\\n\\t\\t\\t\\tthis.active = $();\\n\\t\\t\\t// activate previous panel\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis._activate( Math.max( 0, options.active - 1 ) );\\n\\t\\t\\t}\\n\\t\\t// was active, active panel still exists\\n\\t\\t} else {\\n\\t\\t\\t// make sure active index is correct\\n\\t\\t\\toptions.active = this.headers.index( this.active );\\n\\t\\t}\\n\\n\\t\\tthis._destroyIcons();\\n\\n\\t\\tthis._refresh();\\n\\t},\\n\\n\\t_processPanels: function() {\\n\\t\\tthis.headers = this.element.find( this.options.header )\\n\\t\\t\\t.addClass( \\\"ui-accordion-header ui-helper-reset ui-state-default ui-corner-all\\\" );\\n\\n\\t\\tthis.headers.next()\\n\\t\\t\\t.addClass( \\\"ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom\\\" )\\n\\t\\t\\t.filter(\\\":not(.ui-accordion-content-active)\\\")\\n\\t\\t\\t.hide();\\n\\t},\\n\\n\\t_refresh: function() {\\n\\t\\tvar maxHeight,\\n\\t\\t\\toptions = this.options,\\n\\t\\t\\theightStyle = options.heightStyle,\\n\\t\\t\\tparent = this.element.parent(),\\n\\t\\t\\taccordionId = this.accordionId = \\\"ui-accordion-\\\" +\\n\\t\\t\\t\\t(this.element.attr( \\\"id\\\" ) || ++uid);\\n\\n\\t\\tthis.active = this._findActive( options.active )\\n\\t\\t\\t.addClass( \\\"ui-accordion-header-active ui-state-active ui-corner-top\\\" )\\n\\t\\t\\t.removeClass( \\\"ui-corner-all\\\" );\\n\\t\\tthis.active.next()\\n\\t\\t\\t.addClass( \\\"ui-accordion-content-active\\\" )\\n\\t\\t\\t.show();\\n\\n\\t\\tthis.headers\\n\\t\\t\\t.attr( \\\"role\\\", \\\"tab\\\" )\\n\\t\\t\\t.each(function( i ) {\\n\\t\\t\\t\\tvar header = $( this ),\\n\\t\\t\\t\\t\\theaderId = header.attr( \\\"id\\\" ),\\n\\t\\t\\t\\t\\tpanel = header.next(),\\n\\t\\t\\t\\t\\tpanelId = panel.attr( \\\"id\\\" );\\n\\t\\t\\t\\tif ( !headerId ) {\\n\\t\\t\\t\\t\\theaderId = accordionId + \\\"-header-\\\" + i;\\n\\t\\t\\t\\t\\theader.attr( \\\"id\\\", headerId );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !panelId ) {\\n\\t\\t\\t\\t\\tpanelId = accordionId + \\\"-panel-\\\" + i;\\n\\t\\t\\t\\t\\tpanel.attr( \\\"id\\\", panelId );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\theader.attr( \\\"aria-controls\\\", panelId );\\n\\t\\t\\t\\tpanel.attr( \\\"aria-labelledby\\\", headerId );\\n\\t\\t\\t})\\n\\t\\t\\t.next()\\n\\t\\t\\t\\t.attr( \\\"role\\\", \\\"tabpanel\\\" );\\n\\n\\t\\tthis.headers\\n\\t\\t\\t.not( this.active )\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\\"aria-selected\\\": \\\"false\\\",\\n\\t\\t\\t\\ttabIndex: -1\\n\\t\\t\\t})\\n\\t\\t\\t.next()\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"false\\\",\\n\\t\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"true\\\"\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.hide();\\n\\n\\t\\t// make sure at least one header is in the tab order\\n\\t\\tif ( !this.active.length ) {\\n\\t\\t\\tthis.headers.eq( 0 ).attr( \\\"tabIndex\\\", 0 );\\n\\t\\t} else {\\n\\t\\t\\tthis.active.attr({\\n\\t\\t\\t\\t\\\"aria-selected\\\": \\\"true\\\",\\n\\t\\t\\t\\ttabIndex: 0\\n\\t\\t\\t})\\n\\t\\t\\t.next()\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"false\\\"\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis._createIcons();\\n\\n\\t\\tthis._setupEvents( options.event );\\n\\n\\t\\tif ( heightStyle === \\\"fill\\\" ) {\\n\\t\\t\\tmaxHeight = parent.height();\\n\\t\\t\\tthis.element.siblings( \\\":visible\\\" ).each(function() {\\n\\t\\t\\t\\tvar elem = $( this ),\\n\\t\\t\\t\\t\\tposition = elem.css( \\\"position\\\" );\\n\\n\\t\\t\\t\\tif ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxHeight -= elem.outerHeight( true );\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.headers.each(function() {\\n\\t\\t\\t\\tmaxHeight -= $( this ).outerHeight( true );\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.headers.next()\\n\\t\\t\\t\\t.each(function() {\\n\\t\\t\\t\\t\\t$( this ).height( Math.max( 0, maxHeight -\\n\\t\\t\\t\\t\\t\\t$( this ).innerHeight() + $( this ).height() ) );\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.css( \\\"overflow\\\", \\\"auto\\\" );\\n\\t\\t} else if ( heightStyle === \\\"auto\\\" ) {\\n\\t\\t\\tmaxHeight = 0;\\n\\t\\t\\tthis.headers.next()\\n\\t\\t\\t\\t.each(function() {\\n\\t\\t\\t\\t\\tmaxHeight = Math.max( maxHeight, $( this ).css( \\\"height\\\", \\\"\\\" ).height() );\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.height( maxHeight );\\n\\t\\t}\\n\\t},\\n\\n\\t_activate: function( index ) {\\n\\t\\tvar active = this._findActive( index )[ 0 ];\\n\\n\\t\\t// trying to activate the already active panel\\n\\t\\tif ( active === this.active[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// trying to collapse, simulate a click on the currently active header\\n\\t\\tactive = active || this.active[ 0 ];\\n\\n\\t\\tthis._eventHandler({\\n\\t\\t\\ttarget: active,\\n\\t\\t\\tcurrentTarget: active,\\n\\t\\t\\tpreventDefault: $.noop\\n\\t\\t});\\n\\t},\\n\\n\\t_findActive: function( selector ) {\\n\\t\\treturn typeof selector === \\\"number\\\" ? this.headers.eq( selector ) : $();\\n\\t},\\n\\n\\t_setupEvents: function( event ) {\\n\\t\\tvar events = {\\n\\t\\t\\tkeydown: \\\"_keydown\\\"\\n\\t\\t};\\n\\t\\tif ( event ) {\\n\\t\\t\\t$.each( event.split(\\\" \\\"), function( index, eventName ) {\\n\\t\\t\\t\\tevents[ eventName ] = \\\"_eventHandler\\\";\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis._off( this.headers.add( this.headers.next() ) );\\n\\t\\tthis._on( this.headers, events );\\n\\t\\tthis._on( this.headers.next(), { keydown: \\\"_panelKeyDown\\\" });\\n\\t\\tthis._hoverable( this.headers );\\n\\t\\tthis._focusable( this.headers );\\n\\t},\\n\\n\\t_eventHandler: function( event ) {\\n\\t\\tvar options = this.options,\\n\\t\\t\\tactive = this.active,\\n\\t\\t\\tclicked = $( event.currentTarget ),\\n\\t\\t\\tclickedIsActive = clicked[ 0 ] === active[ 0 ],\\n\\t\\t\\tcollapsing = clickedIsActive && options.collapsible,\\n\\t\\t\\ttoShow = collapsing ? $() : clicked.next(),\\n\\t\\t\\ttoHide = active.next(),\\n\\t\\t\\teventData = {\\n\\t\\t\\t\\toldHeader: active,\\n\\t\\t\\t\\toldPanel: toHide,\\n\\t\\t\\t\\tnewHeader: collapsing ? $() : clicked,\\n\\t\\t\\t\\tnewPanel: toShow\\n\\t\\t\\t};\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif (\\n\\t\\t\\t\\t// click on active header, but not collapsible\\n\\t\\t\\t\\t( clickedIsActive && !options.collapsible ) ||\\n\\t\\t\\t\\t// allow canceling activation\\n\\t\\t\\t\\t( this._trigger( \\\"beforeActivate\\\", event, eventData ) === false ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\toptions.active = collapsing ? false : this.headers.index( clicked );\\n\\n\\t\\t// when the call to ._toggle() comes after the class changes\\n\\t\\t// it causes a very odd bug in IE 8 (see #6720)\\n\\t\\tthis.active = clickedIsActive ? $() : clicked;\\n\\t\\tthis._toggle( eventData );\\n\\n\\t\\t// switch classes\\n\\t\\t// corner classes on the previously active header stay after the animation\\n\\t\\tactive.removeClass( \\\"ui-accordion-header-active ui-state-active\\\" );\\n\\t\\tif ( options.icons ) {\\n\\t\\t\\tactive.children( \\\".ui-accordion-header-icon\\\" )\\n\\t\\t\\t\\t.removeClass( options.icons.activeHeader )\\n\\t\\t\\t\\t.addClass( options.icons.header );\\n\\t\\t}\\n\\n\\t\\tif ( !clickedIsActive ) {\\n\\t\\t\\tclicked\\n\\t\\t\\t\\t.removeClass( \\\"ui-corner-all\\\" )\\n\\t\\t\\t\\t.addClass( \\\"ui-accordion-header-active ui-state-active ui-corner-top\\\" );\\n\\t\\t\\tif ( options.icons ) {\\n\\t\\t\\t\\tclicked.children( \\\".ui-accordion-header-icon\\\" )\\n\\t\\t\\t\\t\\t.removeClass( options.icons.header )\\n\\t\\t\\t\\t\\t.addClass( options.icons.activeHeader );\\n\\t\\t\\t}\\n\\n\\t\\t\\tclicked\\n\\t\\t\\t\\t.next()\\n\\t\\t\\t\\t.addClass( \\\"ui-accordion-content-active\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\t_toggle: function( data ) {\\n\\t\\tvar toShow = data.newPanel,\\n\\t\\t\\ttoHide = this.prevShow.length ? this.prevShow : data.oldPanel;\\n\\n\\t\\t// handle activating a panel during the animation for another activation\\n\\t\\tthis.prevShow.add( this.prevHide ).stop( true, true );\\n\\t\\tthis.prevShow = toShow;\\n\\t\\tthis.prevHide = toHide;\\n\\n\\t\\tif ( this.options.animate ) {\\n\\t\\t\\tthis._animate( toShow, toHide, data );\\n\\t\\t} else {\\n\\t\\t\\ttoHide.hide();\\n\\t\\t\\ttoShow.show();\\n\\t\\t\\tthis._toggleComplete( data );\\n\\t\\t}\\n\\n\\t\\ttoHide.attr({\\n\\t\\t\\t\\\"aria-expanded\\\": \\\"false\\\",\\n\\t\\t\\t\\\"aria-hidden\\\": \\\"true\\\"\\n\\t\\t});\\n\\t\\ttoHide.prev().attr( \\\"aria-selected\\\", \\\"false\\\" );\\n\\t\\t// if we're switching panels, remove the old header from the tab order\\n\\t\\t// if we're opening from collapsed state, remove the previous header from the tab order\\n\\t\\t// if we're collapsing, then keep the collapsing header in the tab order\\n\\t\\tif ( toShow.length && toHide.length ) {\\n\\t\\t\\ttoHide.prev().attr( \\\"tabIndex\\\", -1 );\\n\\t\\t} else if ( toShow.length ) {\\n\\t\\t\\tthis.headers.filter(function() {\\n\\t\\t\\t\\treturn $( this ).attr( \\\"tabIndex\\\" ) === 0;\\n\\t\\t\\t})\\n\\t\\t\\t.attr( \\\"tabIndex\\\", -1 );\\n\\t\\t}\\n\\n\\t\\ttoShow\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"false\\\"\\n\\t\\t\\t})\\n\\t\\t\\t.prev()\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\t\\\"aria-selected\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\ttabIndex: 0\\n\\t\\t\\t\\t});\\n\\t},\\n\\n\\t_animate: function( toShow, toHide, data ) {\\n\\t\\tvar total, easing, duration,\\n\\t\\t\\tthat = this,\\n\\t\\t\\tadjust = 0,\\n\\t\\t\\tdown = toShow.length &&\\n\\t\\t\\t\\t( !toHide.length || ( toShow.index() < toHide.index() ) ),\\n\\t\\t\\tanimate = this.options.animate || {},\\n\\t\\t\\toptions = down && animate.down || animate,\\n\\t\\t\\tcomplete = function() {\\n\\t\\t\\t\\tthat._toggleComplete( data );\\n\\t\\t\\t};\\n\\n\\t\\tif ( typeof options === \\\"number\\\" ) {\\n\\t\\t\\tduration = options;\\n\\t\\t}\\n\\t\\tif ( typeof options === \\\"string\\\" ) {\\n\\t\\t\\teasing = options;\\n\\t\\t}\\n\\t\\t// fall back from options to animation in case of partial down settings\\n\\t\\teasing = easing || options.easing || animate.easing;\\n\\t\\tduration = duration || options.duration || animate.duration;\\n\\n\\t\\tif ( !toHide.length ) {\\n\\t\\t\\treturn toShow.animate( showProps, duration, easing, complete );\\n\\t\\t}\\n\\t\\tif ( !toShow.length ) {\\n\\t\\t\\treturn toHide.animate( hideProps, duration, easing, complete );\\n\\t\\t}\\n\\n\\t\\ttotal = toShow.show().outerHeight();\\n\\t\\ttoHide.animate( hideProps, {\\n\\t\\t\\tduration: duration,\\n\\t\\t\\teasing: easing,\\n\\t\\t\\tstep: function( now, fx ) {\\n\\t\\t\\t\\tfx.now = Math.round( now );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\ttoShow\\n\\t\\t\\t.hide()\\n\\t\\t\\t.animate( showProps, {\\n\\t\\t\\t\\tduration: duration,\\n\\t\\t\\t\\teasing: easing,\\n\\t\\t\\t\\tcomplete: complete,\\n\\t\\t\\t\\tstep: function( now, fx ) {\\n\\t\\t\\t\\t\\tfx.now = Math.round( now );\\n\\t\\t\\t\\t\\tif ( fx.prop !== \\\"height\\\" ) {\\n\\t\\t\\t\\t\\t\\tadjust += fx.now;\\n\\t\\t\\t\\t\\t} else if ( that.options.heightStyle !== \\\"content\\\" ) {\\n\\t\\t\\t\\t\\t\\tfx.now = Math.round( total - toHide.outerHeight() - adjust );\\n\\t\\t\\t\\t\\t\\tadjust = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t},\\n\\n\\t_toggleComplete: function( data ) {\\n\\t\\tvar toHide = data.oldPanel;\\n\\n\\t\\ttoHide\\n\\t\\t\\t.removeClass( \\\"ui-accordion-content-active\\\" )\\n\\t\\t\\t.prev()\\n\\t\\t\\t\\t.removeClass( \\\"ui-corner-top\\\" )\\n\\t\\t\\t\\t.addClass( \\\"ui-corner-all\\\" );\\n\\n\\t\\t// Work around for rendering bug in IE (#5421)\\n\\t\\tif ( toHide.length ) {\\n\\t\\t\\ttoHide.parent()[0].className = toHide.parent()[0].className;\\n\\t\\t}\\n\\n\\t\\tthis._trigger( \\\"activate\\\", null, data );\\n\\t}\\n});\\n\\n})( jQuery );\\n\\n(function( $, undefined ) {\\n\\n// used to prevent race conditions with remote data sources\\nvar requestIndex = 0;\\n\\n$.widget( \\\"ui.autocomplete\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\tdefaultElement: \\\"<input>\\\",\\n\\toptions: {\\n\\t\\tappendTo: null,\\n\\t\\tautoFocus: false,\\n\\t\\tdelay: 300,\\n\\t\\tminLength: 1,\\n\\t\\tposition: {\\n\\t\\t\\tmy: \\\"left top\\\",\\n\\t\\t\\tat: \\\"left bottom\\\",\\n\\t\\t\\tcollision: \\\"none\\\"\\n\\t\\t},\\n\\t\\tsource: null,\\n\\n\\t\\t// callbacks\\n\\t\\tchange: null,\\n\\t\\tclose: null,\\n\\t\\tfocus: null,\\n\\t\\topen: null,\\n\\t\\tresponse: null,\\n\\t\\tsearch: null,\\n\\t\\tselect: null\\n\\t},\\n\\n\\tpending: 0,\\n\\n\\t_create: function() {\\n\\t\\t// Some browsers only repeat keydown events, not keypress events,\\n\\t\\t// so we use the suppressKeyPress flag to determine if we've already\\n\\t\\t// handled the keydown event. #7269\\n\\t\\t// Unfortunately the code for & in keypress is the same as the up arrow,\\n\\t\\t// so we use the suppressKeyPressRepeat flag to avoid handling keypress\\n\\t\\t// events when we know the keydown event was used to modify the\\n\\t\\t// search term. #7799\\n\\t\\tvar suppressKeyPress, suppressKeyPressRepeat, suppressInput,\\n\\t\\t\\tnodeName = this.element[0].nodeName.toLowerCase(),\\n\\t\\t\\tisTextarea = nodeName === \\\"textarea\\\",\\n\\t\\t\\tisInput = nodeName === \\\"input\\\";\\n\\n\\t\\tthis.isMultiLine =\\n\\t\\t\\t// Textareas are always multi-line\\n\\t\\t\\tisTextarea ? true :\\n\\t\\t\\t// Inputs are always single-line, even if inside a contentEditable element\\n\\t\\t\\t// IE also treats inputs as contentEditable\\n\\t\\t\\tisInput ? false :\\n\\t\\t\\t// All other element types are determined by whether or not they're contentEditable\\n\\t\\t\\tthis.element.prop( \\\"isContentEditable\\\" );\\n\\n\\t\\tthis.valueMethod = this.element[ isTextarea || isInput ? \\\"val\\\" : \\\"text\\\" ];\\n\\t\\tthis.isNewMenu = true;\\n\\n\\t\\tthis.element\\n\\t\\t\\t.addClass( \\\"ui-autocomplete-input\\\" )\\n\\t\\t\\t.attr( \\\"autocomplete\\\", \\\"off\\\" );\\n\\n\\t\\tthis._on( this.element, {\\n\\t\\t\\tkeydown: function( event ) {\\n\\t\\t\\t\\t/*jshint maxcomplexity:15*/\\n\\t\\t\\t\\tif ( this.element.prop( \\\"readOnly\\\" ) ) {\\n\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\tsuppressInput = true;\\n\\t\\t\\t\\t\\tsuppressKeyPressRepeat = true;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tsuppressKeyPress = false;\\n\\t\\t\\t\\tsuppressInput = false;\\n\\t\\t\\t\\tsuppressKeyPressRepeat = false;\\n\\t\\t\\t\\tvar keyCode = $.ui.keyCode;\\n\\t\\t\\t\\tswitch( event.keyCode ) {\\n\\t\\t\\t\\tcase keyCode.PAGE_UP:\\n\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\tthis._move( \\\"previousPage\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.PAGE_DOWN:\\n\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\tthis._move( \\\"nextPage\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.UP:\\n\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\tthis._keyEvent( \\\"previous\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.DOWN:\\n\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\tthis._keyEvent( \\\"next\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.ENTER:\\n\\t\\t\\t\\tcase keyCode.NUMPAD_ENTER:\\n\\t\\t\\t\\t\\t// when menu is open and has focus\\n\\t\\t\\t\\t\\tif ( this.menu.active ) {\\n\\t\\t\\t\\t\\t\\t// #6055 - Opera still allows the keypress to occur\\n\\t\\t\\t\\t\\t\\t// which causes forms to submit\\n\\t\\t\\t\\t\\t\\tsuppressKeyPress = true;\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\tthis.menu.select( event );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.TAB:\\n\\t\\t\\t\\t\\tif ( this.menu.active ) {\\n\\t\\t\\t\\t\\t\\tthis.menu.select( event );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.ESCAPE:\\n\\t\\t\\t\\t\\tif ( this.menu.element.is( \\\":visible\\\" ) ) {\\n\\t\\t\\t\\t\\t\\tthis._value( this.term );\\n\\t\\t\\t\\t\\t\\tthis.close( event );\\n\\t\\t\\t\\t\\t\\t// Different browsers have different default behavior for escape\\n\\t\\t\\t\\t\\t\\t// Single press can mean undo or clear\\n\\t\\t\\t\\t\\t\\t// Double press in IE means clear the whole form\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\tsuppressKeyPressRepeat = true;\\n\\t\\t\\t\\t\\t// search timeout should be triggered before the input value is changed\\n\\t\\t\\t\\t\\tthis._searchTimeout( event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tkeypress: function( event ) {\\n\\t\\t\\t\\tif ( suppressKeyPress ) {\\n\\t\\t\\t\\t\\tsuppressKeyPress = false;\\n\\t\\t\\t\\t\\tif ( !this.isMultiLine || this.menu.element.is( \\\":visible\\\" ) ) {\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( suppressKeyPressRepeat ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// replicate some key handlers to allow them to repeat in Firefox and Opera\\n\\t\\t\\t\\tvar keyCode = $.ui.keyCode;\\n\\t\\t\\t\\tswitch( event.keyCode ) {\\n\\t\\t\\t\\tcase keyCode.PAGE_UP:\\n\\t\\t\\t\\t\\tthis._move( \\\"previousPage\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.PAGE_DOWN:\\n\\t\\t\\t\\t\\tthis._move( \\\"nextPage\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.UP:\\n\\t\\t\\t\\t\\tthis._keyEvent( \\\"previous\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase keyCode.DOWN:\\n\\t\\t\\t\\t\\tthis._keyEvent( \\\"next\\\", event );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tinput: function( event ) {\\n\\t\\t\\t\\tif ( suppressInput ) {\\n\\t\\t\\t\\t\\tsuppressInput = false;\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis._searchTimeout( event );\\n\\t\\t\\t},\\n\\t\\t\\tfocus: function() {\\n\\t\\t\\t\\tthis.selectedItem = null;\\n\\t\\t\\t\\tthis.previous = this._value();\\n\\t\\t\\t},\\n\\t\\t\\tblur: function( event ) {\\n\\t\\t\\t\\tif ( this.cancelBlur ) {\\n\\t\\t\\t\\t\\tdelete this.cancelBlur;\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tclearTimeout( this.searching );\\n\\t\\t\\t\\tthis.close( event );\\n\\t\\t\\t\\tthis._change( event );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis._initSource();\\n\\t\\tthis.menu = $( \\\"<ul>\\\" )\\n\\t\\t\\t.addClass( \\\"ui-autocomplete ui-front\\\" )\\n\\t\\t\\t.appendTo( this._appendTo() )\\n\\t\\t\\t.menu({\\n\\t\\t\\t\\t// disable ARIA support, the live region takes care of that\\n\\t\\t\\t\\trole: null\\n\\t\\t\\t})\\n\\t\\t\\t.hide()\\n\\t\\t\\t.data( \\\"ui-menu\\\" );\\n\\n\\t\\tthis._on( this.menu.element, {\\n\\t\\t\\tmousedown: function( event ) {\\n\\t\\t\\t\\t// prevent moving focus out of the text field\\n\\t\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\t\\t// IE doesn't prevent moving focus even with event.preventDefault()\\n\\t\\t\\t\\t// so we set a flag to know when we should ignore the blur event\\n\\t\\t\\t\\tthis.cancelBlur = true;\\n\\t\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t\\tdelete this.cancelBlur;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t// clicking on the scrollbar causes focus to shift to the body\\n\\t\\t\\t\\t// but we can't detect a mouseup or a click immediately afterward\\n\\t\\t\\t\\t// so we have to track the next mousedown and close the menu if\\n\\t\\t\\t\\t// the user clicks somewhere outside of the autocomplete\\n\\t\\t\\t\\tvar menuElement = this.menu.element[ 0 ];\\n\\t\\t\\t\\tif ( !$( event.target ).closest( \\\".ui-menu-item\\\" ).length ) {\\n\\t\\t\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t\\t\\tvar that = this;\\n\\t\\t\\t\\t\\t\\tthis.document.one( \\\"mousedown\\\", function( event ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( event.target !== that.element[ 0 ] &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tevent.target !== menuElement &&\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t!$.contains( menuElement, event.target ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tthat.close();\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tmenufocus: function( event, ui ) {\\n\\t\\t\\t\\t// support: Firefox\\n\\t\\t\\t\\t// Prevent accidental activation of menu items in Firefox (#7024 #9118)\\n\\t\\t\\t\\tif ( this.isNewMenu ) {\\n\\t\\t\\t\\t\\tthis.isNewMenu = false;\\n\\t\\t\\t\\t\\tif ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {\\n\\t\\t\\t\\t\\t\\tthis.menu.blur();\\n\\n\\t\\t\\t\\t\\t\\tthis.document.one( \\\"mousemove\\\", function() {\\n\\t\\t\\t\\t\\t\\t\\t$( event.target ).trigger( event.originalEvent );\\n\\t\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar item = ui.item.data( \\\"ui-autocomplete-item\\\" );\\n\\t\\t\\t\\tif ( false !== this._trigger( \\\"focus\\\", event, { item: item } ) ) {\\n\\t\\t\\t\\t\\t// use value to match what will end up in the input, if it was a key event\\n\\t\\t\\t\\t\\tif ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {\\n\\t\\t\\t\\t\\t\\tthis._value( item.value );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Normally the input is populated with the item's value as the\\n\\t\\t\\t\\t\\t// menu is navigated, causing screen readers to notice a change and\\n\\t\\t\\t\\t\\t// announce the item. Since the focus event was canceled, this doesn't\\n\\t\\t\\t\\t\\t// happen, so we update the live region so that screen readers can\\n\\t\\t\\t\\t\\t// still notice the change and announce it.\\n\\t\\t\\t\\t\\tthis.liveRegion.text( item.value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tmenuselect: function( event, ui ) {\\n\\t\\t\\t\\tvar item = ui.item.data( \\\"ui-autocomplete-item\\\" ),\\n\\t\\t\\t\\t\\tprevious = this.previous;\\n\\n\\t\\t\\t\\t// only trigger when focus was lost (click on menu)\\n\\t\\t\\t\\tif ( this.element[0] !== this.document[0].activeElement ) {\\n\\t\\t\\t\\t\\tthis.element.focus();\\n\\t\\t\\t\\t\\tthis.previous = previous;\\n\\t\\t\\t\\t\\t// #6109 - IE triggers two focus events and the second\\n\\t\\t\\t\\t\\t// is asynchronous, so we need to reset the previous\\n\\t\\t\\t\\t\\t// term synchronously and asynchronously :-(\\n\\t\\t\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t\\t\\tthis.previous = previous;\\n\\t\\t\\t\\t\\t\\tthis.selectedItem = item;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( false !== this._trigger( \\\"select\\\", event, { item: item } ) ) {\\n\\t\\t\\t\\t\\tthis._value( item.value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// reset the term after the select event\\n\\t\\t\\t\\t// this allows custom select handling to work properly\\n\\t\\t\\t\\tthis.term = this._value();\\n\\n\\t\\t\\t\\tthis.close( event );\\n\\t\\t\\t\\tthis.selectedItem = item;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.liveRegion = $( \\\"<span>\\\", {\\n\\t\\t\\t\\trole: \\\"status\\\",\\n\\t\\t\\t\\t\\\"aria-live\\\": \\\"polite\\\"\\n\\t\\t\\t})\\n\\t\\t\\t.addClass( \\\"ui-helper-hidden-accessible\\\" )\\n\\t\\t\\t.insertBefore( this.element );\\n\\n\\t\\t// turning off autocomplete prevents the browser from remembering the\\n\\t\\t// value when navigating through history, so we re-enable autocomplete\\n\\t\\t// if the page is unloaded before the widget is destroyed. #7790\\n\\t\\tthis._on( this.window, {\\n\\t\\t\\tbeforeunload: function() {\\n\\t\\t\\t\\tthis.element.removeAttr( \\\"autocomplete\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tclearTimeout( this.searching );\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-autocomplete-input\\\" )\\n\\t\\t\\t.removeAttr( \\\"autocomplete\\\" );\\n\\t\\tthis.menu.element.remove();\\n\\t\\tthis.liveRegion.remove();\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tthis._super( key, value );\\n\\t\\tif ( key === \\\"source\\\" ) {\\n\\t\\t\\tthis._initSource();\\n\\t\\t}\\n\\t\\tif ( key === \\\"appendTo\\\" ) {\\n\\t\\t\\tthis.menu.element.appendTo( this._appendTo() );\\n\\t\\t}\\n\\t\\tif ( key === \\\"disabled\\\" && value && this.xhr ) {\\n\\t\\t\\tthis.xhr.abort();\\n\\t\\t}\\n\\t},\\n\\n\\t_appendTo: function() {\\n\\t\\tvar element = this.options.appendTo;\\n\\n\\t\\tif ( element ) {\\n\\t\\t\\telement = element.jquery || element.nodeType ?\\n\\t\\t\\t\\t$( element ) :\\n\\t\\t\\t\\tthis.document.find( element ).eq( 0 );\\n\\t\\t}\\n\\n\\t\\tif ( !element ) {\\n\\t\\t\\telement = this.element.closest( \\\".ui-front\\\" );\\n\\t\\t}\\n\\n\\t\\tif ( !element.length ) {\\n\\t\\t\\telement = this.document[0].body;\\n\\t\\t}\\n\\n\\t\\treturn element;\\n\\t},\\n\\n\\t_initSource: function() {\\n\\t\\tvar array, url,\\n\\t\\t\\tthat = this;\\n\\t\\tif ( $.isArray(this.options.source) ) {\\n\\t\\t\\tarray = this.options.source;\\n\\t\\t\\tthis.source = function( request, response ) {\\n\\t\\t\\t\\tresponse( $.ui.autocomplete.filter( array, request.term ) );\\n\\t\\t\\t};\\n\\t\\t} else if ( typeof this.options.source === \\\"string\\\" ) {\\n\\t\\t\\turl = this.options.source;\\n\\t\\t\\tthis.source = function( request, response ) {\\n\\t\\t\\t\\tif ( that.xhr ) {\\n\\t\\t\\t\\t\\tthat.xhr.abort();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthat.xhr = $.ajax({\\n\\t\\t\\t\\t\\turl: url,\\n\\t\\t\\t\\t\\tdata: request,\\n\\t\\t\\t\\t\\tdataType: \\\"json\\\",\\n\\t\\t\\t\\t\\tsuccess: function( data ) {\\n\\t\\t\\t\\t\\t\\tresponse( data );\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\terror: function() {\\n\\t\\t\\t\\t\\t\\tresponse( [] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tthis.source = this.options.source;\\n\\t\\t}\\n\\t},\\n\\n\\t_searchTimeout: function( event ) {\\n\\t\\tclearTimeout( this.searching );\\n\\t\\tthis.searching = this._delay(function() {\\n\\t\\t\\t// only search if the value has changed\\n\\t\\t\\tif ( this.term !== this._value() ) {\\n\\t\\t\\t\\tthis.selectedItem = null;\\n\\t\\t\\t\\tthis.search( null, event );\\n\\t\\t\\t}\\n\\t\\t}, this.options.delay );\\n\\t},\\n\\n\\tsearch: function( value, event ) {\\n\\t\\tvalue = value != null ? value : this._value();\\n\\n\\t\\t// always save the actual value, not the one passed as an argument\\n\\t\\tthis.term = this._value();\\n\\n\\t\\tif ( value.length < this.options.minLength ) {\\n\\t\\t\\treturn this.close( event );\\n\\t\\t}\\n\\n\\t\\tif ( this._trigger( \\\"search\\\", event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\treturn this._search( value );\\n\\t},\\n\\n\\t_search: function( value ) {\\n\\t\\tthis.pending++;\\n\\t\\tthis.element.addClass( \\\"ui-autocomplete-loading\\\" );\\n\\t\\tthis.cancelSearch = false;\\n\\n\\t\\tthis.source( { term: value }, this._response() );\\n\\t},\\n\\n\\t_response: function() {\\n\\t\\tvar that = this,\\n\\t\\t\\tindex = ++requestIndex;\\n\\n\\t\\treturn function( content ) {\\n\\t\\t\\tif ( index === requestIndex ) {\\n\\t\\t\\t\\tthat.__response( content );\\n\\t\\t\\t}\\n\\n\\t\\t\\tthat.pending--;\\n\\t\\t\\tif ( !that.pending ) {\\n\\t\\t\\t\\tthat.element.removeClass( \\\"ui-autocomplete-loading\\\" );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t},\\n\\n\\t__response: function( content ) {\\n\\t\\tif ( content ) {\\n\\t\\t\\tcontent = this._normalize( content );\\n\\t\\t}\\n\\t\\tthis._trigger( \\\"response\\\", null, { content: content } );\\n\\t\\tif ( !this.options.disabled && content && content.length && !this.cancelSearch ) {\\n\\t\\t\\tthis._suggest( content );\\n\\t\\t\\tthis._trigger( \\\"open\\\" );\\n\\t\\t} else {\\n\\t\\t\\t// use ._close() instead of .close() so we don't cancel future searches\\n\\t\\t\\tthis._close();\\n\\t\\t}\\n\\t},\\n\\n\\tclose: function( event ) {\\n\\t\\tthis.cancelSearch = true;\\n\\t\\tthis._close( event );\\n\\t},\\n\\n\\t_close: function( event ) {\\n\\t\\tif ( this.menu.element.is( \\\":visible\\\" ) ) {\\n\\t\\t\\tthis.menu.element.hide();\\n\\t\\t\\tthis.menu.blur();\\n\\t\\t\\tthis.isNewMenu = true;\\n\\t\\t\\tthis._trigger( \\\"close\\\", event );\\n\\t\\t}\\n\\t},\\n\\n\\t_change: function( event ) {\\n\\t\\tif ( this.previous !== this._value() ) {\\n\\t\\t\\tthis._trigger( \\\"change\\\", event, { item: this.selectedItem } );\\n\\t\\t}\\n\\t},\\n\\n\\t_normalize: function( items ) {\\n\\t\\t// assume all items have the right format when the first item is complete\\n\\t\\tif ( items.length && items[0].label && items[0].value ) {\\n\\t\\t\\treturn items;\\n\\t\\t}\\n\\t\\treturn $.map( items, function( item ) {\\n\\t\\t\\tif ( typeof item === \\\"string\\\" ) {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tlabel: item,\\n\\t\\t\\t\\t\\tvalue: item\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\treturn $.extend({\\n\\t\\t\\t\\tlabel: item.label || item.value,\\n\\t\\t\\t\\tvalue: item.value || item.label\\n\\t\\t\\t}, item );\\n\\t\\t});\\n\\t},\\n\\n\\t_suggest: function( items ) {\\n\\t\\tvar ul = this.menu.element.empty();\\n\\t\\tthis._renderMenu( ul, items );\\n\\t\\tthis.isNewMenu = true;\\n\\t\\tthis.menu.refresh();\\n\\n\\t\\t// size and position menu\\n\\t\\tul.show();\\n\\t\\tthis._resizeMenu();\\n\\t\\tul.position( $.extend({\\n\\t\\t\\tof: this.element\\n\\t\\t}, this.options.position ));\\n\\n\\t\\tif ( this.options.autoFocus ) {\\n\\t\\t\\tthis.menu.next();\\n\\t\\t}\\n\\t},\\n\\n\\t_resizeMenu: function() {\\n\\t\\tvar ul = this.menu.element;\\n\\t\\tul.outerWidth( Math.max(\\n\\t\\t\\t// Firefox wraps long text (possibly a rounding bug)\\n\\t\\t\\t// so we add 1px to avoid the wrapping (#7513)\\n\\t\\t\\tul.width( \\\"\\\" ).outerWidth() + 1,\\n\\t\\t\\tthis.element.outerWidth()\\n\\t\\t) );\\n\\t},\\n\\n\\t_renderMenu: function( ul, items ) {\\n\\t\\tvar that = this;\\n\\t\\t$.each( items, function( index, item ) {\\n\\t\\t\\tthat._renderItemData( ul, item );\\n\\t\\t});\\n\\t},\\n\\n\\t_renderItemData: function( ul, item ) {\\n\\t\\treturn this._renderItem( ul, item ).data( \\\"ui-autocomplete-item\\\", item );\\n\\t},\\n\\n\\t_renderItem: function( ul, item ) {\\n\\t\\treturn $( \\\"<li>\\\" )\\n\\t\\t\\t.append( $( \\\"<a>\\\" ).text( item.label ) )\\n\\t\\t\\t.appendTo( ul );\\n\\t},\\n\\n\\t_move: function( direction, event ) {\\n\\t\\tif ( !this.menu.element.is( \\\":visible\\\" ) ) {\\n\\t\\t\\tthis.search( null, event );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( this.menu.isFirstItem() && /^previous/.test( direction ) ||\\n\\t\\t\\t\\tthis.menu.isLastItem() && /^next/.test( direction ) ) {\\n\\t\\t\\tthis._value( this.term );\\n\\t\\t\\tthis.menu.blur();\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis.menu[ direction ]( event );\\n\\t},\\n\\n\\twidget: function() {\\n\\t\\treturn this.menu.element;\\n\\t},\\n\\n\\t_value: function() {\\n\\t\\treturn this.valueMethod.apply( this.element, arguments );\\n\\t},\\n\\n\\t_keyEvent: function( keyEvent, event ) {\\n\\t\\tif ( !this.isMultiLine || this.menu.element.is( \\\":visible\\\" ) ) {\\n\\t\\t\\tthis._move( keyEvent, event );\\n\\n\\t\\t\\t// prevents moving cursor to beginning/end of the text field in some browsers\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t}\\n\\t}\\n});\\n\\n$.extend( $.ui.autocomplete, {\\n\\tescapeRegex: function( value ) {\\n\\t\\treturn value.replace(/[\\\\-\\\\[\\\\]{}()*+?.,\\\\\\\\\\\\^$|#\\\\s]/g, \\\"\\\\\\\\$&\\\");\\n\\t},\\n\\tfilter: function(array, term) {\\n\\t\\tvar matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), \\\"i\\\" );\\n\\t\\treturn $.grep( array, function(value) {\\n\\t\\t\\treturn matcher.test( value.label || value.value || value );\\n\\t\\t});\\n\\t}\\n});\\n\\n\\n// live region extension, adding a `messages` option\\n// NOTE: This is an experimental API. We are still investigating\\n// a full solution for string manipulation and internationalization.\\n$.widget( \\\"ui.autocomplete\\\", $.ui.autocomplete, {\\n\\toptions: {\\n\\t\\tmessages: {\\n\\t\\t\\tnoResults: \\\"No search results.\\\",\\n\\t\\t\\tresults: function( amount ) {\\n\\t\\t\\t\\treturn amount + ( amount > 1 ? \\\" results are\\\" : \\\" result is\\\" ) +\\n\\t\\t\\t\\t\\t\\\" available, use up and down arrow keys to navigate.\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t__response: function( content ) {\\n\\t\\tvar message;\\n\\t\\tthis._superApply( arguments );\\n\\t\\tif ( this.options.disabled || this.cancelSearch ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( content && content.length ) {\\n\\t\\t\\tmessage = this.options.messages.results( content.length );\\n\\t\\t} else {\\n\\t\\t\\tmessage = this.options.messages.noResults;\\n\\t\\t}\\n\\t\\tthis.liveRegion.text( message );\\n\\t}\\n});\\n\\n}( jQuery ));\\n\\n(function( $, undefined ) {\\n\\nvar lastActive, startXPos, startYPos, clickDragged,\\n\\tbaseClasses = \\\"ui-button ui-widget ui-state-default ui-corner-all\\\",\\n\\tstateClasses = \\\"ui-state-hover ui-state-active \\\",\\n\\ttypeClasses = \\\"ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only\\\",\\n\\tformResetHandler = function() {\\n\\t\\tvar form = $( this );\\n\\t\\tsetTimeout(function() {\\n\\t\\t\\tform.find( \\\":ui-button\\\" ).button( \\\"refresh\\\" );\\n\\t\\t}, 1 );\\n\\t},\\n\\tradioGroup = function( radio ) {\\n\\t\\tvar name = radio.name,\\n\\t\\t\\tform = radio.form,\\n\\t\\t\\tradios = $( [] );\\n\\t\\tif ( name ) {\\n\\t\\t\\tname = name.replace( /'/g, \\\"\\\\\\\\'\\\" );\\n\\t\\t\\tif ( form ) {\\n\\t\\t\\t\\tradios = $( form ).find( \\\"[name='\\\" + name + \\\"']\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tradios = $( \\\"[name='\\\" + name + \\\"']\\\", radio.ownerDocument )\\n\\t\\t\\t\\t\\t.filter(function() {\\n\\t\\t\\t\\t\\t\\treturn !this.form;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn radios;\\n\\t};\\n\\n$.widget( \\\"ui.button\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\tdefaultElement: \\\"<button>\\\",\\n\\toptions: {\\n\\t\\tdisabled: null,\\n\\t\\ttext: true,\\n\\t\\tlabel: null,\\n\\t\\ticons: {\\n\\t\\t\\tprimary: null,\\n\\t\\t\\tsecondary: null\\n\\t\\t}\\n\\t},\\n\\t_create: function() {\\n\\t\\tthis.element.closest( \\\"form\\\" )\\n\\t\\t\\t.unbind( \\\"reset\\\" + this.eventNamespace )\\n\\t\\t\\t.bind( \\\"reset\\\" + this.eventNamespace, formResetHandler );\\n\\n\\t\\tif ( typeof this.options.disabled !== \\\"boolean\\\" ) {\\n\\t\\t\\tthis.options.disabled = !!this.element.prop( \\\"disabled\\\" );\\n\\t\\t} else {\\n\\t\\t\\tthis.element.prop( \\\"disabled\\\", this.options.disabled );\\n\\t\\t}\\n\\n\\t\\tthis._determineButtonType();\\n\\t\\tthis.hasTitle = !!this.buttonElement.attr( \\\"title\\\" );\\n\\n\\t\\tvar that = this,\\n\\t\\t\\toptions = this.options,\\n\\t\\t\\ttoggleButton = this.type === \\\"checkbox\\\" || this.type === \\\"radio\\\",\\n\\t\\t\\tactiveClass = !toggleButton ? \\\"ui-state-active\\\" : \\\"\\\",\\n\\t\\t\\tfocusClass = \\\"ui-state-focus\\\";\\n\\n\\t\\tif ( options.label === null ) {\\n\\t\\t\\toptions.label = (this.type === \\\"input\\\" ? this.buttonElement.val() : this.buttonElement.html());\\n\\t\\t}\\n\\n\\t\\tthis._hoverable( this.buttonElement );\\n\\n\\t\\tthis.buttonElement\\n\\t\\t\\t.addClass( baseClasses )\\n\\t\\t\\t.attr( \\\"role\\\", \\\"button\\\" )\\n\\t\\t\\t.bind( \\\"mouseenter\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( this === lastActive ) {\\n\\t\\t\\t\\t\\t$( this ).addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t.bind( \\\"mouseleave\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$( this ).removeClass( activeClass );\\n\\t\\t\\t})\\n\\t\\t\\t.bind( \\\"click\\\" + this.eventNamespace, function( event ) {\\n\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\tevent.stopImmediatePropagation();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\tthis.element\\n\\t\\t\\t.bind( \\\"focus\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\t// no need to check disabled, focus won't be triggered anyway\\n\\t\\t\\t\\tthat.buttonElement.addClass( focusClass );\\n\\t\\t\\t})\\n\\t\\t\\t.bind( \\\"blur\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tthat.buttonElement.removeClass( focusClass );\\n\\t\\t\\t});\\n\\n\\t\\tif ( toggleButton ) {\\n\\t\\t\\tthis.element.bind( \\\"change\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( clickDragged ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthat.refresh();\\n\\t\\t\\t});\\n\\t\\t\\t// if mouse moves between mousedown and mouseup (drag) set clickDragged flag\\n\\t\\t\\t// prevents issue where button state changes but checkbox/radio checked state\\n\\t\\t\\t// does not in Firefox (see ticket #6970)\\n\\t\\t\\tthis.buttonElement\\n\\t\\t\\t\\t.bind( \\\"mousedown\\\" + this.eventNamespace, function( event ) {\\n\\t\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tclickDragged = false;\\n\\t\\t\\t\\t\\tstartXPos = event.pageX;\\n\\t\\t\\t\\t\\tstartYPos = event.pageY;\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.bind( \\\"mouseup\\\" + this.eventNamespace, function( event ) {\\n\\t\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( startXPos !== event.pageX || startYPos !== event.pageY ) {\\n\\t\\t\\t\\t\\t\\tclickDragged = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif ( this.type === \\\"checkbox\\\" ) {\\n\\t\\t\\tthis.buttonElement.bind( \\\"click\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( options.disabled || clickDragged ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else if ( this.type === \\\"radio\\\" ) {\\n\\t\\t\\tthis.buttonElement.bind( \\\"click\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( options.disabled || clickDragged ) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$( this ).addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\tthat.buttonElement.attr( \\\"aria-pressed\\\", \\\"true\\\" );\\n\\n\\t\\t\\t\\tvar radio = that.element[ 0 ];\\n\\t\\t\\t\\tradioGroup( radio )\\n\\t\\t\\t\\t\\t.not( radio )\\n\\t\\t\\t\\t\\t.map(function() {\\n\\t\\t\\t\\t\\t\\treturn $( this ).button( \\\"widget\\\" )[ 0 ];\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\t.removeClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t\\t\\t.attr( \\\"aria-pressed\\\", \\\"false\\\" );\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.buttonElement\\n\\t\\t\\t\\t.bind( \\\"mousedown\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$( this ).addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t\\tlastActive = this;\\n\\t\\t\\t\\t\\tthat.document.one( \\\"mouseup\\\", function() {\\n\\t\\t\\t\\t\\t\\tlastActive = null;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.bind( \\\"mouseup\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t$( this ).removeClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.bind( \\\"keydown\\\" + this.eventNamespace, function(event) {\\n\\t\\t\\t\\t\\tif ( options.disabled ) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {\\n\\t\\t\\t\\t\\t\\t$( this ).addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t// see #8559, we bind to blur here in case the button element loses\\n\\t\\t\\t\\t// focus between keydown and keyup, it would be left in an \\\"active\\\" state\\n\\t\\t\\t\\t.bind( \\\"keyup\\\" + this.eventNamespace + \\\" blur\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\t\\t$( this ).removeClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\tif ( this.buttonElement.is(\\\"a\\\") ) {\\n\\t\\t\\t\\tthis.buttonElement.keyup(function(event) {\\n\\t\\t\\t\\t\\tif ( event.keyCode === $.ui.keyCode.SPACE ) {\\n\\t\\t\\t\\t\\t\\t// TODO pass through original event correctly (just as 2nd argument doesn't work)\\n\\t\\t\\t\\t\\t\\t$( this ).click();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// TODO: pull out $.Widget's handling for the disabled option into\\n\\t\\t// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can\\n\\t\\t// be overridden by individual plugins\\n\\t\\tthis._setOption( \\\"disabled\\\", options.disabled );\\n\\t\\tthis._resetButton();\\n\\t},\\n\\n\\t_determineButtonType: function() {\\n\\t\\tvar ancestor, labelSelector, checked;\\n\\n\\t\\tif ( this.element.is(\\\"[type=checkbox]\\\") ) {\\n\\t\\t\\tthis.type = \\\"checkbox\\\";\\n\\t\\t} else if ( this.element.is(\\\"[type=radio]\\\") ) {\\n\\t\\t\\tthis.type = \\\"radio\\\";\\n\\t\\t} else if ( this.element.is(\\\"input\\\") ) {\\n\\t\\t\\tthis.type = \\\"input\\\";\\n\\t\\t} else {\\n\\t\\t\\tthis.type = \\\"button\\\";\\n\\t\\t}\\n\\n\\t\\tif ( this.type === \\\"checkbox\\\" || this.type === \\\"radio\\\" ) {\\n\\t\\t\\t// we don't search against the document in case the element\\n\\t\\t\\t// is disconnected from the DOM\\n\\t\\t\\tancestor = this.element.parents().last();\\n\\t\\t\\tlabelSelector = \\\"label[for='\\\" + this.element.attr(\\\"id\\\") + \\\"']\\\";\\n\\t\\t\\tthis.buttonElement = ancestor.find( labelSelector );\\n\\t\\t\\tif ( !this.buttonElement.length ) {\\n\\t\\t\\t\\tancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();\\n\\t\\t\\t\\tthis.buttonElement = ancestor.filter( labelSelector );\\n\\t\\t\\t\\tif ( !this.buttonElement.length ) {\\n\\t\\t\\t\\t\\tthis.buttonElement = ancestor.find( labelSelector );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis.element.addClass( \\\"ui-helper-hidden-accessible\\\" );\\n\\n\\t\\t\\tchecked = this.element.is( \\\":checked\\\" );\\n\\t\\t\\tif ( checked ) {\\n\\t\\t\\t\\tthis.buttonElement.addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t}\\n\\t\\t\\tthis.buttonElement.prop( \\\"aria-pressed\\\", checked );\\n\\t\\t} else {\\n\\t\\t\\tthis.buttonElement = this.element;\\n\\t\\t}\\n\\t},\\n\\n\\twidget: function() {\\n\\t\\treturn this.buttonElement;\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-helper-hidden-accessible\\\" );\\n\\t\\tthis.buttonElement\\n\\t\\t\\t.removeClass( baseClasses + \\\" \\\" + stateClasses + \\\" \\\" + typeClasses )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-pressed\\\" )\\n\\t\\t\\t.html( this.buttonElement.find(\\\".ui-button-text\\\").html() );\\n\\n\\t\\tif ( !this.hasTitle ) {\\n\\t\\t\\tthis.buttonElement.removeAttr( \\\"title\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tthis._super( key, value );\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tif ( value ) {\\n\\t\\t\\t\\tthis.element.prop( \\\"disabled\\\", true );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.element.prop( \\\"disabled\\\", false );\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis._resetButton();\\n\\t},\\n\\n\\trefresh: function() {\\n\\t\\t//See #8237 & #8828\\n\\t\\tvar isDisabled = this.element.is( \\\"input, button\\\" ) ? this.element.is( \\\":disabled\\\" ) : this.element.hasClass( \\\"ui-button-disabled\\\" );\\n\\n\\t\\tif ( isDisabled !== this.options.disabled ) {\\n\\t\\t\\tthis._setOption( \\\"disabled\\\", isDisabled );\\n\\t\\t}\\n\\t\\tif ( this.type === \\\"radio\\\" ) {\\n\\t\\t\\tradioGroup( this.element[0] ).each(function() {\\n\\t\\t\\t\\tif ( $( this ).is( \\\":checked\\\" ) ) {\\n\\t\\t\\t\\t\\t$( this ).button( \\\"widget\\\" )\\n\\t\\t\\t\\t\\t\\t.addClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t\\t\\t\\t.attr( \\\"aria-pressed\\\", \\\"true\\\" );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$( this ).button( \\\"widget\\\" )\\n\\t\\t\\t\\t\\t\\t.removeClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t\\t\\t\\t.attr( \\\"aria-pressed\\\", \\\"false\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else if ( this.type === \\\"checkbox\\\" ) {\\n\\t\\t\\tif ( this.element.is( \\\":checked\\\" ) ) {\\n\\t\\t\\t\\tthis.buttonElement\\n\\t\\t\\t\\t\\t.addClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t\\t\\t.attr( \\\"aria-pressed\\\", \\\"true\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.buttonElement\\n\\t\\t\\t\\t\\t.removeClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t\\t\\t.attr( \\\"aria-pressed\\\", \\\"false\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t_resetButton: function() {\\n\\t\\tif ( this.type === \\\"input\\\" ) {\\n\\t\\t\\tif ( this.options.label ) {\\n\\t\\t\\t\\tthis.element.val( this.options.label );\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvar buttonElement = this.buttonElement.removeClass( typeClasses ),\\n\\t\\t\\tbuttonText = $( \\\"<span></span>\\\", this.document[0] )\\n\\t\\t\\t\\t.addClass( \\\"ui-button-text\\\" )\\n\\t\\t\\t\\t.html( this.options.label )\\n\\t\\t\\t\\t.appendTo( buttonElement.empty() )\\n\\t\\t\\t\\t.text(),\\n\\t\\t\\ticons = this.options.icons,\\n\\t\\t\\tmultipleIcons = icons.primary && icons.secondary,\\n\\t\\t\\tbuttonClasses = [];\\n\\n\\t\\tif ( icons.primary || icons.secondary ) {\\n\\t\\t\\tif ( this.options.text ) {\\n\\t\\t\\t\\tbuttonClasses.push( \\\"ui-button-text-icon\\\" + ( multipleIcons ? \\\"s\\\" : ( icons.primary ? \\\"-primary\\\" : \\\"-secondary\\\" ) ) );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( icons.primary ) {\\n\\t\\t\\t\\tbuttonElement.prepend( \\\"<span class='ui-button-icon-primary ui-icon \\\" + icons.primary + \\\"'></span>\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( icons.secondary ) {\\n\\t\\t\\t\\tbuttonElement.append( \\\"<span class='ui-button-icon-secondary ui-icon \\\" + icons.secondary + \\\"'></span>\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( !this.options.text ) {\\n\\t\\t\\t\\tbuttonClasses.push( multipleIcons ? \\\"ui-button-icons-only\\\" : \\\"ui-button-icon-only\\\" );\\n\\n\\t\\t\\t\\tif ( !this.hasTitle ) {\\n\\t\\t\\t\\t\\tbuttonElement.attr( \\\"title\\\", $.trim( buttonText ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tbuttonClasses.push( \\\"ui-button-text-only\\\" );\\n\\t\\t}\\n\\t\\tbuttonElement.addClass( buttonClasses.join( \\\" \\\" ) );\\n\\t}\\n});\\n\\n$.widget( \\\"ui.buttonset\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\titems: \\\"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)\\\"\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tthis.element.addClass( \\\"ui-buttonset\\\" );\\n\\t},\\n\\n\\t_init: function() {\\n\\t\\tthis.refresh();\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tthis.buttons.button( \\\"option\\\", key, value );\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\t},\\n\\n\\trefresh: function() {\\n\\t\\tvar rtl = this.element.css( \\\"direction\\\" ) === \\\"rtl\\\";\\n\\n\\t\\tthis.buttons = this.element.find( this.options.items )\\n\\t\\t\\t.filter( \\\":ui-button\\\" )\\n\\t\\t\\t\\t.button( \\\"refresh\\\" )\\n\\t\\t\\t.end()\\n\\t\\t\\t.not( \\\":ui-button\\\" )\\n\\t\\t\\t\\t.button()\\n\\t\\t\\t.end()\\n\\t\\t\\t.map(function() {\\n\\t\\t\\t\\treturn $( this ).button( \\\"widget\\\" )[ 0 ];\\n\\t\\t\\t})\\n\\t\\t\\t\\t.removeClass( \\\"ui-corner-all ui-corner-left ui-corner-right\\\" )\\n\\t\\t\\t\\t.filter( \\\":first\\\" )\\n\\t\\t\\t\\t\\t.addClass( rtl ? \\\"ui-corner-right\\\" : \\\"ui-corner-left\\\" )\\n\\t\\t\\t\\t.end()\\n\\t\\t\\t\\t.filter( \\\":last\\\" )\\n\\t\\t\\t\\t\\t.addClass( rtl ? \\\"ui-corner-left\\\" : \\\"ui-corner-right\\\" )\\n\\t\\t\\t\\t.end()\\n\\t\\t\\t.end();\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element.removeClass( \\\"ui-buttonset\\\" );\\n\\t\\tthis.buttons\\n\\t\\t\\t.map(function() {\\n\\t\\t\\t\\treturn $( this ).button( \\\"widget\\\" )[ 0 ];\\n\\t\\t\\t})\\n\\t\\t\\t\\t.removeClass( \\\"ui-corner-left ui-corner-right\\\" )\\n\\t\\t\\t.end()\\n\\t\\t\\t.button( \\\"destroy\\\" );\\n\\t}\\n});\\n\\n}( jQuery ) );\\n\\n(function( $, undefined ) {\\n\\n$.extend($.ui, { datepicker: { version: \\\"1.10.3\\\" } });\\n\\nvar PROP_NAME = \\\"datepicker\\\",\\n\\tinstActive;\\n\\n/* Date picker manager.\\n   Use the singleton instance of this class, $.datepicker, to interact with the date picker.\\n   Settings for (groups of) date pickers are maintained in an instance object,\\n   allowing multiple different settings on the same page. */\\n\\nfunction Datepicker() {\\n\\tthis._curInst = null; // The current instance in use\\n\\tthis._keyEvent = false; // If the last event was a key event\\n\\tthis._disabledInputs = []; // List of date picker inputs that have been disabled\\n\\tthis._datepickerShowing = false; // True if the popup picker is showing , false if not\\n\\tthis._inDialog = false; // True if showing within a \\\"dialog\\\", false if not\\n\\tthis._mainDivId = \\\"ui-datepicker-div\\\"; // The ID of the main datepicker division\\n\\tthis._inlineClass = \\\"ui-datepicker-inline\\\"; // The name of the inline marker class\\n\\tthis._appendClass = \\\"ui-datepicker-append\\\"; // The name of the append marker class\\n\\tthis._triggerClass = \\\"ui-datepicker-trigger\\\"; // The name of the trigger marker class\\n\\tthis._dialogClass = \\\"ui-datepicker-dialog\\\"; // The name of the dialog marker class\\n\\tthis._disableClass = \\\"ui-datepicker-disabled\\\"; // The name of the disabled covering marker class\\n\\tthis._unselectableClass = \\\"ui-datepicker-unselectable\\\"; // The name of the unselectable cell marker class\\n\\tthis._currentClass = \\\"ui-datepicker-current-day\\\"; // The name of the current day marker class\\n\\tthis._dayOverClass = \\\"ui-datepicker-days-cell-over\\\"; // The name of the day hover marker class\\n\\tthis.regional = []; // Available regional settings, indexed by language code\\n\\tthis.regional[\\\"\\\"] = { // Default regional settings\\n\\t\\tcloseText: \\\"Done\\\", // Display text for close link\\n\\t\\tprevText: \\\"Prev\\\", // Display text for previous month link\\n\\t\\tnextText: \\\"Next\\\", // Display text for next month link\\n\\t\\tcurrentText: \\\"Today\\\", // Display text for current month link\\n\\t\\tmonthNames: [\\\"January\\\",\\\"February\\\",\\\"March\\\",\\\"April\\\",\\\"May\\\",\\\"June\\\",\\n\\t\\t\\t\\\"July\\\",\\\"August\\\",\\\"September\\\",\\\"October\\\",\\\"November\\\",\\\"December\\\"], // Names of months for drop-down and formatting\\n\\t\\tmonthNamesShort: [\\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", \\\"Apr\\\", \\\"May\\\", \\\"Jun\\\", \\\"Jul\\\", \\\"Aug\\\", \\\"Sep\\\", \\\"Oct\\\", \\\"Nov\\\", \\\"Dec\\\"], // For formatting\\n\\t\\tdayNames: [\\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\"], // For formatting\\n\\t\\tdayNamesShort: [\\\"Sun\\\", \\\"Mon\\\", \\\"Tue\\\", \\\"Wed\\\", \\\"Thu\\\", \\\"Fri\\\", \\\"Sat\\\"], // For formatting\\n\\t\\tdayNamesMin: [\\\"Su\\\",\\\"Mo\\\",\\\"Tu\\\",\\\"We\\\",\\\"Th\\\",\\\"Fr\\\",\\\"Sa\\\"], // Column headings for days starting at Sunday\\n\\t\\tweekHeader: \\\"Wk\\\", // Column header for week of the year\\n\\t\\tdateFormat: \\\"mm/dd/yy\\\", // See format options on parseDate\\n\\t\\tfirstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...\\n\\t\\tisRTL: false, // True if right-to-left language, false if left-to-right\\n\\t\\tshowMonthAfterYear: false, // True if the year select precedes month, false for month then year\\n\\t\\tyearSuffix: \\\"\\\" // Additional text to append to the year in the month headers\\n\\t};\\n\\tthis._defaults = { // Global defaults for all the date picker instances\\n\\t\\tshowOn: \\\"focus\\\", // \\\"focus\\\" for popup on focus,\\n\\t\\t\\t// \\\"button\\\" for trigger button, or \\\"both\\\" for either\\n\\t\\tshowAnim: \\\"fadeIn\\\", // Name of jQuery animation for popup\\n\\t\\tshowOptions: {}, // Options for enhanced animations\\n\\t\\tdefaultDate: null, // Used when field is blank: actual date,\\n\\t\\t\\t// +/-number for offset from today, null for today\\n\\t\\tappendText: \\\"\\\", // Display text following the input box, e.g. showing the format\\n\\t\\tbuttonText: \\\"...\\\", // Text for trigger button\\n\\t\\tbuttonImage: \\\"\\\", // URL for trigger button image\\n\\t\\tbuttonImageOnly: false, // True if the image appears alone, false if it appears on a button\\n\\t\\thideIfNoPrevNext: false, // True to hide next/previous month links\\n\\t\\t\\t// if not applicable, false to just disable them\\n\\t\\tnavigationAsDateFormat: false, // True if date formatting applied to prev/today/next links\\n\\t\\tgotoCurrent: false, // True if today link goes back to current selection instead\\n\\t\\tchangeMonth: false, // True if month can be selected directly, false if only prev/next\\n\\t\\tchangeYear: false, // True if year can be selected directly, false if only prev/next\\n\\t\\tyearRange: \\\"c-10:c+10\\\", // Range of years to display in drop-down,\\n\\t\\t\\t// either relative to today's year (-nn:+nn), relative to currently displayed year\\n\\t\\t\\t// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)\\n\\t\\tshowOtherMonths: false, // True to show dates in other months, false to leave blank\\n\\t\\tselectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable\\n\\t\\tshowWeek: false, // True to show week of the year, false to not show it\\n\\t\\tcalculateWeek: this.iso8601Week, // How to calculate the week of the year,\\n\\t\\t\\t// takes a Date and returns the number of the week for it\\n\\t\\tshortYearCutoff: \\\"+10\\\", // Short year values < this are in the current century,\\n\\t\\t\\t// > this are in the previous century,\\n\\t\\t\\t// string value starting with \\\"+\\\" for current year + value\\n\\t\\tminDate: null, // The earliest selectable date, or null for no limit\\n\\t\\tmaxDate: null, // The latest selectable date, or null for no limit\\n\\t\\tduration: \\\"fast\\\", // Duration of display/closure\\n\\t\\tbeforeShowDay: null, // Function that takes a date and returns an array with\\n\\t\\t\\t// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or \\\"\\\",\\n\\t\\t\\t// [2] = cell title (optional), e.g. $.datepicker.noWeekends\\n\\t\\tbeforeShow: null, // Function that takes an input field and\\n\\t\\t\\t// returns a set of custom settings for the date picker\\n\\t\\tonSelect: null, // Define a callback function when a date is selected\\n\\t\\tonChangeMonthYear: null, // Define a callback function when the month or year is changed\\n\\t\\tonClose: null, // Define a callback function when the datepicker is closed\\n\\t\\tnumberOfMonths: 1, // Number of months to show at a time\\n\\t\\tshowCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)\\n\\t\\tstepMonths: 1, // Number of months to step back/forward\\n\\t\\tstepBigMonths: 12, // Number of months to step back/forward for the big links\\n\\t\\taltField: \\\"\\\", // Selector for an alternate field to store selected dates into\\n\\t\\taltFormat: \\\"\\\", // The date format to use for the alternate field\\n\\t\\tconstrainInput: true, // The input is constrained by the current date format\\n\\t\\tshowButtonPanel: false, // True to show button panel, false to not show it\\n\\t\\tautoSize: false, // True to size the input for the date format, false to leave as is\\n\\t\\tdisabled: false // The initial disabled state\\n\\t};\\n\\t$.extend(this._defaults, this.regional[\\\"\\\"]);\\n\\tthis.dpDiv = bindHover($(\\\"<div id='\\\" + this._mainDivId + \\\"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\\\"));\\n}\\n\\n$.extend(Datepicker.prototype, {\\n\\t/* Class name added to elements to indicate already configured with a date picker. */\\n\\tmarkerClassName: \\\"hasDatepicker\\\",\\n\\n\\t//Keep track of the maximum number of rows displayed (see #7043)\\n\\tmaxRows: 4,\\n\\n\\t// TODO rename to \\\"widget\\\" when switching to widget factory\\n\\t_widgetDatepicker: function() {\\n\\t\\treturn this.dpDiv;\\n\\t},\\n\\n\\t/* Override the default settings for all instances of the date picker.\\n\\t * @param  settings  object - the new settings to use as defaults (anonymous object)\\n\\t * @return the manager object\\n\\t */\\n\\tsetDefaults: function(settings) {\\n\\t\\textendRemove(this._defaults, settings || {});\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/* Attach the date picker to a jQuery selection.\\n\\t * @param  target\\telement - the target input field or division or span\\n\\t * @param  settings  object - the new settings to use for this date picker instance (anonymous)\\n\\t */\\n\\t_attachDatepicker: function(target, settings) {\\n\\t\\tvar nodeName, inline, inst;\\n\\t\\tnodeName = target.nodeName.toLowerCase();\\n\\t\\tinline = (nodeName === \\\"div\\\" || nodeName === \\\"span\\\");\\n\\t\\tif (!target.id) {\\n\\t\\t\\tthis.uuid += 1;\\n\\t\\t\\ttarget.id = \\\"dp\\\" + this.uuid;\\n\\t\\t}\\n\\t\\tinst = this._newInst($(target), inline);\\n\\t\\tinst.settings = $.extend({}, settings || {});\\n\\t\\tif (nodeName === \\\"input\\\") {\\n\\t\\t\\tthis._connectDatepicker(target, inst);\\n\\t\\t} else if (inline) {\\n\\t\\t\\tthis._inlineDatepicker(target, inst);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Create a new instance object. */\\n\\t_newInst: function(target, inline) {\\n\\t\\tvar id = target[0].id.replace(/([^A-Za-z0-9_\\\\-])/g, \\\"\\\\\\\\\\\\\\\\$1\\\"); // escape jQuery meta chars\\n\\t\\treturn {id: id, input: target, // associated target\\n\\t\\t\\tselectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection\\n\\t\\t\\tdrawMonth: 0, drawYear: 0, // month being drawn\\n\\t\\t\\tinline: inline, // is datepicker inline or not\\n\\t\\t\\tdpDiv: (!inline ? this.dpDiv : // presentation div\\n\\t\\t\\tbindHover($(\\\"<div class='\\\" + this._inlineClass + \\\" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>\\\")))};\\n\\t},\\n\\n\\t/* Attach the date picker to an input field. */\\n\\t_connectDatepicker: function(target, inst) {\\n\\t\\tvar input = $(target);\\n\\t\\tinst.append = $([]);\\n\\t\\tinst.trigger = $([]);\\n\\t\\tif (input.hasClass(this.markerClassName)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis._attachments(input, inst);\\n\\t\\tinput.addClass(this.markerClassName).keydown(this._doKeyDown).\\n\\t\\t\\tkeypress(this._doKeyPress).keyup(this._doKeyUp);\\n\\t\\tthis._autoSize(inst);\\n\\t\\t$.data(target, PROP_NAME, inst);\\n\\t\\t//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)\\n\\t\\tif( inst.settings.disabled ) {\\n\\t\\t\\tthis._disableDatepicker( target );\\n\\t\\t}\\n\\t},\\n\\n\\t/* Make attachments based on settings. */\\n\\t_attachments: function(input, inst) {\\n\\t\\tvar showOn, buttonText, buttonImage,\\n\\t\\t\\tappendText = this._get(inst, \\\"appendText\\\"),\\n\\t\\t\\tisRTL = this._get(inst, \\\"isRTL\\\");\\n\\n\\t\\tif (inst.append) {\\n\\t\\t\\tinst.append.remove();\\n\\t\\t}\\n\\t\\tif (appendText) {\\n\\t\\t\\tinst.append = $(\\\"<span class='\\\" + this._appendClass + \\\"'>\\\" + appendText + \\\"</span>\\\");\\n\\t\\t\\tinput[isRTL ? \\\"before\\\" : \\\"after\\\"](inst.append);\\n\\t\\t}\\n\\n\\t\\tinput.unbind(\\\"focus\\\", this._showDatepicker);\\n\\n\\t\\tif (inst.trigger) {\\n\\t\\t\\tinst.trigger.remove();\\n\\t\\t}\\n\\n\\t\\tshowOn = this._get(inst, \\\"showOn\\\");\\n\\t\\tif (showOn === \\\"focus\\\" || showOn === \\\"both\\\") { // pop-up date picker when in the marked field\\n\\t\\t\\tinput.focus(this._showDatepicker);\\n\\t\\t}\\n\\t\\tif (showOn === \\\"button\\\" || showOn === \\\"both\\\") { // pop-up date picker when button clicked\\n\\t\\t\\tbuttonText = this._get(inst, \\\"buttonText\\\");\\n\\t\\t\\tbuttonImage = this._get(inst, \\\"buttonImage\\\");\\n\\t\\t\\tinst.trigger = $(this._get(inst, \\\"buttonImageOnly\\\") ?\\n\\t\\t\\t\\t$(\\\"<img/>\\\").addClass(this._triggerClass).\\n\\t\\t\\t\\t\\tattr({ src: buttonImage, alt: buttonText, title: buttonText }) :\\n\\t\\t\\t\\t$(\\\"<button type='button'></button>\\\").addClass(this._triggerClass).\\n\\t\\t\\t\\t\\thtml(!buttonImage ? buttonText : $(\\\"<img/>\\\").attr(\\n\\t\\t\\t\\t\\t{ src:buttonImage, alt:buttonText, title:buttonText })));\\n\\t\\t\\tinput[isRTL ? \\\"before\\\" : \\\"after\\\"](inst.trigger);\\n\\t\\t\\tinst.trigger.click(function() {\\n\\t\\t\\t\\tif ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {\\n\\t\\t\\t\\t\\t$.datepicker._hideDatepicker();\\n\\t\\t\\t\\t} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {\\n\\t\\t\\t\\t\\t$.datepicker._hideDatepicker();\\n\\t\\t\\t\\t\\t$.datepicker._showDatepicker(input[0]);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$.datepicker._showDatepicker(input[0]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t/* Apply the maximum length for the date format. */\\n\\t_autoSize: function(inst) {\\n\\t\\tif (this._get(inst, \\\"autoSize\\\") && !inst.inline) {\\n\\t\\t\\tvar findMax, max, maxI, i,\\n\\t\\t\\t\\tdate = new Date(2009, 12 - 1, 20), // Ensure double digits\\n\\t\\t\\t\\tdateFormat = this._get(inst, \\\"dateFormat\\\");\\n\\n\\t\\t\\tif (dateFormat.match(/[DM]/)) {\\n\\t\\t\\t\\tfindMax = function(names) {\\n\\t\\t\\t\\t\\tmax = 0;\\n\\t\\t\\t\\t\\tmaxI = 0;\\n\\t\\t\\t\\t\\tfor (i = 0; i < names.length; i++) {\\n\\t\\t\\t\\t\\t\\tif (names[i].length > max) {\\n\\t\\t\\t\\t\\t\\t\\tmax = names[i].length;\\n\\t\\t\\t\\t\\t\\t\\tmaxI = i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn maxI;\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tdate.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?\\n\\t\\t\\t\\t\\t\\\"monthNames\\\" : \\\"monthNamesShort\\\"))));\\n\\t\\t\\t\\tdate.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?\\n\\t\\t\\t\\t\\t\\\"dayNames\\\" : \\\"dayNamesShort\\\"))) + 20 - date.getDay());\\n\\t\\t\\t}\\n\\t\\t\\tinst.input.attr(\\\"size\\\", this._formatDate(inst, date).length);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Attach an inline date picker to a div. */\\n\\t_inlineDatepicker: function(target, inst) {\\n\\t\\tvar divSpan = $(target);\\n\\t\\tif (divSpan.hasClass(this.markerClassName)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tdivSpan.addClass(this.markerClassName).append(inst.dpDiv);\\n\\t\\t$.data(target, PROP_NAME, inst);\\n\\t\\tthis._setDate(inst, this._getDefaultDate(inst), true);\\n\\t\\tthis._updateDatepicker(inst);\\n\\t\\tthis._updateAlternate(inst);\\n\\t\\t//If disabled option is true, disable the datepicker before showing it (see ticket #5665)\\n\\t\\tif( inst.settings.disabled ) {\\n\\t\\t\\tthis._disableDatepicker( target );\\n\\t\\t}\\n\\t\\t// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements\\n\\t\\t// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height\\n\\t\\tinst.dpDiv.css( \\\"display\\\", \\\"block\\\" );\\n\\t},\\n\\n\\t/* Pop-up the date picker in a \\\"dialog\\\" box.\\n\\t * @param  input element - ignored\\n\\t * @param  date\\tstring or Date - the initial date to display\\n\\t * @param  onSelect  function - the function to call when a date is selected\\n\\t * @param  settings  object - update the dialog date picker instance's settings (anonymous object)\\n\\t * @param  pos int[2] - coordinates for the dialog's position within the screen or\\n\\t *\\t\\t\\t\\t\\tevent - with x/y coordinates or\\n\\t *\\t\\t\\t\\t\\tleave empty for default (screen centre)\\n\\t * @return the manager object\\n\\t */\\n\\t_dialogDatepicker: function(input, date, onSelect, settings, pos) {\\n\\t\\tvar id, browserWidth, browserHeight, scrollX, scrollY,\\n\\t\\t\\tinst = this._dialogInst; // internal instance\\n\\n\\t\\tif (!inst) {\\n\\t\\t\\tthis.uuid += 1;\\n\\t\\t\\tid = \\\"dp\\\" + this.uuid;\\n\\t\\t\\tthis._dialogInput = $(\\\"<input type='text' id='\\\" + id +\\n\\t\\t\\t\\t\\\"' style='position: absolute; top: -100px; width: 0px;'/>\\\");\\n\\t\\t\\tthis._dialogInput.keydown(this._doKeyDown);\\n\\t\\t\\t$(\\\"body\\\").append(this._dialogInput);\\n\\t\\t\\tinst = this._dialogInst = this._newInst(this._dialogInput, false);\\n\\t\\t\\tinst.settings = {};\\n\\t\\t\\t$.data(this._dialogInput[0], PROP_NAME, inst);\\n\\t\\t}\\n\\t\\textendRemove(inst.settings, settings || {});\\n\\t\\tdate = (date && date.constructor === Date ? this._formatDate(inst, date) : date);\\n\\t\\tthis._dialogInput.val(date);\\n\\n\\t\\tthis._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);\\n\\t\\tif (!this._pos) {\\n\\t\\t\\tbrowserWidth = document.documentElement.clientWidth;\\n\\t\\t\\tbrowserHeight = document.documentElement.clientHeight;\\n\\t\\t\\tscrollX = document.documentElement.scrollLeft || document.body.scrollLeft;\\n\\t\\t\\tscrollY = document.documentElement.scrollTop || document.body.scrollTop;\\n\\t\\t\\tthis._pos = // should use actual width/height below\\n\\t\\t\\t\\t[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];\\n\\t\\t}\\n\\n\\t\\t// move input on screen for focus, but hidden behind dialog\\n\\t\\tthis._dialogInput.css(\\\"left\\\", (this._pos[0] + 20) + \\\"px\\\").css(\\\"top\\\", this._pos[1] + \\\"px\\\");\\n\\t\\tinst.settings.onSelect = onSelect;\\n\\t\\tthis._inDialog = true;\\n\\t\\tthis.dpDiv.addClass(this._dialogClass);\\n\\t\\tthis._showDatepicker(this._dialogInput[0]);\\n\\t\\tif ($.blockUI) {\\n\\t\\t\\t$.blockUI(this.dpDiv);\\n\\t\\t}\\n\\t\\t$.data(this._dialogInput[0], PROP_NAME, inst);\\n\\t\\treturn this;\\n\\t},\\n\\n\\t/* Detach a datepicker from its control.\\n\\t * @param  target\\telement - the target input field or division or span\\n\\t */\\n\\t_destroyDatepicker: function(target) {\\n\\t\\tvar nodeName,\\n\\t\\t\\t$target = $(target),\\n\\t\\t\\tinst = $.data(target, PROP_NAME);\\n\\n\\t\\tif (!$target.hasClass(this.markerClassName)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tnodeName = target.nodeName.toLowerCase();\\n\\t\\t$.removeData(target, PROP_NAME);\\n\\t\\tif (nodeName === \\\"input\\\") {\\n\\t\\t\\tinst.append.remove();\\n\\t\\t\\tinst.trigger.remove();\\n\\t\\t\\t$target.removeClass(this.markerClassName).\\n\\t\\t\\t\\tunbind(\\\"focus\\\", this._showDatepicker).\\n\\t\\t\\t\\tunbind(\\\"keydown\\\", this._doKeyDown).\\n\\t\\t\\t\\tunbind(\\\"keypress\\\", this._doKeyPress).\\n\\t\\t\\t\\tunbind(\\\"keyup\\\", this._doKeyUp);\\n\\t\\t} else if (nodeName === \\\"div\\\" || nodeName === \\\"span\\\") {\\n\\t\\t\\t$target.removeClass(this.markerClassName).empty();\\n\\t\\t}\\n\\t},\\n\\n\\t/* Enable the date picker to a jQuery selection.\\n\\t * @param  target\\telement - the target input field or division or span\\n\\t */\\n\\t_enableDatepicker: function(target) {\\n\\t\\tvar nodeName, inline,\\n\\t\\t\\t$target = $(target),\\n\\t\\t\\tinst = $.data(target, PROP_NAME);\\n\\n\\t\\tif (!$target.hasClass(this.markerClassName)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tnodeName = target.nodeName.toLowerCase();\\n\\t\\tif (nodeName === \\\"input\\\") {\\n\\t\\t\\ttarget.disabled = false;\\n\\t\\t\\tinst.trigger.filter(\\\"button\\\").\\n\\t\\t\\t\\teach(function() { this.disabled = false; }).end().\\n\\t\\t\\t\\tfilter(\\\"img\\\").css({opacity: \\\"1.0\\\", cursor: \\\"\\\"});\\n\\t\\t} else if (nodeName === \\\"div\\\" || nodeName === \\\"span\\\") {\\n\\t\\t\\tinline = $target.children(\\\".\\\" + this._inlineClass);\\n\\t\\t\\tinline.children().removeClass(\\\"ui-state-disabled\\\");\\n\\t\\t\\tinline.find(\\\"select.ui-datepicker-month, select.ui-datepicker-year\\\").\\n\\t\\t\\t\\tprop(\\\"disabled\\\", false);\\n\\t\\t}\\n\\t\\tthis._disabledInputs = $.map(this._disabledInputs,\\n\\t\\t\\tfunction(value) { return (value === target ? null : value); }); // delete entry\\n\\t},\\n\\n\\t/* Disable the date picker to a jQuery selection.\\n\\t * @param  target\\telement - the target input field or division or span\\n\\t */\\n\\t_disableDatepicker: function(target) {\\n\\t\\tvar nodeName, inline,\\n\\t\\t\\t$target = $(target),\\n\\t\\t\\tinst = $.data(target, PROP_NAME);\\n\\n\\t\\tif (!$target.hasClass(this.markerClassName)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tnodeName = target.nodeName.toLowerCase();\\n\\t\\tif (nodeName === \\\"input\\\") {\\n\\t\\t\\ttarget.disabled = true;\\n\\t\\t\\tinst.trigger.filter(\\\"button\\\").\\n\\t\\t\\t\\teach(function() { this.disabled = true; }).end().\\n\\t\\t\\t\\tfilter(\\\"img\\\").css({opacity: \\\"0.5\\\", cursor: \\\"default\\\"});\\n\\t\\t} else if (nodeName === \\\"div\\\" || nodeName === \\\"span\\\") {\\n\\t\\t\\tinline = $target.children(\\\".\\\" + this._inlineClass);\\n\\t\\t\\tinline.children().addClass(\\\"ui-state-disabled\\\");\\n\\t\\t\\tinline.find(\\\"select.ui-datepicker-month, select.ui-datepicker-year\\\").\\n\\t\\t\\t\\tprop(\\\"disabled\\\", true);\\n\\t\\t}\\n\\t\\tthis._disabledInputs = $.map(this._disabledInputs,\\n\\t\\t\\tfunction(value) { return (value === target ? null : value); }); // delete entry\\n\\t\\tthis._disabledInputs[this._disabledInputs.length] = target;\\n\\t},\\n\\n\\t/* Is the first field in a jQuery collection disabled as a datepicker?\\n\\t * @param  target\\telement - the target input field or division or span\\n\\t * @return boolean - true if disabled, false if enabled\\n\\t */\\n\\t_isDisabledDatepicker: function(target) {\\n\\t\\tif (!target) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (var i = 0; i < this._disabledInputs.length; i++) {\\n\\t\\t\\tif (this._disabledInputs[i] === target) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t},\\n\\n\\t/* Retrieve the instance data for the target control.\\n\\t * @param  target  element - the target input field or division or span\\n\\t * @return  object - the associated instance data\\n\\t * @throws  error if a jQuery problem getting data\\n\\t */\\n\\t_getInst: function(target) {\\n\\t\\ttry {\\n\\t\\t\\treturn $.data(target, PROP_NAME);\\n\\t\\t}\\n\\t\\tcatch (err) {\\n\\t\\t\\tthrow \\\"Missing instance data for this datepicker\\\";\\n\\t\\t}\\n\\t},\\n\\n\\t/* Update or retrieve the settings for a date picker attached to an input field or division.\\n\\t * @param  target  element - the target input field or division or span\\n\\t * @param  name\\tobject - the new settings to update or\\n\\t *\\t\\t\\t\\tstring - the name of the setting to change or retrieve,\\n\\t *\\t\\t\\t\\twhen retrieving also \\\"all\\\" for all instance settings or\\n\\t *\\t\\t\\t\\t\\\"defaults\\\" for all global defaults\\n\\t * @param  value   any - the new value for the setting\\n\\t *\\t\\t\\t\\t(omit if above is an object or to retrieve a value)\\n\\t */\\n\\t_optionDatepicker: function(target, name, value) {\\n\\t\\tvar settings, date, minDate, maxDate,\\n\\t\\t\\tinst = this._getInst(target);\\n\\n\\t\\tif (arguments.length === 2 && typeof name === \\\"string\\\") {\\n\\t\\t\\treturn (name === \\\"defaults\\\" ? $.extend({}, $.datepicker._defaults) :\\n\\t\\t\\t\\t(inst ? (name === \\\"all\\\" ? $.extend({}, inst.settings) :\\n\\t\\t\\t\\tthis._get(inst, name)) : null));\\n\\t\\t}\\n\\n\\t\\tsettings = name || {};\\n\\t\\tif (typeof name === \\\"string\\\") {\\n\\t\\t\\tsettings = {};\\n\\t\\t\\tsettings[name] = value;\\n\\t\\t}\\n\\n\\t\\tif (inst) {\\n\\t\\t\\tif (this._curInst === inst) {\\n\\t\\t\\t\\tthis._hideDatepicker();\\n\\t\\t\\t}\\n\\n\\t\\t\\tdate = this._getDateDatepicker(target, true);\\n\\t\\t\\tminDate = this._getMinMaxDate(inst, \\\"min\\\");\\n\\t\\t\\tmaxDate = this._getMinMaxDate(inst, \\\"max\\\");\\n\\t\\t\\textendRemove(inst.settings, settings);\\n\\t\\t\\t// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided\\n\\t\\t\\tif (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {\\n\\t\\t\\t\\tinst.settings.minDate = this._formatDate(inst, minDate);\\n\\t\\t\\t}\\n\\t\\t\\tif (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {\\n\\t\\t\\t\\tinst.settings.maxDate = this._formatDate(inst, maxDate);\\n\\t\\t\\t}\\n\\t\\t\\tif ( \\\"disabled\\\" in settings ) {\\n\\t\\t\\t\\tif ( settings.disabled ) {\\n\\t\\t\\t\\t\\tthis._disableDatepicker(target);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis._enableDatepicker(target);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis._attachments($(target), inst);\\n\\t\\t\\tthis._autoSize(inst);\\n\\t\\t\\tthis._setDate(inst, date);\\n\\t\\t\\tthis._updateAlternate(inst);\\n\\t\\t\\tthis._updateDatepicker(inst);\\n\\t\\t}\\n\\t},\\n\\n\\t// change method deprecated\\n\\t_changeDatepicker: function(target, name, value) {\\n\\t\\tthis._optionDatepicker(target, name, value);\\n\\t},\\n\\n\\t/* Redraw the date picker attached to an input field or division.\\n\\t * @param  target  element - the target input field or division or span\\n\\t */\\n\\t_refreshDatepicker: function(target) {\\n\\t\\tvar inst = this._getInst(target);\\n\\t\\tif (inst) {\\n\\t\\t\\tthis._updateDatepicker(inst);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Set the dates for a jQuery selection.\\n\\t * @param  target element - the target input field or division or span\\n\\t * @param  date\\tDate - the new date\\n\\t */\\n\\t_setDateDatepicker: function(target, date) {\\n\\t\\tvar inst = this._getInst(target);\\n\\t\\tif (inst) {\\n\\t\\t\\tthis._setDate(inst, date);\\n\\t\\t\\tthis._updateDatepicker(inst);\\n\\t\\t\\tthis._updateAlternate(inst);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Get the date(s) for the first entry in a jQuery selection.\\n\\t * @param  target element - the target input field or division or span\\n\\t * @param  noDefault boolean - true if no default date is to be used\\n\\t * @return Date - the current date\\n\\t */\\n\\t_getDateDatepicker: function(target, noDefault) {\\n\\t\\tvar inst = this._getInst(target);\\n\\t\\tif (inst && !inst.inline) {\\n\\t\\t\\tthis._setDateFromField(inst, noDefault);\\n\\t\\t}\\n\\t\\treturn (inst ? this._getDate(inst) : null);\\n\\t},\\n\\n\\t/* Handle keystrokes. */\\n\\t_doKeyDown: function(event) {\\n\\t\\tvar onSelect, dateStr, sel,\\n\\t\\t\\tinst = $.datepicker._getInst(event.target),\\n\\t\\t\\thandled = true,\\n\\t\\t\\tisRTL = inst.dpDiv.is(\\\".ui-datepicker-rtl\\\");\\n\\n\\t\\tinst._keyEvent = true;\\n\\t\\tif ($.datepicker._datepickerShowing) {\\n\\t\\t\\tswitch (event.keyCode) {\\n\\t\\t\\t\\tcase 9: $.datepicker._hideDatepicker();\\n\\t\\t\\t\\t\\t\\thandled = false;\\n\\t\\t\\t\\t\\t\\tbreak; // hide on tab out\\n\\t\\t\\t\\tcase 13: sel = $(\\\"td.\\\" + $.datepicker._dayOverClass + \\\":not(.\\\" +\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t$.datepicker._currentClass + \\\")\\\", inst.dpDiv);\\n\\t\\t\\t\\t\\t\\tif (sel[0]) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tonSelect = $.datepicker._get(inst, \\\"onSelect\\\");\\n\\t\\t\\t\\t\\t\\tif (onSelect) {\\n\\t\\t\\t\\t\\t\\t\\tdateStr = $.datepicker._formatDate(inst);\\n\\n\\t\\t\\t\\t\\t\\t\\t// trigger custom callback\\n\\t\\t\\t\\t\\t\\t\\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._hideDatepicker();\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn false; // don't submit the form\\n\\t\\t\\t\\tcase 27: $.datepicker._hideDatepicker();\\n\\t\\t\\t\\t\\t\\tbreak; // hide on escape\\n\\t\\t\\t\\tcase 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\\n\\t\\t\\t\\t\\t\\t\\t-$.datepicker._get(inst, \\\"stepBigMonths\\\") :\\n\\t\\t\\t\\t\\t\\t\\t-$.datepicker._get(inst, \\\"stepMonths\\\")), \\\"M\\\");\\n\\t\\t\\t\\t\\t\\tbreak; // previous month/year on page up/+ ctrl\\n\\t\\t\\t\\tcase 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?\\n\\t\\t\\t\\t\\t\\t\\t+$.datepicker._get(inst, \\\"stepBigMonths\\\") :\\n\\t\\t\\t\\t\\t\\t\\t+$.datepicker._get(inst, \\\"stepMonths\\\")), \\\"M\\\");\\n\\t\\t\\t\\t\\t\\tbreak; // next month/year on page down/+ ctrl\\n\\t\\t\\t\\tcase 35: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._clearDate(event.target);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\tbreak; // clear on ctrl or command +end\\n\\t\\t\\t\\tcase 36: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._gotoToday(event.target);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\tbreak; // current on ctrl or command +home\\n\\t\\t\\t\\tcase 37: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), \\\"D\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\t// -1 day on ctrl or command +left\\n\\t\\t\\t\\t\\t\\tif (event.originalEvent.altKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\\n\\t\\t\\t\\t\\t\\t\\t\\t-$.datepicker._get(inst, \\\"stepBigMonths\\\") :\\n\\t\\t\\t\\t\\t\\t\\t\\t-$.datepicker._get(inst, \\\"stepMonths\\\")), \\\"M\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// next month/year on alt +left on Mac\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 38: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, -7, \\\"D\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\tbreak; // -1 week on ctrl or command +up\\n\\t\\t\\t\\tcase 39: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), \\\"D\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\t// +1 day on ctrl or command +right\\n\\t\\t\\t\\t\\t\\tif (event.originalEvent.altKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, (event.ctrlKey ?\\n\\t\\t\\t\\t\\t\\t\\t\\t+$.datepicker._get(inst, \\\"stepBigMonths\\\") :\\n\\t\\t\\t\\t\\t\\t\\t\\t+$.datepicker._get(inst, \\\"stepMonths\\\")), \\\"M\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// next month/year on alt +right\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase 40: if (event.ctrlKey || event.metaKey) {\\n\\t\\t\\t\\t\\t\\t\\t$.datepicker._adjustDate(event.target, +7, \\\"D\\\");\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\thandled = event.ctrlKey || event.metaKey;\\n\\t\\t\\t\\t\\t\\tbreak; // +1 week on ctrl or command +down\\n\\t\\t\\t\\tdefault: handled = false;\\n\\t\\t\\t}\\n\\t\\t} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home\\n\\t\\t\\t$.datepicker._showDatepicker(this);\\n\\t\\t} else {\\n\\t\\t\\thandled = false;\\n\\t\\t}\\n\\n\\t\\tif (handled) {\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tevent.stopPropagation();\\n\\t\\t}\\n\\t},\\n\\n\\t/* Filter entered characters - based on date format. */\\n\\t_doKeyPress: function(event) {\\n\\t\\tvar chars, chr,\\n\\t\\t\\tinst = $.datepicker._getInst(event.target);\\n\\n\\t\\tif ($.datepicker._get(inst, \\\"constrainInput\\\")) {\\n\\t\\t\\tchars = $.datepicker._possibleChars($.datepicker._get(inst, \\\"dateFormat\\\"));\\n\\t\\t\\tchr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);\\n\\t\\t\\treturn event.ctrlKey || event.metaKey || (chr < \\\" \\\" || !chars || chars.indexOf(chr) > -1);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Synchronise manual entry and field/alternate field. */\\n\\t_doKeyUp: function(event) {\\n\\t\\tvar date,\\n\\t\\t\\tinst = $.datepicker._getInst(event.target);\\n\\n\\t\\tif (inst.input.val() !== inst.lastVal) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdate = $.datepicker.parseDate($.datepicker._get(inst, \\\"dateFormat\\\"),\\n\\t\\t\\t\\t\\t(inst.input ? inst.input.val() : null),\\n\\t\\t\\t\\t\\t$.datepicker._getFormatConfig(inst));\\n\\n\\t\\t\\t\\tif (date) { // only if valid\\n\\t\\t\\t\\t\\t$.datepicker._setDateFromField(inst);\\n\\t\\t\\t\\t\\t$.datepicker._updateAlternate(inst);\\n\\t\\t\\t\\t\\t$.datepicker._updateDatepicker(inst);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcatch (err) {\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t},\\n\\n\\t/* Pop-up the date picker for a given input field.\\n\\t * If false returned from beforeShow event handler do not show.\\n\\t * @param  input  element - the input field attached to the date picker or\\n\\t *\\t\\t\\t\\t\\tevent - if triggered by focus\\n\\t */\\n\\t_showDatepicker: function(input) {\\n\\t\\tinput = input.target || input;\\n\\t\\tif (input.nodeName.toLowerCase() !== \\\"input\\\") { // find from button/image trigger\\n\\t\\t\\tinput = $(\\\"input\\\", input.parentNode)[0];\\n\\t\\t}\\n\\n\\t\\tif ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar inst, beforeShow, beforeShowSettings, isFixed,\\n\\t\\t\\toffset, showAnim, duration;\\n\\n\\t\\tinst = $.datepicker._getInst(input);\\n\\t\\tif ($.datepicker._curInst && $.datepicker._curInst !== inst) {\\n\\t\\t\\t$.datepicker._curInst.dpDiv.stop(true, true);\\n\\t\\t\\tif ( inst && $.datepicker._datepickerShowing ) {\\n\\t\\t\\t\\t$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tbeforeShow = $.datepicker._get(inst, \\\"beforeShow\\\");\\n\\t\\tbeforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};\\n\\t\\tif(beforeShowSettings === false){\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\textendRemove(inst.settings, beforeShowSettings);\\n\\n\\t\\tinst.lastVal = null;\\n\\t\\t$.datepicker._lastInput = input;\\n\\t\\t$.datepicker._setDateFromField(inst);\\n\\n\\t\\tif ($.datepicker._inDialog) { // hide cursor\\n\\t\\t\\tinput.value = \\\"\\\";\\n\\t\\t}\\n\\t\\tif (!$.datepicker._pos) { // position below input\\n\\t\\t\\t$.datepicker._pos = $.datepicker._findPos(input);\\n\\t\\t\\t$.datepicker._pos[1] += input.offsetHeight; // add the height\\n\\t\\t}\\n\\n\\t\\tisFixed = false;\\n\\t\\t$(input).parents().each(function() {\\n\\t\\t\\tisFixed |= $(this).css(\\\"position\\\") === \\\"fixed\\\";\\n\\t\\t\\treturn !isFixed;\\n\\t\\t});\\n\\n\\t\\toffset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};\\n\\t\\t$.datepicker._pos = null;\\n\\t\\t//to avoid flashes on Firefox\\n\\t\\tinst.dpDiv.empty();\\n\\t\\t// determine sizing offscreen\\n\\t\\tinst.dpDiv.css({position: \\\"absolute\\\", display: \\\"block\\\", top: \\\"-1000px\\\"});\\n\\t\\t$.datepicker._updateDatepicker(inst);\\n\\t\\t// fix width for dynamic number of date pickers\\n\\t\\t// and adjust position before showing\\n\\t\\toffset = $.datepicker._checkOffset(inst, offset, isFixed);\\n\\t\\tinst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?\\n\\t\\t\\t\\\"static\\\" : (isFixed ? \\\"fixed\\\" : \\\"absolute\\\")), display: \\\"none\\\",\\n\\t\\t\\tleft: offset.left + \\\"px\\\", top: offset.top + \\\"px\\\"});\\n\\n\\t\\tif (!inst.inline) {\\n\\t\\t\\tshowAnim = $.datepicker._get(inst, \\\"showAnim\\\");\\n\\t\\t\\tduration = $.datepicker._get(inst, \\\"duration\\\");\\n\\t\\t\\tinst.dpDiv.zIndex($(input).zIndex()+1);\\n\\t\\t\\t$.datepicker._datepickerShowing = true;\\n\\n\\t\\t\\tif ( $.effects && $.effects.effect[ showAnim ] ) {\\n\\t\\t\\t\\tinst.dpDiv.show(showAnim, $.datepicker._get(inst, \\\"showOptions\\\"), duration);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinst.dpDiv[showAnim || \\\"show\\\"](showAnim ? duration : null);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( $.datepicker._shouldFocusInput( inst ) ) {\\n\\t\\t\\t\\tinst.input.focus();\\n\\t\\t\\t}\\n\\n\\t\\t\\t$.datepicker._curInst = inst;\\n\\t\\t}\\n\\t},\\n\\n\\t/* Generate the date picker content. */\\n\\t_updateDatepicker: function(inst) {\\n\\t\\tthis.maxRows = 4; //Reset the max number of rows being displayed (see #7043)\\n\\t\\tinstActive = inst; // for delegate hover events\\n\\t\\tinst.dpDiv.empty().append(this._generateHTML(inst));\\n\\t\\tthis._attachHandlers(inst);\\n\\t\\tinst.dpDiv.find(\\\".\\\" + this._dayOverClass + \\\" a\\\").mouseover();\\n\\n\\t\\tvar origyearshtml,\\n\\t\\t\\tnumMonths = this._getNumberOfMonths(inst),\\n\\t\\t\\tcols = numMonths[1],\\n\\t\\t\\twidth = 17;\\n\\n\\t\\tinst.dpDiv.removeClass(\\\"ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4\\\").width(\\\"\\\");\\n\\t\\tif (cols > 1) {\\n\\t\\t\\tinst.dpDiv.addClass(\\\"ui-datepicker-multi-\\\" + cols).css(\\\"width\\\", (width * cols) + \\\"em\\\");\\n\\t\\t}\\n\\t\\tinst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? \\\"add\\\" : \\\"remove\\\") +\\n\\t\\t\\t\\\"Class\\\"](\\\"ui-datepicker-multi\\\");\\n\\t\\tinst.dpDiv[(this._get(inst, \\\"isRTL\\\") ? \\\"add\\\" : \\\"remove\\\") +\\n\\t\\t\\t\\\"Class\\\"](\\\"ui-datepicker-rtl\\\");\\n\\n\\t\\tif (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {\\n\\t\\t\\tinst.input.focus();\\n\\t\\t}\\n\\n\\t\\t// deffered render of the years select (to avoid flashes on Firefox)\\n\\t\\tif( inst.yearshtml ){\\n\\t\\t\\torigyearshtml = inst.yearshtml;\\n\\t\\t\\tsetTimeout(function(){\\n\\t\\t\\t\\t//assure that inst.yearshtml didn't change.\\n\\t\\t\\t\\tif( origyearshtml === inst.yearshtml && inst.yearshtml ){\\n\\t\\t\\t\\t\\tinst.dpDiv.find(\\\"select.ui-datepicker-year:first\\\").replaceWith(inst.yearshtml);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\torigyearshtml = inst.yearshtml = null;\\n\\t\\t\\t}, 0);\\n\\t\\t}\\n\\t},\\n\\n\\t// #6694 - don't focus the input if it's already focused\\n\\t// this breaks the change event in IE\\n\\t// Support: IE and jQuery <1.9\\n\\t_shouldFocusInput: function( inst ) {\\n\\t\\treturn inst.input && inst.input.is( \\\":visible\\\" ) && !inst.input.is( \\\":disabled\\\" ) && !inst.input.is( \\\":focus\\\" );\\n\\t},\\n\\n\\t/* Check positioning to remain on screen. */\\n\\t_checkOffset: function(inst, offset, isFixed) {\\n\\t\\tvar dpWidth = inst.dpDiv.outerWidth(),\\n\\t\\t\\tdpHeight = inst.dpDiv.outerHeight(),\\n\\t\\t\\tinputWidth = inst.input ? inst.input.outerWidth() : 0,\\n\\t\\t\\tinputHeight = inst.input ? inst.input.outerHeight() : 0,\\n\\t\\t\\tviewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),\\n\\t\\t\\tviewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());\\n\\n\\t\\toffset.left -= (this._get(inst, \\\"isRTL\\\") ? (dpWidth - inputWidth) : 0);\\n\\t\\toffset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;\\n\\t\\toffset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;\\n\\n\\t\\t// now check if datepicker is showing outside window viewport - move to a better place if so.\\n\\t\\toffset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?\\n\\t\\t\\tMath.abs(offset.left + dpWidth - viewWidth) : 0);\\n\\t\\toffset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?\\n\\t\\t\\tMath.abs(dpHeight + inputHeight) : 0);\\n\\n\\t\\treturn offset;\\n\\t},\\n\\n\\t/* Find an object's position on the screen. */\\n\\t_findPos: function(obj) {\\n\\t\\tvar position,\\n\\t\\t\\tinst = this._getInst(obj),\\n\\t\\t\\tisRTL = this._get(inst, \\\"isRTL\\\");\\n\\n\\t\\twhile (obj && (obj.type === \\\"hidden\\\" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {\\n\\t\\t\\tobj = obj[isRTL ? \\\"previousSibling\\\" : \\\"nextSibling\\\"];\\n\\t\\t}\\n\\n\\t\\tposition = $(obj).offset();\\n\\t\\treturn [position.left, position.top];\\n\\t},\\n\\n\\t/* Hide the date picker from view.\\n\\t * @param  input  element - the input field attached to the date picker\\n\\t */\\n\\t_hideDatepicker: function(input) {\\n\\t\\tvar showAnim, duration, postProcess, onClose,\\n\\t\\t\\tinst = this._curInst;\\n\\n\\t\\tif (!inst || (input && inst !== $.data(input, PROP_NAME))) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif (this._datepickerShowing) {\\n\\t\\t\\tshowAnim = this._get(inst, \\\"showAnim\\\");\\n\\t\\t\\tduration = this._get(inst, \\\"duration\\\");\\n\\t\\t\\tpostProcess = function() {\\n\\t\\t\\t\\t$.datepicker._tidyDialog(inst);\\n\\t\\t\\t};\\n\\n\\t\\t\\t// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed\\n\\t\\t\\tif ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {\\n\\t\\t\\t\\tinst.dpDiv.hide(showAnim, $.datepicker._get(inst, \\\"showOptions\\\"), duration, postProcess);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tinst.dpDiv[(showAnim === \\\"slideDown\\\" ? \\\"slideUp\\\" :\\n\\t\\t\\t\\t\\t(showAnim === \\\"fadeIn\\\" ? \\\"fadeOut\\\" : \\\"hide\\\"))]((showAnim ? duration : null), postProcess);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!showAnim) {\\n\\t\\t\\t\\tpostProcess();\\n\\t\\t\\t}\\n\\t\\t\\tthis._datepickerShowing = false;\\n\\n\\t\\t\\tonClose = this._get(inst, \\\"onClose\\\");\\n\\t\\t\\tif (onClose) {\\n\\t\\t\\t\\tonClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : \\\"\\\"), inst]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._lastInput = null;\\n\\t\\t\\tif (this._inDialog) {\\n\\t\\t\\t\\tthis._dialogInput.css({ position: \\\"absolute\\\", left: \\\"0\\\", top: \\\"-100px\\\" });\\n\\t\\t\\t\\tif ($.blockUI) {\\n\\t\\t\\t\\t\\t$.unblockUI();\\n\\t\\t\\t\\t\\t$(\\\"body\\\").append(this.dpDiv);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis._inDialog = false;\\n\\t\\t}\\n\\t},\\n\\n\\t/* Tidy up after a dialog display. */\\n\\t_tidyDialog: function(inst) {\\n\\t\\tinst.dpDiv.removeClass(this._dialogClass).unbind(\\\".ui-datepicker-calendar\\\");\\n\\t},\\n\\n\\t/* Close date picker if clicked elsewhere. */\\n\\t_checkExternalClick: function(event) {\\n\\t\\tif (!$.datepicker._curInst) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar $target = $(event.target),\\n\\t\\t\\tinst = $.datepicker._getInst($target[0]);\\n\\n\\t\\tif ( ( ( $target[0].id !== $.datepicker._mainDivId &&\\n\\t\\t\\t\\t$target.parents(\\\"#\\\" + $.datepicker._mainDivId).length === 0 &&\\n\\t\\t\\t\\t!$target.hasClass($.datepicker.markerClassName) &&\\n\\t\\t\\t\\t!$target.closest(\\\".\\\" + $.datepicker._triggerClass).length &&\\n\\t\\t\\t\\t$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||\\n\\t\\t\\t( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {\\n\\t\\t\\t\\t$.datepicker._hideDatepicker();\\n\\t\\t}\\n\\t},\\n\\n\\t/* Adjust one of the date sub-fields. */\\n\\t_adjustDate: function(id, offset, period) {\\n\\t\\tvar target = $(id),\\n\\t\\t\\tinst = this._getInst(target[0]);\\n\\n\\t\\tif (this._isDisabledDatepicker(target[0])) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tthis._adjustInstDate(inst, offset +\\n\\t\\t\\t(period === \\\"M\\\" ? this._get(inst, \\\"showCurrentAtPos\\\") : 0), // undo positioning\\n\\t\\t\\tperiod);\\n\\t\\tthis._updateDatepicker(inst);\\n\\t},\\n\\n\\t/* Action for current link. */\\n\\t_gotoToday: function(id) {\\n\\t\\tvar date,\\n\\t\\t\\ttarget = $(id),\\n\\t\\t\\tinst = this._getInst(target[0]);\\n\\n\\t\\tif (this._get(inst, \\\"gotoCurrent\\\") && inst.currentDay) {\\n\\t\\t\\tinst.selectedDay = inst.currentDay;\\n\\t\\t\\tinst.drawMonth = inst.selectedMonth = inst.currentMonth;\\n\\t\\t\\tinst.drawYear = inst.selectedYear = inst.currentYear;\\n\\t\\t} else {\\n\\t\\t\\tdate = new Date();\\n\\t\\t\\tinst.selectedDay = date.getDate();\\n\\t\\t\\tinst.drawMonth = inst.selectedMonth = date.getMonth();\\n\\t\\t\\tinst.drawYear = inst.selectedYear = date.getFullYear();\\n\\t\\t}\\n\\t\\tthis._notifyChange(inst);\\n\\t\\tthis._adjustDate(target);\\n\\t},\\n\\n\\t/* Action for selecting a new month/year. */\\n\\t_selectMonthYear: function(id, select, period) {\\n\\t\\tvar target = $(id),\\n\\t\\t\\tinst = this._getInst(target[0]);\\n\\n\\t\\tinst[\\\"selected\\\" + (period === \\\"M\\\" ? \\\"Month\\\" : \\\"Year\\\")] =\\n\\t\\tinst[\\\"draw\\\" + (period === \\\"M\\\" ? \\\"Month\\\" : \\\"Year\\\")] =\\n\\t\\t\\tparseInt(select.options[select.selectedIndex].value,10);\\n\\n\\t\\tthis._notifyChange(inst);\\n\\t\\tthis._adjustDate(target);\\n\\t},\\n\\n\\t/* Action for selecting a day. */\\n\\t_selectDay: function(id, month, year, td) {\\n\\t\\tvar inst,\\n\\t\\t\\ttarget = $(id);\\n\\n\\t\\tif ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tinst = this._getInst(target[0]);\\n\\t\\tinst.selectedDay = inst.currentDay = $(\\\"a\\\", td).html();\\n\\t\\tinst.selectedMonth = inst.currentMonth = month;\\n\\t\\tinst.selectedYear = inst.currentYear = year;\\n\\t\\tthis._selectDate(id, this._formatDate(inst,\\n\\t\\t\\tinst.currentDay, inst.currentMonth, inst.currentYear));\\n\\t},\\n\\n\\t/* Erase the input field and hide the date picker. */\\n\\t_clearDate: function(id) {\\n\\t\\tvar target = $(id);\\n\\t\\tthis._selectDate(target, \\\"\\\");\\n\\t},\\n\\n\\t/* Update the input field with the selected date. */\\n\\t_selectDate: function(id, dateStr) {\\n\\t\\tvar onSelect,\\n\\t\\t\\ttarget = $(id),\\n\\t\\t\\tinst = this._getInst(target[0]);\\n\\n\\t\\tdateStr = (dateStr != null ? dateStr : this._formatDate(inst));\\n\\t\\tif (inst.input) {\\n\\t\\t\\tinst.input.val(dateStr);\\n\\t\\t}\\n\\t\\tthis._updateAlternate(inst);\\n\\n\\t\\tonSelect = this._get(inst, \\\"onSelect\\\");\\n\\t\\tif (onSelect) {\\n\\t\\t\\tonSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback\\n\\t\\t} else if (inst.input) {\\n\\t\\t\\tinst.input.trigger(\\\"change\\\"); // fire the change event\\n\\t\\t}\\n\\n\\t\\tif (inst.inline){\\n\\t\\t\\tthis._updateDatepicker(inst);\\n\\t\\t} else {\\n\\t\\t\\tthis._hideDatepicker();\\n\\t\\t\\tthis._lastInput = inst.input[0];\\n\\t\\t\\tif (typeof(inst.input[0]) !== \\\"object\\\") {\\n\\t\\t\\t\\tinst.input.focus(); // restore focus\\n\\t\\t\\t}\\n\\t\\t\\tthis._lastInput = null;\\n\\t\\t}\\n\\t},\\n\\n\\t/* Update any alternate field to synchronise with the main field. */\\n\\t_updateAlternate: function(inst) {\\n\\t\\tvar altFormat, date, dateStr,\\n\\t\\t\\taltField = this._get(inst, \\\"altField\\\");\\n\\n\\t\\tif (altField) { // update alternate field too\\n\\t\\t\\taltFormat = this._get(inst, \\\"altFormat\\\") || this._get(inst, \\\"dateFormat\\\");\\n\\t\\t\\tdate = this._getDate(inst);\\n\\t\\t\\tdateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));\\n\\t\\t\\t$(altField).each(function() { $(this).val(dateStr); });\\n\\t\\t}\\n\\t},\\n\\n\\t/* Set as beforeShowDay function to prevent selection of weekends.\\n\\t * @param  date  Date - the date to customise\\n\\t * @return [boolean, string] - is this date selectable?, what is its CSS class?\\n\\t */\\n\\tnoWeekends: function(date) {\\n\\t\\tvar day = date.getDay();\\n\\t\\treturn [(day > 0 && day < 6), \\\"\\\"];\\n\\t},\\n\\n\\t/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.\\n\\t * @param  date  Date - the date to get the week for\\n\\t * @return  number - the number of the week within the year that contains this date\\n\\t */\\n\\tiso8601Week: function(date) {\\n\\t\\tvar time,\\n\\t\\t\\tcheckDate = new Date(date.getTime());\\n\\n\\t\\t// Find Thursday of this week starting on Monday\\n\\t\\tcheckDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));\\n\\n\\t\\ttime = checkDate.getTime();\\n\\t\\tcheckDate.setMonth(0); // Compare with Jan 1\\n\\t\\tcheckDate.setDate(1);\\n\\t\\treturn Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\\n\\t},\\n\\n\\t/* Parse a string value into a date object.\\n\\t * See formatDate below for the possible formats.\\n\\t *\\n\\t * @param  format string - the expected format of the date\\n\\t * @param  value string - the date in the above format\\n\\t * @param  settings Object - attributes include:\\n\\t *\\t\\t\\t\\t\\tshortYearCutoff  number - the cutoff year for determining the century (optional)\\n\\t *\\t\\t\\t\\t\\tdayNamesShort\\tstring[7] - abbreviated names of the days from Sunday (optional)\\n\\t *\\t\\t\\t\\t\\tdayNames\\t\\tstring[7] - names of the days from Sunday (optional)\\n\\t *\\t\\t\\t\\t\\tmonthNamesShort string[12] - abbreviated names of the months (optional)\\n\\t *\\t\\t\\t\\t\\tmonthNames\\t\\tstring[12] - names of the months (optional)\\n\\t * @return  Date - the extracted date value or null if value is blank\\n\\t */\\n\\tparseDate: function (format, value, settings) {\\n\\t\\tif (format == null || value == null) {\\n\\t\\t\\tthrow \\\"Invalid arguments\\\";\\n\\t\\t}\\n\\n\\t\\tvalue = (typeof value === \\\"object\\\" ? value.toString() : value + \\\"\\\");\\n\\t\\tif (value === \\\"\\\") {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t\\tvar iFormat, dim, extra,\\n\\t\\t\\tiValue = 0,\\n\\t\\t\\tshortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,\\n\\t\\t\\tshortYearCutoff = (typeof shortYearCutoffTemp !== \\\"string\\\" ? shortYearCutoffTemp :\\n\\t\\t\\t\\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),\\n\\t\\t\\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\\n\\t\\t\\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\\n\\t\\t\\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\\n\\t\\t\\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\\n\\t\\t\\tyear = -1,\\n\\t\\t\\tmonth = -1,\\n\\t\\t\\tday = -1,\\n\\t\\t\\tdoy = -1,\\n\\t\\t\\tliteral = false,\\n\\t\\t\\tdate,\\n\\t\\t\\t// Check whether a format character is doubled\\n\\t\\t\\tlookAhead = function(match) {\\n\\t\\t\\t\\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\\n\\t\\t\\t\\tif (matches) {\\n\\t\\t\\t\\t\\tiFormat++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn matches;\\n\\t\\t\\t},\\n\\t\\t\\t// Extract a number from the string value\\n\\t\\t\\tgetNumber = function(match) {\\n\\t\\t\\t\\tvar isDoubled = lookAhead(match),\\n\\t\\t\\t\\t\\tsize = (match === \\\"@\\\" ? 14 : (match === \\\"!\\\" ? 20 :\\n\\t\\t\\t\\t\\t(match === \\\"y\\\" && isDoubled ? 4 : (match === \\\"o\\\" ? 3 : 2)))),\\n\\t\\t\\t\\t\\tdigits = new RegExp(\\\"^\\\\\\\\d{1,\\\" + size + \\\"}\\\"),\\n\\t\\t\\t\\t\\tnum = value.substring(iValue).match(digits);\\n\\t\\t\\t\\tif (!num) {\\n\\t\\t\\t\\t\\tthrow \\\"Missing number at position \\\" + iValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tiValue += num[0].length;\\n\\t\\t\\t\\treturn parseInt(num[0], 10);\\n\\t\\t\\t},\\n\\t\\t\\t// Extract a name from the string value and convert to an index\\n\\t\\t\\tgetName = function(match, shortNames, longNames) {\\n\\t\\t\\t\\tvar index = -1,\\n\\t\\t\\t\\t\\tnames = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {\\n\\t\\t\\t\\t\\t\\treturn [ [k, v] ];\\n\\t\\t\\t\\t\\t}).sort(function (a, b) {\\n\\t\\t\\t\\t\\t\\treturn -(a[1].length - b[1].length);\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t$.each(names, function (i, pair) {\\n\\t\\t\\t\\t\\tvar name = pair[1];\\n\\t\\t\\t\\t\\tif (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {\\n\\t\\t\\t\\t\\t\\tindex = pair[0];\\n\\t\\t\\t\\t\\t\\tiValue += name.length;\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\tif (index !== -1) {\\n\\t\\t\\t\\t\\treturn index + 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthrow \\\"Unknown name at position \\\" + iValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t// Confirm that a literal character matches the string value\\n\\t\\t\\tcheckLiteral = function() {\\n\\t\\t\\t\\tif (value.charAt(iValue) !== format.charAt(iFormat)) {\\n\\t\\t\\t\\t\\tthrow \\\"Unexpected literal at position \\\" + iValue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tiValue++;\\n\\t\\t\\t};\\n\\n\\t\\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\\n\\t\\t\\tif (literal) {\\n\\t\\t\\t\\tif (format.charAt(iFormat) === \\\"'\\\" && !lookAhead(\\\"'\\\")) {\\n\\t\\t\\t\\t\\tliteral = false;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcheckLiteral();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tswitch (format.charAt(iFormat)) {\\n\\t\\t\\t\\t\\tcase \\\"d\\\":\\n\\t\\t\\t\\t\\t\\tday = getNumber(\\\"d\\\");\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"D\\\":\\n\\t\\t\\t\\t\\t\\tgetName(\\\"D\\\", dayNamesShort, dayNames);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"o\\\":\\n\\t\\t\\t\\t\\t\\tdoy = getNumber(\\\"o\\\");\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"m\\\":\\n\\t\\t\\t\\t\\t\\tmonth = getNumber(\\\"m\\\");\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"M\\\":\\n\\t\\t\\t\\t\\t\\tmonth = getName(\\\"M\\\", monthNamesShort, monthNames);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"y\\\":\\n\\t\\t\\t\\t\\t\\tyear = getNumber(\\\"y\\\");\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"@\\\":\\n\\t\\t\\t\\t\\t\\tdate = new Date(getNumber(\\\"@\\\"));\\n\\t\\t\\t\\t\\t\\tyear = date.getFullYear();\\n\\t\\t\\t\\t\\t\\tmonth = date.getMonth() + 1;\\n\\t\\t\\t\\t\\t\\tday = date.getDate();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"!\\\":\\n\\t\\t\\t\\t\\t\\tdate = new Date((getNumber(\\\"!\\\") - this._ticksTo1970) / 10000);\\n\\t\\t\\t\\t\\t\\tyear = date.getFullYear();\\n\\t\\t\\t\\t\\t\\tmonth = date.getMonth() + 1;\\n\\t\\t\\t\\t\\t\\tday = date.getDate();\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"'\\\":\\n\\t\\t\\t\\t\\t\\tif (lookAhead(\\\"'\\\")){\\n\\t\\t\\t\\t\\t\\t\\tcheckLiteral();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tliteral = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tcheckLiteral();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (iValue < value.length){\\n\\t\\t\\textra = value.substr(iValue);\\n\\t\\t\\tif (!/^\\\\s+/.test(extra)) {\\n\\t\\t\\t\\tthrow \\\"Extra/unparsed characters found in date: \\\" + extra;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (year === -1) {\\n\\t\\t\\tyear = new Date().getFullYear();\\n\\t\\t} else if (year < 100) {\\n\\t\\t\\tyear += new Date().getFullYear() - new Date().getFullYear() % 100 +\\n\\t\\t\\t\\t(year <= shortYearCutoff ? 0 : -100);\\n\\t\\t}\\n\\n\\t\\tif (doy > -1) {\\n\\t\\t\\tmonth = 1;\\n\\t\\t\\tday = doy;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tdim = this._getDaysInMonth(year, month - 1);\\n\\t\\t\\t\\tif (day <= dim) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmonth++;\\n\\t\\t\\t\\tday -= dim;\\n\\t\\t\\t} while (true);\\n\\t\\t}\\n\\n\\t\\tdate = this._daylightSavingAdjust(new Date(year, month - 1, day));\\n\\t\\tif (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {\\n\\t\\t\\tthrow \\\"Invalid date\\\"; // E.g. 31/02/00\\n\\t\\t}\\n\\t\\treturn date;\\n\\t},\\n\\n\\t/* Standard date formats. */\\n\\tATOM: \\\"yy-mm-dd\\\", // RFC 3339 (ISO 8601)\\n\\tCOOKIE: \\\"D, dd M yy\\\",\\n\\tISO_8601: \\\"yy-mm-dd\\\",\\n\\tRFC_822: \\\"D, d M y\\\",\\n\\tRFC_850: \\\"DD, dd-M-y\\\",\\n\\tRFC_1036: \\\"D, d M y\\\",\\n\\tRFC_1123: \\\"D, d M yy\\\",\\n\\tRFC_2822: \\\"D, d M yy\\\",\\n\\tRSS: \\\"D, d M y\\\", // RFC 822\\n\\tTICKS: \\\"!\\\",\\n\\tTIMESTAMP: \\\"@\\\",\\n\\tW3C: \\\"yy-mm-dd\\\", // ISO 8601\\n\\n\\t_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +\\n\\t\\tMath.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),\\n\\n\\t/* Format a date object into a string value.\\n\\t * The format can be combinations of the following:\\n\\t * d  - day of month (no leading zero)\\n\\t * dd - day of month (two digit)\\n\\t * o  - day of year (no leading zeros)\\n\\t * oo - day of year (three digit)\\n\\t * D  - day name short\\n\\t * DD - day name long\\n\\t * m  - month of year (no leading zero)\\n\\t * mm - month of year (two digit)\\n\\t * M  - month name short\\n\\t * MM - month name long\\n\\t * y  - year (two digit)\\n\\t * yy - year (four digit)\\n\\t * @ - Unix timestamp (ms since 01/01/1970)\\n\\t * ! - Windows ticks (100ns since 01/01/0001)\\n\\t * \\\"...\\\" - literal text\\n\\t * '' - single quote\\n\\t *\\n\\t * @param  format string - the desired format of the date\\n\\t * @param  date Date - the date value to format\\n\\t * @param  settings Object - attributes include:\\n\\t *\\t\\t\\t\\t\\tdayNamesShort\\tstring[7] - abbreviated names of the days from Sunday (optional)\\n\\t *\\t\\t\\t\\t\\tdayNames\\t\\tstring[7] - names of the days from Sunday (optional)\\n\\t *\\t\\t\\t\\t\\tmonthNamesShort string[12] - abbreviated names of the months (optional)\\n\\t *\\t\\t\\t\\t\\tmonthNames\\t\\tstring[12] - names of the months (optional)\\n\\t * @return  string - the date in the above format\\n\\t */\\n\\tformatDate: function (format, date, settings) {\\n\\t\\tif (!date) {\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\t}\\n\\n\\t\\tvar iFormat,\\n\\t\\t\\tdayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,\\n\\t\\t\\tdayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,\\n\\t\\t\\tmonthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,\\n\\t\\t\\tmonthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,\\n\\t\\t\\t// Check whether a format character is doubled\\n\\t\\t\\tlookAhead = function(match) {\\n\\t\\t\\t\\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\\n\\t\\t\\t\\tif (matches) {\\n\\t\\t\\t\\t\\tiFormat++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn matches;\\n\\t\\t\\t},\\n\\t\\t\\t// Format a number, with leading zero if necessary\\n\\t\\t\\tformatNumber = function(match, value, len) {\\n\\t\\t\\t\\tvar num = \\\"\\\" + value;\\n\\t\\t\\t\\tif (lookAhead(match)) {\\n\\t\\t\\t\\t\\twhile (num.length < len) {\\n\\t\\t\\t\\t\\t\\tnum = \\\"0\\\" + num;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn num;\\n\\t\\t\\t},\\n\\t\\t\\t// Format a name, short or long as requested\\n\\t\\t\\tformatName = function(match, value, shortNames, longNames) {\\n\\t\\t\\t\\treturn (lookAhead(match) ? longNames[value] : shortNames[value]);\\n\\t\\t\\t},\\n\\t\\t\\toutput = \\\"\\\",\\n\\t\\t\\tliteral = false;\\n\\n\\t\\tif (date) {\\n\\t\\t\\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\\n\\t\\t\\t\\tif (literal) {\\n\\t\\t\\t\\t\\tif (format.charAt(iFormat) === \\\"'\\\" && !lookAhead(\\\"'\\\")) {\\n\\t\\t\\t\\t\\t\\tliteral = false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\toutput += format.charAt(iFormat);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tswitch (format.charAt(iFormat)) {\\n\\t\\t\\t\\t\\t\\tcase \\\"d\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += formatNumber(\\\"d\\\", date.getDate(), 2);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"D\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += formatName(\\\"D\\\", date.getDay(), dayNamesShort, dayNames);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"o\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += formatNumber(\\\"o\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\tMath.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"m\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += formatNumber(\\\"m\\\", date.getMonth() + 1, 2);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"M\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += formatName(\\\"M\\\", date.getMonth(), monthNamesShort, monthNames);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"y\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += (lookAhead(\\\"y\\\") ? date.getFullYear() :\\n\\t\\t\\t\\t\\t\\t\\t\\t(date.getYear() % 100 < 10 ? \\\"0\\\" : \\\"\\\") + date.getYear() % 100);\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"@\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += date.getTime();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"!\\\":\\n\\t\\t\\t\\t\\t\\t\\toutput += date.getTime() * 10000 + this._ticksTo1970;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"'\\\":\\n\\t\\t\\t\\t\\t\\t\\tif (lookAhead(\\\"'\\\")) {\\n\\t\\t\\t\\t\\t\\t\\t\\toutput += \\\"'\\\";\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tliteral = true;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\toutput += format.charAt(iFormat);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn output;\\n\\t},\\n\\n\\t/* Extract all possible characters from the date format. */\\n\\t_possibleChars: function (format) {\\n\\t\\tvar iFormat,\\n\\t\\t\\tchars = \\\"\\\",\\n\\t\\t\\tliteral = false,\\n\\t\\t\\t// Check whether a format character is doubled\\n\\t\\t\\tlookAhead = function(match) {\\n\\t\\t\\t\\tvar matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);\\n\\t\\t\\t\\tif (matches) {\\n\\t\\t\\t\\t\\tiFormat++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn matches;\\n\\t\\t\\t};\\n\\n\\t\\tfor (iFormat = 0; iFormat < format.length; iFormat++) {\\n\\t\\t\\tif (literal) {\\n\\t\\t\\t\\tif (format.charAt(iFormat) === \\\"'\\\" && !lookAhead(\\\"'\\\")) {\\n\\t\\t\\t\\t\\tliteral = false;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tchars += format.charAt(iFormat);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tswitch (format.charAt(iFormat)) {\\n\\t\\t\\t\\t\\tcase \\\"d\\\": case \\\"m\\\": case \\\"y\\\": case \\\"@\\\":\\n\\t\\t\\t\\t\\t\\tchars += \\\"0123456789\\\";\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"D\\\": case \\\"M\\\":\\n\\t\\t\\t\\t\\t\\treturn null; // Accept anything\\n\\t\\t\\t\\t\\tcase \\\"'\\\":\\n\\t\\t\\t\\t\\t\\tif (lookAhead(\\\"'\\\")) {\\n\\t\\t\\t\\t\\t\\t\\tchars += \\\"'\\\";\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tliteral = true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\tchars += format.charAt(iFormat);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn chars;\\n\\t},\\n\\n\\t/* Get a setting value, defaulting if necessary. */\\n\\t_get: function(inst, name) {\\n\\t\\treturn inst.settings[name] !== undefined ?\\n\\t\\t\\tinst.settings[name] : this._defaults[name];\\n\\t},\\n\\n\\t/* Parse existing date and initialise date picker. */\\n\\t_setDateFromField: function(inst, noDefault) {\\n\\t\\tif (inst.input.val() === inst.lastVal) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar dateFormat = this._get(inst, \\\"dateFormat\\\"),\\n\\t\\t\\tdates = inst.lastVal = inst.input ? inst.input.val() : null,\\n\\t\\t\\tdefaultDate = this._getDefaultDate(inst),\\n\\t\\t\\tdate = defaultDate,\\n\\t\\t\\tsettings = this._getFormatConfig(inst);\\n\\n\\t\\ttry {\\n\\t\\t\\tdate = this.parseDate(dateFormat, dates, settings) || defaultDate;\\n\\t\\t} catch (event) {\\n\\t\\t\\tdates = (noDefault ? \\\"\\\" : dates);\\n\\t\\t}\\n\\t\\tinst.selectedDay = date.getDate();\\n\\t\\tinst.drawMonth = inst.selectedMonth = date.getMonth();\\n\\t\\tinst.drawYear = inst.selectedYear = date.getFullYear();\\n\\t\\tinst.currentDay = (dates ? date.getDate() : 0);\\n\\t\\tinst.currentMonth = (dates ? date.getMonth() : 0);\\n\\t\\tinst.currentYear = (dates ? date.getFullYear() : 0);\\n\\t\\tthis._adjustInstDate(inst);\\n\\t},\\n\\n\\t/* Retrieve the default date shown on opening. */\\n\\t_getDefaultDate: function(inst) {\\n\\t\\treturn this._restrictMinMax(inst,\\n\\t\\t\\tthis._determineDate(inst, this._get(inst, \\\"defaultDate\\\"), new Date()));\\n\\t},\\n\\n\\t/* A date may be specified as an exact value or a relative one. */\\n\\t_determineDate: function(inst, date, defaultDate) {\\n\\t\\tvar offsetNumeric = function(offset) {\\n\\t\\t\\t\\tvar date = new Date();\\n\\t\\t\\t\\tdate.setDate(date.getDate() + offset);\\n\\t\\t\\t\\treturn date;\\n\\t\\t\\t},\\n\\t\\t\\toffsetString = function(offset) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\treturn $.datepicker.parseDate($.datepicker._get(inst, \\\"dateFormat\\\"),\\n\\t\\t\\t\\t\\t\\toffset, $.datepicker._getFormatConfig(inst));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcatch (e) {\\n\\t\\t\\t\\t\\t// Ignore\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar date = (offset.toLowerCase().match(/^c/) ?\\n\\t\\t\\t\\t\\t$.datepicker._getDate(inst) : null) || new Date(),\\n\\t\\t\\t\\t\\tyear = date.getFullYear(),\\n\\t\\t\\t\\t\\tmonth = date.getMonth(),\\n\\t\\t\\t\\t\\tday = date.getDate(),\\n\\t\\t\\t\\t\\tpattern = /([+\\\\-]?[0-9]+)\\\\s*(d|D|w|W|m|M|y|Y)?/g,\\n\\t\\t\\t\\t\\tmatches = pattern.exec(offset);\\n\\n\\t\\t\\t\\twhile (matches) {\\n\\t\\t\\t\\t\\tswitch (matches[2] || \\\"d\\\") {\\n\\t\\t\\t\\t\\t\\tcase \\\"d\\\" : case \\\"D\\\" :\\n\\t\\t\\t\\t\\t\\t\\tday += parseInt(matches[1],10); break;\\n\\t\\t\\t\\t\\t\\tcase \\\"w\\\" : case \\\"W\\\" :\\n\\t\\t\\t\\t\\t\\t\\tday += parseInt(matches[1],10) * 7; break;\\n\\t\\t\\t\\t\\t\\tcase \\\"m\\\" : case \\\"M\\\" :\\n\\t\\t\\t\\t\\t\\t\\tmonth += parseInt(matches[1],10);\\n\\t\\t\\t\\t\\t\\t\\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase \\\"y\\\": case \\\"Y\\\" :\\n\\t\\t\\t\\t\\t\\t\\tyear += parseInt(matches[1],10);\\n\\t\\t\\t\\t\\t\\t\\tday = Math.min(day, $.datepicker._getDaysInMonth(year, month));\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmatches = pattern.exec(offset);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn new Date(year, month, day);\\n\\t\\t\\t},\\n\\t\\t\\tnewDate = (date == null || date === \\\"\\\" ? defaultDate : (typeof date === \\\"string\\\" ? offsetString(date) :\\n\\t\\t\\t\\t(typeof date === \\\"number\\\" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));\\n\\n\\t\\tnewDate = (newDate && newDate.toString() === \\\"Invalid Date\\\" ? defaultDate : newDate);\\n\\t\\tif (newDate) {\\n\\t\\t\\tnewDate.setHours(0);\\n\\t\\t\\tnewDate.setMinutes(0);\\n\\t\\t\\tnewDate.setSeconds(0);\\n\\t\\t\\tnewDate.setMilliseconds(0);\\n\\t\\t}\\n\\t\\treturn this._daylightSavingAdjust(newDate);\\n\\t},\\n\\n\\t/* Handle switch to/from daylight saving.\\n\\t * Hours may be non-zero on daylight saving cut-over:\\n\\t * > 12 when midnight changeover, but then cannot generate\\n\\t * midnight datetime, so jump to 1AM, otherwise reset.\\n\\t * @param  date  (Date) the date to check\\n\\t * @return  (Date) the corrected date\\n\\t */\\n\\t_daylightSavingAdjust: function(date) {\\n\\t\\tif (!date) {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\tdate.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);\\n\\t\\treturn date;\\n\\t},\\n\\n\\t/* Set the date(s) directly. */\\n\\t_setDate: function(inst, date, noChange) {\\n\\t\\tvar clear = !date,\\n\\t\\t\\torigMonth = inst.selectedMonth,\\n\\t\\t\\torigYear = inst.selectedYear,\\n\\t\\t\\tnewDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));\\n\\n\\t\\tinst.selectedDay = inst.currentDay = newDate.getDate();\\n\\t\\tinst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();\\n\\t\\tinst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();\\n\\t\\tif ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {\\n\\t\\t\\tthis._notifyChange(inst);\\n\\t\\t}\\n\\t\\tthis._adjustInstDate(inst);\\n\\t\\tif (inst.input) {\\n\\t\\t\\tinst.input.val(clear ? \\\"\\\" : this._formatDate(inst));\\n\\t\\t}\\n\\t},\\n\\n\\t/* Retrieve the date(s) directly. */\\n\\t_getDate: function(inst) {\\n\\t\\tvar startDate = (!inst.currentYear || (inst.input && inst.input.val() === \\\"\\\") ? null :\\n\\t\\t\\tthis._daylightSavingAdjust(new Date(\\n\\t\\t\\tinst.currentYear, inst.currentMonth, inst.currentDay)));\\n\\t\\t\\treturn startDate;\\n\\t},\\n\\n\\t/* Attach the onxxx handlers.  These are declared statically so\\n\\t * they work with static code transformers like Caja.\\n\\t */\\n\\t_attachHandlers: function(inst) {\\n\\t\\tvar stepMonths = this._get(inst, \\\"stepMonths\\\"),\\n\\t\\t\\tid = \\\"#\\\" + inst.id.replace( /\\\\\\\\\\\\\\\\/g, \\\"\\\\\\\\\\\" );\\n\\t\\tinst.dpDiv.find(\\\"[data-handler]\\\").map(function () {\\n\\t\\t\\tvar handler = {\\n\\t\\t\\t\\tprev: function () {\\n\\t\\t\\t\\t\\t$.datepicker._adjustDate(id, -stepMonths, \\\"M\\\");\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tnext: function () {\\n\\t\\t\\t\\t\\t$.datepicker._adjustDate(id, +stepMonths, \\\"M\\\");\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\thide: function () {\\n\\t\\t\\t\\t\\t$.datepicker._hideDatepicker();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\ttoday: function () {\\n\\t\\t\\t\\t\\t$.datepicker._gotoToday(id);\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tselectDay: function () {\\n\\t\\t\\t\\t\\t$.datepicker._selectDay(id, +this.getAttribute(\\\"data-month\\\"), +this.getAttribute(\\\"data-year\\\"), this);\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tselectMonth: function () {\\n\\t\\t\\t\\t\\t$.datepicker._selectMonthYear(id, this, \\\"M\\\");\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tselectYear: function () {\\n\\t\\t\\t\\t\\t$.datepicker._selectMonthYear(id, this, \\\"Y\\\");\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\t$(this).bind(this.getAttribute(\\\"data-event\\\"), handler[this.getAttribute(\\\"data-handler\\\")]);\\n\\t\\t});\\n\\t},\\n\\n\\t/* Generate the HTML for the current state of the date picker. */\\n\\t_generateHTML: function(inst) {\\n\\t\\tvar maxDraw, prevText, prev, nextText, next, currentText, gotoDate,\\n\\t\\t\\tcontrols, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,\\n\\t\\t\\tmonthNames, monthNamesShort, beforeShowDay, showOtherMonths,\\n\\t\\t\\tselectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,\\n\\t\\t\\tcornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,\\n\\t\\t\\tprintDate, dRow, tbody, daySettings, otherMonth, unselectable,\\n\\t\\t\\ttempDate = new Date(),\\n\\t\\t\\ttoday = this._daylightSavingAdjust(\\n\\t\\t\\t\\tnew Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time\\n\\t\\t\\tisRTL = this._get(inst, \\\"isRTL\\\"),\\n\\t\\t\\tshowButtonPanel = this._get(inst, \\\"showButtonPanel\\\"),\\n\\t\\t\\thideIfNoPrevNext = this._get(inst, \\\"hideIfNoPrevNext\\\"),\\n\\t\\t\\tnavigationAsDateFormat = this._get(inst, \\\"navigationAsDateFormat\\\"),\\n\\t\\t\\tnumMonths = this._getNumberOfMonths(inst),\\n\\t\\t\\tshowCurrentAtPos = this._get(inst, \\\"showCurrentAtPos\\\"),\\n\\t\\t\\tstepMonths = this._get(inst, \\\"stepMonths\\\"),\\n\\t\\t\\tisMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),\\n\\t\\t\\tcurrentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :\\n\\t\\t\\t\\tnew Date(inst.currentYear, inst.currentMonth, inst.currentDay))),\\n\\t\\t\\tminDate = this._getMinMaxDate(inst, \\\"min\\\"),\\n\\t\\t\\tmaxDate = this._getMinMaxDate(inst, \\\"max\\\"),\\n\\t\\t\\tdrawMonth = inst.drawMonth - showCurrentAtPos,\\n\\t\\t\\tdrawYear = inst.drawYear;\\n\\n\\t\\tif (drawMonth < 0) {\\n\\t\\t\\tdrawMonth += 12;\\n\\t\\t\\tdrawYear--;\\n\\t\\t}\\n\\t\\tif (maxDate) {\\n\\t\\t\\tmaxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),\\n\\t\\t\\t\\tmaxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));\\n\\t\\t\\tmaxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);\\n\\t\\t\\twhile (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {\\n\\t\\t\\t\\tdrawMonth--;\\n\\t\\t\\t\\tif (drawMonth < 0) {\\n\\t\\t\\t\\t\\tdrawMonth = 11;\\n\\t\\t\\t\\t\\tdrawYear--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tinst.drawMonth = drawMonth;\\n\\t\\tinst.drawYear = drawYear;\\n\\n\\t\\tprevText = this._get(inst, \\\"prevText\\\");\\n\\t\\tprevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,\\n\\t\\t\\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),\\n\\t\\t\\tthis._getFormatConfig(inst)));\\n\\n\\t\\tprev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?\\n\\t\\t\\t\\\"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'\\\" +\\n\\t\\t\\t\\\" title='\\\" + prevText + \\\"'><span class='ui-icon ui-icon-circle-triangle-\\\" + ( isRTL ? \\\"e\\\" : \\\"w\\\") + \\\"'>\\\" + prevText + \\\"</span></a>\\\" :\\n\\t\\t\\t(hideIfNoPrevNext ? \\\"\\\" : \\\"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='\\\"+ prevText +\\\"'><span class='ui-icon ui-icon-circle-triangle-\\\" + ( isRTL ? \\\"e\\\" : \\\"w\\\") + \\\"'>\\\" + prevText + \\\"</span></a>\\\"));\\n\\n\\t\\tnextText = this._get(inst, \\\"nextText\\\");\\n\\t\\tnextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,\\n\\t\\t\\tthis._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),\\n\\t\\t\\tthis._getFormatConfig(inst)));\\n\\n\\t\\tnext = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?\\n\\t\\t\\t\\\"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'\\\" +\\n\\t\\t\\t\\\" title='\\\" + nextText + \\\"'><span class='ui-icon ui-icon-circle-triangle-\\\" + ( isRTL ? \\\"w\\\" : \\\"e\\\") + \\\"'>\\\" + nextText + \\\"</span></a>\\\" :\\n\\t\\t\\t(hideIfNoPrevNext ? \\\"\\\" : \\\"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='\\\"+ nextText + \\\"'><span class='ui-icon ui-icon-circle-triangle-\\\" + ( isRTL ? \\\"w\\\" : \\\"e\\\") + \\\"'>\\\" + nextText + \\\"</span></a>\\\"));\\n\\n\\t\\tcurrentText = this._get(inst, \\\"currentText\\\");\\n\\t\\tgotoDate = (this._get(inst, \\\"gotoCurrent\\\") && inst.currentDay ? currentDate : today);\\n\\t\\tcurrentText = (!navigationAsDateFormat ? currentText :\\n\\t\\t\\tthis.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));\\n\\n\\t\\tcontrols = (!inst.inline ? \\\"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>\\\" +\\n\\t\\t\\tthis._get(inst, \\\"closeText\\\") + \\\"</button>\\\" : \\\"\\\");\\n\\n\\t\\tbuttonPanel = (showButtonPanel) ? \\\"<div class='ui-datepicker-buttonpane ui-widget-content'>\\\" + (isRTL ? controls : \\\"\\\") +\\n\\t\\t\\t(this._isInRange(inst, gotoDate) ? \\\"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'\\\" +\\n\\t\\t\\t\\\">\\\" + currentText + \\\"</button>\\\" : \\\"\\\") + (isRTL ? \\\"\\\" : controls) + \\\"</div>\\\" : \\\"\\\";\\n\\n\\t\\tfirstDay = parseInt(this._get(inst, \\\"firstDay\\\"),10);\\n\\t\\tfirstDay = (isNaN(firstDay) ? 0 : firstDay);\\n\\n\\t\\tshowWeek = this._get(inst, \\\"showWeek\\\");\\n\\t\\tdayNames = this._get(inst, \\\"dayNames\\\");\\n\\t\\tdayNamesMin = this._get(inst, \\\"dayNamesMin\\\");\\n\\t\\tmonthNames = this._get(inst, \\\"monthNames\\\");\\n\\t\\tmonthNamesShort = this._get(inst, \\\"monthNamesShort\\\");\\n\\t\\tbeforeShowDay = this._get(inst, \\\"beforeShowDay\\\");\\n\\t\\tshowOtherMonths = this._get(inst, \\\"showOtherMonths\\\");\\n\\t\\tselectOtherMonths = this._get(inst, \\\"selectOtherMonths\\\");\\n\\t\\tdefaultDate = this._getDefaultDate(inst);\\n\\t\\thtml = \\\"\\\";\\n\\t\\tdow;\\n\\t\\tfor (row = 0; row < numMonths[0]; row++) {\\n\\t\\t\\tgroup = \\\"\\\";\\n\\t\\t\\tthis.maxRows = 4;\\n\\t\\t\\tfor (col = 0; col < numMonths[1]; col++) {\\n\\t\\t\\t\\tselectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));\\n\\t\\t\\t\\tcornerClass = \\\" ui-corner-all\\\";\\n\\t\\t\\t\\tcalender = \\\"\\\";\\n\\t\\t\\t\\tif (isMultiMonth) {\\n\\t\\t\\t\\t\\tcalender += \\\"<div class='ui-datepicker-group\\\";\\n\\t\\t\\t\\t\\tif (numMonths[1] > 1) {\\n\\t\\t\\t\\t\\t\\tswitch (col) {\\n\\t\\t\\t\\t\\t\\t\\tcase 0: calender += \\\" ui-datepicker-group-first\\\";\\n\\t\\t\\t\\t\\t\\t\\t\\tcornerClass = \\\" ui-corner-\\\" + (isRTL ? \\\"right\\\" : \\\"left\\\"); break;\\n\\t\\t\\t\\t\\t\\t\\tcase numMonths[1]-1: calender += \\\" ui-datepicker-group-last\\\";\\n\\t\\t\\t\\t\\t\\t\\t\\tcornerClass = \\\" ui-corner-\\\" + (isRTL ? \\\"left\\\" : \\\"right\\\"); break;\\n\\t\\t\\t\\t\\t\\t\\tdefault: calender += \\\" ui-datepicker-group-middle\\\"; cornerClass = \\\"\\\"; break;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcalender += \\\"'>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcalender += \\\"<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix\\\" + cornerClass + \\\"'>\\\" +\\n\\t\\t\\t\\t\\t(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : \\\"\\\") +\\n\\t\\t\\t\\t\\t(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : \\\"\\\") +\\n\\t\\t\\t\\t\\tthis._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,\\n\\t\\t\\t\\t\\trow > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers\\n\\t\\t\\t\\t\\t\\\"</div><table class='ui-datepicker-calendar'><thead>\\\" +\\n\\t\\t\\t\\t\\t\\\"<tr>\\\";\\n\\t\\t\\t\\tthead = (showWeek ? \\\"<th class='ui-datepicker-week-col'>\\\" + this._get(inst, \\\"weekHeader\\\") + \\\"</th>\\\" : \\\"\\\");\\n\\t\\t\\t\\tfor (dow = 0; dow < 7; dow++) { // days of the week\\n\\t\\t\\t\\t\\tday = (dow + firstDay) % 7;\\n\\t\\t\\t\\t\\tthead += \\\"<th\\\" + ((dow + firstDay + 6) % 7 >= 5 ? \\\" class='ui-datepicker-week-end'\\\" : \\\"\\\") + \\\">\\\" +\\n\\t\\t\\t\\t\\t\\t\\\"<span title='\\\" + dayNames[day] + \\\"'>\\\" + dayNamesMin[day] + \\\"</span></th>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcalender += thead + \\\"</tr></thead><tbody>\\\";\\n\\t\\t\\t\\tdaysInMonth = this._getDaysInMonth(drawYear, drawMonth);\\n\\t\\t\\t\\tif (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {\\n\\t\\t\\t\\t\\tinst.selectedDay = Math.min(inst.selectedDay, daysInMonth);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tleadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;\\n\\t\\t\\t\\tcurRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate\\n\\t\\t\\t\\tnumRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)\\n\\t\\t\\t\\tthis.maxRows = numRows;\\n\\t\\t\\t\\tprintDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));\\n\\t\\t\\t\\tfor (dRow = 0; dRow < numRows; dRow++) { // create date picker rows\\n\\t\\t\\t\\t\\tcalender += \\\"<tr>\\\";\\n\\t\\t\\t\\t\\ttbody = (!showWeek ? \\\"\\\" : \\\"<td class='ui-datepicker-week-col'>\\\" +\\n\\t\\t\\t\\t\\t\\tthis._get(inst, \\\"calculateWeek\\\")(printDate) + \\\"</td>\\\");\\n\\t\\t\\t\\t\\tfor (dow = 0; dow < 7; dow++) { // create date picker days\\n\\t\\t\\t\\t\\t\\tdaySettings = (beforeShowDay ?\\n\\t\\t\\t\\t\\t\\t\\tbeforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, \\\"\\\"]);\\n\\t\\t\\t\\t\\t\\totherMonth = (printDate.getMonth() !== drawMonth);\\n\\t\\t\\t\\t\\t\\tunselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||\\n\\t\\t\\t\\t\\t\\t\\t(minDate && printDate < minDate) || (maxDate && printDate > maxDate);\\n\\t\\t\\t\\t\\t\\ttbody += \\\"<td class='\\\" +\\n\\t\\t\\t\\t\\t\\t\\t((dow + firstDay + 6) % 7 >= 5 ? \\\" ui-datepicker-week-end\\\" : \\\"\\\") + // highlight weekends\\n\\t\\t\\t\\t\\t\\t\\t(otherMonth ? \\\" ui-datepicker-other-month\\\" : \\\"\\\") + // highlight days from other months\\n\\t\\t\\t\\t\\t\\t\\t((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key\\n\\t\\t\\t\\t\\t\\t\\t(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?\\n\\t\\t\\t\\t\\t\\t\\t// or defaultDate is current printedDate and defaultDate is selectedDate\\n\\t\\t\\t\\t\\t\\t\\t\\\" \\\" + this._dayOverClass : \\\"\\\") + // highlight selected day\\n\\t\\t\\t\\t\\t\\t\\t(unselectable ? \\\" \\\" + this._unselectableClass + \\\" ui-state-disabled\\\": \\\"\\\") +  // highlight unselectable days\\n\\t\\t\\t\\t\\t\\t\\t(otherMonth && !showOtherMonths ? \\\"\\\" : \\\" \\\" + daySettings[1] + // highlight custom dates\\n\\t\\t\\t\\t\\t\\t\\t(printDate.getTime() === currentDate.getTime() ? \\\" \\\" + this._currentClass : \\\"\\\") + // highlight selected day\\n\\t\\t\\t\\t\\t\\t\\t(printDate.getTime() === today.getTime() ? \\\" ui-datepicker-today\\\" : \\\"\\\")) + \\\"'\\\" + // highlight today (if different)\\n\\t\\t\\t\\t\\t\\t\\t((!otherMonth || showOtherMonths) && daySettings[2] ? \\\" title='\\\" + daySettings[2].replace(/'/g, \\\"&#39;\\\") + \\\"'\\\" : \\\"\\\") + // cell title\\n\\t\\t\\t\\t\\t\\t\\t(unselectable ? \\\"\\\" : \\\" data-handler='selectDay' data-event='click' data-month='\\\" + printDate.getMonth() + \\\"' data-year='\\\" + printDate.getFullYear() + \\\"'\\\") + \\\">\\\" + // actions\\n\\t\\t\\t\\t\\t\\t\\t(otherMonth && !showOtherMonths ? \\\"&#xa0;\\\" : // display for other months\\n\\t\\t\\t\\t\\t\\t\\t(unselectable ? \\\"<span class='ui-state-default'>\\\" + printDate.getDate() + \\\"</span>\\\" : \\\"<a class='ui-state-default\\\" +\\n\\t\\t\\t\\t\\t\\t\\t(printDate.getTime() === today.getTime() ? \\\" ui-state-highlight\\\" : \\\"\\\") +\\n\\t\\t\\t\\t\\t\\t\\t(printDate.getTime() === currentDate.getTime() ? \\\" ui-state-active\\\" : \\\"\\\") + // highlight selected day\\n\\t\\t\\t\\t\\t\\t\\t(otherMonth ? \\\" ui-priority-secondary\\\" : \\\"\\\") + // distinguish dates from other months\\n\\t\\t\\t\\t\\t\\t\\t\\\"' href='#'>\\\" + printDate.getDate() + \\\"</a>\\\")) + \\\"</td>\\\"; // display selectable date\\n\\t\\t\\t\\t\\t\\tprintDate.setDate(printDate.getDate() + 1);\\n\\t\\t\\t\\t\\t\\tprintDate = this._daylightSavingAdjust(printDate);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcalender += tbody + \\\"</tr>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdrawMonth++;\\n\\t\\t\\t\\tif (drawMonth > 11) {\\n\\t\\t\\t\\t\\tdrawMonth = 0;\\n\\t\\t\\t\\t\\tdrawYear++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcalender += \\\"</tbody></table>\\\" + (isMultiMonth ? \\\"</div>\\\" +\\n\\t\\t\\t\\t\\t\\t\\t((numMonths[0] > 0 && col === numMonths[1]-1) ? \\\"<div class='ui-datepicker-row-break'></div>\\\" : \\\"\\\") : \\\"\\\");\\n\\t\\t\\t\\tgroup += calender;\\n\\t\\t\\t}\\n\\t\\t\\thtml += group;\\n\\t\\t}\\n\\t\\thtml += buttonPanel;\\n\\t\\tinst._keyEvent = false;\\n\\t\\treturn html;\\n\\t},\\n\\n\\t/* Generate the month and year header. */\\n\\t_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,\\n\\t\\t\\tsecondary, monthNames, monthNamesShort) {\\n\\n\\t\\tvar inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,\\n\\t\\t\\tchangeMonth = this._get(inst, \\\"changeMonth\\\"),\\n\\t\\t\\tchangeYear = this._get(inst, \\\"changeYear\\\"),\\n\\t\\t\\tshowMonthAfterYear = this._get(inst, \\\"showMonthAfterYear\\\"),\\n\\t\\t\\thtml = \\\"<div class='ui-datepicker-title'>\\\",\\n\\t\\t\\tmonthHtml = \\\"\\\";\\n\\n\\t\\t// month selection\\n\\t\\tif (secondary || !changeMonth) {\\n\\t\\t\\tmonthHtml += \\\"<span class='ui-datepicker-month'>\\\" + monthNames[drawMonth] + \\\"</span>\\\";\\n\\t\\t} else {\\n\\t\\t\\tinMinYear = (minDate && minDate.getFullYear() === drawYear);\\n\\t\\t\\tinMaxYear = (maxDate && maxDate.getFullYear() === drawYear);\\n\\t\\t\\tmonthHtml += \\\"<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>\\\";\\n\\t\\t\\tfor ( month = 0; month < 12; month++) {\\n\\t\\t\\t\\tif ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {\\n\\t\\t\\t\\t\\tmonthHtml += \\\"<option value='\\\" + month + \\\"'\\\" +\\n\\t\\t\\t\\t\\t\\t(month === drawMonth ? \\\" selected='selected'\\\" : \\\"\\\") +\\n\\t\\t\\t\\t\\t\\t\\\">\\\" + monthNamesShort[month] + \\\"</option>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tmonthHtml += \\\"</select>\\\";\\n\\t\\t}\\n\\n\\t\\tif (!showMonthAfterYear) {\\n\\t\\t\\thtml += monthHtml + (secondary || !(changeMonth && changeYear) ? \\\"&#xa0;\\\" : \\\"\\\");\\n\\t\\t}\\n\\n\\t\\t// year selection\\n\\t\\tif ( !inst.yearshtml ) {\\n\\t\\t\\tinst.yearshtml = \\\"\\\";\\n\\t\\t\\tif (secondary || !changeYear) {\\n\\t\\t\\t\\thtml += \\\"<span class='ui-datepicker-year'>\\\" + drawYear + \\\"</span>\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// determine range of years to display\\n\\t\\t\\t\\tyears = this._get(inst, \\\"yearRange\\\").split(\\\":\\\");\\n\\t\\t\\t\\tthisYear = new Date().getFullYear();\\n\\t\\t\\t\\tdetermineYear = function(value) {\\n\\t\\t\\t\\t\\tvar year = (value.match(/c[+\\\\-].*/) ? drawYear + parseInt(value.substring(1), 10) :\\n\\t\\t\\t\\t\\t\\t(value.match(/[+\\\\-].*/) ? thisYear + parseInt(value, 10) :\\n\\t\\t\\t\\t\\t\\tparseInt(value, 10)));\\n\\t\\t\\t\\t\\treturn (isNaN(year) ? thisYear : year);\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tyear = determineYear(years[0]);\\n\\t\\t\\t\\tendYear = Math.max(year, determineYear(years[1] || \\\"\\\"));\\n\\t\\t\\t\\tyear = (minDate ? Math.max(year, minDate.getFullYear()) : year);\\n\\t\\t\\t\\tendYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);\\n\\t\\t\\t\\tinst.yearshtml += \\\"<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>\\\";\\n\\t\\t\\t\\tfor (; year <= endYear; year++) {\\n\\t\\t\\t\\t\\tinst.yearshtml += \\\"<option value='\\\" + year + \\\"'\\\" +\\n\\t\\t\\t\\t\\t\\t(year === drawYear ? \\\" selected='selected'\\\" : \\\"\\\") +\\n\\t\\t\\t\\t\\t\\t\\\">\\\" + year + \\\"</option>\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tinst.yearshtml += \\\"</select>\\\";\\n\\n\\t\\t\\t\\thtml += inst.yearshtml;\\n\\t\\t\\t\\tinst.yearshtml = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\thtml += this._get(inst, \\\"yearSuffix\\\");\\n\\t\\tif (showMonthAfterYear) {\\n\\t\\t\\thtml += (secondary || !(changeMonth && changeYear) ? \\\"&#xa0;\\\" : \\\"\\\") + monthHtml;\\n\\t\\t}\\n\\t\\thtml += \\\"</div>\\\"; // Close datepicker_header\\n\\t\\treturn html;\\n\\t},\\n\\n\\t/* Adjust one of the date sub-fields. */\\n\\t_adjustInstDate: function(inst, offset, period) {\\n\\t\\tvar year = inst.drawYear + (period === \\\"Y\\\" ? offset : 0),\\n\\t\\t\\tmonth = inst.drawMonth + (period === \\\"M\\\" ? offset : 0),\\n\\t\\t\\tday = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === \\\"D\\\" ? offset : 0),\\n\\t\\t\\tdate = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));\\n\\n\\t\\tinst.selectedDay = date.getDate();\\n\\t\\tinst.drawMonth = inst.selectedMonth = date.getMonth();\\n\\t\\tinst.drawYear = inst.selectedYear = date.getFullYear();\\n\\t\\tif (period === \\\"M\\\" || period === \\\"Y\\\") {\\n\\t\\t\\tthis._notifyChange(inst);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Ensure a date is within any min/max bounds. */\\n\\t_restrictMinMax: function(inst, date) {\\n\\t\\tvar minDate = this._getMinMaxDate(inst, \\\"min\\\"),\\n\\t\\t\\tmaxDate = this._getMinMaxDate(inst, \\\"max\\\"),\\n\\t\\t\\tnewDate = (minDate && date < minDate ? minDate : date);\\n\\t\\treturn (maxDate && newDate > maxDate ? maxDate : newDate);\\n\\t},\\n\\n\\t/* Notify change of month/year. */\\n\\t_notifyChange: function(inst) {\\n\\t\\tvar onChange = this._get(inst, \\\"onChangeMonthYear\\\");\\n\\t\\tif (onChange) {\\n\\t\\t\\tonChange.apply((inst.input ? inst.input[0] : null),\\n\\t\\t\\t\\t[inst.selectedYear, inst.selectedMonth + 1, inst]);\\n\\t\\t}\\n\\t},\\n\\n\\t/* Determine the number of months to show. */\\n\\t_getNumberOfMonths: function(inst) {\\n\\t\\tvar numMonths = this._get(inst, \\\"numberOfMonths\\\");\\n\\t\\treturn (numMonths == null ? [1, 1] : (typeof numMonths === \\\"number\\\" ? [1, numMonths] : numMonths));\\n\\t},\\n\\n\\t/* Determine the current maximum date - ensure no time components are set. */\\n\\t_getMinMaxDate: function(inst, minMax) {\\n\\t\\treturn this._determineDate(inst, this._get(inst, minMax + \\\"Date\\\"), null);\\n\\t},\\n\\n\\t/* Find the number of days in a given month. */\\n\\t_getDaysInMonth: function(year, month) {\\n\\t\\treturn 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();\\n\\t},\\n\\n\\t/* Find the day of the week of the first of a month. */\\n\\t_getFirstDayOfMonth: function(year, month) {\\n\\t\\treturn new Date(year, month, 1).getDay();\\n\\t},\\n\\n\\t/* Determines if we should allow a \\\"next/prev\\\" month display change. */\\n\\t_canAdjustMonth: function(inst, offset, curYear, curMonth) {\\n\\t\\tvar numMonths = this._getNumberOfMonths(inst),\\n\\t\\t\\tdate = this._daylightSavingAdjust(new Date(curYear,\\n\\t\\t\\tcurMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));\\n\\n\\t\\tif (offset < 0) {\\n\\t\\t\\tdate.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));\\n\\t\\t}\\n\\t\\treturn this._isInRange(inst, date);\\n\\t},\\n\\n\\t/* Is the given date in the accepted range? */\\n\\t_isInRange: function(inst, date) {\\n\\t\\tvar yearSplit, currentYear,\\n\\t\\t\\tminDate = this._getMinMaxDate(inst, \\\"min\\\"),\\n\\t\\t\\tmaxDate = this._getMinMaxDate(inst, \\\"max\\\"),\\n\\t\\t\\tminYear = null,\\n\\t\\t\\tmaxYear = null,\\n\\t\\t\\tyears = this._get(inst, \\\"yearRange\\\");\\n\\t\\t\\tif (years){\\n\\t\\t\\t\\tyearSplit = years.split(\\\":\\\");\\n\\t\\t\\t\\tcurrentYear = new Date().getFullYear();\\n\\t\\t\\t\\tminYear = parseInt(yearSplit[0], 10);\\n\\t\\t\\t\\tmaxYear = parseInt(yearSplit[1], 10);\\n\\t\\t\\t\\tif ( yearSplit[0].match(/[+\\\\-].*/) ) {\\n\\t\\t\\t\\t\\tminYear += currentYear;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( yearSplit[1].match(/[+\\\\-].*/) ) {\\n\\t\\t\\t\\t\\tmaxYear += currentYear;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\treturn ((!minDate || date.getTime() >= minDate.getTime()) &&\\n\\t\\t\\t(!maxDate || date.getTime() <= maxDate.getTime()) &&\\n\\t\\t\\t(!minYear || date.getFullYear() >= minYear) &&\\n\\t\\t\\t(!maxYear || date.getFullYear() <= maxYear));\\n\\t},\\n\\n\\t/* Provide the configuration settings for formatting/parsing. */\\n\\t_getFormatConfig: function(inst) {\\n\\t\\tvar shortYearCutoff = this._get(inst, \\\"shortYearCutoff\\\");\\n\\t\\tshortYearCutoff = (typeof shortYearCutoff !== \\\"string\\\" ? shortYearCutoff :\\n\\t\\t\\tnew Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));\\n\\t\\treturn {shortYearCutoff: shortYearCutoff,\\n\\t\\t\\tdayNamesShort: this._get(inst, \\\"dayNamesShort\\\"), dayNames: this._get(inst, \\\"dayNames\\\"),\\n\\t\\t\\tmonthNamesShort: this._get(inst, \\\"monthNamesShort\\\"), monthNames: this._get(inst, \\\"monthNames\\\")};\\n\\t},\\n\\n\\t/* Format the given date for display. */\\n\\t_formatDate: function(inst, day, month, year) {\\n\\t\\tif (!day) {\\n\\t\\t\\tinst.currentDay = inst.selectedDay;\\n\\t\\t\\tinst.currentMonth = inst.selectedMonth;\\n\\t\\t\\tinst.currentYear = inst.selectedYear;\\n\\t\\t}\\n\\t\\tvar date = (day ? (typeof day === \\\"object\\\" ? day :\\n\\t\\t\\tthis._daylightSavingAdjust(new Date(year, month, day))) :\\n\\t\\t\\tthis._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));\\n\\t\\treturn this.formatDate(this._get(inst, \\\"dateFormat\\\"), date, this._getFormatConfig(inst));\\n\\t}\\n});\\n\\n/*\\n * Bind hover events for datepicker elements.\\n * Done via delegate so the binding only occurs once in the lifetime of the parent div.\\n * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.\\n */\\nfunction bindHover(dpDiv) {\\n\\tvar selector = \\\"button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a\\\";\\n\\treturn dpDiv.delegate(selector, \\\"mouseout\\\", function() {\\n\\t\\t\\t$(this).removeClass(\\\"ui-state-hover\\\");\\n\\t\\t\\tif (this.className.indexOf(\\\"ui-datepicker-prev\\\") !== -1) {\\n\\t\\t\\t\\t$(this).removeClass(\\\"ui-datepicker-prev-hover\\\");\\n\\t\\t\\t}\\n\\t\\t\\tif (this.className.indexOf(\\\"ui-datepicker-next\\\") !== -1) {\\n\\t\\t\\t\\t$(this).removeClass(\\\"ui-datepicker-next-hover\\\");\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t.delegate(selector, \\\"mouseover\\\", function(){\\n\\t\\t\\tif (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {\\n\\t\\t\\t\\t$(this).parents(\\\".ui-datepicker-calendar\\\").find(\\\"a\\\").removeClass(\\\"ui-state-hover\\\");\\n\\t\\t\\t\\t$(this).addClass(\\\"ui-state-hover\\\");\\n\\t\\t\\t\\tif (this.className.indexOf(\\\"ui-datepicker-prev\\\") !== -1) {\\n\\t\\t\\t\\t\\t$(this).addClass(\\\"ui-datepicker-prev-hover\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (this.className.indexOf(\\\"ui-datepicker-next\\\") !== -1) {\\n\\t\\t\\t\\t\\t$(this).addClass(\\\"ui-datepicker-next-hover\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n}\\n\\n/* jQuery extend now ignores nulls! */\\nfunction extendRemove(target, props) {\\n\\t$.extend(target, props);\\n\\tfor (var name in props) {\\n\\t\\tif (props[name] == null) {\\n\\t\\t\\ttarget[name] = props[name];\\n\\t\\t}\\n\\t}\\n\\treturn target;\\n}\\n\\n/* Invoke the datepicker functionality.\\n   @param  options  string - a command, optionally followed by additional parameters or\\n\\t\\t\\t\\t\\tObject - settings for attaching new datepicker functionality\\n   @return  jQuery object */\\n$.fn.datepicker = function(options){\\n\\n\\t/* Verify an empty collection wasn't passed - Fixes #6976 */\\n\\tif ( !this.length ) {\\n\\t\\treturn this;\\n\\t}\\n\\n\\t/* Initialise the date picker. */\\n\\tif (!$.datepicker.initialized) {\\n\\t\\t$(document).mousedown($.datepicker._checkExternalClick);\\n\\t\\t$.datepicker.initialized = true;\\n\\t}\\n\\n\\t/* Append datepicker main container to body if not exist. */\\n\\tif ($(\\\"#\\\"+$.datepicker._mainDivId).length === 0) {\\n\\t\\t$(\\\"body\\\").append($.datepicker.dpDiv);\\n\\t}\\n\\n\\tvar otherArgs = Array.prototype.slice.call(arguments, 1);\\n\\tif (typeof options === \\\"string\\\" && (options === \\\"isDisabled\\\" || options === \\\"getDate\\\" || options === \\\"widget\\\")) {\\n\\t\\treturn $.datepicker[\\\"_\\\" + options + \\\"Datepicker\\\"].\\n\\t\\t\\tapply($.datepicker, [this[0]].concat(otherArgs));\\n\\t}\\n\\tif (options === \\\"option\\\" && arguments.length === 2 && typeof arguments[1] === \\\"string\\\") {\\n\\t\\treturn $.datepicker[\\\"_\\\" + options + \\\"Datepicker\\\"].\\n\\t\\t\\tapply($.datepicker, [this[0]].concat(otherArgs));\\n\\t}\\n\\treturn this.each(function() {\\n\\t\\ttypeof options === \\\"string\\\" ?\\n\\t\\t\\t$.datepicker[\\\"_\\\" + options + \\\"Datepicker\\\"].\\n\\t\\t\\t\\tapply($.datepicker, [this].concat(otherArgs)) :\\n\\t\\t\\t$.datepicker._attachDatepicker(this, options);\\n\\t});\\n};\\n\\n$.datepicker = new Datepicker(); // singleton instance\\n$.datepicker.initialized = false;\\n$.datepicker.uuid = new Date().getTime();\\n$.datepicker.version = \\\"1.10.3\\\";\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\nvar sizeRelatedOptions = {\\n\\t\\tbuttons: true,\\n\\t\\theight: true,\\n\\t\\tmaxHeight: true,\\n\\t\\tmaxWidth: true,\\n\\t\\tminHeight: true,\\n\\t\\tminWidth: true,\\n\\t\\twidth: true\\n\\t},\\n\\tresizableRelatedOptions = {\\n\\t\\tmaxHeight: true,\\n\\t\\tmaxWidth: true,\\n\\t\\tminHeight: true,\\n\\t\\tminWidth: true\\n\\t};\\n\\n$.widget( \\\"ui.dialog\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tappendTo: \\\"body\\\",\\n\\t\\tautoOpen: true,\\n\\t\\tbuttons: [],\\n\\t\\tcloseOnEscape: true,\\n\\t\\tcloseText: \\\"close\\\",\\n\\t\\tdialogClass: \\\"\\\",\\n\\t\\tdraggable: true,\\n\\t\\thide: null,\\n\\t\\theight: \\\"auto\\\",\\n\\t\\tmaxHeight: null,\\n\\t\\tmaxWidth: null,\\n\\t\\tminHeight: 150,\\n\\t\\tminWidth: 150,\\n\\t\\tmodal: false,\\n\\t\\tposition: {\\n\\t\\t\\tmy: \\\"center\\\",\\n\\t\\t\\tat: \\\"center\\\",\\n\\t\\t\\tof: window,\\n\\t\\t\\tcollision: \\\"fit\\\",\\n\\t\\t\\t// Ensure the titlebar is always visible\\n\\t\\t\\tusing: function( pos ) {\\n\\t\\t\\t\\tvar topOffset = $( this ).css( pos ).offset().top;\\n\\t\\t\\t\\tif ( topOffset < 0 ) {\\n\\t\\t\\t\\t\\t$( this ).css( \\\"top\\\", pos.top - topOffset );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tresizable: true,\\n\\t\\tshow: null,\\n\\t\\ttitle: null,\\n\\t\\twidth: 300,\\n\\n\\t\\t// callbacks\\n\\t\\tbeforeClose: null,\\n\\t\\tclose: null,\\n\\t\\tdrag: null,\\n\\t\\tdragStart: null,\\n\\t\\tdragStop: null,\\n\\t\\tfocus: null,\\n\\t\\topen: null,\\n\\t\\tresize: null,\\n\\t\\tresizeStart: null,\\n\\t\\tresizeStop: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tthis.originalCss = {\\n\\t\\t\\tdisplay: this.element[0].style.display,\\n\\t\\t\\twidth: this.element[0].style.width,\\n\\t\\t\\tminHeight: this.element[0].style.minHeight,\\n\\t\\t\\tmaxHeight: this.element[0].style.maxHeight,\\n\\t\\t\\theight: this.element[0].style.height\\n\\t\\t};\\n\\t\\tthis.originalPosition = {\\n\\t\\t\\tparent: this.element.parent(),\\n\\t\\t\\tindex: this.element.parent().children().index( this.element )\\n\\t\\t};\\n\\t\\tthis.originalTitle = this.element.attr(\\\"title\\\");\\n\\t\\tthis.options.title = this.options.title || this.originalTitle;\\n\\n\\t\\tthis._createWrapper();\\n\\n\\t\\tthis.element\\n\\t\\t\\t.show()\\n\\t\\t\\t.removeAttr(\\\"title\\\")\\n\\t\\t\\t.addClass(\\\"ui-dialog-content ui-widget-content\\\")\\n\\t\\t\\t.appendTo( this.uiDialog );\\n\\n\\t\\tthis._createTitlebar();\\n\\t\\tthis._createButtonPane();\\n\\n\\t\\tif ( this.options.draggable && $.fn.draggable ) {\\n\\t\\t\\tthis._makeDraggable();\\n\\t\\t}\\n\\t\\tif ( this.options.resizable && $.fn.resizable ) {\\n\\t\\t\\tthis._makeResizable();\\n\\t\\t}\\n\\n\\t\\tthis._isOpen = false;\\n\\t},\\n\\n\\t_init: function() {\\n\\t\\tif ( this.options.autoOpen ) {\\n\\t\\t\\tthis.open();\\n\\t\\t}\\n\\t},\\n\\n\\t_appendTo: function() {\\n\\t\\tvar element = this.options.appendTo;\\n\\t\\tif ( element && (element.jquery || element.nodeType) ) {\\n\\t\\t\\treturn $( element );\\n\\t\\t}\\n\\t\\treturn this.document.find( element || \\\"body\\\" ).eq( 0 );\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tvar next,\\n\\t\\t\\toriginalPosition = this.originalPosition;\\n\\n\\t\\tthis._destroyOverlay();\\n\\n\\t\\tthis.element\\n\\t\\t\\t.removeUniqueId()\\n\\t\\t\\t.removeClass(\\\"ui-dialog-content ui-widget-content\\\")\\n\\t\\t\\t.css( this.originalCss )\\n\\t\\t\\t// Without detaching first, the following becomes really slow\\n\\t\\t\\t.detach();\\n\\n\\t\\tthis.uiDialog.stop( true, true ).remove();\\n\\n\\t\\tif ( this.originalTitle ) {\\n\\t\\t\\tthis.element.attr( \\\"title\\\", this.originalTitle );\\n\\t\\t}\\n\\n\\t\\tnext = originalPosition.parent.children().eq( originalPosition.index );\\n\\t\\t// Don't try to place the dialog next to itself (#8613)\\n\\t\\tif ( next.length && next[0] !== this.element[0] ) {\\n\\t\\t\\tnext.before( this.element );\\n\\t\\t} else {\\n\\t\\t\\toriginalPosition.parent.append( this.element );\\n\\t\\t}\\n\\t},\\n\\n\\twidget: function() {\\n\\t\\treturn this.uiDialog;\\n\\t},\\n\\n\\tdisable: $.noop,\\n\\tenable: $.noop,\\n\\n\\tclose: function( event ) {\\n\\t\\tvar that = this;\\n\\n\\t\\tif ( !this._isOpen || this._trigger( \\\"beforeClose\\\", event ) === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._isOpen = false;\\n\\t\\tthis._destroyOverlay();\\n\\n\\t\\tif ( !this.opener.filter(\\\":focusable\\\").focus().length ) {\\n\\t\\t\\t// Hiding a focused element doesn't trigger blur in WebKit\\n\\t\\t\\t// so in case we have nothing to focus on, explicitly blur the active element\\n\\t\\t\\t// https://bugs.webkit.org/show_bug.cgi?id=47182\\n\\t\\t\\t$( this.document[0].activeElement ).blur();\\n\\t\\t}\\n\\n\\t\\tthis._hide( this.uiDialog, this.options.hide, function() {\\n\\t\\t\\tthat._trigger( \\\"close\\\", event );\\n\\t\\t});\\n\\t},\\n\\n\\tisOpen: function() {\\n\\t\\treturn this._isOpen;\\n\\t},\\n\\n\\tmoveToTop: function() {\\n\\t\\tthis._moveToTop();\\n\\t},\\n\\n\\t_moveToTop: function( event, silent ) {\\n\\t\\tvar moved = !!this.uiDialog.nextAll(\\\":visible\\\").insertBefore( this.uiDialog ).length;\\n\\t\\tif ( moved && !silent ) {\\n\\t\\t\\tthis._trigger( \\\"focus\\\", event );\\n\\t\\t}\\n\\t\\treturn moved;\\n\\t},\\n\\n\\topen: function() {\\n\\t\\tvar that = this;\\n\\t\\tif ( this._isOpen ) {\\n\\t\\t\\tif ( this._moveToTop() ) {\\n\\t\\t\\t\\tthis._focusTabbable();\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._isOpen = true;\\n\\t\\tthis.opener = $( this.document[0].activeElement );\\n\\n\\t\\tthis._size();\\n\\t\\tthis._position();\\n\\t\\tthis._createOverlay();\\n\\t\\tthis._moveToTop( null, true );\\n\\t\\tthis._show( this.uiDialog, this.options.show, function() {\\n\\t\\t\\tthat._focusTabbable();\\n\\t\\t\\tthat._trigger(\\\"focus\\\");\\n\\t\\t});\\n\\n\\t\\tthis._trigger(\\\"open\\\");\\n\\t},\\n\\n\\t_focusTabbable: function() {\\n\\t\\t// Set focus to the first match:\\n\\t\\t// 1. First element inside the dialog matching [autofocus]\\n\\t\\t// 2. Tabbable element inside the content element\\n\\t\\t// 3. Tabbable element inside the buttonpane\\n\\t\\t// 4. The close button\\n\\t\\t// 5. The dialog itself\\n\\t\\tvar hasFocus = this.element.find(\\\"[autofocus]\\\");\\n\\t\\tif ( !hasFocus.length ) {\\n\\t\\t\\thasFocus = this.element.find(\\\":tabbable\\\");\\n\\t\\t}\\n\\t\\tif ( !hasFocus.length ) {\\n\\t\\t\\thasFocus = this.uiDialogButtonPane.find(\\\":tabbable\\\");\\n\\t\\t}\\n\\t\\tif ( !hasFocus.length ) {\\n\\t\\t\\thasFocus = this.uiDialogTitlebarClose.filter(\\\":tabbable\\\");\\n\\t\\t}\\n\\t\\tif ( !hasFocus.length ) {\\n\\t\\t\\thasFocus = this.uiDialog;\\n\\t\\t}\\n\\t\\thasFocus.eq( 0 ).focus();\\n\\t},\\n\\n\\t_keepFocus: function( event ) {\\n\\t\\tfunction checkFocus() {\\n\\t\\t\\tvar activeElement = this.document[0].activeElement,\\n\\t\\t\\t\\tisActive = this.uiDialog[0] === activeElement ||\\n\\t\\t\\t\\t\\t$.contains( this.uiDialog[0], activeElement );\\n\\t\\t\\tif ( !isActive ) {\\n\\t\\t\\t\\tthis._focusTabbable();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tevent.preventDefault();\\n\\t\\tcheckFocus.call( this );\\n\\t\\t// support: IE\\n\\t\\t// IE <= 8 doesn't prevent moving focus even with event.preventDefault()\\n\\t\\t// so we check again later\\n\\t\\tthis._delay( checkFocus );\\n\\t},\\n\\n\\t_createWrapper: function() {\\n\\t\\tthis.uiDialog = $(\\\"<div>\\\")\\n\\t\\t\\t.addClass( \\\"ui-dialog ui-widget ui-widget-content ui-corner-all ui-front \\\" +\\n\\t\\t\\t\\tthis.options.dialogClass )\\n\\t\\t\\t.hide()\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\t// Setting tabIndex makes the div focusable\\n\\t\\t\\t\\ttabIndex: -1,\\n\\t\\t\\t\\trole: \\\"dialog\\\"\\n\\t\\t\\t})\\n\\t\\t\\t.appendTo( this._appendTo() );\\n\\n\\t\\tthis._on( this.uiDialog, {\\n\\t\\t\\tkeydown: function( event ) {\\n\\t\\t\\t\\tif ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&\\n\\t\\t\\t\\t\\t\\tevent.keyCode === $.ui.keyCode.ESCAPE ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\tthis.close( event );\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// prevent tabbing out of dialogs\\n\\t\\t\\t\\tif ( event.keyCode !== $.ui.keyCode.TAB ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar tabbables = this.uiDialog.find(\\\":tabbable\\\"),\\n\\t\\t\\t\\t\\tfirst = tabbables.filter(\\\":first\\\"),\\n\\t\\t\\t\\t\\tlast  = tabbables.filter(\\\":last\\\");\\n\\n\\t\\t\\t\\tif ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {\\n\\t\\t\\t\\t\\tfirst.focus( 1 );\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {\\n\\t\\t\\t\\t\\tlast.focus( 1 );\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tmousedown: function( event ) {\\n\\t\\t\\t\\tif ( this._moveToTop( event ) ) {\\n\\t\\t\\t\\t\\tthis._focusTabbable();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// We assume that any existing aria-describedby attribute means\\n\\t\\t// that the dialog content is marked up properly\\n\\t\\t// otherwise we brute force the content as the description\\n\\t\\tif ( !this.element.find(\\\"[aria-describedby]\\\").length ) {\\n\\t\\t\\tthis.uiDialog.attr({\\n\\t\\t\\t\\t\\\"aria-describedby\\\": this.element.uniqueId().attr(\\\"id\\\")\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t_createTitlebar: function() {\\n\\t\\tvar uiDialogTitle;\\n\\n\\t\\tthis.uiDialogTitlebar = $(\\\"<div>\\\")\\n\\t\\t\\t.addClass(\\\"ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix\\\")\\n\\t\\t\\t.prependTo( this.uiDialog );\\n\\t\\tthis._on( this.uiDialogTitlebar, {\\n\\t\\t\\tmousedown: function( event ) {\\n\\t\\t\\t\\t// Don't prevent click on close button (#8838)\\n\\t\\t\\t\\t// Focusing a dialog that is partially scrolled out of view\\n\\t\\t\\t\\t// causes the browser to scroll it into view, preventing the click event\\n\\t\\t\\t\\tif ( !$( event.target ).closest(\\\".ui-dialog-titlebar-close\\\") ) {\\n\\t\\t\\t\\t\\t// Dialog isn't getting focus when dragging (#8063)\\n\\t\\t\\t\\t\\tthis.uiDialog.focus();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.uiDialogTitlebarClose = $(\\\"<button></button>\\\")\\n\\t\\t\\t.button({\\n\\t\\t\\t\\tlabel: this.options.closeText,\\n\\t\\t\\t\\ticons: {\\n\\t\\t\\t\\t\\tprimary: \\\"ui-icon-closethick\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\ttext: false\\n\\t\\t\\t})\\n\\t\\t\\t.addClass(\\\"ui-dialog-titlebar-close\\\")\\n\\t\\t\\t.appendTo( this.uiDialogTitlebar );\\n\\t\\tthis._on( this.uiDialogTitlebarClose, {\\n\\t\\t\\tclick: function( event ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\tthis.close( event );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tuiDialogTitle = $(\\\"<span>\\\")\\n\\t\\t\\t.uniqueId()\\n\\t\\t\\t.addClass(\\\"ui-dialog-title\\\")\\n\\t\\t\\t.prependTo( this.uiDialogTitlebar );\\n\\t\\tthis._title( uiDialogTitle );\\n\\n\\t\\tthis.uiDialog.attr({\\n\\t\\t\\t\\\"aria-labelledby\\\": uiDialogTitle.attr(\\\"id\\\")\\n\\t\\t});\\n\\t},\\n\\n\\t_title: function( title ) {\\n\\t\\tif ( !this.options.title ) {\\n\\t\\t\\ttitle.html(\\\"&#160;\\\");\\n\\t\\t}\\n\\t\\ttitle.text( this.options.title );\\n\\t},\\n\\n\\t_createButtonPane: function() {\\n\\t\\tthis.uiDialogButtonPane = $(\\\"<div>\\\")\\n\\t\\t\\t.addClass(\\\"ui-dialog-buttonpane ui-widget-content ui-helper-clearfix\\\");\\n\\n\\t\\tthis.uiButtonSet = $(\\\"<div>\\\")\\n\\t\\t\\t.addClass(\\\"ui-dialog-buttonset\\\")\\n\\t\\t\\t.appendTo( this.uiDialogButtonPane );\\n\\n\\t\\tthis._createButtons();\\n\\t},\\n\\n\\t_createButtons: function() {\\n\\t\\tvar that = this,\\n\\t\\t\\tbuttons = this.options.buttons;\\n\\n\\t\\t// if we already have a button pane, remove it\\n\\t\\tthis.uiDialogButtonPane.remove();\\n\\t\\tthis.uiButtonSet.empty();\\n\\n\\t\\tif ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {\\n\\t\\t\\tthis.uiDialog.removeClass(\\\"ui-dialog-buttons\\\");\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t$.each( buttons, function( name, props ) {\\n\\t\\t\\tvar click, buttonOptions;\\n\\t\\t\\tprops = $.isFunction( props ) ?\\n\\t\\t\\t\\t{ click: props, text: name } :\\n\\t\\t\\t\\tprops;\\n\\t\\t\\t// Default to a non-submitting button\\n\\t\\t\\tprops = $.extend( { type: \\\"button\\\" }, props );\\n\\t\\t\\t// Change the context for the click callback to be the main element\\n\\t\\t\\tclick = props.click;\\n\\t\\t\\tprops.click = function() {\\n\\t\\t\\t\\tclick.apply( that.element[0], arguments );\\n\\t\\t\\t};\\n\\t\\t\\tbuttonOptions = {\\n\\t\\t\\t\\ticons: props.icons,\\n\\t\\t\\t\\ttext: props.showText\\n\\t\\t\\t};\\n\\t\\t\\tdelete props.icons;\\n\\t\\t\\tdelete props.showText;\\n\\t\\t\\t$( \\\"<button></button>\\\", props )\\n\\t\\t\\t\\t.button( buttonOptions )\\n\\t\\t\\t\\t.appendTo( that.uiButtonSet );\\n\\t\\t});\\n\\t\\tthis.uiDialog.addClass(\\\"ui-dialog-buttons\\\");\\n\\t\\tthis.uiDialogButtonPane.appendTo( this.uiDialog );\\n\\t},\\n\\n\\t_makeDraggable: function() {\\n\\t\\tvar that = this,\\n\\t\\t\\toptions = this.options;\\n\\n\\t\\tfunction filteredUi( ui ) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tposition: ui.position,\\n\\t\\t\\t\\toffset: ui.offset\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tthis.uiDialog.draggable({\\n\\t\\t\\tcancel: \\\".ui-dialog-content, .ui-dialog-titlebar-close\\\",\\n\\t\\t\\thandle: \\\".ui-dialog-titlebar\\\",\\n\\t\\t\\tcontainment: \\\"document\\\",\\n\\t\\t\\tstart: function( event, ui ) {\\n\\t\\t\\t\\t$( this ).addClass(\\\"ui-dialog-dragging\\\");\\n\\t\\t\\t\\tthat._blockFrames();\\n\\t\\t\\t\\tthat._trigger( \\\"dragStart\\\", event, filteredUi( ui ) );\\n\\t\\t\\t},\\n\\t\\t\\tdrag: function( event, ui ) {\\n\\t\\t\\t\\tthat._trigger( \\\"drag\\\", event, filteredUi( ui ) );\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( event, ui ) {\\n\\t\\t\\t\\toptions.position = [\\n\\t\\t\\t\\t\\tui.position.left - that.document.scrollLeft(),\\n\\t\\t\\t\\t\\tui.position.top - that.document.scrollTop()\\n\\t\\t\\t\\t];\\n\\t\\t\\t\\t$( this ).removeClass(\\\"ui-dialog-dragging\\\");\\n\\t\\t\\t\\tthat._unblockFrames();\\n\\t\\t\\t\\tthat._trigger( \\\"dragStop\\\", event, filteredUi( ui ) );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_makeResizable: function() {\\n\\t\\tvar that = this,\\n\\t\\t\\toptions = this.options,\\n\\t\\t\\thandles = options.resizable,\\n\\t\\t\\t// .ui-resizable has position: relative defined in the stylesheet\\n\\t\\t\\t// but dialogs have to use absolute or fixed positioning\\n\\t\\t\\tposition = this.uiDialog.css(\\\"position\\\"),\\n\\t\\t\\tresizeHandles = typeof handles === \\\"string\\\" ?\\n\\t\\t\\t\\thandles\\t:\\n\\t\\t\\t\\t\\\"n,e,s,w,se,sw,ne,nw\\\";\\n\\n\\t\\tfunction filteredUi( ui ) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\toriginalPosition: ui.originalPosition,\\n\\t\\t\\t\\toriginalSize: ui.originalSize,\\n\\t\\t\\t\\tposition: ui.position,\\n\\t\\t\\t\\tsize: ui.size\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tthis.uiDialog.resizable({\\n\\t\\t\\tcancel: \\\".ui-dialog-content\\\",\\n\\t\\t\\tcontainment: \\\"document\\\",\\n\\t\\t\\talsoResize: this.element,\\n\\t\\t\\tmaxWidth: options.maxWidth,\\n\\t\\t\\tmaxHeight: options.maxHeight,\\n\\t\\t\\tminWidth: options.minWidth,\\n\\t\\t\\tminHeight: this._minHeight(),\\n\\t\\t\\thandles: resizeHandles,\\n\\t\\t\\tstart: function( event, ui ) {\\n\\t\\t\\t\\t$( this ).addClass(\\\"ui-dialog-resizing\\\");\\n\\t\\t\\t\\tthat._blockFrames();\\n\\t\\t\\t\\tthat._trigger( \\\"resizeStart\\\", event, filteredUi( ui ) );\\n\\t\\t\\t},\\n\\t\\t\\tresize: function( event, ui ) {\\n\\t\\t\\t\\tthat._trigger( \\\"resize\\\", event, filteredUi( ui ) );\\n\\t\\t\\t},\\n\\t\\t\\tstop: function( event, ui ) {\\n\\t\\t\\t\\toptions.height = $( this ).height();\\n\\t\\t\\t\\toptions.width = $( this ).width();\\n\\t\\t\\t\\t$( this ).removeClass(\\\"ui-dialog-resizing\\\");\\n\\t\\t\\t\\tthat._unblockFrames();\\n\\t\\t\\t\\tthat._trigger( \\\"resizeStop\\\", event, filteredUi( ui ) );\\n\\t\\t\\t}\\n\\t\\t})\\n\\t\\t.css( \\\"position\\\", position );\\n\\t},\\n\\n\\t_minHeight: function() {\\n\\t\\tvar options = this.options;\\n\\n\\t\\treturn options.height === \\\"auto\\\" ?\\n\\t\\t\\toptions.minHeight :\\n\\t\\t\\tMath.min( options.minHeight, options.height );\\n\\t},\\n\\n\\t_position: function() {\\n\\t\\t// Need to show the dialog to get the actual offset in the position plugin\\n\\t\\tvar isVisible = this.uiDialog.is(\\\":visible\\\");\\n\\t\\tif ( !isVisible ) {\\n\\t\\t\\tthis.uiDialog.show();\\n\\t\\t}\\n\\t\\tthis.uiDialog.position( this.options.position );\\n\\t\\tif ( !isVisible ) {\\n\\t\\t\\tthis.uiDialog.hide();\\n\\t\\t}\\n\\t},\\n\\n\\t_setOptions: function( options ) {\\n\\t\\tvar that = this,\\n\\t\\t\\tresize = false,\\n\\t\\t\\tresizableOptions = {};\\n\\n\\t\\t$.each( options, function( key, value ) {\\n\\t\\t\\tthat._setOption( key, value );\\n\\n\\t\\t\\tif ( key in sizeRelatedOptions ) {\\n\\t\\t\\t\\tresize = true;\\n\\t\\t\\t}\\n\\t\\t\\tif ( key in resizableRelatedOptions ) {\\n\\t\\t\\t\\tresizableOptions[ key ] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tif ( resize ) {\\n\\t\\t\\tthis._size();\\n\\t\\t\\tthis._position();\\n\\t\\t}\\n\\t\\tif ( this.uiDialog.is(\\\":data(ui-resizable)\\\") ) {\\n\\t\\t\\tthis.uiDialog.resizable( \\\"option\\\", resizableOptions );\\n\\t\\t}\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\t/*jshint maxcomplexity:15*/\\n\\t\\tvar isDraggable, isResizable,\\n\\t\\t\\tuiDialog = this.uiDialog;\\n\\n\\t\\tif ( key === \\\"dialogClass\\\" ) {\\n\\t\\t\\tuiDialog\\n\\t\\t\\t\\t.removeClass( this.options.dialogClass )\\n\\t\\t\\t\\t.addClass( value );\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\n\\t\\tif ( key === \\\"appendTo\\\" ) {\\n\\t\\t\\tthis.uiDialog.appendTo( this._appendTo() );\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"buttons\\\" ) {\\n\\t\\t\\tthis._createButtons();\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"closeText\\\" ) {\\n\\t\\t\\tthis.uiDialogTitlebarClose.button({\\n\\t\\t\\t\\t// Ensure that we always pass a string\\n\\t\\t\\t\\tlabel: \\\"\\\" + value\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"draggable\\\" ) {\\n\\t\\t\\tisDraggable = uiDialog.is(\\\":data(ui-draggable)\\\");\\n\\t\\t\\tif ( isDraggable && !value ) {\\n\\t\\t\\t\\tuiDialog.draggable(\\\"destroy\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( !isDraggable && value ) {\\n\\t\\t\\t\\tthis._makeDraggable();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"position\\\" ) {\\n\\t\\t\\tthis._position();\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"resizable\\\" ) {\\n\\t\\t\\t// currently resizable, becoming non-resizable\\n\\t\\t\\tisResizable = uiDialog.is(\\\":data(ui-resizable)\\\");\\n\\t\\t\\tif ( isResizable && !value ) {\\n\\t\\t\\t\\tuiDialog.resizable(\\\"destroy\\\");\\n\\t\\t\\t}\\n\\n\\t\\t\\t// currently resizable, changing handles\\n\\t\\t\\tif ( isResizable && typeof value === \\\"string\\\" ) {\\n\\t\\t\\t\\tuiDialog.resizable( \\\"option\\\", \\\"handles\\\", value );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// currently non-resizable, becoming resizable\\n\\t\\t\\tif ( !isResizable && value !== false ) {\\n\\t\\t\\t\\tthis._makeResizable();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"title\\\" ) {\\n\\t\\t\\tthis._title( this.uiDialogTitlebar.find(\\\".ui-dialog-title\\\") );\\n\\t\\t}\\n\\t},\\n\\n\\t_size: function() {\\n\\t\\t// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content\\n\\t\\t// divs will both have width and height set, so we need to reset them\\n\\t\\tvar nonContentHeight, minContentHeight, maxContentHeight,\\n\\t\\t\\toptions = this.options;\\n\\n\\t\\t// Reset content sizing\\n\\t\\tthis.element.show().css({\\n\\t\\t\\twidth: \\\"auto\\\",\\n\\t\\t\\tminHeight: 0,\\n\\t\\t\\tmaxHeight: \\\"none\\\",\\n\\t\\t\\theight: 0\\n\\t\\t});\\n\\n\\t\\tif ( options.minWidth > options.width ) {\\n\\t\\t\\toptions.width = options.minWidth;\\n\\t\\t}\\n\\n\\t\\t// reset wrapper sizing\\n\\t\\t// determine the height of all the non-content elements\\n\\t\\tnonContentHeight = this.uiDialog.css({\\n\\t\\t\\t\\theight: \\\"auto\\\",\\n\\t\\t\\t\\twidth: options.width\\n\\t\\t\\t})\\n\\t\\t\\t.outerHeight();\\n\\t\\tminContentHeight = Math.max( 0, options.minHeight - nonContentHeight );\\n\\t\\tmaxContentHeight = typeof options.maxHeight === \\\"number\\\" ?\\n\\t\\t\\tMath.max( 0, options.maxHeight - nonContentHeight ) :\\n\\t\\t\\t\\\"none\\\";\\n\\n\\t\\tif ( options.height === \\\"auto\\\" ) {\\n\\t\\t\\tthis.element.css({\\n\\t\\t\\t\\tminHeight: minContentHeight,\\n\\t\\t\\t\\tmaxHeight: maxContentHeight,\\n\\t\\t\\t\\theight: \\\"auto\\\"\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tthis.element.height( Math.max( 0, options.height - nonContentHeight ) );\\n\\t\\t}\\n\\n\\t\\tif (this.uiDialog.is(\\\":data(ui-resizable)\\\") ) {\\n\\t\\t\\tthis.uiDialog.resizable( \\\"option\\\", \\\"minHeight\\\", this._minHeight() );\\n\\t\\t}\\n\\t},\\n\\n\\t_blockFrames: function() {\\n\\t\\tthis.iframeBlocks = this.document.find( \\\"iframe\\\" ).map(function() {\\n\\t\\t\\tvar iframe = $( this );\\n\\n\\t\\t\\treturn $( \\\"<div>\\\" )\\n\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\t\\t\\twidth: iframe.outerWidth(),\\n\\t\\t\\t\\t\\theight: iframe.outerHeight()\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.appendTo( iframe.parent() )\\n\\t\\t\\t\\t.offset( iframe.offset() )[0];\\n\\t\\t});\\n\\t},\\n\\n\\t_unblockFrames: function() {\\n\\t\\tif ( this.iframeBlocks ) {\\n\\t\\t\\tthis.iframeBlocks.remove();\\n\\t\\t\\tdelete this.iframeBlocks;\\n\\t\\t}\\n\\t},\\n\\n\\t_allowInteraction: function( event ) {\\n\\t\\tif ( $( event.target ).closest(\\\".ui-dialog\\\").length ) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// TODO: Remove hack when datepicker implements\\n\\t\\t// the .ui-front logic (#8989)\\n\\t\\treturn !!$( event.target ).closest(\\\".ui-datepicker\\\").length;\\n\\t},\\n\\n\\t_createOverlay: function() {\\n\\t\\tif ( !this.options.modal ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvar that = this,\\n\\t\\t\\twidgetFullName = this.widgetFullName;\\n\\t\\tif ( !$.ui.dialog.overlayInstances ) {\\n\\t\\t\\t// Prevent use of anchors and inputs.\\n\\t\\t\\t// We use a delay in case the overlay is created from an\\n\\t\\t\\t// event that we're going to be cancelling. (#2804)\\n\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t// Handle .dialog().dialog(\\\"close\\\") (#4065)\\n\\t\\t\\t\\tif ( $.ui.dialog.overlayInstances ) {\\n\\t\\t\\t\\t\\tthis.document.bind( \\\"focusin.dialog\\\", function( event ) {\\n\\t\\t\\t\\t\\t\\tif ( !that._allowInteraction( event ) ) {\\n\\t\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t\\t\\t$(\\\".ui-dialog:visible:last .ui-dialog-content\\\")\\n\\t\\t\\t\\t\\t\\t\\t\\t.data( widgetFullName )._focusTabbable();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis.overlay = $(\\\"<div>\\\")\\n\\t\\t\\t.addClass(\\\"ui-widget-overlay ui-front\\\")\\n\\t\\t\\t.appendTo( this._appendTo() );\\n\\t\\tthis._on( this.overlay, {\\n\\t\\t\\tmousedown: \\\"_keepFocus\\\"\\n\\t\\t});\\n\\t\\t$.ui.dialog.overlayInstances++;\\n\\t},\\n\\n\\t_destroyOverlay: function() {\\n\\t\\tif ( !this.options.modal ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( this.overlay ) {\\n\\t\\t\\t$.ui.dialog.overlayInstances--;\\n\\n\\t\\t\\tif ( !$.ui.dialog.overlayInstances ) {\\n\\t\\t\\t\\tthis.document.unbind( \\\"focusin.dialog\\\" );\\n\\t\\t\\t}\\n\\t\\t\\tthis.overlay.remove();\\n\\t\\t\\tthis.overlay = null;\\n\\t\\t}\\n\\t}\\n});\\n\\n$.ui.dialog.overlayInstances = 0;\\n\\n// DEPRECATED\\nif ( $.uiBackCompat !== false ) {\\n\\t// position option with array notation\\n\\t// just override with old implementation\\n\\t$.widget( \\\"ui.dialog\\\", $.ui.dialog, {\\n\\t\\t_position: function() {\\n\\t\\t\\tvar position = this.options.position,\\n\\t\\t\\t\\tmyAt = [],\\n\\t\\t\\t\\toffset = [ 0, 0 ],\\n\\t\\t\\t\\tisVisible;\\n\\n\\t\\t\\tif ( position ) {\\n\\t\\t\\t\\tif ( typeof position === \\\"string\\\" || (typeof position === \\\"object\\\" && \\\"0\\\" in position ) ) {\\n\\t\\t\\t\\t\\tmyAt = position.split ? position.split(\\\" \\\") : [ position[0], position[1] ];\\n\\t\\t\\t\\t\\tif ( myAt.length === 1 ) {\\n\\t\\t\\t\\t\\t\\tmyAt[1] = myAt[0];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t$.each( [ \\\"left\\\", \\\"top\\\" ], function( i, offsetPosition ) {\\n\\t\\t\\t\\t\\t\\tif ( +myAt[ i ] === myAt[ i ] ) {\\n\\t\\t\\t\\t\\t\\t\\toffset[ i ] = myAt[ i ];\\n\\t\\t\\t\\t\\t\\t\\tmyAt[ i ] = offsetPosition;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\t\\tposition = {\\n\\t\\t\\t\\t\\t\\tmy: myAt[0] + (offset[0] < 0 ? offset[0] : \\\"+\\\" + offset[0]) + \\\" \\\" +\\n\\t\\t\\t\\t\\t\\t\\tmyAt[1] + (offset[1] < 0 ? offset[1] : \\\"+\\\" + offset[1]),\\n\\t\\t\\t\\t\\t\\tat: myAt.join(\\\" \\\")\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tposition = $.extend( {}, $.ui.dialog.prototype.options.position, position );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tposition = $.ui.dialog.prototype.options.position;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// need to show the dialog to get the actual offset in the position plugin\\n\\t\\t\\tisVisible = this.uiDialog.is(\\\":visible\\\");\\n\\t\\t\\tif ( !isVisible ) {\\n\\t\\t\\t\\tthis.uiDialog.show();\\n\\t\\t\\t}\\n\\t\\t\\tthis.uiDialog.position( position );\\n\\t\\t\\tif ( !isVisible ) {\\n\\t\\t\\t\\tthis.uiDialog.hide();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n}\\n\\n}( jQuery ) );\\n\\n(function( $, undefined ) {\\n\\nvar rvertical = /up|down|vertical/,\\n\\trpositivemotion = /up|left|vertical|horizontal/;\\n\\n$.effects.effect.blind = function( o, done ) {\\n\\t// Create element\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"height\\\", \\\"width\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"hide\\\" ),\\n\\t\\tdirection = o.direction || \\\"up\\\",\\n\\t\\tvertical = rvertical.test( direction ),\\n\\t\\tref = vertical ? \\\"height\\\" : \\\"width\\\",\\n\\t\\tref2 = vertical ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tmotion = rpositivemotion.test( direction ),\\n\\t\\tanimation = {},\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\twrapper, distance, margin;\\n\\n\\t// if already wrapped, the wrapper's properties are my property. #6245\\n\\tif ( el.parent().is( \\\".ui-effects-wrapper\\\" ) ) {\\n\\t\\t$.effects.save( el.parent(), props );\\n\\t} else {\\n\\t\\t$.effects.save( el, props );\\n\\t}\\n\\tel.show();\\n\\twrapper = $.effects.createWrapper( el ).css({\\n\\t\\toverflow: \\\"hidden\\\"\\n\\t});\\n\\n\\tdistance = wrapper[ ref ]();\\n\\tmargin = parseFloat( wrapper.css( ref2 ) ) || 0;\\n\\n\\tanimation[ ref ] = show ? distance : 0;\\n\\tif ( !motion ) {\\n\\t\\tel\\n\\t\\t\\t.css( vertical ? \\\"bottom\\\" : \\\"right\\\", 0 )\\n\\t\\t\\t.css( vertical ? \\\"top\\\" : \\\"left\\\", \\\"auto\\\" )\\n\\t\\t\\t.css({ position: \\\"absolute\\\" });\\n\\n\\t\\tanimation[ ref2 ] = show ? margin : distance + margin;\\n\\t}\\n\\n\\t// start at 0 if we are showing\\n\\tif ( show ) {\\n\\t\\twrapper.css( ref, 0 );\\n\\t\\tif ( ! motion ) {\\n\\t\\t\\twrapper.css( ref2, margin + distance );\\n\\t\\t}\\n\\t}\\n\\n\\t// Animate\\n\\twrapper.animate( animation, {\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tqueue: false,\\n\\t\\tcomplete: function() {\\n\\t\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\t});\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.bounce = function( o, done ) {\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"height\\\", \\\"width\\\" ],\\n\\n\\t\\t// defaults:\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"effect\\\" ),\\n\\t\\thide = mode === \\\"hide\\\",\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\tdirection = o.direction || \\\"up\\\",\\n\\t\\tdistance = o.distance,\\n\\t\\ttimes = o.times || 5,\\n\\n\\t\\t// number of internal animations\\n\\t\\tanims = times * 2 + ( show || hide ? 1 : 0 ),\\n\\t\\tspeed = o.duration / anims,\\n\\t\\teasing = o.easing,\\n\\n\\t\\t// utility:\\n\\t\\tref = ( direction === \\\"up\\\" || direction === \\\"down\\\" ) ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tmotion = ( direction === \\\"up\\\" || direction === \\\"left\\\" ),\\n\\t\\ti,\\n\\t\\tupAnim,\\n\\t\\tdownAnim,\\n\\n\\t\\t// we will need to re-assemble the queue to stack our animations in place\\n\\t\\tqueue = el.queue(),\\n\\t\\tqueuelen = queue.length;\\n\\n\\t// Avoid touching opacity to prevent clearType and PNG issues in IE\\n\\tif ( show || hide ) {\\n\\t\\tprops.push( \\\"opacity\\\" );\\n\\t}\\n\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\t$.effects.createWrapper( el ); // Create Wrapper\\n\\n\\t// default distance for the BIGGEST bounce is the outer Distance / 3\\n\\tif ( !distance ) {\\n\\t\\tdistance = el[ ref === \\\"top\\\" ? \\\"outerHeight\\\" : \\\"outerWidth\\\" ]() / 3;\\n\\t}\\n\\n\\tif ( show ) {\\n\\t\\tdownAnim = { opacity: 1 };\\n\\t\\tdownAnim[ ref ] = 0;\\n\\n\\t\\t// if we are showing, force opacity 0 and set the initial position\\n\\t\\t// then do the \\\"first\\\" animation\\n\\t\\tel.css( \\\"opacity\\\", 0 )\\n\\t\\t\\t.css( ref, motion ? -distance * 2 : distance * 2 )\\n\\t\\t\\t.animate( downAnim, speed, easing );\\n\\t}\\n\\n\\t// start at the smallest distance if we are hiding\\n\\tif ( hide ) {\\n\\t\\tdistance = distance / Math.pow( 2, times - 1 );\\n\\t}\\n\\n\\tdownAnim = {};\\n\\tdownAnim[ ref ] = 0;\\n\\t// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here\\n\\tfor ( i = 0; i < times; i++ ) {\\n\\t\\tupAnim = {};\\n\\t\\tupAnim[ ref ] = ( motion ? \\\"-=\\\" : \\\"+=\\\" ) + distance;\\n\\n\\t\\tel.animate( upAnim, speed, easing )\\n\\t\\t\\t.animate( downAnim, speed, easing );\\n\\n\\t\\tdistance = hide ? distance * 2 : distance / 2;\\n\\t}\\n\\n\\t// Last Bounce when Hiding\\n\\tif ( hide ) {\\n\\t\\tupAnim = { opacity: 0 };\\n\\t\\tupAnim[ ref ] = ( motion ? \\\"-=\\\" : \\\"+=\\\" ) + distance;\\n\\n\\t\\tel.animate( upAnim, speed, easing );\\n\\t}\\n\\n\\tel.queue(function() {\\n\\t\\tif ( hide ) {\\n\\t\\t\\tel.hide();\\n\\t\\t}\\n\\t\\t$.effects.restore( el, props );\\n\\t\\t$.effects.removeWrapper( el );\\n\\t\\tdone();\\n\\t});\\n\\n\\t// inject all the animations we just queued to be first in line (after \\\"inprogress\\\")\\n\\tif ( queuelen > 1) {\\n\\t\\tqueue.splice.apply( queue,\\n\\t\\t\\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\\n\\t}\\n\\tel.dequeue();\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.clip = function( o, done ) {\\n\\t// Create element\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"height\\\", \\\"width\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"hide\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\tdirection = o.direction || \\\"vertical\\\",\\n\\t\\tvert = direction === \\\"vertical\\\",\\n\\t\\tsize = vert ? \\\"height\\\" : \\\"width\\\",\\n\\t\\tposition = vert ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tanimation = {},\\n\\t\\twrapper, animate, distance;\\n\\n\\t// Save & Show\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\n\\t// Create Wrapper\\n\\twrapper = $.effects.createWrapper( el ).css({\\n\\t\\toverflow: \\\"hidden\\\"\\n\\t});\\n\\tanimate = ( el[0].tagName === \\\"IMG\\\" ) ? wrapper : el;\\n\\tdistance = animate[ size ]();\\n\\n\\t// Shift\\n\\tif ( show ) {\\n\\t\\tanimate.css( size, 0 );\\n\\t\\tanimate.css( position, distance / 2 );\\n\\t}\\n\\n\\t// Create Animation Object:\\n\\tanimation[ size ] = show ? distance : 0;\\n\\tanimation[ position ] = show ? 0 : distance / 2;\\n\\n\\t// Animate\\n\\tanimate.animate( animation, {\\n\\t\\tqueue: false,\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tcomplete: function() {\\n\\t\\t\\tif ( !show ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\t});\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.drop = function( o, done ) {\\n\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"opacity\\\", \\\"height\\\", \\\"width\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"hide\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\tdirection = o.direction || \\\"left\\\",\\n\\t\\tref = ( direction === \\\"up\\\" || direction === \\\"down\\\" ) ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tmotion = ( direction === \\\"up\\\" || direction === \\\"left\\\" ) ? \\\"pos\\\" : \\\"neg\\\",\\n\\t\\tanimation = {\\n\\t\\t\\topacity: show ? 1 : 0\\n\\t\\t},\\n\\t\\tdistance;\\n\\n\\t// Adjust\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\t$.effects.createWrapper( el );\\n\\n\\tdistance = o.distance || el[ ref === \\\"top\\\" ? \\\"outerHeight\\\": \\\"outerWidth\\\" ]( true ) / 2;\\n\\n\\tif ( show ) {\\n\\t\\tel\\n\\t\\t\\t.css( \\\"opacity\\\", 0 )\\n\\t\\t\\t.css( ref, motion === \\\"pos\\\" ? -distance : distance );\\n\\t}\\n\\n\\t// Animation\\n\\tanimation[ ref ] = ( show ?\\n\\t\\t( motion === \\\"pos\\\" ? \\\"+=\\\" : \\\"-=\\\" ) :\\n\\t\\t( motion === \\\"pos\\\" ? \\\"-=\\\" : \\\"+=\\\" ) ) +\\n\\t\\tdistance;\\n\\n\\t// Animate\\n\\tel.animate( animation, {\\n\\t\\tqueue: false,\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tcomplete: function() {\\n\\t\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\t});\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.explode = function( o, done ) {\\n\\n\\tvar rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,\\n\\t\\tcells = rows,\\n\\t\\tel = $( this ),\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"hide\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\n\\t\\t// show and then visibility:hidden the element before calculating offset\\n\\t\\toffset = el.show().css( \\\"visibility\\\", \\\"hidden\\\" ).offset(),\\n\\n\\t\\t// width and height of a piece\\n\\t\\twidth = Math.ceil( el.outerWidth() / cells ),\\n\\t\\theight = Math.ceil( el.outerHeight() / rows ),\\n\\t\\tpieces = [],\\n\\n\\t\\t// loop\\n\\t\\ti, j, left, top, mx, my;\\n\\n\\t// children animate complete:\\n\\tfunction childComplete() {\\n\\t\\tpieces.push( this );\\n\\t\\tif ( pieces.length === rows * cells ) {\\n\\t\\t\\tanimComplete();\\n\\t\\t}\\n\\t}\\n\\n\\t// clone the element for each row and cell.\\n\\tfor( i = 0; i < rows ; i++ ) { // ===>\\n\\t\\ttop = offset.top + i * height;\\n\\t\\tmy = i - ( rows - 1 ) / 2 ;\\n\\n\\t\\tfor( j = 0; j < cells ; j++ ) { // |||\\n\\t\\t\\tleft = offset.left + j * width;\\n\\t\\t\\tmx = j - ( cells - 1 ) / 2 ;\\n\\n\\t\\t\\t// Create a clone of the now hidden main element that will be absolute positioned\\n\\t\\t\\t// within a wrapper div off the -left and -top equal to size of our pieces\\n\\t\\t\\tel\\n\\t\\t\\t\\t.clone()\\n\\t\\t\\t\\t.appendTo( \\\"body\\\" )\\n\\t\\t\\t\\t.wrap( \\\"<div></div>\\\" )\\n\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\t\\t\\tvisibility: \\\"visible\\\",\\n\\t\\t\\t\\t\\tleft: -j * width,\\n\\t\\t\\t\\t\\ttop: -i * height\\n\\t\\t\\t\\t})\\n\\n\\t\\t\\t// select the wrapper - make it overflow: hidden and absolute positioned based on\\n\\t\\t\\t// where the original was located +left and +top equal to the size of pieces\\n\\t\\t\\t\\t.parent()\\n\\t\\t\\t\\t.addClass( \\\"ui-effects-explode\\\" )\\n\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\t\\t\\toverflow: \\\"hidden\\\",\\n\\t\\t\\t\\t\\twidth: width,\\n\\t\\t\\t\\t\\theight: height,\\n\\t\\t\\t\\t\\tleft: left + ( show ? mx * width : 0 ),\\n\\t\\t\\t\\t\\ttop: top + ( show ? my * height : 0 ),\\n\\t\\t\\t\\t\\topacity: show ? 0 : 1\\n\\t\\t\\t\\t}).animate({\\n\\t\\t\\t\\t\\tleft: left + ( show ? 0 : mx * width ),\\n\\t\\t\\t\\t\\ttop: top + ( show ? 0 : my * height ),\\n\\t\\t\\t\\t\\topacity: show ? 1 : 0\\n\\t\\t\\t\\t}, o.duration || 500, o.easing, childComplete );\\n\\t\\t}\\n\\t}\\n\\n\\tfunction animComplete() {\\n\\t\\tel.css({\\n\\t\\t\\tvisibility: \\\"visible\\\"\\n\\t\\t});\\n\\t\\t$( pieces ).remove();\\n\\t\\tif ( !show ) {\\n\\t\\t\\tel.hide();\\n\\t\\t}\\n\\t\\tdone();\\n\\t}\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.fade = function( o, done ) {\\n\\tvar el = $( this ),\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"toggle\\\" );\\n\\n\\tel.animate({\\n\\t\\topacity: mode\\n\\t}, {\\n\\t\\tqueue: false,\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tcomplete: done\\n\\t});\\n};\\n\\n})( jQuery );\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.fold = function( o, done ) {\\n\\n\\t// Create element\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"height\\\", \\\"width\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"hide\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\thide = mode === \\\"hide\\\",\\n\\t\\tsize = o.size || 15,\\n\\t\\tpercent = /([0-9]+)%/.exec( size ),\\n\\t\\thorizFirst = !!o.horizFirst,\\n\\t\\twidthFirst = show !== horizFirst,\\n\\t\\tref = widthFirst ? [ \\\"width\\\", \\\"height\\\" ] : [ \\\"height\\\", \\\"width\\\" ],\\n\\t\\tduration = o.duration / 2,\\n\\t\\twrapper, distance,\\n\\t\\tanimation1 = {},\\n\\t\\tanimation2 = {};\\n\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\n\\t// Create Wrapper\\n\\twrapper = $.effects.createWrapper( el ).css({\\n\\t\\toverflow: \\\"hidden\\\"\\n\\t});\\n\\tdistance = widthFirst ?\\n\\t\\t[ wrapper.width(), wrapper.height() ] :\\n\\t\\t[ wrapper.height(), wrapper.width() ];\\n\\n\\tif ( percent ) {\\n\\t\\tsize = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];\\n\\t}\\n\\tif ( show ) {\\n\\t\\twrapper.css( horizFirst ? {\\n\\t\\t\\theight: 0,\\n\\t\\t\\twidth: size\\n\\t\\t} : {\\n\\t\\t\\theight: size,\\n\\t\\t\\twidth: 0\\n\\t\\t});\\n\\t}\\n\\n\\t// Animation\\n\\tanimation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;\\n\\tanimation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;\\n\\n\\t// Animate\\n\\twrapper\\n\\t\\t.animate( animation1, duration, o.easing )\\n\\t\\t.animate( animation2, duration, o.easing, function() {\\n\\t\\t\\tif ( hide ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t});\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.highlight = function( o, done ) {\\n\\tvar elem = $( this ),\\n\\t\\tprops = [ \\\"backgroundImage\\\", \\\"backgroundColor\\\", \\\"opacity\\\" ],\\n\\t\\tmode = $.effects.setMode( elem, o.mode || \\\"show\\\" ),\\n\\t\\tanimation = {\\n\\t\\t\\tbackgroundColor: elem.css( \\\"backgroundColor\\\" )\\n\\t\\t};\\n\\n\\tif (mode === \\\"hide\\\") {\\n\\t\\tanimation.opacity = 0;\\n\\t}\\n\\n\\t$.effects.save( elem, props );\\n\\n\\telem\\n\\t\\t.show()\\n\\t\\t.css({\\n\\t\\t\\tbackgroundImage: \\\"none\\\",\\n\\t\\t\\tbackgroundColor: o.color || \\\"#ffff99\\\"\\n\\t\\t})\\n\\t\\t.animate( animation, {\\n\\t\\t\\tqueue: false,\\n\\t\\t\\tduration: o.duration,\\n\\t\\t\\teasing: o.easing,\\n\\t\\t\\tcomplete: function() {\\n\\t\\t\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\t\\telem.hide();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$.effects.restore( elem, props );\\n\\t\\t\\t\\tdone();\\n\\t\\t\\t}\\n\\t\\t});\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.pulsate = function( o, done ) {\\n\\tvar elem = $( this ),\\n\\t\\tmode = $.effects.setMode( elem, o.mode || \\\"show\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\thide = mode === \\\"hide\\\",\\n\\t\\tshowhide = ( show || mode === \\\"hide\\\" ),\\n\\n\\t\\t// showing or hiding leaves of the \\\"last\\\" animation\\n\\t\\tanims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),\\n\\t\\tduration = o.duration / anims,\\n\\t\\tanimateTo = 0,\\n\\t\\tqueue = elem.queue(),\\n\\t\\tqueuelen = queue.length,\\n\\t\\ti;\\n\\n\\tif ( show || !elem.is(\\\":visible\\\")) {\\n\\t\\telem.css( \\\"opacity\\\", 0 ).show();\\n\\t\\tanimateTo = 1;\\n\\t}\\n\\n\\t// anims - 1 opacity \\\"toggles\\\"\\n\\tfor ( i = 1; i < anims; i++ ) {\\n\\t\\telem.animate({\\n\\t\\t\\topacity: animateTo\\n\\t\\t}, duration, o.easing );\\n\\t\\tanimateTo = 1 - animateTo;\\n\\t}\\n\\n\\telem.animate({\\n\\t\\topacity: animateTo\\n\\t}, duration, o.easing);\\n\\n\\telem.queue(function() {\\n\\t\\tif ( hide ) {\\n\\t\\t\\telem.hide();\\n\\t\\t}\\n\\t\\tdone();\\n\\t});\\n\\n\\t// We just queued up \\\"anims\\\" animations, we need to put them next in the queue\\n\\tif ( queuelen > 1 ) {\\n\\t\\tqueue.splice.apply( queue,\\n\\t\\t\\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\\n\\t}\\n\\telem.dequeue();\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.puff = function( o, done ) {\\n\\tvar elem = $( this ),\\n\\t\\tmode = $.effects.setMode( elem, o.mode || \\\"hide\\\" ),\\n\\t\\thide = mode === \\\"hide\\\",\\n\\t\\tpercent = parseInt( o.percent, 10 ) || 150,\\n\\t\\tfactor = percent / 100,\\n\\t\\toriginal = {\\n\\t\\t\\theight: elem.height(),\\n\\t\\t\\twidth: elem.width(),\\n\\t\\t\\touterHeight: elem.outerHeight(),\\n\\t\\t\\touterWidth: elem.outerWidth()\\n\\t\\t};\\n\\n\\t$.extend( o, {\\n\\t\\teffect: \\\"scale\\\",\\n\\t\\tqueue: false,\\n\\t\\tfade: true,\\n\\t\\tmode: mode,\\n\\t\\tcomplete: done,\\n\\t\\tpercent: hide ? percent : 100,\\n\\t\\tfrom: hide ?\\n\\t\\t\\toriginal :\\n\\t\\t\\t{\\n\\t\\t\\t\\theight: original.height * factor,\\n\\t\\t\\t\\twidth: original.width * factor,\\n\\t\\t\\t\\touterHeight: original.outerHeight * factor,\\n\\t\\t\\t\\touterWidth: original.outerWidth * factor\\n\\t\\t\\t}\\n\\t});\\n\\n\\telem.effect( o );\\n};\\n\\n$.effects.effect.scale = function( o, done ) {\\n\\n\\t// Create element\\n\\tvar el = $( this ),\\n\\t\\toptions = $.extend( true, {}, o ),\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"effect\\\" ),\\n\\t\\tpercent = parseInt( o.percent, 10 ) ||\\n\\t\\t\\t( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === \\\"hide\\\" ? 0 : 100 ) ),\\n\\t\\tdirection = o.direction || \\\"both\\\",\\n\\t\\torigin = o.origin,\\n\\t\\toriginal = {\\n\\t\\t\\theight: el.height(),\\n\\t\\t\\twidth: el.width(),\\n\\t\\t\\touterHeight: el.outerHeight(),\\n\\t\\t\\touterWidth: el.outerWidth()\\n\\t\\t},\\n\\t\\tfactor = {\\n\\t\\t\\ty: direction !== \\\"horizontal\\\" ? (percent / 100) : 1,\\n\\t\\t\\tx: direction !== \\\"vertical\\\" ? (percent / 100) : 1\\n\\t\\t};\\n\\n\\t// We are going to pass this effect to the size effect:\\n\\toptions.effect = \\\"size\\\";\\n\\toptions.queue = false;\\n\\toptions.complete = done;\\n\\n\\t// Set default origin and restore for show/hide\\n\\tif ( mode !== \\\"effect\\\" ) {\\n\\t\\toptions.origin = origin || [\\\"middle\\\",\\\"center\\\"];\\n\\t\\toptions.restore = true;\\n\\t}\\n\\n\\toptions.from = o.from || ( mode === \\\"show\\\" ? {\\n\\t\\theight: 0,\\n\\t\\twidth: 0,\\n\\t\\touterHeight: 0,\\n\\t\\touterWidth: 0\\n\\t} : original );\\n\\toptions.to = {\\n\\t\\theight: original.height * factor.y,\\n\\t\\twidth: original.width * factor.x,\\n\\t\\touterHeight: original.outerHeight * factor.y,\\n\\t\\touterWidth: original.outerWidth * factor.x\\n\\t};\\n\\n\\t// Fade option to support puff\\n\\tif ( options.fade ) {\\n\\t\\tif ( mode === \\\"show\\\" ) {\\n\\t\\t\\toptions.from.opacity = 0;\\n\\t\\t\\toptions.to.opacity = 1;\\n\\t\\t}\\n\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\toptions.from.opacity = 1;\\n\\t\\t\\toptions.to.opacity = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t// Animate\\n\\tel.effect( options );\\n\\n};\\n\\n$.effects.effect.size = function( o, done ) {\\n\\n\\t// Create element\\n\\tvar original, baseline, factor,\\n\\t\\tel = $( this ),\\n\\t\\tprops0 = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"width\\\", \\\"height\\\", \\\"overflow\\\", \\\"opacity\\\" ],\\n\\n\\t\\t// Always restore\\n\\t\\tprops1 = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"overflow\\\", \\\"opacity\\\" ],\\n\\n\\t\\t// Copy for children\\n\\t\\tprops2 = [ \\\"width\\\", \\\"height\\\", \\\"overflow\\\" ],\\n\\t\\tcProps = [ \\\"fontSize\\\" ],\\n\\t\\tvProps = [ \\\"borderTopWidth\\\", \\\"borderBottomWidth\\\", \\\"paddingTop\\\", \\\"paddingBottom\\\" ],\\n\\t\\thProps = [ \\\"borderLeftWidth\\\", \\\"borderRightWidth\\\", \\\"paddingLeft\\\", \\\"paddingRight\\\" ],\\n\\n\\t\\t// Set options\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"effect\\\" ),\\n\\t\\trestore = o.restore || mode !== \\\"effect\\\",\\n\\t\\tscale = o.scale || \\\"both\\\",\\n\\t\\torigin = o.origin || [ \\\"middle\\\", \\\"center\\\" ],\\n\\t\\tposition = el.css( \\\"position\\\" ),\\n\\t\\tprops = restore ? props0 : props1,\\n\\t\\tzero = {\\n\\t\\t\\theight: 0,\\n\\t\\t\\twidth: 0,\\n\\t\\t\\touterHeight: 0,\\n\\t\\t\\touterWidth: 0\\n\\t\\t};\\n\\n\\tif ( mode === \\\"show\\\" ) {\\n\\t\\tel.show();\\n\\t}\\n\\toriginal = {\\n\\t\\theight: el.height(),\\n\\t\\twidth: el.width(),\\n\\t\\touterHeight: el.outerHeight(),\\n\\t\\touterWidth: el.outerWidth()\\n\\t};\\n\\n\\tif ( o.mode === \\\"toggle\\\" && mode === \\\"show\\\" ) {\\n\\t\\tel.from = o.to || zero;\\n\\t\\tel.to = o.from || original;\\n\\t} else {\\n\\t\\tel.from = o.from || ( mode === \\\"show\\\" ? zero : original );\\n\\t\\tel.to = o.to || ( mode === \\\"hide\\\" ? zero : original );\\n\\t}\\n\\n\\t// Set scaling factor\\n\\tfactor = {\\n\\t\\tfrom: {\\n\\t\\t\\ty: el.from.height / original.height,\\n\\t\\t\\tx: el.from.width / original.width\\n\\t\\t},\\n\\t\\tto: {\\n\\t\\t\\ty: el.to.height / original.height,\\n\\t\\t\\tx: el.to.width / original.width\\n\\t\\t}\\n\\t};\\n\\n\\t// Scale the css box\\n\\tif ( scale === \\\"box\\\" || scale === \\\"both\\\" ) {\\n\\n\\t\\t// Vertical props scaling\\n\\t\\tif ( factor.from.y !== factor.to.y ) {\\n\\t\\t\\tprops = props.concat( vProps );\\n\\t\\t\\tel.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );\\n\\t\\t\\tel.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );\\n\\t\\t}\\n\\n\\t\\t// Horizontal props scaling\\n\\t\\tif ( factor.from.x !== factor.to.x ) {\\n\\t\\t\\tprops = props.concat( hProps );\\n\\t\\t\\tel.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );\\n\\t\\t\\tel.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );\\n\\t\\t}\\n\\t}\\n\\n\\t// Scale the content\\n\\tif ( scale === \\\"content\\\" || scale === \\\"both\\\" ) {\\n\\n\\t\\t// Vertical props scaling\\n\\t\\tif ( factor.from.y !== factor.to.y ) {\\n\\t\\t\\tprops = props.concat( cProps ).concat( props2 );\\n\\t\\t\\tel.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );\\n\\t\\t\\tel.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );\\n\\t\\t}\\n\\t}\\n\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\t$.effects.createWrapper( el );\\n\\tel.css( \\\"overflow\\\", \\\"hidden\\\" ).css( el.from );\\n\\n\\t// Adjust\\n\\tif (origin) { // Calculate baseline shifts\\n\\t\\tbaseline = $.effects.getBaseline( origin, original );\\n\\t\\tel.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;\\n\\t\\tel.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;\\n\\t\\tel.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;\\n\\t\\tel.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;\\n\\t}\\n\\tel.css( el.from ); // set top & left\\n\\n\\t// Animate\\n\\tif ( scale === \\\"content\\\" || scale === \\\"both\\\" ) { // Scale the children\\n\\n\\t\\t// Add margins/font-size\\n\\t\\tvProps = vProps.concat([ \\\"marginTop\\\", \\\"marginBottom\\\" ]).concat(cProps);\\n\\t\\thProps = hProps.concat([ \\\"marginLeft\\\", \\\"marginRight\\\" ]);\\n\\t\\tprops2 = props0.concat(vProps).concat(hProps);\\n\\n\\t\\tel.find( \\\"*[width]\\\" ).each( function(){\\n\\t\\t\\tvar child = $( this ),\\n\\t\\t\\t\\tc_original = {\\n\\t\\t\\t\\t\\theight: child.height(),\\n\\t\\t\\t\\t\\twidth: child.width(),\\n\\t\\t\\t\\t\\touterHeight: child.outerHeight(),\\n\\t\\t\\t\\t\\touterWidth: child.outerWidth()\\n\\t\\t\\t\\t};\\n\\t\\t\\tif (restore) {\\n\\t\\t\\t\\t$.effects.save(child, props2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tchild.from = {\\n\\t\\t\\t\\theight: c_original.height * factor.from.y,\\n\\t\\t\\t\\twidth: c_original.width * factor.from.x,\\n\\t\\t\\t\\touterHeight: c_original.outerHeight * factor.from.y,\\n\\t\\t\\t\\touterWidth: c_original.outerWidth * factor.from.x\\n\\t\\t\\t};\\n\\t\\t\\tchild.to = {\\n\\t\\t\\t\\theight: c_original.height * factor.to.y,\\n\\t\\t\\t\\twidth: c_original.width * factor.to.x,\\n\\t\\t\\t\\touterHeight: c_original.height * factor.to.y,\\n\\t\\t\\t\\touterWidth: c_original.width * factor.to.x\\n\\t\\t\\t};\\n\\n\\t\\t\\t// Vertical props scaling\\n\\t\\t\\tif ( factor.from.y !== factor.to.y ) {\\n\\t\\t\\t\\tchild.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );\\n\\t\\t\\t\\tchild.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Horizontal props scaling\\n\\t\\t\\tif ( factor.from.x !== factor.to.x ) {\\n\\t\\t\\t\\tchild.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );\\n\\t\\t\\t\\tchild.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Animate children\\n\\t\\t\\tchild.css( child.from );\\n\\t\\t\\tchild.animate( child.to, o.duration, o.easing, function() {\\n\\n\\t\\t\\t\\t// Restore children\\n\\t\\t\\t\\tif ( restore ) {\\n\\t\\t\\t\\t\\t$.effects.restore( child, props2 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t});\\n\\t}\\n\\n\\t// Animate\\n\\tel.animate( el.to, {\\n\\t\\tqueue: false,\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tcomplete: function() {\\n\\t\\t\\tif ( el.to.opacity === 0 ) {\\n\\t\\t\\t\\tel.css( \\\"opacity\\\", el.from.opacity );\\n\\t\\t\\t}\\n\\t\\t\\tif( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\tif ( !restore ) {\\n\\n\\t\\t\\t\\t// we need to calculate our new positioning based on the scaling\\n\\t\\t\\t\\tif ( position === \\\"static\\\" ) {\\n\\t\\t\\t\\t\\tel.css({\\n\\t\\t\\t\\t\\t\\tposition: \\\"relative\\\",\\n\\t\\t\\t\\t\\t\\ttop: el.to.top,\\n\\t\\t\\t\\t\\t\\tleft: el.to.left\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$.each([ \\\"top\\\", \\\"left\\\" ], function( idx, pos ) {\\n\\t\\t\\t\\t\\t\\tel.css( pos, function( _, str ) {\\n\\t\\t\\t\\t\\t\\t\\tvar val = parseInt( str, 10 ),\\n\\t\\t\\t\\t\\t\\t\\t\\ttoRef = idx ? el.to.left : el.to.top;\\n\\n\\t\\t\\t\\t\\t\\t\\t// if original was \\\"auto\\\", recalculate the new value from wrapper\\n\\t\\t\\t\\t\\t\\t\\tif ( str === \\\"auto\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn toRef + \\\"px\\\";\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\treturn val + toRef + \\\"px\\\";\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\t});\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.shake = function( o, done ) {\\n\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"height\\\", \\\"width\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"effect\\\" ),\\n\\t\\tdirection = o.direction || \\\"left\\\",\\n\\t\\tdistance = o.distance || 20,\\n\\t\\ttimes = o.times || 3,\\n\\t\\tanims = times * 2 + 1,\\n\\t\\tspeed = Math.round(o.duration/anims),\\n\\t\\tref = (direction === \\\"up\\\" || direction === \\\"down\\\") ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tpositiveMotion = (direction === \\\"up\\\" || direction === \\\"left\\\"),\\n\\t\\tanimation = {},\\n\\t\\tanimation1 = {},\\n\\t\\tanimation2 = {},\\n\\t\\ti,\\n\\n\\t\\t// we will need to re-assemble the queue to stack our animations in place\\n\\t\\tqueue = el.queue(),\\n\\t\\tqueuelen = queue.length;\\n\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\t$.effects.createWrapper( el );\\n\\n\\t// Animation\\n\\tanimation[ ref ] = ( positiveMotion ? \\\"-=\\\" : \\\"+=\\\" ) + distance;\\n\\tanimation1[ ref ] = ( positiveMotion ? \\\"+=\\\" : \\\"-=\\\" ) + distance * 2;\\n\\tanimation2[ ref ] = ( positiveMotion ? \\\"-=\\\" : \\\"+=\\\" ) + distance * 2;\\n\\n\\t// Animate\\n\\tel.animate( animation, speed, o.easing );\\n\\n\\t// Shakes\\n\\tfor ( i = 1; i < times; i++ ) {\\n\\t\\tel.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );\\n\\t}\\n\\tel\\n\\t\\t.animate( animation1, speed, o.easing )\\n\\t\\t.animate( animation, speed / 2, o.easing )\\n\\t\\t.queue(function() {\\n\\t\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t});\\n\\n\\t// inject all the animations we just queued to be first in line (after \\\"inprogress\\\")\\n\\tif ( queuelen > 1) {\\n\\t\\tqueue.splice.apply( queue,\\n\\t\\t\\t[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );\\n\\t}\\n\\tel.dequeue();\\n\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.slide = function( o, done ) {\\n\\n\\t// Create element\\n\\tvar el = $( this ),\\n\\t\\tprops = [ \\\"position\\\", \\\"top\\\", \\\"bottom\\\", \\\"left\\\", \\\"right\\\", \\\"width\\\", \\\"height\\\" ],\\n\\t\\tmode = $.effects.setMode( el, o.mode || \\\"show\\\" ),\\n\\t\\tshow = mode === \\\"show\\\",\\n\\t\\tdirection = o.direction || \\\"left\\\",\\n\\t\\tref = (direction === \\\"up\\\" || direction === \\\"down\\\") ? \\\"top\\\" : \\\"left\\\",\\n\\t\\tpositiveMotion = (direction === \\\"up\\\" || direction === \\\"left\\\"),\\n\\t\\tdistance,\\n\\t\\tanimation = {};\\n\\n\\t// Adjust\\n\\t$.effects.save( el, props );\\n\\tel.show();\\n\\tdistance = o.distance || el[ ref === \\\"top\\\" ? \\\"outerHeight\\\" : \\\"outerWidth\\\" ]( true );\\n\\n\\t$.effects.createWrapper( el ).css({\\n\\t\\toverflow: \\\"hidden\\\"\\n\\t});\\n\\n\\tif ( show ) {\\n\\t\\tel.css( ref, positiveMotion ? (isNaN(distance) ? \\\"-\\\" + distance : -distance) : distance );\\n\\t}\\n\\n\\t// Animation\\n\\tanimation[ ref ] = ( show ?\\n\\t\\t( positiveMotion ? \\\"+=\\\" : \\\"-=\\\") :\\n\\t\\t( positiveMotion ? \\\"-=\\\" : \\\"+=\\\")) +\\n\\t\\tdistance;\\n\\n\\t// Animate\\n\\tel.animate( animation, {\\n\\t\\tqueue: false,\\n\\t\\tduration: o.duration,\\n\\t\\teasing: o.easing,\\n\\t\\tcomplete: function() {\\n\\t\\t\\tif ( mode === \\\"hide\\\" ) {\\n\\t\\t\\t\\tel.hide();\\n\\t\\t\\t}\\n\\t\\t\\t$.effects.restore( el, props );\\n\\t\\t\\t$.effects.removeWrapper( el );\\n\\t\\t\\tdone();\\n\\t\\t}\\n\\t});\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.effects.effect.transfer = function( o, done ) {\\n\\tvar elem = $( this ),\\n\\t\\ttarget = $( o.to ),\\n\\t\\ttargetFixed = target.css( \\\"position\\\" ) === \\\"fixed\\\",\\n\\t\\tbody = $(\\\"body\\\"),\\n\\t\\tfixTop = targetFixed ? body.scrollTop() : 0,\\n\\t\\tfixLeft = targetFixed ? body.scrollLeft() : 0,\\n\\t\\tendPosition = target.offset(),\\n\\t\\tanimation = {\\n\\t\\t\\ttop: endPosition.top - fixTop ,\\n\\t\\t\\tleft: endPosition.left - fixLeft ,\\n\\t\\t\\theight: target.innerHeight(),\\n\\t\\t\\twidth: target.innerWidth()\\n\\t\\t},\\n\\t\\tstartPosition = elem.offset(),\\n\\t\\ttransfer = $( \\\"<div class='ui-effects-transfer'></div>\\\" )\\n\\t\\t\\t.appendTo( document.body )\\n\\t\\t\\t.addClass( o.className )\\n\\t\\t\\t.css({\\n\\t\\t\\t\\ttop: startPosition.top - fixTop ,\\n\\t\\t\\t\\tleft: startPosition.left - fixLeft ,\\n\\t\\t\\t\\theight: elem.innerHeight(),\\n\\t\\t\\t\\twidth: elem.innerWidth(),\\n\\t\\t\\t\\tposition: targetFixed ? \\\"fixed\\\" : \\\"absolute\\\"\\n\\t\\t\\t})\\n\\t\\t\\t.animate( animation, o.duration, o.easing, function() {\\n\\t\\t\\t\\ttransfer.remove();\\n\\t\\t\\t\\tdone();\\n\\t\\t\\t});\\n};\\n\\n})(jQuery);\\n\\n(function( $, undefined ) {\\n\\n$.widget( \\\"ui.menu\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\tdefaultElement: \\\"<ul>\\\",\\n\\tdelay: 300,\\n\\toptions: {\\n\\t\\ticons: {\\n\\t\\t\\tsubmenu: \\\"ui-icon-carat-1-e\\\"\\n\\t\\t},\\n\\t\\tmenus: \\\"ul\\\",\\n\\t\\tposition: {\\n\\t\\t\\tmy: \\\"left top\\\",\\n\\t\\t\\tat: \\\"right top\\\"\\n\\t\\t},\\n\\t\\trole: \\\"menu\\\",\\n\\n\\t\\t// callbacks\\n\\t\\tblur: null,\\n\\t\\tfocus: null,\\n\\t\\tselect: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tthis.activeMenu = this.element;\\n\\t\\t// flag used to prevent firing of the click handler\\n\\t\\t// as the event bubbles up through nested menus\\n\\t\\tthis.mouseHandled = false;\\n\\t\\tthis.element\\n\\t\\t\\t.uniqueId()\\n\\t\\t\\t.addClass( \\\"ui-menu ui-widget ui-widget-content ui-corner-all\\\" )\\n\\t\\t\\t.toggleClass( \\\"ui-menu-icons\\\", !!this.element.find( \\\".ui-icon\\\" ).length )\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\trole: this.options.role,\\n\\t\\t\\t\\ttabIndex: 0\\n\\t\\t\\t})\\n\\t\\t\\t// need to catch all clicks on disabled menu\\n\\t\\t\\t// not possible through _on\\n\\t\\t\\t.bind( \\\"click\\\" + this.eventNamespace, $.proxy(function( event ) {\\n\\t\\t\\t\\tif ( this.options.disabled ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, this ));\\n\\n\\t\\tif ( this.options.disabled ) {\\n\\t\\t\\tthis.element\\n\\t\\t\\t\\t.addClass( \\\"ui-state-disabled\\\" )\\n\\t\\t\\t\\t.attr( \\\"aria-disabled\\\", \\\"true\\\" );\\n\\t\\t}\\n\\n\\t\\tthis._on({\\n\\t\\t\\t// Prevent focus from sticking to links inside menu after clicking\\n\\t\\t\\t// them (focus should always stay on UL during navigation).\\n\\t\\t\\t\\\"mousedown .ui-menu-item > a\\\": function( event ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t},\\n\\t\\t\\t\\\"click .ui-state-disabled > a\\\": function( event ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t},\\n\\t\\t\\t\\\"click .ui-menu-item:has(a)\\\": function( event ) {\\n\\t\\t\\t\\tvar target = $( event.target ).closest( \\\".ui-menu-item\\\" );\\n\\t\\t\\t\\tif ( !this.mouseHandled && target.not( \\\".ui-state-disabled\\\" ).length ) {\\n\\t\\t\\t\\t\\tthis.mouseHandled = true;\\n\\n\\t\\t\\t\\t\\tthis.select( event );\\n\\t\\t\\t\\t\\t// Open submenu on click\\n\\t\\t\\t\\t\\tif ( target.has( \\\".ui-menu\\\" ).length ) {\\n\\t\\t\\t\\t\\t\\tthis.expand( event );\\n\\t\\t\\t\\t\\t} else if ( !this.element.is( \\\":focus\\\" ) ) {\\n\\t\\t\\t\\t\\t\\t// Redirect focus to the menu\\n\\t\\t\\t\\t\\t\\tthis.element.trigger( \\\"focus\\\", [ true ] );\\n\\n\\t\\t\\t\\t\\t\\t// If the active item is on the top level, let it stay active.\\n\\t\\t\\t\\t\\t\\t// Otherwise, blur the active item since it is no longer visible.\\n\\t\\t\\t\\t\\t\\tif ( this.active && this.active.parents( \\\".ui-menu\\\" ).length === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tclearTimeout( this.timer );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t\\\"mouseenter .ui-menu-item\\\": function( event ) {\\n\\t\\t\\t\\tvar target = $( event.currentTarget );\\n\\t\\t\\t\\t// Remove ui-state-active class from siblings of the newly focused menu item\\n\\t\\t\\t\\t// to avoid a jump caused by adjacent elements both having a class with a border\\n\\t\\t\\t\\ttarget.siblings().children( \\\".ui-state-active\\\" ).removeClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\tthis.focus( event, target );\\n\\t\\t\\t},\\n\\t\\t\\tmouseleave: \\\"collapseAll\\\",\\n\\t\\t\\t\\\"mouseleave .ui-menu\\\": \\\"collapseAll\\\",\\n\\t\\t\\tfocus: function( event, keepActiveItem ) {\\n\\t\\t\\t\\t// If there's already an active item, keep it active\\n\\t\\t\\t\\t// If not, activate the first item\\n\\t\\t\\t\\tvar item = this.active || this.element.children( \\\".ui-menu-item\\\" ).eq( 0 );\\n\\n\\t\\t\\t\\tif ( !keepActiveItem ) {\\n\\t\\t\\t\\t\\tthis.focus( event, item );\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tblur: function( event ) {\\n\\t\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t\\tif ( !$.contains( this.element[0], this.document[0].activeElement ) ) {\\n\\t\\t\\t\\t\\t\\tthis.collapseAll( event );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t},\\n\\t\\t\\tkeydown: \\\"_keydown\\\"\\n\\t\\t});\\n\\n\\t\\tthis.refresh();\\n\\n\\t\\t// Clicks outside of a menu collapse any open menus\\n\\t\\tthis._on( this.document, {\\n\\t\\t\\tclick: function( event ) {\\n\\t\\t\\t\\tif ( !$( event.target ).closest( \\\".ui-menu\\\" ).length ) {\\n\\t\\t\\t\\t\\tthis.collapseAll( event );\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Reset the mouseHandled flag\\n\\t\\t\\t\\tthis.mouseHandled = false;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\t// Destroy (sub)menus\\n\\t\\tthis.element\\n\\t\\t\\t.removeAttr( \\\"aria-activedescendant\\\" )\\n\\t\\t\\t.find( \\\".ui-menu\\\" ).addBack()\\n\\t\\t\\t\\t.removeClass( \\\"ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"tabIndex\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"aria-labelledby\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"aria-expanded\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"aria-hidden\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"aria-disabled\\\" )\\n\\t\\t\\t\\t.removeUniqueId()\\n\\t\\t\\t\\t.show();\\n\\n\\t\\t// Destroy menu items\\n\\t\\tthis.element.find( \\\".ui-menu-item\\\" )\\n\\t\\t\\t.removeClass( \\\"ui-menu-item\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-disabled\\\" )\\n\\t\\t\\t.children( \\\"a\\\" )\\n\\t\\t\\t\\t.removeUniqueId()\\n\\t\\t\\t\\t.removeClass( \\\"ui-corner-all ui-state-hover\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"tabIndex\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t\\t.removeAttr( \\\"aria-haspopup\\\" )\\n\\t\\t\\t\\t.children().each( function() {\\n\\t\\t\\t\\t\\tvar elem = $( this );\\n\\t\\t\\t\\t\\tif ( elem.data( \\\"ui-menu-submenu-carat\\\" ) ) {\\n\\t\\t\\t\\t\\t\\telem.remove();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\n\\t\\t// Destroy menu dividers\\n\\t\\tthis.element.find( \\\".ui-menu-divider\\\" ).removeClass( \\\"ui-menu-divider ui-widget-content\\\" );\\n\\t},\\n\\n\\t_keydown: function( event ) {\\n\\t\\t/*jshint maxcomplexity:20*/\\n\\t\\tvar match, prev, character, skip, regex,\\n\\t\\t\\tpreventDefault = true;\\n\\n\\t\\tfunction escape( value ) {\\n\\t\\t\\treturn value.replace( /[\\\\-\\\\[\\\\]{}()*+?.,\\\\\\\\\\\\^$|#\\\\s]/g, \\\"\\\\\\\\$&\\\" );\\n\\t\\t}\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\t\\tcase $.ui.keyCode.PAGE_UP:\\n\\t\\t\\tthis.previousPage( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.PAGE_DOWN:\\n\\t\\t\\tthis.nextPage( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.HOME:\\n\\t\\t\\tthis._move( \\\"first\\\", \\\"first\\\", event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.END:\\n\\t\\t\\tthis._move( \\\"last\\\", \\\"last\\\", event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.UP:\\n\\t\\t\\tthis.previous( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.DOWN:\\n\\t\\t\\tthis.next( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.LEFT:\\n\\t\\t\\tthis.collapse( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.RIGHT:\\n\\t\\t\\tif ( this.active && !this.active.is( \\\".ui-state-disabled\\\" ) ) {\\n\\t\\t\\t\\tthis.expand( event );\\n\\t\\t\\t}\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.ENTER:\\n\\t\\tcase $.ui.keyCode.SPACE:\\n\\t\\t\\tthis._activate( event );\\n\\t\\t\\tbreak;\\n\\t\\tcase $.ui.keyCode.ESCAPE:\\n\\t\\t\\tthis.collapse( event );\\n\\t\\t\\tbreak;\\n\\t\\tdefault:\\n\\t\\t\\tpreventDefault = false;\\n\\t\\t\\tprev = this.previousFilter || \\\"\\\";\\n\\t\\t\\tcharacter = String.fromCharCode( event.keyCode );\\n\\t\\t\\tskip = false;\\n\\n\\t\\t\\tclearTimeout( this.filterTimer );\\n\\n\\t\\t\\tif ( character === prev ) {\\n\\t\\t\\t\\tskip = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcharacter = prev + character;\\n\\t\\t\\t}\\n\\n\\t\\t\\tregex = new RegExp( \\\"^\\\" + escape( character ), \\\"i\\\" );\\n\\t\\t\\tmatch = this.activeMenu.children( \\\".ui-menu-item\\\" ).filter(function() {\\n\\t\\t\\t\\treturn regex.test( $( this ).children( \\\"a\\\" ).text() );\\n\\t\\t\\t});\\n\\t\\t\\tmatch = skip && match.index( this.active.next() ) !== -1 ?\\n\\t\\t\\t\\tthis.active.nextAll( \\\".ui-menu-item\\\" ) :\\n\\t\\t\\t\\tmatch;\\n\\n\\t\\t\\t// If no matches on the current filter, reset to the last character pressed\\n\\t\\t\\t// to move down the menu to the first item that starts with that character\\n\\t\\t\\tif ( !match.length ) {\\n\\t\\t\\t\\tcharacter = String.fromCharCode( event.keyCode );\\n\\t\\t\\t\\tregex = new RegExp( \\\"^\\\" + escape( character ), \\\"i\\\" );\\n\\t\\t\\t\\tmatch = this.activeMenu.children( \\\".ui-menu-item\\\" ).filter(function() {\\n\\t\\t\\t\\t\\treturn regex.test( $( this ).children( \\\"a\\\" ).text() );\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( match.length ) {\\n\\t\\t\\t\\tthis.focus( event, match );\\n\\t\\t\\t\\tif ( match.length > 1 ) {\\n\\t\\t\\t\\t\\tthis.previousFilter = character;\\n\\t\\t\\t\\t\\tthis.filterTimer = this._delay(function() {\\n\\t\\t\\t\\t\\t\\tdelete this.previousFilter;\\n\\t\\t\\t\\t\\t}, 1000 );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdelete this.previousFilter;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdelete this.previousFilter;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( preventDefault ) {\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t}\\n\\t},\\n\\n\\t_activate: function( event ) {\\n\\t\\tif ( !this.active.is( \\\".ui-state-disabled\\\" ) ) {\\n\\t\\t\\tif ( this.active.children( \\\"a[aria-haspopup='true']\\\" ).length ) {\\n\\t\\t\\t\\tthis.expand( event );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.select( event );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\trefresh: function() {\\n\\t\\tvar menus,\\n\\t\\t\\ticon = this.options.icons.submenu,\\n\\t\\t\\tsubmenus = this.element.find( this.options.menus );\\n\\n\\t\\t// Initialize nested menus\\n\\t\\tsubmenus.filter( \\\":not(.ui-menu)\\\" )\\n\\t\\t\\t.addClass( \\\"ui-menu ui-widget ui-widget-content ui-corner-all\\\" )\\n\\t\\t\\t.hide()\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\trole: this.options.role,\\n\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"false\\\"\\n\\t\\t\\t})\\n\\t\\t\\t.each(function() {\\n\\t\\t\\t\\tvar menu = $( this ),\\n\\t\\t\\t\\t\\titem = menu.prev( \\\"a\\\" ),\\n\\t\\t\\t\\t\\tsubmenuCarat = $( \\\"<span>\\\" )\\n\\t\\t\\t\\t\\t\\t.addClass( \\\"ui-menu-icon ui-icon \\\" + icon )\\n\\t\\t\\t\\t\\t\\t.data( \\\"ui-menu-submenu-carat\\\", true );\\n\\n\\t\\t\\t\\titem\\n\\t\\t\\t\\t\\t.attr( \\\"aria-haspopup\\\", \\\"true\\\" )\\n\\t\\t\\t\\t\\t.prepend( submenuCarat );\\n\\t\\t\\t\\tmenu.attr( \\\"aria-labelledby\\\", item.attr( \\\"id\\\" ) );\\n\\t\\t\\t});\\n\\n\\t\\tmenus = submenus.add( this.element );\\n\\n\\t\\t// Don't refresh list items that are already adapted\\n\\t\\tmenus.children( \\\":not(.ui-menu-item):has(a)\\\" )\\n\\t\\t\\t.addClass( \\\"ui-menu-item\\\" )\\n\\t\\t\\t.attr( \\\"role\\\", \\\"presentation\\\" )\\n\\t\\t\\t.children( \\\"a\\\" )\\n\\t\\t\\t\\t.uniqueId()\\n\\t\\t\\t\\t.addClass( \\\"ui-corner-all\\\" )\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\ttabIndex: -1,\\n\\t\\t\\t\\t\\trole: this._itemRole()\\n\\t\\t\\t\\t});\\n\\n\\t\\t// Initialize unlinked menu-items containing spaces and/or dashes only as dividers\\n\\t\\tmenus.children( \\\":not(.ui-menu-item)\\\" ).each(function() {\\n\\t\\t\\tvar item = $( this );\\n\\t\\t\\t// hyphen, em dash, en dash\\n\\t\\t\\tif ( !/[^\\\\-\\\\u2014\\\\u2013\\\\s]/.test( item.text() ) ) {\\n\\t\\t\\t\\titem.addClass( \\\"ui-widget-content ui-menu-divider\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\t// Add aria-disabled attribute to any disabled menu item\\n\\t\\tmenus.children( \\\".ui-state-disabled\\\" ).attr( \\\"aria-disabled\\\", \\\"true\\\" );\\n\\n\\t\\t// If the active item has been removed, blur the menu\\n\\t\\tif ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {\\n\\t\\t\\tthis.blur();\\n\\t\\t}\\n\\t},\\n\\n\\t_itemRole: function() {\\n\\t\\treturn {\\n\\t\\t\\tmenu: \\\"menuitem\\\",\\n\\t\\t\\tlistbox: \\\"option\\\"\\n\\t\\t}[ this.options.role ];\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"icons\\\" ) {\\n\\t\\t\\tthis.element.find( \\\".ui-menu-icon\\\" )\\n\\t\\t\\t\\t.removeClass( this.options.icons.submenu )\\n\\t\\t\\t\\t.addClass( value.submenu );\\n\\t\\t}\\n\\t\\tthis._super( key, value );\\n\\t},\\n\\n\\tfocus: function( event, item ) {\\n\\t\\tvar nested, focused;\\n\\t\\tthis.blur( event, event && event.type === \\\"focus\\\" );\\n\\n\\t\\tthis._scrollIntoView( item );\\n\\n\\t\\tthis.active = item.first();\\n\\t\\tfocused = this.active.children( \\\"a\\\" ).addClass( \\\"ui-state-focus\\\" );\\n\\t\\t// Only update aria-activedescendant if there's a role\\n\\t\\t// otherwise we assume focus is managed elsewhere\\n\\t\\tif ( this.options.role ) {\\n\\t\\t\\tthis.element.attr( \\\"aria-activedescendant\\\", focused.attr( \\\"id\\\" ) );\\n\\t\\t}\\n\\n\\t\\t// Highlight active parent menu item, if any\\n\\t\\tthis.active\\n\\t\\t\\t.parent()\\n\\t\\t\\t.closest( \\\".ui-menu-item\\\" )\\n\\t\\t\\t.children( \\\"a:first\\\" )\\n\\t\\t\\t.addClass( \\\"ui-state-active\\\" );\\n\\n\\t\\tif ( event && event.type === \\\"keydown\\\" ) {\\n\\t\\t\\tthis._close();\\n\\t\\t} else {\\n\\t\\t\\tthis.timer = this._delay(function() {\\n\\t\\t\\t\\tthis._close();\\n\\t\\t\\t}, this.delay );\\n\\t\\t}\\n\\n\\t\\tnested = item.children( \\\".ui-menu\\\" );\\n\\t\\tif ( nested.length && ( /^mouse/.test( event.type ) ) ) {\\n\\t\\t\\tthis._startOpening(nested);\\n\\t\\t}\\n\\t\\tthis.activeMenu = item.parent();\\n\\n\\t\\tthis._trigger( \\\"focus\\\", event, { item: item } );\\n\\t},\\n\\n\\t_scrollIntoView: function( item ) {\\n\\t\\tvar borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;\\n\\t\\tif ( this._hasScroll() ) {\\n\\t\\t\\tborderTop = parseFloat( $.css( this.activeMenu[0], \\\"borderTopWidth\\\" ) ) || 0;\\n\\t\\t\\tpaddingTop = parseFloat( $.css( this.activeMenu[0], \\\"paddingTop\\\" ) ) || 0;\\n\\t\\t\\toffset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;\\n\\t\\t\\tscroll = this.activeMenu.scrollTop();\\n\\t\\t\\telementHeight = this.activeMenu.height();\\n\\t\\t\\titemHeight = item.height();\\n\\n\\t\\t\\tif ( offset < 0 ) {\\n\\t\\t\\t\\tthis.activeMenu.scrollTop( scroll + offset );\\n\\t\\t\\t} else if ( offset + itemHeight > elementHeight ) {\\n\\t\\t\\t\\tthis.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\tblur: function( event, fromFocus ) {\\n\\t\\tif ( !fromFocus ) {\\n\\t\\t\\tclearTimeout( this.timer );\\n\\t\\t}\\n\\n\\t\\tif ( !this.active ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.active.children( \\\"a\\\" ).removeClass( \\\"ui-state-focus\\\" );\\n\\t\\tthis.active = null;\\n\\n\\t\\tthis._trigger( \\\"blur\\\", event, { item: this.active } );\\n\\t},\\n\\n\\t_startOpening: function( submenu ) {\\n\\t\\tclearTimeout( this.timer );\\n\\n\\t\\t// Don't open if already open fixes a Firefox bug that caused a .5 pixel\\n\\t\\t// shift in the submenu position when mousing over the carat icon\\n\\t\\tif ( submenu.attr( \\\"aria-hidden\\\" ) !== \\\"true\\\" ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.timer = this._delay(function() {\\n\\t\\t\\tthis._close();\\n\\t\\t\\tthis._open( submenu );\\n\\t\\t}, this.delay );\\n\\t},\\n\\n\\t_open: function( submenu ) {\\n\\t\\tvar position = $.extend({\\n\\t\\t\\tof: this.active\\n\\t\\t}, this.options.position );\\n\\n\\t\\tclearTimeout( this.timer );\\n\\t\\tthis.element.find( \\\".ui-menu\\\" ).not( submenu.parents( \\\".ui-menu\\\" ) )\\n\\t\\t\\t.hide()\\n\\t\\t\\t.attr( \\\"aria-hidden\\\", \\\"true\\\" );\\n\\n\\t\\tsubmenu\\n\\t\\t\\t.show()\\n\\t\\t\\t.removeAttr( \\\"aria-hidden\\\" )\\n\\t\\t\\t.attr( \\\"aria-expanded\\\", \\\"true\\\" )\\n\\t\\t\\t.position( position );\\n\\t},\\n\\n\\tcollapseAll: function( event, all ) {\\n\\t\\tclearTimeout( this.timer );\\n\\t\\tthis.timer = this._delay(function() {\\n\\t\\t\\t// If we were passed an event, look for the submenu that contains the event\\n\\t\\t\\tvar currentMenu = all ? this.element :\\n\\t\\t\\t\\t$( event && event.target ).closest( this.element.find( \\\".ui-menu\\\" ) );\\n\\n\\t\\t\\t// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway\\n\\t\\t\\tif ( !currentMenu.length ) {\\n\\t\\t\\t\\tcurrentMenu = this.element;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._close( currentMenu );\\n\\n\\t\\t\\tthis.blur( event );\\n\\t\\t\\tthis.activeMenu = currentMenu;\\n\\t\\t}, this.delay );\\n\\t},\\n\\n\\t// With no arguments, closes the currently active menu - if nothing is active\\n\\t// it closes all menus.  If passed an argument, it will search for menus BELOW\\n\\t_close: function( startMenu ) {\\n\\t\\tif ( !startMenu ) {\\n\\t\\t\\tstartMenu = this.active ? this.active.parent() : this.element;\\n\\t\\t}\\n\\n\\t\\tstartMenu\\n\\t\\t\\t.find( \\\".ui-menu\\\" )\\n\\t\\t\\t\\t.hide()\\n\\t\\t\\t\\t.attr( \\\"aria-hidden\\\", \\\"true\\\" )\\n\\t\\t\\t\\t.attr( \\\"aria-expanded\\\", \\\"false\\\" )\\n\\t\\t\\t.end()\\n\\t\\t\\t.find( \\\"a.ui-state-active\\\" )\\n\\t\\t\\t\\t.removeClass( \\\"ui-state-active\\\" );\\n\\t},\\n\\n\\tcollapse: function( event ) {\\n\\t\\tvar newItem = this.active &&\\n\\t\\t\\tthis.active.parent().closest( \\\".ui-menu-item\\\", this.element );\\n\\t\\tif ( newItem && newItem.length ) {\\n\\t\\t\\tthis._close();\\n\\t\\t\\tthis.focus( event, newItem );\\n\\t\\t}\\n\\t},\\n\\n\\texpand: function( event ) {\\n\\t\\tvar newItem = this.active &&\\n\\t\\t\\tthis.active\\n\\t\\t\\t\\t.children( \\\".ui-menu \\\" )\\n\\t\\t\\t\\t.children( \\\".ui-menu-item\\\" )\\n\\t\\t\\t\\t.first();\\n\\n\\t\\tif ( newItem && newItem.length ) {\\n\\t\\t\\tthis._open( newItem.parent() );\\n\\n\\t\\t\\t// Delay so Firefox will not hide activedescendant change in expanding submenu from AT\\n\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\tthis.focus( event, newItem );\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\tnext: function( event ) {\\n\\t\\tthis._move( \\\"next\\\", \\\"first\\\", event );\\n\\t},\\n\\n\\tprevious: function( event ) {\\n\\t\\tthis._move( \\\"prev\\\", \\\"last\\\", event );\\n\\t},\\n\\n\\tisFirstItem: function() {\\n\\t\\treturn this.active && !this.active.prevAll( \\\".ui-menu-item\\\" ).length;\\n\\t},\\n\\n\\tisLastItem: function() {\\n\\t\\treturn this.active && !this.active.nextAll( \\\".ui-menu-item\\\" ).length;\\n\\t},\\n\\n\\t_move: function( direction, filter, event ) {\\n\\t\\tvar next;\\n\\t\\tif ( this.active ) {\\n\\t\\t\\tif ( direction === \\\"first\\\" || direction === \\\"last\\\" ) {\\n\\t\\t\\t\\tnext = this.active\\n\\t\\t\\t\\t\\t[ direction === \\\"first\\\" ? \\\"prevAll\\\" : \\\"nextAll\\\" ]( \\\".ui-menu-item\\\" )\\n\\t\\t\\t\\t\\t.eq( -1 );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnext = this.active\\n\\t\\t\\t\\t\\t[ direction + \\\"All\\\" ]( \\\".ui-menu-item\\\" )\\n\\t\\t\\t\\t\\t.eq( 0 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( !next || !next.length || !this.active ) {\\n\\t\\t\\tnext = this.activeMenu.children( \\\".ui-menu-item\\\" )[ filter ]();\\n\\t\\t}\\n\\n\\t\\tthis.focus( event, next );\\n\\t},\\n\\n\\tnextPage: function( event ) {\\n\\t\\tvar item, base, height;\\n\\n\\t\\tif ( !this.active ) {\\n\\t\\t\\tthis.next( event );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( this.isLastItem() ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( this._hasScroll() ) {\\n\\t\\t\\tbase = this.active.offset().top;\\n\\t\\t\\theight = this.element.height();\\n\\t\\t\\tthis.active.nextAll( \\\".ui-menu-item\\\" ).each(function() {\\n\\t\\t\\t\\titem = $( this );\\n\\t\\t\\t\\treturn item.offset().top - base - height < 0;\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.focus( event, item );\\n\\t\\t} else {\\n\\t\\t\\tthis.focus( event, this.activeMenu.children( \\\".ui-menu-item\\\" )\\n\\t\\t\\t\\t[ !this.active ? \\\"first\\\" : \\\"last\\\" ]() );\\n\\t\\t}\\n\\t},\\n\\n\\tpreviousPage: function( event ) {\\n\\t\\tvar item, base, height;\\n\\t\\tif ( !this.active ) {\\n\\t\\t\\tthis.next( event );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( this.isFirstItem() ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( this._hasScroll() ) {\\n\\t\\t\\tbase = this.active.offset().top;\\n\\t\\t\\theight = this.element.height();\\n\\t\\t\\tthis.active.prevAll( \\\".ui-menu-item\\\" ).each(function() {\\n\\t\\t\\t\\titem = $( this );\\n\\t\\t\\t\\treturn item.offset().top - base + height > 0;\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.focus( event, item );\\n\\t\\t} else {\\n\\t\\t\\tthis.focus( event, this.activeMenu.children( \\\".ui-menu-item\\\" ).first() );\\n\\t\\t}\\n\\t},\\n\\n\\t_hasScroll: function() {\\n\\t\\treturn this.element.outerHeight() < this.element.prop( \\\"scrollHeight\\\" );\\n\\t},\\n\\n\\tselect: function( event ) {\\n\\t\\t// TODO: It should never be possible to not have an active item at this\\n\\t\\t// point, but the tests don't trigger mouseenter before click.\\n\\t\\tthis.active = this.active || $( event.target ).closest( \\\".ui-menu-item\\\" );\\n\\t\\tvar ui = { item: this.active };\\n\\t\\tif ( !this.active.has( \\\".ui-menu\\\" ).length ) {\\n\\t\\t\\tthis.collapseAll( event, true );\\n\\t\\t}\\n\\t\\tthis._trigger( \\\"select\\\", event, ui );\\n\\t}\\n});\\n\\n}( jQuery ));\\n\\n(function( $, undefined ) {\\n\\n$.ui = $.ui || {};\\n\\nvar cachedScrollbarWidth,\\n\\tmax = Math.max,\\n\\tabs = Math.abs,\\n\\tround = Math.round,\\n\\trhorizontal = /left|center|right/,\\n\\trvertical = /top|center|bottom/,\\n\\troffset = /[\\\\+\\\\-]\\\\d+(\\\\.[\\\\d]+)?%?/,\\n\\trposition = /^\\\\w+/,\\n\\trpercent = /%$/,\\n\\t_position = $.fn.position;\\n\\nfunction getOffsets( offsets, width, height ) {\\n\\treturn [\\n\\t\\tparseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),\\n\\t\\tparseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )\\n\\t];\\n}\\n\\nfunction parseCss( element, property ) {\\n\\treturn parseInt( $.css( element, property ), 10 ) || 0;\\n}\\n\\nfunction getDimensions( elem ) {\\n\\tvar raw = elem[0];\\n\\tif ( raw.nodeType === 9 ) {\\n\\t\\treturn {\\n\\t\\t\\twidth: elem.width(),\\n\\t\\t\\theight: elem.height(),\\n\\t\\t\\toffset: { top: 0, left: 0 }\\n\\t\\t};\\n\\t}\\n\\tif ( $.isWindow( raw ) ) {\\n\\t\\treturn {\\n\\t\\t\\twidth: elem.width(),\\n\\t\\t\\theight: elem.height(),\\n\\t\\t\\toffset: { top: elem.scrollTop(), left: elem.scrollLeft() }\\n\\t\\t};\\n\\t}\\n\\tif ( raw.preventDefault ) {\\n\\t\\treturn {\\n\\t\\t\\twidth: 0,\\n\\t\\t\\theight: 0,\\n\\t\\t\\toffset: { top: raw.pageY, left: raw.pageX }\\n\\t\\t};\\n\\t}\\n\\treturn {\\n\\t\\twidth: elem.outerWidth(),\\n\\t\\theight: elem.outerHeight(),\\n\\t\\toffset: elem.offset()\\n\\t};\\n}\\n\\n$.position = {\\n\\tscrollbarWidth: function() {\\n\\t\\tif ( cachedScrollbarWidth !== undefined ) {\\n\\t\\t\\treturn cachedScrollbarWidth;\\n\\t\\t}\\n\\t\\tvar w1, w2,\\n\\t\\t\\tdiv = $( \\\"<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>\\\" ),\\n\\t\\t\\tinnerDiv = div.children()[0];\\n\\n\\t\\t$( \\\"body\\\" ).append( div );\\n\\t\\tw1 = innerDiv.offsetWidth;\\n\\t\\tdiv.css( \\\"overflow\\\", \\\"scroll\\\" );\\n\\n\\t\\tw2 = innerDiv.offsetWidth;\\n\\n\\t\\tif ( w1 === w2 ) {\\n\\t\\t\\tw2 = div[0].clientWidth;\\n\\t\\t}\\n\\n\\t\\tdiv.remove();\\n\\n\\t\\treturn (cachedScrollbarWidth = w1 - w2);\\n\\t},\\n\\tgetScrollInfo: function( within ) {\\n\\t\\tvar overflowX = within.isWindow ? \\\"\\\" : within.element.css( \\\"overflow-x\\\" ),\\n\\t\\t\\toverflowY = within.isWindow ? \\\"\\\" : within.element.css( \\\"overflow-y\\\" ),\\n\\t\\t\\thasOverflowX = overflowX === \\\"scroll\\\" ||\\n\\t\\t\\t\\t( overflowX === \\\"auto\\\" && within.width < within.element[0].scrollWidth ),\\n\\t\\t\\thasOverflowY = overflowY === \\\"scroll\\\" ||\\n\\t\\t\\t\\t( overflowY === \\\"auto\\\" && within.height < within.element[0].scrollHeight );\\n\\t\\treturn {\\n\\t\\t\\twidth: hasOverflowY ? $.position.scrollbarWidth() : 0,\\n\\t\\t\\theight: hasOverflowX ? $.position.scrollbarWidth() : 0\\n\\t\\t};\\n\\t},\\n\\tgetWithinInfo: function( element ) {\\n\\t\\tvar withinElement = $( element || window ),\\n\\t\\t\\tisWindow = $.isWindow( withinElement[0] );\\n\\t\\treturn {\\n\\t\\t\\telement: withinElement,\\n\\t\\t\\tisWindow: isWindow,\\n\\t\\t\\toffset: withinElement.offset() || { left: 0, top: 0 },\\n\\t\\t\\tscrollLeft: withinElement.scrollLeft(),\\n\\t\\t\\tscrollTop: withinElement.scrollTop(),\\n\\t\\t\\twidth: isWindow ? withinElement.width() : withinElement.outerWidth(),\\n\\t\\t\\theight: isWindow ? withinElement.height() : withinElement.outerHeight()\\n\\t\\t};\\n\\t}\\n};\\n\\n$.fn.position = function( options ) {\\n\\tif ( !options || !options.of ) {\\n\\t\\treturn _position.apply( this, arguments );\\n\\t}\\n\\n\\t// make a copy, we don't want to modify arguments\\n\\toptions = $.extend( {}, options );\\n\\n\\tvar atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,\\n\\t\\ttarget = $( options.of ),\\n\\t\\twithin = $.position.getWithinInfo( options.within ),\\n\\t\\tscrollInfo = $.position.getScrollInfo( within ),\\n\\t\\tcollision = ( options.collision || \\\"flip\\\" ).split( \\\" \\\" ),\\n\\t\\toffsets = {};\\n\\n\\tdimensions = getDimensions( target );\\n\\tif ( target[0].preventDefault ) {\\n\\t\\t// force left top to allow flipping\\n\\t\\toptions.at = \\\"left top\\\";\\n\\t}\\n\\ttargetWidth = dimensions.width;\\n\\ttargetHeight = dimensions.height;\\n\\ttargetOffset = dimensions.offset;\\n\\t// clone to reuse original targetOffset later\\n\\tbasePosition = $.extend( {}, targetOffset );\\n\\n\\t// force my and at to have valid horizontal and vertical positions\\n\\t// if a value is missing or invalid, it will be converted to center\\n\\t$.each( [ \\\"my\\\", \\\"at\\\" ], function() {\\n\\t\\tvar pos = ( options[ this ] || \\\"\\\" ).split( \\\" \\\" ),\\n\\t\\t\\thorizontalOffset,\\n\\t\\t\\tverticalOffset;\\n\\n\\t\\tif ( pos.length === 1) {\\n\\t\\t\\tpos = rhorizontal.test( pos[ 0 ] ) ?\\n\\t\\t\\t\\tpos.concat( [ \\\"center\\\" ] ) :\\n\\t\\t\\t\\trvertical.test( pos[ 0 ] ) ?\\n\\t\\t\\t\\t\\t[ \\\"center\\\" ].concat( pos ) :\\n\\t\\t\\t\\t\\t[ \\\"center\\\", \\\"center\\\" ];\\n\\t\\t}\\n\\t\\tpos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : \\\"center\\\";\\n\\t\\tpos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : \\\"center\\\";\\n\\n\\t\\t// calculate offsets\\n\\t\\thorizontalOffset = roffset.exec( pos[ 0 ] );\\n\\t\\tverticalOffset = roffset.exec( pos[ 1 ] );\\n\\t\\toffsets[ this ] = [\\n\\t\\t\\thorizontalOffset ? horizontalOffset[ 0 ] : 0,\\n\\t\\t\\tverticalOffset ? verticalOffset[ 0 ] : 0\\n\\t\\t];\\n\\n\\t\\t// reduce to just the positions without the offsets\\n\\t\\toptions[ this ] = [\\n\\t\\t\\trposition.exec( pos[ 0 ] )[ 0 ],\\n\\t\\t\\trposition.exec( pos[ 1 ] )[ 0 ]\\n\\t\\t];\\n\\t});\\n\\n\\t// normalize collision option\\n\\tif ( collision.length === 1 ) {\\n\\t\\tcollision[ 1 ] = collision[ 0 ];\\n\\t}\\n\\n\\tif ( options.at[ 0 ] === \\\"right\\\" ) {\\n\\t\\tbasePosition.left += targetWidth;\\n\\t} else if ( options.at[ 0 ] === \\\"center\\\" ) {\\n\\t\\tbasePosition.left += targetWidth / 2;\\n\\t}\\n\\n\\tif ( options.at[ 1 ] === \\\"bottom\\\" ) {\\n\\t\\tbasePosition.top += targetHeight;\\n\\t} else if ( options.at[ 1 ] === \\\"center\\\" ) {\\n\\t\\tbasePosition.top += targetHeight / 2;\\n\\t}\\n\\n\\tatOffset = getOffsets( offsets.at, targetWidth, targetHeight );\\n\\tbasePosition.left += atOffset[ 0 ];\\n\\tbasePosition.top += atOffset[ 1 ];\\n\\n\\treturn this.each(function() {\\n\\t\\tvar collisionPosition, using,\\n\\t\\t\\telem = $( this ),\\n\\t\\t\\telemWidth = elem.outerWidth(),\\n\\t\\t\\telemHeight = elem.outerHeight(),\\n\\t\\t\\tmarginLeft = parseCss( this, \\\"marginLeft\\\" ),\\n\\t\\t\\tmarginTop = parseCss( this, \\\"marginTop\\\" ),\\n\\t\\t\\tcollisionWidth = elemWidth + marginLeft + parseCss( this, \\\"marginRight\\\" ) + scrollInfo.width,\\n\\t\\t\\tcollisionHeight = elemHeight + marginTop + parseCss( this, \\\"marginBottom\\\" ) + scrollInfo.height,\\n\\t\\t\\tposition = $.extend( {}, basePosition ),\\n\\t\\t\\tmyOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );\\n\\n\\t\\tif ( options.my[ 0 ] === \\\"right\\\" ) {\\n\\t\\t\\tposition.left -= elemWidth;\\n\\t\\t} else if ( options.my[ 0 ] === \\\"center\\\" ) {\\n\\t\\t\\tposition.left -= elemWidth / 2;\\n\\t\\t}\\n\\n\\t\\tif ( options.my[ 1 ] === \\\"bottom\\\" ) {\\n\\t\\t\\tposition.top -= elemHeight;\\n\\t\\t} else if ( options.my[ 1 ] === \\\"center\\\" ) {\\n\\t\\t\\tposition.top -= elemHeight / 2;\\n\\t\\t}\\n\\n\\t\\tposition.left += myOffset[ 0 ];\\n\\t\\tposition.top += myOffset[ 1 ];\\n\\n\\t\\t// if the browser doesn't support fractions, then round for consistent results\\n\\t\\tif ( !$.support.offsetFractions ) {\\n\\t\\t\\tposition.left = round( position.left );\\n\\t\\t\\tposition.top = round( position.top );\\n\\t\\t}\\n\\n\\t\\tcollisionPosition = {\\n\\t\\t\\tmarginLeft: marginLeft,\\n\\t\\t\\tmarginTop: marginTop\\n\\t\\t};\\n\\n\\t\\t$.each( [ \\\"left\\\", \\\"top\\\" ], function( i, dir ) {\\n\\t\\t\\tif ( $.ui.position[ collision[ i ] ] ) {\\n\\t\\t\\t\\t$.ui.position[ collision[ i ] ][ dir ]( position, {\\n\\t\\t\\t\\t\\ttargetWidth: targetWidth,\\n\\t\\t\\t\\t\\ttargetHeight: targetHeight,\\n\\t\\t\\t\\t\\telemWidth: elemWidth,\\n\\t\\t\\t\\t\\telemHeight: elemHeight,\\n\\t\\t\\t\\t\\tcollisionPosition: collisionPosition,\\n\\t\\t\\t\\t\\tcollisionWidth: collisionWidth,\\n\\t\\t\\t\\t\\tcollisionHeight: collisionHeight,\\n\\t\\t\\t\\t\\toffset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],\\n\\t\\t\\t\\t\\tmy: options.my,\\n\\t\\t\\t\\t\\tat: options.at,\\n\\t\\t\\t\\t\\twithin: within,\\n\\t\\t\\t\\t\\telem : elem\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tif ( options.using ) {\\n\\t\\t\\t// adds feedback as second argument to using callback, if present\\n\\t\\t\\tusing = function( props ) {\\n\\t\\t\\t\\tvar left = targetOffset.left - position.left,\\n\\t\\t\\t\\t\\tright = left + targetWidth - elemWidth,\\n\\t\\t\\t\\t\\ttop = targetOffset.top - position.top,\\n\\t\\t\\t\\t\\tbottom = top + targetHeight - elemHeight,\\n\\t\\t\\t\\t\\tfeedback = {\\n\\t\\t\\t\\t\\t\\ttarget: {\\n\\t\\t\\t\\t\\t\\t\\telement: target,\\n\\t\\t\\t\\t\\t\\t\\tleft: targetOffset.left,\\n\\t\\t\\t\\t\\t\\t\\ttop: targetOffset.top,\\n\\t\\t\\t\\t\\t\\t\\twidth: targetWidth,\\n\\t\\t\\t\\t\\t\\t\\theight: targetHeight\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\telement: {\\n\\t\\t\\t\\t\\t\\t\\telement: elem,\\n\\t\\t\\t\\t\\t\\t\\tleft: position.left,\\n\\t\\t\\t\\t\\t\\t\\ttop: position.top,\\n\\t\\t\\t\\t\\t\\t\\twidth: elemWidth,\\n\\t\\t\\t\\t\\t\\t\\theight: elemHeight\\n\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\thorizontal: right < 0 ? \\\"left\\\" : left > 0 ? \\\"right\\\" : \\\"center\\\",\\n\\t\\t\\t\\t\\t\\tvertical: bottom < 0 ? \\\"top\\\" : top > 0 ? \\\"bottom\\\" : \\\"middle\\\"\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\tif ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {\\n\\t\\t\\t\\t\\tfeedback.horizontal = \\\"center\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {\\n\\t\\t\\t\\t\\tfeedback.vertical = \\\"middle\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {\\n\\t\\t\\t\\t\\tfeedback.important = \\\"horizontal\\\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tfeedback.important = \\\"vertical\\\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\toptions.using.call( this, props, feedback );\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\telem.offset( $.extend( position, { using: using } ) );\\n\\t});\\n};\\n\\n$.ui.position = {\\n\\tfit: {\\n\\t\\tleft: function( position, data ) {\\n\\t\\t\\tvar within = data.within,\\n\\t\\t\\t\\twithinOffset = within.isWindow ? within.scrollLeft : within.offset.left,\\n\\t\\t\\t\\touterWidth = within.width,\\n\\t\\t\\t\\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\\n\\t\\t\\t\\toverLeft = withinOffset - collisionPosLeft,\\n\\t\\t\\t\\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,\\n\\t\\t\\t\\tnewOverRight;\\n\\n\\t\\t\\t// element is wider than within\\n\\t\\t\\tif ( data.collisionWidth > outerWidth ) {\\n\\t\\t\\t\\t// element is initially over the left side of within\\n\\t\\t\\t\\tif ( overLeft > 0 && overRight <= 0 ) {\\n\\t\\t\\t\\t\\tnewOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;\\n\\t\\t\\t\\t\\tposition.left += overLeft - newOverRight;\\n\\t\\t\\t\\t// element is initially over right side of within\\n\\t\\t\\t\\t} else if ( overRight > 0 && overLeft <= 0 ) {\\n\\t\\t\\t\\t\\tposition.left = withinOffset;\\n\\t\\t\\t\\t// element is initially over both left and right sides of within\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( overLeft > overRight ) {\\n\\t\\t\\t\\t\\t\\tposition.left = withinOffset + outerWidth - data.collisionWidth;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tposition.left = withinOffset;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t// too far left -> align with left edge\\n\\t\\t\\t} else if ( overLeft > 0 ) {\\n\\t\\t\\t\\tposition.left += overLeft;\\n\\t\\t\\t// too far right -> align with right edge\\n\\t\\t\\t} else if ( overRight > 0 ) {\\n\\t\\t\\t\\tposition.left -= overRight;\\n\\t\\t\\t// adjust based on position and margin\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tposition.left = max( position.left - collisionPosLeft, position.left );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttop: function( position, data ) {\\n\\t\\t\\tvar within = data.within,\\n\\t\\t\\t\\twithinOffset = within.isWindow ? within.scrollTop : within.offset.top,\\n\\t\\t\\t\\touterHeight = data.within.height,\\n\\t\\t\\t\\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\\n\\t\\t\\t\\toverTop = withinOffset - collisionPosTop,\\n\\t\\t\\t\\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,\\n\\t\\t\\t\\tnewOverBottom;\\n\\n\\t\\t\\t// element is taller than within\\n\\t\\t\\tif ( data.collisionHeight > outerHeight ) {\\n\\t\\t\\t\\t// element is initially over the top of within\\n\\t\\t\\t\\tif ( overTop > 0 && overBottom <= 0 ) {\\n\\t\\t\\t\\t\\tnewOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;\\n\\t\\t\\t\\t\\tposition.top += overTop - newOverBottom;\\n\\t\\t\\t\\t// element is initially over bottom of within\\n\\t\\t\\t\\t} else if ( overBottom > 0 && overTop <= 0 ) {\\n\\t\\t\\t\\t\\tposition.top = withinOffset;\\n\\t\\t\\t\\t// element is initially over both top and bottom of within\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( overTop > overBottom ) {\\n\\t\\t\\t\\t\\t\\tposition.top = withinOffset + outerHeight - data.collisionHeight;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tposition.top = withinOffset;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t// too far up -> align with top\\n\\t\\t\\t} else if ( overTop > 0 ) {\\n\\t\\t\\t\\tposition.top += overTop;\\n\\t\\t\\t// too far down -> align with bottom edge\\n\\t\\t\\t} else if ( overBottom > 0 ) {\\n\\t\\t\\t\\tposition.top -= overBottom;\\n\\t\\t\\t// adjust based on position and margin\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tposition.top = max( position.top - collisionPosTop, position.top );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tflip: {\\n\\t\\tleft: function( position, data ) {\\n\\t\\t\\tvar within = data.within,\\n\\t\\t\\t\\twithinOffset = within.offset.left + within.scrollLeft,\\n\\t\\t\\t\\touterWidth = within.width,\\n\\t\\t\\t\\toffsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,\\n\\t\\t\\t\\tcollisionPosLeft = position.left - data.collisionPosition.marginLeft,\\n\\t\\t\\t\\toverLeft = collisionPosLeft - offsetLeft,\\n\\t\\t\\t\\toverRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,\\n\\t\\t\\t\\tmyOffset = data.my[ 0 ] === \\\"left\\\" ?\\n\\t\\t\\t\\t\\t-data.elemWidth :\\n\\t\\t\\t\\t\\tdata.my[ 0 ] === \\\"right\\\" ?\\n\\t\\t\\t\\t\\t\\tdata.elemWidth :\\n\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\tatOffset = data.at[ 0 ] === \\\"left\\\" ?\\n\\t\\t\\t\\t\\tdata.targetWidth :\\n\\t\\t\\t\\t\\tdata.at[ 0 ] === \\\"right\\\" ?\\n\\t\\t\\t\\t\\t\\t-data.targetWidth :\\n\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\toffset = -2 * data.offset[ 0 ],\\n\\t\\t\\t\\tnewOverRight,\\n\\t\\t\\t\\tnewOverLeft;\\n\\n\\t\\t\\tif ( overLeft < 0 ) {\\n\\t\\t\\t\\tnewOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;\\n\\t\\t\\t\\tif ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {\\n\\t\\t\\t\\t\\tposition.left += myOffset + atOffset + offset;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if ( overRight > 0 ) {\\n\\t\\t\\t\\tnewOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;\\n\\t\\t\\t\\tif ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {\\n\\t\\t\\t\\t\\tposition.left += myOffset + atOffset + offset;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttop: function( position, data ) {\\n\\t\\t\\tvar within = data.within,\\n\\t\\t\\t\\twithinOffset = within.offset.top + within.scrollTop,\\n\\t\\t\\t\\touterHeight = within.height,\\n\\t\\t\\t\\toffsetTop = within.isWindow ? within.scrollTop : within.offset.top,\\n\\t\\t\\t\\tcollisionPosTop = position.top - data.collisionPosition.marginTop,\\n\\t\\t\\t\\toverTop = collisionPosTop - offsetTop,\\n\\t\\t\\t\\toverBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,\\n\\t\\t\\t\\ttop = data.my[ 1 ] === \\\"top\\\",\\n\\t\\t\\t\\tmyOffset = top ?\\n\\t\\t\\t\\t\\t-data.elemHeight :\\n\\t\\t\\t\\t\\tdata.my[ 1 ] === \\\"bottom\\\" ?\\n\\t\\t\\t\\t\\t\\tdata.elemHeight :\\n\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\tatOffset = data.at[ 1 ] === \\\"top\\\" ?\\n\\t\\t\\t\\t\\tdata.targetHeight :\\n\\t\\t\\t\\t\\tdata.at[ 1 ] === \\\"bottom\\\" ?\\n\\t\\t\\t\\t\\t\\t-data.targetHeight :\\n\\t\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\toffset = -2 * data.offset[ 1 ],\\n\\t\\t\\t\\tnewOverTop,\\n\\t\\t\\t\\tnewOverBottom;\\n\\t\\t\\tif ( overTop < 0 ) {\\n\\t\\t\\t\\tnewOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;\\n\\t\\t\\t\\tif ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {\\n\\t\\t\\t\\t\\tposition.top += myOffset + atOffset + offset;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse if ( overBottom > 0 ) {\\n\\t\\t\\t\\tnewOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;\\n\\t\\t\\t\\tif ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {\\n\\t\\t\\t\\t\\tposition.top += myOffset + atOffset + offset;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tflipfit: {\\n\\t\\tleft: function() {\\n\\t\\t\\t$.ui.position.flip.left.apply( this, arguments );\\n\\t\\t\\t$.ui.position.fit.left.apply( this, arguments );\\n\\t\\t},\\n\\t\\ttop: function() {\\n\\t\\t\\t$.ui.position.flip.top.apply( this, arguments );\\n\\t\\t\\t$.ui.position.fit.top.apply( this, arguments );\\n\\t\\t}\\n\\t}\\n};\\n\\n// fraction support test\\n(function () {\\n\\tvar testElement, testElementParent, testElementStyle, offsetLeft, i,\\n\\t\\tbody = document.getElementsByTagName( \\\"body\\\" )[ 0 ],\\n\\t\\tdiv = document.createElement( \\\"div\\\" );\\n\\n\\t//Create a \\\"fake body\\\" for testing based on method used in jQuery.support\\n\\ttestElement = document.createElement( body ? \\\"div\\\" : \\\"body\\\" );\\n\\ttestElementStyle = {\\n\\t\\tvisibility: \\\"hidden\\\",\\n\\t\\twidth: 0,\\n\\t\\theight: 0,\\n\\t\\tborder: 0,\\n\\t\\tmargin: 0,\\n\\t\\tbackground: \\\"none\\\"\\n\\t};\\n\\tif ( body ) {\\n\\t\\t$.extend( testElementStyle, {\\n\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\tleft: \\\"-1000px\\\",\\n\\t\\t\\ttop: \\\"-1000px\\\"\\n\\t\\t});\\n\\t}\\n\\tfor ( i in testElementStyle ) {\\n\\t\\ttestElement.style[ i ] = testElementStyle[ i ];\\n\\t}\\n\\ttestElement.appendChild( div );\\n\\ttestElementParent = body || document.documentElement;\\n\\ttestElementParent.insertBefore( testElement, testElementParent.firstChild );\\n\\n\\tdiv.style.cssText = \\\"position: absolute; left: 10.7432222px;\\\";\\n\\n\\toffsetLeft = $( div ).offset().left;\\n\\t$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;\\n\\n\\ttestElement.innerHTML = \\\"\\\";\\n\\ttestElementParent.removeChild( testElement );\\n})();\\n\\n}( jQuery ) );\\n\\n(function( $, undefined ) {\\n\\n$.widget( \\\"ui.progressbar\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tmax: 100,\\n\\t\\tvalue: 0,\\n\\n\\t\\tchange: null,\\n\\t\\tcomplete: null\\n\\t},\\n\\n\\tmin: 0,\\n\\n\\t_create: function() {\\n\\t\\t// Constrain initial value\\n\\t\\tthis.oldValue = this.options.value = this._constrainedValue();\\n\\n\\t\\tthis.element\\n\\t\\t\\t.addClass( \\\"ui-progressbar ui-widget ui-widget-content ui-corner-all\\\" )\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\t// Only set static values, aria-valuenow and aria-valuemax are\\n\\t\\t\\t\\t// set inside _refreshValue()\\n\\t\\t\\t\\trole: \\\"progressbar\\\",\\n\\t\\t\\t\\t\\\"aria-valuemin\\\": this.min\\n\\t\\t\\t});\\n\\n\\t\\tthis.valueDiv = $( \\\"<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>\\\" )\\n\\t\\t\\t.appendTo( this.element );\\n\\n\\t\\tthis._refreshValue();\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-progressbar ui-widget ui-widget-content ui-corner-all\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuemin\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuemax\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuenow\\\" );\\n\\n\\t\\tthis.valueDiv.remove();\\n\\t},\\n\\n\\tvalue: function( newValue ) {\\n\\t\\tif ( newValue === undefined ) {\\n\\t\\t\\treturn this.options.value;\\n\\t\\t}\\n\\n\\t\\tthis.options.value = this._constrainedValue( newValue );\\n\\t\\tthis._refreshValue();\\n\\t},\\n\\n\\t_constrainedValue: function( newValue ) {\\n\\t\\tif ( newValue === undefined ) {\\n\\t\\t\\tnewValue = this.options.value;\\n\\t\\t}\\n\\n\\t\\tthis.indeterminate = newValue === false;\\n\\n\\t\\t// sanitize value\\n\\t\\tif ( typeof newValue !== \\\"number\\\" ) {\\n\\t\\t\\tnewValue = 0;\\n\\t\\t}\\n\\n\\t\\treturn this.indeterminate ? false :\\n\\t\\t\\tMath.min( this.options.max, Math.max( this.min, newValue ) );\\n\\t},\\n\\n\\t_setOptions: function( options ) {\\n\\t\\t// Ensure \\\"value\\\" option is set after other values (like max)\\n\\t\\tvar value = options.value;\\n\\t\\tdelete options.value;\\n\\n\\t\\tthis._super( options );\\n\\n\\t\\tthis.options.value = this._constrainedValue( value );\\n\\t\\tthis._refreshValue();\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"max\\\" ) {\\n\\t\\t\\t// Don't allow a max less than min\\n\\t\\t\\tvalue = Math.max( this.min, value );\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\t},\\n\\n\\t_percentage: function() {\\n\\t\\treturn this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );\\n\\t},\\n\\n\\t_refreshValue: function() {\\n\\t\\tvar value = this.options.value,\\n\\t\\t\\tpercentage = this._percentage();\\n\\n\\t\\tthis.valueDiv\\n\\t\\t\\t.toggle( this.indeterminate || value > this.min )\\n\\t\\t\\t.toggleClass( \\\"ui-corner-right\\\", value === this.options.max )\\n\\t\\t\\t.width( percentage.toFixed(0) + \\\"%\\\" );\\n\\n\\t\\tthis.element.toggleClass( \\\"ui-progressbar-indeterminate\\\", this.indeterminate );\\n\\n\\t\\tif ( this.indeterminate ) {\\n\\t\\t\\tthis.element.removeAttr( \\\"aria-valuenow\\\" );\\n\\t\\t\\tif ( !this.overlayDiv ) {\\n\\t\\t\\t\\tthis.overlayDiv = $( \\\"<div class='ui-progressbar-overlay'></div>\\\" ).appendTo( this.valueDiv );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tthis.element.attr({\\n\\t\\t\\t\\t\\\"aria-valuemax\\\": this.options.max,\\n\\t\\t\\t\\t\\\"aria-valuenow\\\": value\\n\\t\\t\\t});\\n\\t\\t\\tif ( this.overlayDiv ) {\\n\\t\\t\\t\\tthis.overlayDiv.remove();\\n\\t\\t\\t\\tthis.overlayDiv = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( this.oldValue !== value ) {\\n\\t\\t\\tthis.oldValue = value;\\n\\t\\t\\tthis._trigger( \\\"change\\\" );\\n\\t\\t}\\n\\t\\tif ( value === this.options.max ) {\\n\\t\\t\\tthis._trigger( \\\"complete\\\" );\\n\\t\\t}\\n\\t}\\n});\\n\\n})( jQuery );\\n\\n(function( $, undefined ) {\\n\\n// number of pages in a slider\\n// (how many times can you page up/down to go through the whole range)\\nvar numPages = 5;\\n\\n$.widget( \\\"ui.slider\\\", $.ui.mouse, {\\n\\tversion: \\\"1.10.3\\\",\\n\\twidgetEventPrefix: \\\"slide\\\",\\n\\n\\toptions: {\\n\\t\\tanimate: false,\\n\\t\\tdistance: 0,\\n\\t\\tmax: 100,\\n\\t\\tmin: 0,\\n\\t\\torientation: \\\"horizontal\\\",\\n\\t\\trange: false,\\n\\t\\tstep: 1,\\n\\t\\tvalue: 0,\\n\\t\\tvalues: null,\\n\\n\\t\\t// callbacks\\n\\t\\tchange: null,\\n\\t\\tslide: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tthis._keySliding = false;\\n\\t\\tthis._mouseSliding = false;\\n\\t\\tthis._animateOff = true;\\n\\t\\tthis._handleIndex = null;\\n\\t\\tthis._detectOrientation();\\n\\t\\tthis._mouseInit();\\n\\n\\t\\tthis.element\\n\\t\\t\\t.addClass( \\\"ui-slider\\\" +\\n\\t\\t\\t\\t\\\" ui-slider-\\\" + this.orientation +\\n\\t\\t\\t\\t\\\" ui-widget\\\" +\\n\\t\\t\\t\\t\\\" ui-widget-content\\\" +\\n\\t\\t\\t\\t\\\" ui-corner-all\\\");\\n\\n\\t\\tthis._refresh();\\n\\t\\tthis._setOption( \\\"disabled\\\", this.options.disabled );\\n\\n\\t\\tthis._animateOff = false;\\n\\t},\\n\\n\\t_refresh: function() {\\n\\t\\tthis._createRange();\\n\\t\\tthis._createHandles();\\n\\t\\tthis._setupEvents();\\n\\t\\tthis._refreshValue();\\n\\t},\\n\\n\\t_createHandles: function() {\\n\\t\\tvar i, handleCount,\\n\\t\\t\\toptions = this.options,\\n\\t\\t\\texistingHandles = this.element.find( \\\".ui-slider-handle\\\" ).addClass( \\\"ui-state-default ui-corner-all\\\" ),\\n\\t\\t\\thandle = \\\"<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>\\\",\\n\\t\\t\\thandles = [];\\n\\n\\t\\thandleCount = ( options.values && options.values.length ) || 1;\\n\\n\\t\\tif ( existingHandles.length > handleCount ) {\\n\\t\\t\\texistingHandles.slice( handleCount ).remove();\\n\\t\\t\\texistingHandles = existingHandles.slice( 0, handleCount );\\n\\t\\t}\\n\\n\\t\\tfor ( i = existingHandles.length; i < handleCount; i++ ) {\\n\\t\\t\\thandles.push( handle );\\n\\t\\t}\\n\\n\\t\\tthis.handles = existingHandles.add( $( handles.join( \\\"\\\" ) ).appendTo( this.element ) );\\n\\n\\t\\tthis.handle = this.handles.eq( 0 );\\n\\n\\t\\tthis.handles.each(function( i ) {\\n\\t\\t\\t$( this ).data( \\\"ui-slider-handle-index\\\", i );\\n\\t\\t});\\n\\t},\\n\\n\\t_createRange: function() {\\n\\t\\tvar options = this.options,\\n\\t\\t\\tclasses = \\\"\\\";\\n\\n\\t\\tif ( options.range ) {\\n\\t\\t\\tif ( options.range === true ) {\\n\\t\\t\\t\\tif ( !options.values ) {\\n\\t\\t\\t\\t\\toptions.values = [ this._valueMin(), this._valueMin() ];\\n\\t\\t\\t\\t} else if ( options.values.length && options.values.length !== 2 ) {\\n\\t\\t\\t\\t\\toptions.values = [ options.values[0], options.values[0] ];\\n\\t\\t\\t\\t} else if ( $.isArray( options.values ) ) {\\n\\t\\t\\t\\t\\toptions.values = options.values.slice(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( !this.range || !this.range.length ) {\\n\\t\\t\\t\\tthis.range = $( \\\"<div></div>\\\" )\\n\\t\\t\\t\\t\\t.appendTo( this.element );\\n\\n\\t\\t\\t\\tclasses = \\\"ui-slider-range\\\" +\\n\\t\\t\\t\\t// note: this isn't the most fittingly semantic framework class for this element,\\n\\t\\t\\t\\t// but worked best visually with a variety of themes\\n\\t\\t\\t\\t\\\" ui-widget-header ui-corner-all\\\";\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.range.removeClass( \\\"ui-slider-range-min ui-slider-range-max\\\" )\\n\\t\\t\\t\\t\\t// Handle range switching from true to min/max\\n\\t\\t\\t\\t\\t.css({\\n\\t\\t\\t\\t\\t\\t\\\"left\\\": \\\"\\\",\\n\\t\\t\\t\\t\\t\\t\\\"bottom\\\": \\\"\\\"\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.range.addClass( classes +\\n\\t\\t\\t\\t( ( options.range === \\\"min\\\" || options.range === \\\"max\\\" ) ? \\\" ui-slider-range-\\\" + options.range : \\\"\\\" ) );\\n\\t\\t} else {\\n\\t\\t\\tthis.range = $([]);\\n\\t\\t}\\n\\t},\\n\\n\\t_setupEvents: function() {\\n\\t\\tvar elements = this.handles.add( this.range ).filter( \\\"a\\\" );\\n\\t\\tthis._off( elements );\\n\\t\\tthis._on( elements, this._handleEvents );\\n\\t\\tthis._hoverable( elements );\\n\\t\\tthis._focusable( elements );\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.handles.remove();\\n\\t\\tthis.range.remove();\\n\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-slider\\\" +\\n\\t\\t\\t\\t\\\" ui-slider-horizontal\\\" +\\n\\t\\t\\t\\t\\\" ui-slider-vertical\\\" +\\n\\t\\t\\t\\t\\\" ui-widget\\\" +\\n\\t\\t\\t\\t\\\" ui-widget-content\\\" +\\n\\t\\t\\t\\t\\\" ui-corner-all\\\" );\\n\\n\\t\\tthis._mouseDestroy();\\n\\t},\\n\\n\\t_mouseCapture: function( event ) {\\n\\t\\tvar position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,\\n\\t\\t\\tthat = this,\\n\\t\\t\\to = this.options;\\n\\n\\t\\tif ( o.disabled ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tthis.elementSize = {\\n\\t\\t\\twidth: this.element.outerWidth(),\\n\\t\\t\\theight: this.element.outerHeight()\\n\\t\\t};\\n\\t\\tthis.elementOffset = this.element.offset();\\n\\n\\t\\tposition = { x: event.pageX, y: event.pageY };\\n\\t\\tnormValue = this._normValueFromMouse( position );\\n\\t\\tdistance = this._valueMax() - this._valueMin() + 1;\\n\\t\\tthis.handles.each(function( i ) {\\n\\t\\t\\tvar thisDistance = Math.abs( normValue - that.values(i) );\\n\\t\\t\\tif (( distance > thisDistance ) ||\\n\\t\\t\\t\\t( distance === thisDistance &&\\n\\t\\t\\t\\t\\t(i === that._lastChangedValue || that.values(i) === o.min ))) {\\n\\t\\t\\t\\tdistance = thisDistance;\\n\\t\\t\\t\\tclosestHandle = $( this );\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tallowed = this._start( event, index );\\n\\t\\tif ( allowed === false ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tthis._mouseSliding = true;\\n\\n\\t\\tthis._handleIndex = index;\\n\\n\\t\\tclosestHandle\\n\\t\\t\\t.addClass( \\\"ui-state-active\\\" )\\n\\t\\t\\t.focus();\\n\\n\\t\\toffset = closestHandle.offset();\\n\\t\\tmouseOverHandle = !$( event.target ).parents().addBack().is( \\\".ui-slider-handle\\\" );\\n\\t\\tthis._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {\\n\\t\\t\\tleft: event.pageX - offset.left - ( closestHandle.width() / 2 ),\\n\\t\\t\\ttop: event.pageY - offset.top -\\n\\t\\t\\t\\t( closestHandle.height() / 2 ) -\\n\\t\\t\\t\\t( parseInt( closestHandle.css(\\\"borderTopWidth\\\"), 10 ) || 0 ) -\\n\\t\\t\\t\\t( parseInt( closestHandle.css(\\\"borderBottomWidth\\\"), 10 ) || 0) +\\n\\t\\t\\t\\t( parseInt( closestHandle.css(\\\"marginTop\\\"), 10 ) || 0)\\n\\t\\t};\\n\\n\\t\\tif ( !this.handles.hasClass( \\\"ui-state-hover\\\" ) ) {\\n\\t\\t\\tthis._slide( event, index, normValue );\\n\\t\\t}\\n\\t\\tthis._animateOff = true;\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_mouseStart: function() {\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_mouseDrag: function( event ) {\\n\\t\\tvar position = { x: event.pageX, y: event.pageY },\\n\\t\\t\\tnormValue = this._normValueFromMouse( position );\\n\\n\\t\\tthis._slide( event, this._handleIndex, normValue );\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_mouseStop: function( event ) {\\n\\t\\tthis.handles.removeClass( \\\"ui-state-active\\\" );\\n\\t\\tthis._mouseSliding = false;\\n\\n\\t\\tthis._stop( event, this._handleIndex );\\n\\t\\tthis._change( event, this._handleIndex );\\n\\n\\t\\tthis._handleIndex = null;\\n\\t\\tthis._clickOffset = null;\\n\\t\\tthis._animateOff = false;\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_detectOrientation: function() {\\n\\t\\tthis.orientation = ( this.options.orientation === \\\"vertical\\\" ) ? \\\"vertical\\\" : \\\"horizontal\\\";\\n\\t},\\n\\n\\t_normValueFromMouse: function( position ) {\\n\\t\\tvar pixelTotal,\\n\\t\\t\\tpixelMouse,\\n\\t\\t\\tpercentMouse,\\n\\t\\t\\tvalueTotal,\\n\\t\\t\\tvalueMouse;\\n\\n\\t\\tif ( this.orientation === \\\"horizontal\\\" ) {\\n\\t\\t\\tpixelTotal = this.elementSize.width;\\n\\t\\t\\tpixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );\\n\\t\\t} else {\\n\\t\\t\\tpixelTotal = this.elementSize.height;\\n\\t\\t\\tpixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );\\n\\t\\t}\\n\\n\\t\\tpercentMouse = ( pixelMouse / pixelTotal );\\n\\t\\tif ( percentMouse > 1 ) {\\n\\t\\t\\tpercentMouse = 1;\\n\\t\\t}\\n\\t\\tif ( percentMouse < 0 ) {\\n\\t\\t\\tpercentMouse = 0;\\n\\t\\t}\\n\\t\\tif ( this.orientation === \\\"vertical\\\" ) {\\n\\t\\t\\tpercentMouse = 1 - percentMouse;\\n\\t\\t}\\n\\n\\t\\tvalueTotal = this._valueMax() - this._valueMin();\\n\\t\\tvalueMouse = this._valueMin() + percentMouse * valueTotal;\\n\\n\\t\\treturn this._trimAlignValue( valueMouse );\\n\\t},\\n\\n\\t_start: function( event, index ) {\\n\\t\\tvar uiHash = {\\n\\t\\t\\thandle: this.handles[ index ],\\n\\t\\t\\tvalue: this.value()\\n\\t\\t};\\n\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\tuiHash.value = this.values( index );\\n\\t\\t\\tuiHash.values = this.values();\\n\\t\\t}\\n\\t\\treturn this._trigger( \\\"start\\\", event, uiHash );\\n\\t},\\n\\n\\t_slide: function( event, index, newVal ) {\\n\\t\\tvar otherVal,\\n\\t\\t\\tnewValues,\\n\\t\\t\\tallowed;\\n\\n\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\totherVal = this.values( index ? 0 : 1 );\\n\\n\\t\\t\\tif ( ( this.options.values.length === 2 && this.options.range === true ) &&\\n\\t\\t\\t\\t\\t( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\tnewVal = otherVal;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( newVal !== this.values( index ) ) {\\n\\t\\t\\t\\tnewValues = this.values();\\n\\t\\t\\t\\tnewValues[ index ] = newVal;\\n\\t\\t\\t\\t// A slide can be canceled by returning false from the slide callback\\n\\t\\t\\t\\tallowed = this._trigger( \\\"slide\\\", event, {\\n\\t\\t\\t\\t\\thandle: this.handles[ index ],\\n\\t\\t\\t\\t\\tvalue: newVal,\\n\\t\\t\\t\\t\\tvalues: newValues\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\totherVal = this.values( index ? 0 : 1 );\\n\\t\\t\\t\\tif ( allowed !== false ) {\\n\\t\\t\\t\\t\\tthis.values( index, newVal, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif ( newVal !== this.value() ) {\\n\\t\\t\\t\\t// A slide can be canceled by returning false from the slide callback\\n\\t\\t\\t\\tallowed = this._trigger( \\\"slide\\\", event, {\\n\\t\\t\\t\\t\\thandle: this.handles[ index ],\\n\\t\\t\\t\\t\\tvalue: newVal\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\tif ( allowed !== false ) {\\n\\t\\t\\t\\t\\tthis.value( newVal );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t_stop: function( event, index ) {\\n\\t\\tvar uiHash = {\\n\\t\\t\\thandle: this.handles[ index ],\\n\\t\\t\\tvalue: this.value()\\n\\t\\t};\\n\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\tuiHash.value = this.values( index );\\n\\t\\t\\tuiHash.values = this.values();\\n\\t\\t}\\n\\n\\t\\tthis._trigger( \\\"stop\\\", event, uiHash );\\n\\t},\\n\\n\\t_change: function( event, index ) {\\n\\t\\tif ( !this._keySliding && !this._mouseSliding ) {\\n\\t\\t\\tvar uiHash = {\\n\\t\\t\\t\\thandle: this.handles[ index ],\\n\\t\\t\\t\\tvalue: this.value()\\n\\t\\t\\t};\\n\\t\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\t\\tuiHash.value = this.values( index );\\n\\t\\t\\t\\tuiHash.values = this.values();\\n\\t\\t\\t}\\n\\n\\t\\t\\t//store the last changed value index for reference when handles overlap\\n\\t\\t\\tthis._lastChangedValue = index;\\n\\n\\t\\t\\tthis._trigger( \\\"change\\\", event, uiHash );\\n\\t\\t}\\n\\t},\\n\\n\\tvalue: function( newValue ) {\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\tthis.options.value = this._trimAlignValue( newValue );\\n\\t\\t\\tthis._refreshValue();\\n\\t\\t\\tthis._change( null, 0 );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\treturn this._value();\\n\\t},\\n\\n\\tvalues: function( index, newValue ) {\\n\\t\\tvar vals,\\n\\t\\t\\tnewValues,\\n\\t\\t\\ti;\\n\\n\\t\\tif ( arguments.length > 1 ) {\\n\\t\\t\\tthis.options.values[ index ] = this._trimAlignValue( newValue );\\n\\t\\t\\tthis._refreshValue();\\n\\t\\t\\tthis._change( null, index );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\tif ( $.isArray( arguments[ 0 ] ) ) {\\n\\t\\t\\t\\tvals = this.options.values;\\n\\t\\t\\t\\tnewValues = arguments[ 0 ];\\n\\t\\t\\t\\tfor ( i = 0; i < vals.length; i += 1 ) {\\n\\t\\t\\t\\t\\tvals[ i ] = this._trimAlignValue( newValues[ i ] );\\n\\t\\t\\t\\t\\tthis._change( null, i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis._refreshValue();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\t\\t\\treturn this._values( index );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn this.value();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn this._values();\\n\\t\\t}\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tvar i,\\n\\t\\t\\tvalsLength = 0;\\n\\n\\t\\tif ( key === \\\"range\\\" && this.options.range === true ) {\\n\\t\\t\\tif ( value === \\\"min\\\" ) {\\n\\t\\t\\t\\tthis.options.value = this._values( 0 );\\n\\t\\t\\t\\tthis.options.values = null;\\n\\t\\t\\t} else if ( value === \\\"max\\\" ) {\\n\\t\\t\\t\\tthis.options.value = this._values( this.options.values.length-1 );\\n\\t\\t\\t\\tthis.options.values = null;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( $.isArray( this.options.values ) ) {\\n\\t\\t\\tvalsLength = this.options.values.length;\\n\\t\\t}\\n\\n\\t\\t$.Widget.prototype._setOption.apply( this, arguments );\\n\\n\\t\\tswitch ( key ) {\\n\\t\\t\\tcase \\\"orientation\\\":\\n\\t\\t\\t\\tthis._detectOrientation();\\n\\t\\t\\t\\tthis.element\\n\\t\\t\\t\\t\\t.removeClass( \\\"ui-slider-horizontal ui-slider-vertical\\\" )\\n\\t\\t\\t\\t\\t.addClass( \\\"ui-slider-\\\" + this.orientation );\\n\\t\\t\\t\\tthis._refreshValue();\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"value\\\":\\n\\t\\t\\t\\tthis._animateOff = true;\\n\\t\\t\\t\\tthis._refreshValue();\\n\\t\\t\\t\\tthis._change( null, 0 );\\n\\t\\t\\t\\tthis._animateOff = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"values\\\":\\n\\t\\t\\t\\tthis._animateOff = true;\\n\\t\\t\\t\\tthis._refreshValue();\\n\\t\\t\\t\\tfor ( i = 0; i < valsLength; i += 1 ) {\\n\\t\\t\\t\\t\\tthis._change( null, i );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis._animateOff = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"min\\\":\\n\\t\\t\\tcase \\\"max\\\":\\n\\t\\t\\t\\tthis._animateOff = true;\\n\\t\\t\\t\\tthis._refreshValue();\\n\\t\\t\\t\\tthis._animateOff = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase \\\"range\\\":\\n\\t\\t\\t\\tthis._animateOff = true;\\n\\t\\t\\t\\tthis._refresh();\\n\\t\\t\\t\\tthis._animateOff = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t},\\n\\n\\t//internal value getter\\n\\t// _value() returns value trimmed by min and max, aligned by step\\n\\t_value: function() {\\n\\t\\tvar val = this.options.value;\\n\\t\\tval = this._trimAlignValue( val );\\n\\n\\t\\treturn val;\\n\\t},\\n\\n\\t//internal values getter\\n\\t// _values() returns array of values trimmed by min and max, aligned by step\\n\\t// _values( index ) returns single value trimmed by min and max, aligned by step\\n\\t_values: function( index ) {\\n\\t\\tvar val,\\n\\t\\t\\tvals,\\n\\t\\t\\ti;\\n\\n\\t\\tif ( arguments.length ) {\\n\\t\\t\\tval = this.options.values[ index ];\\n\\t\\t\\tval = this._trimAlignValue( val );\\n\\n\\t\\t\\treturn val;\\n\\t\\t} else if ( this.options.values && this.options.values.length ) {\\n\\t\\t\\t// .slice() creates a copy of the array\\n\\t\\t\\t// this copy gets trimmed by min and max and then returned\\n\\t\\t\\tvals = this.options.values.slice();\\n\\t\\t\\tfor ( i = 0; i < vals.length; i+= 1) {\\n\\t\\t\\t\\tvals[ i ] = this._trimAlignValue( vals[ i ] );\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn vals;\\n\\t\\t} else {\\n\\t\\t\\treturn [];\\n\\t\\t}\\n\\t},\\n\\n\\t// returns the step-aligned value that val is closest to, between (inclusive) min and max\\n\\t_trimAlignValue: function( val ) {\\n\\t\\tif ( val <= this._valueMin() ) {\\n\\t\\t\\treturn this._valueMin();\\n\\t\\t}\\n\\t\\tif ( val >= this._valueMax() ) {\\n\\t\\t\\treturn this._valueMax();\\n\\t\\t}\\n\\t\\tvar step = ( this.options.step > 0 ) ? this.options.step : 1,\\n\\t\\t\\tvalModStep = (val - this._valueMin()) % step,\\n\\t\\t\\talignValue = val - valModStep;\\n\\n\\t\\tif ( Math.abs(valModStep) * 2 >= step ) {\\n\\t\\t\\talignValue += ( valModStep > 0 ) ? step : ( -step );\\n\\t\\t}\\n\\n\\t\\t// Since JavaScript has problems with large floats, round\\n\\t\\t// the final value to 5 digits after the decimal point (see #4124)\\n\\t\\treturn parseFloat( alignValue.toFixed(5) );\\n\\t},\\n\\n\\t_valueMin: function() {\\n\\t\\treturn this.options.min;\\n\\t},\\n\\n\\t_valueMax: function() {\\n\\t\\treturn this.options.max;\\n\\t},\\n\\n\\t_refreshValue: function() {\\n\\t\\tvar lastValPercent, valPercent, value, valueMin, valueMax,\\n\\t\\t\\toRange = this.options.range,\\n\\t\\t\\to = this.options,\\n\\t\\t\\tthat = this,\\n\\t\\t\\tanimate = ( !this._animateOff ) ? o.animate : false,\\n\\t\\t\\t_set = {};\\n\\n\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\tthis.handles.each(function( i ) {\\n\\t\\t\\t\\tvalPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;\\n\\t\\t\\t\\t_set[ that.orientation === \\\"horizontal\\\" ? \\\"left\\\" : \\\"bottom\\\" ] = valPercent + \\\"%\\\";\\n\\t\\t\\t\\t$( this ).stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( _set, o.animate );\\n\\t\\t\\t\\tif ( that.options.range === true ) {\\n\\t\\t\\t\\t\\tif ( that.orientation === \\\"horizontal\\\" ) {\\n\\t\\t\\t\\t\\t\\tif ( i === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tthat.range.stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { left: valPercent + \\\"%\\\" }, o.animate );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( i === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tthat.range[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { width: ( valPercent - lastValPercent ) + \\\"%\\\" }, { queue: false, duration: o.animate } );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif ( i === 0 ) {\\n\\t\\t\\t\\t\\t\\t\\tthat.range.stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { bottom: ( valPercent ) + \\\"%\\\" }, o.animate );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( i === 1 ) {\\n\\t\\t\\t\\t\\t\\t\\tthat.range[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { height: ( valPercent - lastValPercent ) + \\\"%\\\" }, { queue: false, duration: o.animate } );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastValPercent = valPercent;\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tvalue = this.value();\\n\\t\\t\\tvalueMin = this._valueMin();\\n\\t\\t\\tvalueMax = this._valueMax();\\n\\t\\t\\tvalPercent = ( valueMax !== valueMin ) ?\\n\\t\\t\\t\\t\\t( value - valueMin ) / ( valueMax - valueMin ) * 100 :\\n\\t\\t\\t\\t\\t0;\\n\\t\\t\\t_set[ this.orientation === \\\"horizontal\\\" ? \\\"left\\\" : \\\"bottom\\\" ] = valPercent + \\\"%\\\";\\n\\t\\t\\tthis.handle.stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( _set, o.animate );\\n\\n\\t\\t\\tif ( oRange === \\\"min\\\" && this.orientation === \\\"horizontal\\\" ) {\\n\\t\\t\\t\\tthis.range.stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { width: valPercent + \\\"%\\\" }, o.animate );\\n\\t\\t\\t}\\n\\t\\t\\tif ( oRange === \\\"max\\\" && this.orientation === \\\"horizontal\\\" ) {\\n\\t\\t\\t\\tthis.range[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { width: ( 100 - valPercent ) + \\\"%\\\" }, { queue: false, duration: o.animate } );\\n\\t\\t\\t}\\n\\t\\t\\tif ( oRange === \\\"min\\\" && this.orientation === \\\"vertical\\\" ) {\\n\\t\\t\\t\\tthis.range.stop( 1, 1 )[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { height: valPercent + \\\"%\\\" }, o.animate );\\n\\t\\t\\t}\\n\\t\\t\\tif ( oRange === \\\"max\\\" && this.orientation === \\\"vertical\\\" ) {\\n\\t\\t\\t\\tthis.range[ animate ? \\\"animate\\\" : \\\"css\\\" ]( { height: ( 100 - valPercent ) + \\\"%\\\" }, { queue: false, duration: o.animate } );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t_handleEvents: {\\n\\t\\tkeydown: function( event ) {\\n\\t\\t\\t/*jshint maxcomplexity:25*/\\n\\t\\t\\tvar allowed, curVal, newVal, step,\\n\\t\\t\\t\\tindex = $( event.target ).data( \\\"ui-slider-handle-index\\\" );\\n\\n\\t\\t\\tswitch ( event.keyCode ) {\\n\\t\\t\\t\\tcase $.ui.keyCode.HOME:\\n\\t\\t\\t\\tcase $.ui.keyCode.END:\\n\\t\\t\\t\\tcase $.ui.keyCode.PAGE_UP:\\n\\t\\t\\t\\tcase $.ui.keyCode.PAGE_DOWN:\\n\\t\\t\\t\\tcase $.ui.keyCode.UP:\\n\\t\\t\\t\\tcase $.ui.keyCode.RIGHT:\\n\\t\\t\\t\\tcase $.ui.keyCode.DOWN:\\n\\t\\t\\t\\tcase $.ui.keyCode.LEFT:\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\tif ( !this._keySliding ) {\\n\\t\\t\\t\\t\\t\\tthis._keySliding = true;\\n\\t\\t\\t\\t\\t\\t$( event.target ).addClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t\\t\\t\\tallowed = this._start( event, index );\\n\\t\\t\\t\\t\\t\\tif ( allowed === false ) {\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstep = this.options.step;\\n\\t\\t\\tif ( this.options.values && this.options.values.length ) {\\n\\t\\t\\t\\tcurVal = newVal = this.values( index );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcurVal = newVal = this.value();\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( event.keyCode ) {\\n\\t\\t\\t\\tcase $.ui.keyCode.HOME:\\n\\t\\t\\t\\t\\tnewVal = this._valueMin();\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase $.ui.keyCode.END:\\n\\t\\t\\t\\t\\tnewVal = this._valueMax();\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase $.ui.keyCode.PAGE_UP:\\n\\t\\t\\t\\t\\tnewVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase $.ui.keyCode.PAGE_DOWN:\\n\\t\\t\\t\\t\\tnewVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase $.ui.keyCode.UP:\\n\\t\\t\\t\\tcase $.ui.keyCode.RIGHT:\\n\\t\\t\\t\\t\\tif ( curVal === this._valueMax() ) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewVal = this._trimAlignValue( curVal + step );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcase $.ui.keyCode.DOWN:\\n\\t\\t\\t\\tcase $.ui.keyCode.LEFT:\\n\\t\\t\\t\\t\\tif ( curVal === this._valueMin() ) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnewVal = this._trimAlignValue( curVal - step );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._slide( event, index, newVal );\\n\\t\\t},\\n\\t\\tclick: function( event ) {\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t},\\n\\t\\tkeyup: function( event ) {\\n\\t\\t\\tvar index = $( event.target ).data( \\\"ui-slider-handle-index\\\" );\\n\\n\\t\\t\\tif ( this._keySliding ) {\\n\\t\\t\\t\\tthis._keySliding = false;\\n\\t\\t\\t\\tthis._stop( event, index );\\n\\t\\t\\t\\tthis._change( event, index );\\n\\t\\t\\t\\t$( event.target ).removeClass( \\\"ui-state-active\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n});\\n\\n}(jQuery));\\n\\n(function( $ ) {\\n\\nfunction modifier( fn ) {\\n\\treturn function() {\\n\\t\\tvar previous = this.element.val();\\n\\t\\tfn.apply( this, arguments );\\n\\t\\tthis._refresh();\\n\\t\\tif ( previous !== this.element.val() ) {\\n\\t\\t\\tthis._trigger( \\\"change\\\" );\\n\\t\\t}\\n\\t};\\n}\\n\\n$.widget( \\\"ui.spinner\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\tdefaultElement: \\\"<input>\\\",\\n\\twidgetEventPrefix: \\\"spin\\\",\\n\\toptions: {\\n\\t\\tculture: null,\\n\\t\\ticons: {\\n\\t\\t\\tdown: \\\"ui-icon-triangle-1-s\\\",\\n\\t\\t\\tup: \\\"ui-icon-triangle-1-n\\\"\\n\\t\\t},\\n\\t\\tincremental: true,\\n\\t\\tmax: null,\\n\\t\\tmin: null,\\n\\t\\tnumberFormat: null,\\n\\t\\tpage: 10,\\n\\t\\tstep: 1,\\n\\n\\t\\tchange: null,\\n\\t\\tspin: null,\\n\\t\\tstart: null,\\n\\t\\tstop: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\t// handle string values that need to be parsed\\n\\t\\tthis._setOption( \\\"max\\\", this.options.max );\\n\\t\\tthis._setOption( \\\"min\\\", this.options.min );\\n\\t\\tthis._setOption( \\\"step\\\", this.options.step );\\n\\n\\t\\t// format the value, but don't constrain\\n\\t\\tthis._value( this.element.val(), true );\\n\\n\\t\\tthis._draw();\\n\\t\\tthis._on( this._events );\\n\\t\\tthis._refresh();\\n\\n\\t\\t// turning off autocomplete prevents the browser from remembering the\\n\\t\\t// value when navigating through history, so we re-enable autocomplete\\n\\t\\t// if the page is unloaded before the widget is destroyed. #7790\\n\\t\\tthis._on( this.window, {\\n\\t\\t\\tbeforeunload: function() {\\n\\t\\t\\t\\tthis.element.removeAttr( \\\"autocomplete\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_getCreateOptions: function() {\\n\\t\\tvar options = {},\\n\\t\\t\\telement = this.element;\\n\\n\\t\\t$.each( [ \\\"min\\\", \\\"max\\\", \\\"step\\\" ], function( i, option ) {\\n\\t\\t\\tvar value = element.attr( option );\\n\\t\\t\\tif ( value !== undefined && value.length ) {\\n\\t\\t\\t\\toptions[ option ] = value;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn options;\\n\\t},\\n\\n\\t_events: {\\n\\t\\tkeydown: function( event ) {\\n\\t\\t\\tif ( this._start( event ) && this._keydown( event ) ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tkeyup: \\\"_stop\\\",\\n\\t\\tfocus: function() {\\n\\t\\t\\tthis.previous = this.element.val();\\n\\t\\t},\\n\\t\\tblur: function( event ) {\\n\\t\\t\\tif ( this.cancelBlur ) {\\n\\t\\t\\t\\tdelete this.cancelBlur;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._stop();\\n\\t\\t\\tthis._refresh();\\n\\t\\t\\tif ( this.previous !== this.element.val() ) {\\n\\t\\t\\t\\tthis._trigger( \\\"change\\\", event );\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tmousewheel: function( event, delta ) {\\n\\t\\t\\tif ( !delta ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif ( !this.spinning && !this._start( event ) ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._spin( (delta > 0 ? 1 : -1) * this.options.step, event );\\n\\t\\t\\tclearTimeout( this.mousewheelTimer );\\n\\t\\t\\tthis.mousewheelTimer = this._delay(function() {\\n\\t\\t\\t\\tif ( this.spinning ) {\\n\\t\\t\\t\\t\\tthis._stop( event );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, 100 );\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t},\\n\\t\\t\\\"mousedown .ui-spinner-button\\\": function( event ) {\\n\\t\\t\\tvar previous;\\n\\n\\t\\t\\t// We never want the buttons to have focus; whenever the user is\\n\\t\\t\\t// interacting with the spinner, the focus should be on the input.\\n\\t\\t\\t// If the input is focused then this.previous is properly set from\\n\\t\\t\\t// when the input first received focus. If the input is not focused\\n\\t\\t\\t// then we need to set this.previous based on the value before spinning.\\n\\t\\t\\tprevious = this.element[0] === this.document[0].activeElement ?\\n\\t\\t\\t\\tthis.previous : this.element.val();\\n\\t\\t\\tfunction checkFocus() {\\n\\t\\t\\t\\tvar isActive = this.element[0] === this.document[0].activeElement;\\n\\t\\t\\t\\tif ( !isActive ) {\\n\\t\\t\\t\\t\\tthis.element.focus();\\n\\t\\t\\t\\t\\tthis.previous = previous;\\n\\t\\t\\t\\t\\t// support: IE\\n\\t\\t\\t\\t\\t// IE sets focus asynchronously, so we need to check if focus\\n\\t\\t\\t\\t\\t// moved off of the input because the user clicked on the button.\\n\\t\\t\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\t\\t\\tthis.previous = previous;\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ensure focus is on (or stays on) the text field\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tcheckFocus.call( this );\\n\\n\\t\\t\\t// support: IE\\n\\t\\t\\t// IE doesn't prevent moving focus even with event.preventDefault()\\n\\t\\t\\t// so we set a flag to know when we should ignore the blur event\\n\\t\\t\\t// and check (again) if focus moved off of the input.\\n\\t\\t\\tthis.cancelBlur = true;\\n\\t\\t\\tthis._delay(function() {\\n\\t\\t\\t\\tdelete this.cancelBlur;\\n\\t\\t\\t\\tcheckFocus.call( this );\\n\\t\\t\\t});\\n\\n\\t\\t\\tif ( this._start( event ) === false ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._repeat( null, $( event.currentTarget ).hasClass( \\\"ui-spinner-up\\\" ) ? 1 : -1, event );\\n\\t\\t},\\n\\t\\t\\\"mouseup .ui-spinner-button\\\": \\\"_stop\\\",\\n\\t\\t\\\"mouseenter .ui-spinner-button\\\": function( event ) {\\n\\t\\t\\t// button will add ui-state-active if mouse was down while mouseleave and kept down\\n\\t\\t\\tif ( !$( event.currentTarget ).hasClass( \\\"ui-state-active\\\" ) ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this._start( event ) === false ) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tthis._repeat( null, $( event.currentTarget ).hasClass( \\\"ui-spinner-up\\\" ) ? 1 : -1, event );\\n\\t\\t},\\n\\t\\t// TODO: do we really want to consider this a stop?\\n\\t\\t// shouldn't we just stop the repeater and wait until mouseup before\\n\\t\\t// we trigger the stop event?\\n\\t\\t\\\"mouseleave .ui-spinner-button\\\": \\\"_stop\\\"\\n\\t},\\n\\n\\t_draw: function() {\\n\\t\\tvar uiSpinner = this.uiSpinner = this.element\\n\\t\\t\\t.addClass( \\\"ui-spinner-input\\\" )\\n\\t\\t\\t.attr( \\\"autocomplete\\\", \\\"off\\\" )\\n\\t\\t\\t.wrap( this._uiSpinnerHtml() )\\n\\t\\t\\t.parent()\\n\\t\\t\\t\\t// add buttons\\n\\t\\t\\t\\t.append( this._buttonHtml() );\\n\\n\\t\\tthis.element.attr( \\\"role\\\", \\\"spinbutton\\\" );\\n\\n\\t\\t// button bindings\\n\\t\\tthis.buttons = uiSpinner.find( \\\".ui-spinner-button\\\" )\\n\\t\\t\\t.attr( \\\"tabIndex\\\", -1 )\\n\\t\\t\\t.button()\\n\\t\\t\\t.removeClass( \\\"ui-corner-all\\\" );\\n\\n\\t\\t// IE 6 doesn't understand height: 50% for the buttons\\n\\t\\t// unless the wrapper has an explicit height\\n\\t\\tif ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&\\n\\t\\t\\t\\tuiSpinner.height() > 0 ) {\\n\\t\\t\\tuiSpinner.height( uiSpinner.height() );\\n\\t\\t}\\n\\n\\t\\t// disable spinner if element was already disabled\\n\\t\\tif ( this.options.disabled ) {\\n\\t\\t\\tthis.disable();\\n\\t\\t}\\n\\t},\\n\\n\\t_keydown: function( event ) {\\n\\t\\tvar options = this.options,\\n\\t\\t\\tkeyCode = $.ui.keyCode;\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\t\\tcase keyCode.UP:\\n\\t\\t\\tthis._repeat( null, 1, event );\\n\\t\\t\\treturn true;\\n\\t\\tcase keyCode.DOWN:\\n\\t\\t\\tthis._repeat( null, -1, event );\\n\\t\\t\\treturn true;\\n\\t\\tcase keyCode.PAGE_UP:\\n\\t\\t\\tthis._repeat( null, options.page, event );\\n\\t\\t\\treturn true;\\n\\t\\tcase keyCode.PAGE_DOWN:\\n\\t\\t\\tthis._repeat( null, -options.page, event );\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t},\\n\\n\\t_uiSpinnerHtml: function() {\\n\\t\\treturn \\\"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>\\\";\\n\\t},\\n\\n\\t_buttonHtml: function() {\\n\\t\\treturn \\\"\\\" +\\n\\t\\t\\t\\\"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>\\\" +\\n\\t\\t\\t\\t\\\"<span class='ui-icon \\\" + this.options.icons.up + \\\"'>&#9650;</span>\\\" +\\n\\t\\t\\t\\\"</a>\\\" +\\n\\t\\t\\t\\\"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>\\\" +\\n\\t\\t\\t\\t\\\"<span class='ui-icon \\\" + this.options.icons.down + \\\"'>&#9660;</span>\\\" +\\n\\t\\t\\t\\\"</a>\\\";\\n\\t},\\n\\n\\t_start: function( event ) {\\n\\t\\tif ( !this.spinning && this._trigger( \\\"start\\\", event ) === false ) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tif ( !this.counter ) {\\n\\t\\t\\tthis.counter = 1;\\n\\t\\t}\\n\\t\\tthis.spinning = true;\\n\\t\\treturn true;\\n\\t},\\n\\n\\t_repeat: function( i, steps, event ) {\\n\\t\\ti = i || 500;\\n\\n\\t\\tclearTimeout( this.timer );\\n\\t\\tthis.timer = this._delay(function() {\\n\\t\\t\\tthis._repeat( 40, steps, event );\\n\\t\\t}, i );\\n\\n\\t\\tthis._spin( steps * this.options.step, event );\\n\\t},\\n\\n\\t_spin: function( step, event ) {\\n\\t\\tvar value = this.value() || 0;\\n\\n\\t\\tif ( !this.counter ) {\\n\\t\\t\\tthis.counter = 1;\\n\\t\\t}\\n\\n\\t\\tvalue = this._adjustValue( value + step * this._increment( this.counter ) );\\n\\n\\t\\tif ( !this.spinning || this._trigger( \\\"spin\\\", event, { value: value } ) !== false) {\\n\\t\\t\\tthis._value( value );\\n\\t\\t\\tthis.counter++;\\n\\t\\t}\\n\\t},\\n\\n\\t_increment: function( i ) {\\n\\t\\tvar incremental = this.options.incremental;\\n\\n\\t\\tif ( incremental ) {\\n\\t\\t\\treturn $.isFunction( incremental ) ?\\n\\t\\t\\t\\tincremental( i ) :\\n\\t\\t\\t\\tMath.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );\\n\\t\\t}\\n\\n\\t\\treturn 1;\\n\\t},\\n\\n\\t_precision: function() {\\n\\t\\tvar precision = this._precisionOf( this.options.step );\\n\\t\\tif ( this.options.min !== null ) {\\n\\t\\t\\tprecision = Math.max( precision, this._precisionOf( this.options.min ) );\\n\\t\\t}\\n\\t\\treturn precision;\\n\\t},\\n\\n\\t_precisionOf: function( num ) {\\n\\t\\tvar str = num.toString(),\\n\\t\\t\\tdecimal = str.indexOf( \\\".\\\" );\\n\\t\\treturn decimal === -1 ? 0 : str.length - decimal - 1;\\n\\t},\\n\\n\\t_adjustValue: function( value ) {\\n\\t\\tvar base, aboveMin,\\n\\t\\t\\toptions = this.options;\\n\\n\\t\\t// make sure we're at a valid step\\n\\t\\t// - find out where we are relative to the base (min or 0)\\n\\t\\tbase = options.min !== null ? options.min : 0;\\n\\t\\taboveMin = value - base;\\n\\t\\t// - round to the nearest step\\n\\t\\taboveMin = Math.round(aboveMin / options.step) * options.step;\\n\\t\\t// - rounding is based on 0, so adjust back to our base\\n\\t\\tvalue = base + aboveMin;\\n\\n\\t\\t// fix precision from bad JS floating point math\\n\\t\\tvalue = parseFloat( value.toFixed( this._precision() ) );\\n\\n\\t\\t// clamp the value\\n\\t\\tif ( options.max !== null && value > options.max) {\\n\\t\\t\\treturn options.max;\\n\\t\\t}\\n\\t\\tif ( options.min !== null && value < options.min ) {\\n\\t\\t\\treturn options.min;\\n\\t\\t}\\n\\n\\t\\treturn value;\\n\\t},\\n\\n\\t_stop: function( event ) {\\n\\t\\tif ( !this.spinning ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tclearTimeout( this.timer );\\n\\t\\tclearTimeout( this.mousewheelTimer );\\n\\t\\tthis.counter = 0;\\n\\t\\tthis.spinning = false;\\n\\t\\tthis._trigger( \\\"stop\\\", event );\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"culture\\\" || key === \\\"numberFormat\\\" ) {\\n\\t\\t\\tvar prevValue = this._parse( this.element.val() );\\n\\t\\t\\tthis.options[ key ] = value;\\n\\t\\t\\tthis.element.val( this._format( prevValue ) );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"max\\\" || key === \\\"min\\\" || key === \\\"step\\\" ) {\\n\\t\\t\\tif ( typeof value === \\\"string\\\" ) {\\n\\t\\t\\t\\tvalue = this._parse( value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( key === \\\"icons\\\" ) {\\n\\t\\t\\tthis.buttons.first().find( \\\".ui-icon\\\" )\\n\\t\\t\\t\\t.removeClass( this.options.icons.up )\\n\\t\\t\\t\\t.addClass( value.up );\\n\\t\\t\\tthis.buttons.last().find( \\\".ui-icon\\\" )\\n\\t\\t\\t\\t.removeClass( this.options.icons.down )\\n\\t\\t\\t\\t.addClass( value.down );\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tif ( value ) {\\n\\t\\t\\t\\tthis.element.prop( \\\"disabled\\\", true );\\n\\t\\t\\t\\tthis.buttons.button( \\\"disable\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.element.prop( \\\"disabled\\\", false );\\n\\t\\t\\t\\tthis.buttons.button( \\\"enable\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\n\\t_setOptions: modifier(function( options ) {\\n\\t\\tthis._super( options );\\n\\t\\tthis._value( this.element.val() );\\n\\t}),\\n\\n\\t_parse: function( val ) {\\n\\t\\tif ( typeof val === \\\"string\\\" && val !== \\\"\\\" ) {\\n\\t\\t\\tval = window.Globalize && this.options.numberFormat ?\\n\\t\\t\\t\\tGlobalize.parseFloat( val, 10, this.options.culture ) : +val;\\n\\t\\t}\\n\\t\\treturn val === \\\"\\\" || isNaN( val ) ? null : val;\\n\\t},\\n\\n\\t_format: function( value ) {\\n\\t\\tif ( value === \\\"\\\" ) {\\n\\t\\t\\treturn \\\"\\\";\\n\\t\\t}\\n\\t\\treturn window.Globalize && this.options.numberFormat ?\\n\\t\\t\\tGlobalize.format( value, this.options.numberFormat, this.options.culture ) :\\n\\t\\t\\tvalue;\\n\\t},\\n\\n\\t_refresh: function() {\\n\\t\\tthis.element.attr({\\n\\t\\t\\t\\\"aria-valuemin\\\": this.options.min,\\n\\t\\t\\t\\\"aria-valuemax\\\": this.options.max,\\n\\t\\t\\t// TODO: what should we do with values that can't be parsed?\\n\\t\\t\\t\\\"aria-valuenow\\\": this._parse( this.element.val() )\\n\\t\\t});\\n\\t},\\n\\n\\t// update the value without triggering change\\n\\t_value: function( value, allowAny ) {\\n\\t\\tvar parsed;\\n\\t\\tif ( value !== \\\"\\\" ) {\\n\\t\\t\\tparsed = this._parse( value );\\n\\t\\t\\tif ( parsed !== null ) {\\n\\t\\t\\t\\tif ( !allowAny ) {\\n\\t\\t\\t\\t\\tparsed = this._adjustValue( parsed );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = this._format( parsed );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis.element.val( value );\\n\\t\\tthis._refresh();\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tthis.element\\n\\t\\t\\t.removeClass( \\\"ui-spinner-input\\\" )\\n\\t\\t\\t.prop( \\\"disabled\\\", false )\\n\\t\\t\\t.removeAttr( \\\"autocomplete\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuemin\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuemax\\\" )\\n\\t\\t\\t.removeAttr( \\\"aria-valuenow\\\" );\\n\\t\\tthis.uiSpinner.replaceWith( this.element );\\n\\t},\\n\\n\\tstepUp: modifier(function( steps ) {\\n\\t\\tthis._stepUp( steps );\\n\\t}),\\n\\t_stepUp: function( steps ) {\\n\\t\\tif ( this._start() ) {\\n\\t\\t\\tthis._spin( (steps || 1) * this.options.step );\\n\\t\\t\\tthis._stop();\\n\\t\\t}\\n\\t},\\n\\n\\tstepDown: modifier(function( steps ) {\\n\\t\\tthis._stepDown( steps );\\n\\t}),\\n\\t_stepDown: function( steps ) {\\n\\t\\tif ( this._start() ) {\\n\\t\\t\\tthis._spin( (steps || 1) * -this.options.step );\\n\\t\\t\\tthis._stop();\\n\\t\\t}\\n\\t},\\n\\n\\tpageUp: modifier(function( pages ) {\\n\\t\\tthis._stepUp( (pages || 1) * this.options.page );\\n\\t}),\\n\\n\\tpageDown: modifier(function( pages ) {\\n\\t\\tthis._stepDown( (pages || 1) * this.options.page );\\n\\t}),\\n\\n\\tvalue: function( newVal ) {\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\treturn this._parse( this.element.val() );\\n\\t\\t}\\n\\t\\tmodifier( this._value ).call( this, newVal );\\n\\t},\\n\\n\\twidget: function() {\\n\\t\\treturn this.uiSpinner;\\n\\t}\\n});\\n\\n}( jQuery ) );\\n\\n(function( $, undefined ) {\\n\\nvar tabId = 0,\\n\\trhash = /#.*$/;\\n\\nfunction getNextTabId() {\\n\\treturn ++tabId;\\n}\\n\\nfunction isLocal( anchor ) {\\n\\treturn anchor.hash.length > 1 &&\\n\\t\\tdecodeURIComponent( anchor.href.replace( rhash, \\\"\\\" ) ) ===\\n\\t\\t\\tdecodeURIComponent( location.href.replace( rhash, \\\"\\\" ) );\\n}\\n\\n$.widget( \\\"ui.tabs\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\tdelay: 300,\\n\\toptions: {\\n\\t\\tactive: null,\\n\\t\\tcollapsible: false,\\n\\t\\tevent: \\\"click\\\",\\n\\t\\theightStyle: \\\"content\\\",\\n\\t\\thide: null,\\n\\t\\tshow: null,\\n\\n\\t\\t// callbacks\\n\\t\\tactivate: null,\\n\\t\\tbeforeActivate: null,\\n\\t\\tbeforeLoad: null,\\n\\t\\tload: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tvar that = this,\\n\\t\\t\\toptions = this.options;\\n\\n\\t\\tthis.running = false;\\n\\n\\t\\tthis.element\\n\\t\\t\\t.addClass( \\\"ui-tabs ui-widget ui-widget-content ui-corner-all\\\" )\\n\\t\\t\\t.toggleClass( \\\"ui-tabs-collapsible\\\", options.collapsible )\\n\\t\\t\\t// Prevent users from focusing disabled tabs via click\\n\\t\\t\\t.delegate( \\\".ui-tabs-nav > li\\\", \\\"mousedown\\\" + this.eventNamespace, function( event ) {\\n\\t\\t\\t\\tif ( $( this ).is( \\\".ui-state-disabled\\\" ) ) {\\n\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\t\\t// support: IE <9\\n\\t\\t\\t// Preventing the default action in mousedown doesn't prevent IE\\n\\t\\t\\t// from focusing the element, so if the anchor gets focused, blur.\\n\\t\\t\\t// We don't have to worry about focusing the previously focused\\n\\t\\t\\t// element since clicking on a non-focusable element should focus\\n\\t\\t\\t// the body anyway.\\n\\t\\t\\t.delegate( \\\".ui-tabs-anchor\\\", \\\"focus\\\" + this.eventNamespace, function() {\\n\\t\\t\\t\\tif ( $( this ).closest( \\\"li\\\" ).is( \\\".ui-state-disabled\\\" ) ) {\\n\\t\\t\\t\\t\\tthis.blur();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\tthis._processTabs();\\n\\t\\toptions.active = this._initialActive();\\n\\n\\t\\t// Take disabling tabs via class attribute from HTML\\n\\t\\t// into account and update option properly.\\n\\t\\tif ( $.isArray( options.disabled ) ) {\\n\\t\\t\\toptions.disabled = $.unique( options.disabled.concat(\\n\\t\\t\\t\\t$.map( this.tabs.filter( \\\".ui-state-disabled\\\" ), function( li ) {\\n\\t\\t\\t\\t\\treturn that.tabs.index( li );\\n\\t\\t\\t\\t})\\n\\t\\t\\t) ).sort();\\n\\t\\t}\\n\\n\\t\\t// check for length avoids error when initializing empty list\\n\\t\\tif ( this.options.active !== false && this.anchors.length ) {\\n\\t\\t\\tthis.active = this._findActive( options.active );\\n\\t\\t} else {\\n\\t\\t\\tthis.active = $();\\n\\t\\t}\\n\\n\\t\\tthis._refresh();\\n\\n\\t\\tif ( this.active.length ) {\\n\\t\\t\\tthis.load( options.active );\\n\\t\\t}\\n\\t},\\n\\n\\t_initialActive: function() {\\n\\t\\tvar active = this.options.active,\\n\\t\\t\\tcollapsible = this.options.collapsible,\\n\\t\\t\\tlocationHash = location.hash.substring( 1 );\\n\\n\\t\\tif ( active === null ) {\\n\\t\\t\\t// check the fragment identifier in the URL\\n\\t\\t\\tif ( locationHash ) {\\n\\t\\t\\t\\tthis.tabs.each(function( i, tab ) {\\n\\t\\t\\t\\t\\tif ( $( tab ).attr( \\\"aria-controls\\\" ) === locationHash ) {\\n\\t\\t\\t\\t\\t\\tactive = i;\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check for a tab marked active via a class\\n\\t\\t\\tif ( active === null ) {\\n\\t\\t\\t\\tactive = this.tabs.index( this.tabs.filter( \\\".ui-tabs-active\\\" ) );\\n\\t\\t\\t}\\n\\n\\t\\t\\t// no active tab, set to false\\n\\t\\t\\tif ( active === null || active === -1 ) {\\n\\t\\t\\t\\tactive = this.tabs.length ? 0 : false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// handle numbers: negative, out of range\\n\\t\\tif ( active !== false ) {\\n\\t\\t\\tactive = this.tabs.index( this.tabs.eq( active ) );\\n\\t\\t\\tif ( active === -1 ) {\\n\\t\\t\\t\\tactive = collapsible ? false : 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// don't allow collapsible: false and active: false\\n\\t\\tif ( !collapsible && active === false && this.anchors.length ) {\\n\\t\\t\\tactive = 0;\\n\\t\\t}\\n\\n\\t\\treturn active;\\n\\t},\\n\\n\\t_getCreateEventData: function() {\\n\\t\\treturn {\\n\\t\\t\\ttab: this.active,\\n\\t\\t\\tpanel: !this.active.length ? $() : this._getPanelForTab( this.active )\\n\\t\\t};\\n\\t},\\n\\n\\t_tabKeydown: function( event ) {\\n\\t\\t/*jshint maxcomplexity:15*/\\n\\t\\tvar focusedTab = $( this.document[0].activeElement ).closest( \\\"li\\\" ),\\n\\t\\t\\tselectedIndex = this.tabs.index( focusedTab ),\\n\\t\\t\\tgoingForward = true;\\n\\n\\t\\tif ( this._handlePageNav( event ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\t\\t\\tcase $.ui.keyCode.RIGHT:\\n\\t\\t\\tcase $.ui.keyCode.DOWN:\\n\\t\\t\\t\\tselectedIndex++;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase $.ui.keyCode.UP:\\n\\t\\t\\tcase $.ui.keyCode.LEFT:\\n\\t\\t\\t\\tgoingForward = false;\\n\\t\\t\\t\\tselectedIndex--;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase $.ui.keyCode.END:\\n\\t\\t\\t\\tselectedIndex = this.anchors.length - 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase $.ui.keyCode.HOME:\\n\\t\\t\\t\\tselectedIndex = 0;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\tcase $.ui.keyCode.SPACE:\\n\\t\\t\\t\\t// Activate only, no collapsing\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\tclearTimeout( this.activating );\\n\\t\\t\\t\\tthis._activate( selectedIndex );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tcase $.ui.keyCode.ENTER:\\n\\t\\t\\t\\t// Toggle (cancel delayed activation, allow collapsing)\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\tclearTimeout( this.activating );\\n\\t\\t\\t\\t// Determine if we should collapse or activate\\n\\t\\t\\t\\tthis._activate( selectedIndex === this.options.active ? false : selectedIndex );\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Focus the appropriate tab, based on which key was pressed\\n\\t\\tevent.preventDefault();\\n\\t\\tclearTimeout( this.activating );\\n\\t\\tselectedIndex = this._focusNextTab( selectedIndex, goingForward );\\n\\n\\t\\t// Navigating with control key will prevent automatic activation\\n\\t\\tif ( !event.ctrlKey ) {\\n\\t\\t\\t// Update aria-selected immediately so that AT think the tab is already selected.\\n\\t\\t\\t// Otherwise AT may confuse the user by stating that they need to activate the tab,\\n\\t\\t\\t// but the tab will already be activated by the time the announcement finishes.\\n\\t\\t\\tfocusedTab.attr( \\\"aria-selected\\\", \\\"false\\\" );\\n\\t\\t\\tthis.tabs.eq( selectedIndex ).attr( \\\"aria-selected\\\", \\\"true\\\" );\\n\\n\\t\\t\\tthis.activating = this._delay(function() {\\n\\t\\t\\t\\tthis.option( \\\"active\\\", selectedIndex );\\n\\t\\t\\t}, this.delay );\\n\\t\\t}\\n\\t},\\n\\n\\t_panelKeydown: function( event ) {\\n\\t\\tif ( this._handlePageNav( event ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Ctrl+up moves focus to the current tab\\n\\t\\tif ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\tthis.active.focus();\\n\\t\\t}\\n\\t},\\n\\n\\t// Alt+page up/down moves focus to the previous/next tab (and activates)\\n\\t_handlePageNav: function( event ) {\\n\\t\\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {\\n\\t\\t\\tthis._activate( this._focusNextTab( this.options.active - 1, false ) );\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {\\n\\t\\t\\tthis._activate( this._focusNextTab( this.options.active + 1, true ) );\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t},\\n\\n\\t_findNextTab: function( index, goingForward ) {\\n\\t\\tvar lastTabIndex = this.tabs.length - 1;\\n\\n\\t\\tfunction constrain() {\\n\\t\\t\\tif ( index > lastTabIndex ) {\\n\\t\\t\\t\\tindex = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ( index < 0 ) {\\n\\t\\t\\t\\tindex = lastTabIndex;\\n\\t\\t\\t}\\n\\t\\t\\treturn index;\\n\\t\\t}\\n\\n\\t\\twhile ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {\\n\\t\\t\\tindex = goingForward ? index + 1 : index - 1;\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\t},\\n\\n\\t_focusNextTab: function( index, goingForward ) {\\n\\t\\tindex = this._findNextTab( index, goingForward );\\n\\t\\tthis.tabs.eq( index ).focus();\\n\\t\\treturn index;\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tif ( key === \\\"active\\\" ) {\\n\\t\\t\\t// _activate() will handle invalid values and update this.options\\n\\t\\t\\tthis._activate( value );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\t// don't use the widget factory's disabled handling\\n\\t\\t\\tthis._setupDisabled( value );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value);\\n\\n\\t\\tif ( key === \\\"collapsible\\\" ) {\\n\\t\\t\\tthis.element.toggleClass( \\\"ui-tabs-collapsible\\\", value );\\n\\t\\t\\t// Setting collapsible: false while collapsed; open first panel\\n\\t\\t\\tif ( !value && this.options.active === false ) {\\n\\t\\t\\t\\tthis._activate( 0 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"event\\\" ) {\\n\\t\\t\\tthis._setupEvents( value );\\n\\t\\t}\\n\\n\\t\\tif ( key === \\\"heightStyle\\\" ) {\\n\\t\\t\\tthis._setupHeightStyle( value );\\n\\t\\t}\\n\\t},\\n\\n\\t_tabId: function( tab ) {\\n\\t\\treturn tab.attr( \\\"aria-controls\\\" ) || \\\"ui-tabs-\\\" + getNextTabId();\\n\\t},\\n\\n\\t_sanitizeSelector: function( hash ) {\\n\\t\\treturn hash ? hash.replace( /[!\\\"$%&'()*+,.\\\\/:;<=>?@\\\\[\\\\]\\\\^`{|}~]/g, \\\"\\\\\\\\$&\\\" ) : \\\"\\\";\\n\\t},\\n\\n\\trefresh: function() {\\n\\t\\tvar options = this.options,\\n\\t\\t\\tlis = this.tablist.children( \\\":has(a[href])\\\" );\\n\\n\\t\\t// get disabled tabs from class attribute from HTML\\n\\t\\t// this will get converted to a boolean if needed in _refresh()\\n\\t\\toptions.disabled = $.map( lis.filter( \\\".ui-state-disabled\\\" ), function( tab ) {\\n\\t\\t\\treturn lis.index( tab );\\n\\t\\t});\\n\\n\\t\\tthis._processTabs();\\n\\n\\t\\t// was collapsed or no tabs\\n\\t\\tif ( options.active === false || !this.anchors.length ) {\\n\\t\\t\\toptions.active = false;\\n\\t\\t\\tthis.active = $();\\n\\t\\t// was active, but active tab is gone\\n\\t\\t} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {\\n\\t\\t\\t// all remaining tabs are disabled\\n\\t\\t\\tif ( this.tabs.length === options.disabled.length ) {\\n\\t\\t\\t\\toptions.active = false;\\n\\t\\t\\t\\tthis.active = $();\\n\\t\\t\\t// activate previous tab\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );\\n\\t\\t\\t}\\n\\t\\t// was active, active tab still exists\\n\\t\\t} else {\\n\\t\\t\\t// make sure active index is correct\\n\\t\\t\\toptions.active = this.tabs.index( this.active );\\n\\t\\t}\\n\\n\\t\\tthis._refresh();\\n\\t},\\n\\n\\t_refresh: function() {\\n\\t\\tthis._setupDisabled( this.options.disabled );\\n\\t\\tthis._setupEvents( this.options.event );\\n\\t\\tthis._setupHeightStyle( this.options.heightStyle );\\n\\n\\t\\tthis.tabs.not( this.active ).attr({\\n\\t\\t\\t\\\"aria-selected\\\": \\\"false\\\",\\n\\t\\t\\ttabIndex: -1\\n\\t\\t});\\n\\t\\tthis.panels.not( this._getPanelForTab( this.active ) )\\n\\t\\t\\t.hide()\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"false\\\",\\n\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"true\\\"\\n\\t\\t\\t});\\n\\n\\t\\t// Make sure one tab is in the tab order\\n\\t\\tif ( !this.active.length ) {\\n\\t\\t\\tthis.tabs.eq( 0 ).attr( \\\"tabIndex\\\", 0 );\\n\\t\\t} else {\\n\\t\\t\\tthis.active\\n\\t\\t\\t\\t.addClass( \\\"ui-tabs-active ui-state-active\\\" )\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\t\\\"aria-selected\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\ttabIndex: 0\\n\\t\\t\\t\\t});\\n\\t\\t\\tthis._getPanelForTab( this.active )\\n\\t\\t\\t\\t.show()\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\t\\\"aria-expanded\\\": \\\"true\\\",\\n\\t\\t\\t\\t\\t\\\"aria-hidden\\\": \\\"false\\\"\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t_processTabs: function() {\\n\\t\\tvar that = this;\\n\\n\\t\\tthis.tablist = this._getList()\\n\\t\\t\\t.addClass( \\\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\\\" )\\n\\t\\t\\t.attr( \\\"role\\\", \\\"tablist\\\" );\\n\\n\\t\\tthis.tabs = this.tablist.find( \\\"> li:has(a[href])\\\" )\\n\\t\\t\\t.addClass( \\\"ui-state-default ui-corner-top\\\" )\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\trole: \\\"tab\\\",\\n\\t\\t\\t\\ttabIndex: -1\\n\\t\\t\\t});\\n\\n\\t\\tthis.anchors = this.tabs.map(function() {\\n\\t\\t\\t\\treturn $( \\\"a\\\", this )[ 0 ];\\n\\t\\t\\t})\\n\\t\\t\\t.addClass( \\\"ui-tabs-anchor\\\" )\\n\\t\\t\\t.attr({\\n\\t\\t\\t\\trole: \\\"presentation\\\",\\n\\t\\t\\t\\ttabIndex: -1\\n\\t\\t\\t});\\n\\n\\t\\tthis.panels = $();\\n\\n\\t\\tthis.anchors.each(function( i, anchor ) {\\n\\t\\t\\tvar selector, panel, panelId,\\n\\t\\t\\t\\tanchorId = $( anchor ).uniqueId().attr( \\\"id\\\" ),\\n\\t\\t\\t\\ttab = $( anchor ).closest( \\\"li\\\" ),\\n\\t\\t\\t\\toriginalAriaControls = tab.attr( \\\"aria-controls\\\" );\\n\\n\\t\\t\\t// inline tab\\n\\t\\t\\tif ( isLocal( anchor ) ) {\\n\\t\\t\\t\\tselector = anchor.hash;\\n\\t\\t\\t\\tpanel = that.element.find( that._sanitizeSelector( selector ) );\\n\\t\\t\\t// remote tab\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpanelId = that._tabId( tab );\\n\\t\\t\\t\\tselector = \\\"#\\\" + panelId;\\n\\t\\t\\t\\tpanel = that.element.find( selector );\\n\\t\\t\\t\\tif ( !panel.length ) {\\n\\t\\t\\t\\t\\tpanel = that._createPanel( panelId );\\n\\t\\t\\t\\t\\tpanel.insertAfter( that.panels[ i - 1 ] || that.tablist );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpanel.attr( \\\"aria-live\\\", \\\"polite\\\" );\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( panel.length) {\\n\\t\\t\\t\\tthat.panels = that.panels.add( panel );\\n\\t\\t\\t}\\n\\t\\t\\tif ( originalAriaControls ) {\\n\\t\\t\\t\\ttab.data( \\\"ui-tabs-aria-controls\\\", originalAriaControls );\\n\\t\\t\\t}\\n\\t\\t\\ttab.attr({\\n\\t\\t\\t\\t\\\"aria-controls\\\": selector.substring( 1 ),\\n\\t\\t\\t\\t\\\"aria-labelledby\\\": anchorId\\n\\t\\t\\t});\\n\\t\\t\\tpanel.attr( \\\"aria-labelledby\\\", anchorId );\\n\\t\\t});\\n\\n\\t\\tthis.panels\\n\\t\\t\\t.addClass( \\\"ui-tabs-panel ui-widget-content ui-corner-bottom\\\" )\\n\\t\\t\\t.attr( \\\"role\\\", \\\"tabpanel\\\" );\\n\\t},\\n\\n\\t// allow overriding how to find the list for rare usage scenarios (#7715)\\n\\t_getList: function() {\\n\\t\\treturn this.element.find( \\\"ol,ul\\\" ).eq( 0 );\\n\\t},\\n\\n\\t_createPanel: function( id ) {\\n\\t\\treturn $( \\\"<div>\\\" )\\n\\t\\t\\t.attr( \\\"id\\\", id )\\n\\t\\t\\t.addClass( \\\"ui-tabs-panel ui-widget-content ui-corner-bottom\\\" )\\n\\t\\t\\t.data( \\\"ui-tabs-destroy\\\", true );\\n\\t},\\n\\n\\t_setupDisabled: function( disabled ) {\\n\\t\\tif ( $.isArray( disabled ) ) {\\n\\t\\t\\tif ( !disabled.length ) {\\n\\t\\t\\t\\tdisabled = false;\\n\\t\\t\\t} else if ( disabled.length === this.anchors.length ) {\\n\\t\\t\\t\\tdisabled = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// disable tabs\\n\\t\\tfor ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {\\n\\t\\t\\tif ( disabled === true || $.inArray( i, disabled ) !== -1 ) {\\n\\t\\t\\t\\t$( li )\\n\\t\\t\\t\\t\\t.addClass( \\\"ui-state-disabled\\\" )\\n\\t\\t\\t\\t\\t.attr( \\\"aria-disabled\\\", \\\"true\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$( li )\\n\\t\\t\\t\\t\\t.removeClass( \\\"ui-state-disabled\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-disabled\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tthis.options.disabled = disabled;\\n\\t},\\n\\n\\t_setupEvents: function( event ) {\\n\\t\\tvar events = {\\n\\t\\t\\tclick: function( event ) {\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif ( event ) {\\n\\t\\t\\t$.each( event.split(\\\" \\\"), function( index, eventName ) {\\n\\t\\t\\t\\tevents[ eventName ] = \\\"_eventHandler\\\";\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis._off( this.anchors.add( this.tabs ).add( this.panels ) );\\n\\t\\tthis._on( this.anchors, events );\\n\\t\\tthis._on( this.tabs, { keydown: \\\"_tabKeydown\\\" } );\\n\\t\\tthis._on( this.panels, { keydown: \\\"_panelKeydown\\\" } );\\n\\n\\t\\tthis._focusable( this.tabs );\\n\\t\\tthis._hoverable( this.tabs );\\n\\t},\\n\\n\\t_setupHeightStyle: function( heightStyle ) {\\n\\t\\tvar maxHeight,\\n\\t\\t\\tparent = this.element.parent();\\n\\n\\t\\tif ( heightStyle === \\\"fill\\\" ) {\\n\\t\\t\\tmaxHeight = parent.height();\\n\\t\\t\\tmaxHeight -= this.element.outerHeight() - this.element.height();\\n\\n\\t\\t\\tthis.element.siblings( \\\":visible\\\" ).each(function() {\\n\\t\\t\\t\\tvar elem = $( this ),\\n\\t\\t\\t\\t\\tposition = elem.css( \\\"position\\\" );\\n\\n\\t\\t\\t\\tif ( position === \\\"absolute\\\" || position === \\\"fixed\\\" ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmaxHeight -= elem.outerHeight( true );\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.element.children().not( this.panels ).each(function() {\\n\\t\\t\\t\\tmaxHeight -= $( this ).outerHeight( true );\\n\\t\\t\\t});\\n\\n\\t\\t\\tthis.panels.each(function() {\\n\\t\\t\\t\\t$( this ).height( Math.max( 0, maxHeight -\\n\\t\\t\\t\\t\\t$( this ).innerHeight() + $( this ).height() ) );\\n\\t\\t\\t})\\n\\t\\t\\t.css( \\\"overflow\\\", \\\"auto\\\" );\\n\\t\\t} else if ( heightStyle === \\\"auto\\\" ) {\\n\\t\\t\\tmaxHeight = 0;\\n\\t\\t\\tthis.panels.each(function() {\\n\\t\\t\\t\\tmaxHeight = Math.max( maxHeight, $( this ).height( \\\"\\\" ).height() );\\n\\t\\t\\t}).height( maxHeight );\\n\\t\\t}\\n\\t},\\n\\n\\t_eventHandler: function( event ) {\\n\\t\\tvar options = this.options,\\n\\t\\t\\tactive = this.active,\\n\\t\\t\\tanchor = $( event.currentTarget ),\\n\\t\\t\\ttab = anchor.closest( \\\"li\\\" ),\\n\\t\\t\\tclickedIsActive = tab[ 0 ] === active[ 0 ],\\n\\t\\t\\tcollapsing = clickedIsActive && options.collapsible,\\n\\t\\t\\ttoShow = collapsing ? $() : this._getPanelForTab( tab ),\\n\\t\\t\\ttoHide = !active.length ? $() : this._getPanelForTab( active ),\\n\\t\\t\\teventData = {\\n\\t\\t\\t\\toldTab: active,\\n\\t\\t\\t\\toldPanel: toHide,\\n\\t\\t\\t\\tnewTab: collapsing ? $() : tab,\\n\\t\\t\\t\\tnewPanel: toShow\\n\\t\\t\\t};\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tif ( tab.hasClass( \\\"ui-state-disabled\\\" ) ||\\n\\t\\t\\t\\t// tab is already loading\\n\\t\\t\\t\\ttab.hasClass( \\\"ui-tabs-loading\\\" ) ||\\n\\t\\t\\t\\t// can't switch durning an animation\\n\\t\\t\\t\\tthis.running ||\\n\\t\\t\\t\\t// click on active header, but not collapsible\\n\\t\\t\\t\\t( clickedIsActive && !options.collapsible ) ||\\n\\t\\t\\t\\t// allow canceling activation\\n\\t\\t\\t\\t( this._trigger( \\\"beforeActivate\\\", event, eventData ) === false ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\toptions.active = collapsing ? false : this.tabs.index( tab );\\n\\n\\t\\tthis.active = clickedIsActive ? $() : tab;\\n\\t\\tif ( this.xhr ) {\\n\\t\\t\\tthis.xhr.abort();\\n\\t\\t}\\n\\n\\t\\tif ( !toHide.length && !toShow.length ) {\\n\\t\\t\\t$.error( \\\"jQuery UI Tabs: Mismatching fragment identifier.\\\" );\\n\\t\\t}\\n\\n\\t\\tif ( toShow.length ) {\\n\\t\\t\\tthis.load( this.tabs.index( tab ), event );\\n\\t\\t}\\n\\t\\tthis._toggle( event, eventData );\\n\\t},\\n\\n\\t// handles show/hide for selecting tabs\\n\\t_toggle: function( event, eventData ) {\\n\\t\\tvar that = this,\\n\\t\\t\\ttoShow = eventData.newPanel,\\n\\t\\t\\ttoHide = eventData.oldPanel;\\n\\n\\t\\tthis.running = true;\\n\\n\\t\\tfunction complete() {\\n\\t\\t\\tthat.running = false;\\n\\t\\t\\tthat._trigger( \\\"activate\\\", event, eventData );\\n\\t\\t}\\n\\n\\t\\tfunction show() {\\n\\t\\t\\teventData.newTab.closest( \\\"li\\\" ).addClass( \\\"ui-tabs-active ui-state-active\\\" );\\n\\n\\t\\t\\tif ( toShow.length && that.options.show ) {\\n\\t\\t\\t\\tthat._show( toShow, that.options.show, complete );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttoShow.show();\\n\\t\\t\\t\\tcomplete();\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// start out by hiding, then showing, then completing\\n\\t\\tif ( toHide.length && this.options.hide ) {\\n\\t\\t\\tthis._hide( toHide, this.options.hide, function() {\\n\\t\\t\\t\\teventData.oldTab.closest( \\\"li\\\" ).removeClass( \\\"ui-tabs-active ui-state-active\\\" );\\n\\t\\t\\t\\tshow();\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\teventData.oldTab.closest( \\\"li\\\" ).removeClass( \\\"ui-tabs-active ui-state-active\\\" );\\n\\t\\t\\ttoHide.hide();\\n\\t\\t\\tshow();\\n\\t\\t}\\n\\n\\t\\ttoHide.attr({\\n\\t\\t\\t\\\"aria-expanded\\\": \\\"false\\\",\\n\\t\\t\\t\\\"aria-hidden\\\": \\\"true\\\"\\n\\t\\t});\\n\\t\\teventData.oldTab.attr( \\\"aria-selected\\\", \\\"false\\\" );\\n\\t\\t// If we're switching tabs, remove the old tab from the tab order.\\n\\t\\t// If we're opening from collapsed state, remove the previous tab from the tab order.\\n\\t\\t// If we're collapsing, then keep the collapsing tab in the tab order.\\n\\t\\tif ( toShow.length && toHide.length ) {\\n\\t\\t\\teventData.oldTab.attr( \\\"tabIndex\\\", -1 );\\n\\t\\t} else if ( toShow.length ) {\\n\\t\\t\\tthis.tabs.filter(function() {\\n\\t\\t\\t\\treturn $( this ).attr( \\\"tabIndex\\\" ) === 0;\\n\\t\\t\\t})\\n\\t\\t\\t.attr( \\\"tabIndex\\\", -1 );\\n\\t\\t}\\n\\n\\t\\ttoShow.attr({\\n\\t\\t\\t\\\"aria-expanded\\\": \\\"true\\\",\\n\\t\\t\\t\\\"aria-hidden\\\": \\\"false\\\"\\n\\t\\t});\\n\\t\\teventData.newTab.attr({\\n\\t\\t\\t\\\"aria-selected\\\": \\\"true\\\",\\n\\t\\t\\ttabIndex: 0\\n\\t\\t});\\n\\t},\\n\\n\\t_activate: function( index ) {\\n\\t\\tvar anchor,\\n\\t\\t\\tactive = this._findActive( index );\\n\\n\\t\\t// trying to activate the already active panel\\n\\t\\tif ( active[ 0 ] === this.active[ 0 ] ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// trying to collapse, simulate a click on the current active header\\n\\t\\tif ( !active.length ) {\\n\\t\\t\\tactive = this.active;\\n\\t\\t}\\n\\n\\t\\tanchor = active.find( \\\".ui-tabs-anchor\\\" )[ 0 ];\\n\\t\\tthis._eventHandler({\\n\\t\\t\\ttarget: anchor,\\n\\t\\t\\tcurrentTarget: anchor,\\n\\t\\t\\tpreventDefault: $.noop\\n\\t\\t});\\n\\t},\\n\\n\\t_findActive: function( index ) {\\n\\t\\treturn index === false ? $() : this.tabs.eq( index );\\n\\t},\\n\\n\\t_getIndex: function( index ) {\\n\\t\\t// meta-function to give users option to provide a href string instead of a numerical index.\\n\\t\\tif ( typeof index === \\\"string\\\" ) {\\n\\t\\t\\tindex = this.anchors.index( this.anchors.filter( \\\"[href$='\\\" + index + \\\"']\\\" ) );\\n\\t\\t}\\n\\n\\t\\treturn index;\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tif ( this.xhr ) {\\n\\t\\t\\tthis.xhr.abort();\\n\\t\\t}\\n\\n\\t\\tthis.element.removeClass( \\\"ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible\\\" );\\n\\n\\t\\tthis.tablist\\n\\t\\t\\t.removeClass( \\\"ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" );\\n\\n\\t\\tthis.anchors\\n\\t\\t\\t.removeClass( \\\"ui-tabs-anchor\\\" )\\n\\t\\t\\t.removeAttr( \\\"role\\\" )\\n\\t\\t\\t.removeAttr( \\\"tabIndex\\\" )\\n\\t\\t\\t.removeUniqueId();\\n\\n\\t\\tthis.tabs.add( this.panels ).each(function() {\\n\\t\\t\\tif ( $.data( this, \\\"ui-tabs-destroy\\\" ) ) {\\n\\t\\t\\t\\t$( this ).remove();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$( this )\\n\\t\\t\\t\\t\\t.removeClass( \\\"ui-state-default ui-state-active ui-state-disabled \\\" +\\n\\t\\t\\t\\t\\t\\t\\\"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"tabIndex\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-live\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-busy\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-selected\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-labelledby\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-hidden\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"aria-expanded\\\" )\\n\\t\\t\\t\\t\\t.removeAttr( \\\"role\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.tabs.each(function() {\\n\\t\\t\\tvar li = $( this ),\\n\\t\\t\\t\\tprev = li.data( \\\"ui-tabs-aria-controls\\\" );\\n\\t\\t\\tif ( prev ) {\\n\\t\\t\\t\\tli\\n\\t\\t\\t\\t\\t.attr( \\\"aria-controls\\\", prev )\\n\\t\\t\\t\\t\\t.removeData( \\\"ui-tabs-aria-controls\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tli.removeAttr( \\\"aria-controls\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tthis.panels.show();\\n\\n\\t\\tif ( this.options.heightStyle !== \\\"content\\\" ) {\\n\\t\\t\\tthis.panels.css( \\\"height\\\", \\\"\\\" );\\n\\t\\t}\\n\\t},\\n\\n\\tenable: function( index ) {\\n\\t\\tvar disabled = this.options.disabled;\\n\\t\\tif ( disabled === false ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( index === undefined ) {\\n\\t\\t\\tdisabled = false;\\n\\t\\t} else {\\n\\t\\t\\tindex = this._getIndex( index );\\n\\t\\t\\tif ( $.isArray( disabled ) ) {\\n\\t\\t\\t\\tdisabled = $.map( disabled, function( num ) {\\n\\t\\t\\t\\t\\treturn num !== index ? num : null;\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdisabled = $.map( this.tabs, function( li, num ) {\\n\\t\\t\\t\\t\\treturn num !== index ? num : null;\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis._setupDisabled( disabled );\\n\\t},\\n\\n\\tdisable: function( index ) {\\n\\t\\tvar disabled = this.options.disabled;\\n\\t\\tif ( disabled === true ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( index === undefined ) {\\n\\t\\t\\tdisabled = true;\\n\\t\\t} else {\\n\\t\\t\\tindex = this._getIndex( index );\\n\\t\\t\\tif ( $.inArray( index, disabled ) !== -1 ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif ( $.isArray( disabled ) ) {\\n\\t\\t\\t\\tdisabled = $.merge( [ index ], disabled ).sort();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdisabled = [ index ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tthis._setupDisabled( disabled );\\n\\t},\\n\\n\\tload: function( index, event ) {\\n\\t\\tindex = this._getIndex( index );\\n\\t\\tvar that = this,\\n\\t\\t\\ttab = this.tabs.eq( index ),\\n\\t\\t\\tanchor = tab.find( \\\".ui-tabs-anchor\\\" ),\\n\\t\\t\\tpanel = this._getPanelForTab( tab ),\\n\\t\\t\\teventData = {\\n\\t\\t\\t\\ttab: tab,\\n\\t\\t\\t\\tpanel: panel\\n\\t\\t\\t};\\n\\n\\t\\t// not remote\\n\\t\\tif ( isLocal( anchor[ 0 ] ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );\\n\\n\\t\\t// support: jQuery <1.8\\n\\t\\t// jQuery <1.8 returns false if the request is canceled in beforeSend,\\n\\t\\t// but as of 1.8, $.ajax() always returns a jqXHR object.\\n\\t\\tif ( this.xhr && this.xhr.statusText !== \\\"canceled\\\" ) {\\n\\t\\t\\ttab.addClass( \\\"ui-tabs-loading\\\" );\\n\\t\\t\\tpanel.attr( \\\"aria-busy\\\", \\\"true\\\" );\\n\\n\\t\\t\\tthis.xhr\\n\\t\\t\\t\\t.success(function( response ) {\\n\\t\\t\\t\\t\\t// support: jQuery <1.8\\n\\t\\t\\t\\t\\t// http://bugs.jquery.com/ticket/11778\\n\\t\\t\\t\\t\\tsetTimeout(function() {\\n\\t\\t\\t\\t\\t\\tpanel.html( response );\\n\\t\\t\\t\\t\\t\\tthat._trigger( \\\"load\\\", event, eventData );\\n\\t\\t\\t\\t\\t}, 1 );\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.complete(function( jqXHR, status ) {\\n\\t\\t\\t\\t\\t// support: jQuery <1.8\\n\\t\\t\\t\\t\\t// http://bugs.jquery.com/ticket/11778\\n\\t\\t\\t\\t\\tsetTimeout(function() {\\n\\t\\t\\t\\t\\t\\tif ( status === \\\"abort\\\" ) {\\n\\t\\t\\t\\t\\t\\t\\tthat.panels.stop( false, true );\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttab.removeClass( \\\"ui-tabs-loading\\\" );\\n\\t\\t\\t\\t\\t\\tpanel.removeAttr( \\\"aria-busy\\\" );\\n\\n\\t\\t\\t\\t\\t\\tif ( jqXHR === that.xhr ) {\\n\\t\\t\\t\\t\\t\\t\\tdelete that.xhr;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}, 1 );\\n\\t\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t_ajaxSettings: function( anchor, event, eventData ) {\\n\\t\\tvar that = this;\\n\\t\\treturn {\\n\\t\\t\\turl: anchor.attr( \\\"href\\\" ),\\n\\t\\t\\tbeforeSend: function( jqXHR, settings ) {\\n\\t\\t\\t\\treturn that._trigger( \\\"beforeLoad\\\", event,\\n\\t\\t\\t\\t\\t$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t},\\n\\n\\t_getPanelForTab: function( tab ) {\\n\\t\\tvar id = $( tab ).attr( \\\"aria-controls\\\" );\\n\\t\\treturn this.element.find( this._sanitizeSelector( \\\"#\\\" + id ) );\\n\\t}\\n});\\n\\n})( jQuery );\\n\\n(function( $ ) {\\n\\nvar increments = 0;\\n\\nfunction addDescribedBy( elem, id ) {\\n\\tvar describedby = (elem.attr( \\\"aria-describedby\\\" ) || \\\"\\\").split( /\\\\s+/ );\\n\\tdescribedby.push( id );\\n\\telem\\n\\t\\t.data( \\\"ui-tooltip-id\\\", id )\\n\\t\\t.attr( \\\"aria-describedby\\\", $.trim( describedby.join( \\\" \\\" ) ) );\\n}\\n\\nfunction removeDescribedBy( elem ) {\\n\\tvar id = elem.data( \\\"ui-tooltip-id\\\" ),\\n\\t\\tdescribedby = (elem.attr( \\\"aria-describedby\\\" ) || \\\"\\\").split( /\\\\s+/ ),\\n\\t\\tindex = $.inArray( id, describedby );\\n\\tif ( index !== -1 ) {\\n\\t\\tdescribedby.splice( index, 1 );\\n\\t}\\n\\n\\telem.removeData( \\\"ui-tooltip-id\\\" );\\n\\tdescribedby = $.trim( describedby.join( \\\" \\\" ) );\\n\\tif ( describedby ) {\\n\\t\\telem.attr( \\\"aria-describedby\\\", describedby );\\n\\t} else {\\n\\t\\telem.removeAttr( \\\"aria-describedby\\\" );\\n\\t}\\n}\\n\\n$.widget( \\\"ui.tooltip\\\", {\\n\\tversion: \\\"1.10.3\\\",\\n\\toptions: {\\n\\t\\tcontent: function() {\\n\\t\\t\\t// support: IE<9, Opera in jQuery <1.7\\n\\t\\t\\t// .text() can't accept undefined, so coerce to a string\\n\\t\\t\\tvar title = $( this ).attr( \\\"title\\\" ) || \\\"\\\";\\n\\t\\t\\t// Escape title, since we're going from an attribute to raw HTML\\n\\t\\t\\treturn $( \\\"<a>\\\" ).text( title ).html();\\n\\t\\t},\\n\\t\\thide: true,\\n\\t\\t// Disabled elements have inconsistent behavior across browsers (#8661)\\n\\t\\titems: \\\"[title]:not([disabled])\\\",\\n\\t\\tposition: {\\n\\t\\t\\tmy: \\\"left top+15\\\",\\n\\t\\t\\tat: \\\"left bottom\\\",\\n\\t\\t\\tcollision: \\\"flipfit flip\\\"\\n\\t\\t},\\n\\t\\tshow: true,\\n\\t\\ttooltipClass: null,\\n\\t\\ttrack: false,\\n\\n\\t\\t// callbacks\\n\\t\\tclose: null,\\n\\t\\topen: null\\n\\t},\\n\\n\\t_create: function() {\\n\\t\\tthis._on({\\n\\t\\t\\tmouseover: \\\"open\\\",\\n\\t\\t\\tfocusin: \\\"open\\\"\\n\\t\\t});\\n\\n\\t\\t// IDs of generated tooltips, needed for destroy\\n\\t\\tthis.tooltips = {};\\n\\t\\t// IDs of parent tooltips where we removed the title attribute\\n\\t\\tthis.parents = {};\\n\\n\\t\\tif ( this.options.disabled ) {\\n\\t\\t\\tthis._disable();\\n\\t\\t}\\n\\t},\\n\\n\\t_setOption: function( key, value ) {\\n\\t\\tvar that = this;\\n\\n\\t\\tif ( key === \\\"disabled\\\" ) {\\n\\t\\t\\tthis[ value ? \\\"_disable\\\" : \\\"_enable\\\" ]();\\n\\t\\t\\tthis.options[ key ] = value;\\n\\t\\t\\t// disable element style changes\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tthis._super( key, value );\\n\\n\\t\\tif ( key === \\\"content\\\" ) {\\n\\t\\t\\t$.each( this.tooltips, function( id, element ) {\\n\\t\\t\\t\\tthat._updateContent( element );\\n\\t\\t\\t});\\n\\t\\t}\\n\\t},\\n\\n\\t_disable: function() {\\n\\t\\tvar that = this;\\n\\n\\t\\t// close open tooltips\\n\\t\\t$.each( this.tooltips, function( id, element ) {\\n\\t\\t\\tvar event = $.Event( \\\"blur\\\" );\\n\\t\\t\\tevent.target = event.currentTarget = element[0];\\n\\t\\t\\tthat.close( event, true );\\n\\t\\t});\\n\\n\\t\\t// remove title attributes to prevent native tooltips\\n\\t\\tthis.element.find( this.options.items ).addBack().each(function() {\\n\\t\\t\\tvar element = $( this );\\n\\t\\t\\tif ( element.is( \\\"[title]\\\" ) ) {\\n\\t\\t\\t\\telement\\n\\t\\t\\t\\t\\t.data( \\\"ui-tooltip-title\\\", element.attr( \\\"title\\\" ) )\\n\\t\\t\\t\\t\\t.attr( \\\"title\\\", \\\"\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\t_enable: function() {\\n\\t\\t// restore title attributes\\n\\t\\tthis.element.find( this.options.items ).addBack().each(function() {\\n\\t\\t\\tvar element = $( this );\\n\\t\\t\\tif ( element.data( \\\"ui-tooltip-title\\\" ) ) {\\n\\t\\t\\t\\telement.attr( \\\"title\\\", element.data( \\\"ui-tooltip-title\\\" ) );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t},\\n\\n\\topen: function( event ) {\\n\\t\\tvar that = this,\\n\\t\\t\\ttarget = $( event ? event.target : this.element )\\n\\t\\t\\t\\t// we need closest here due to mouseover bubbling,\\n\\t\\t\\t\\t// but always pointing at the same event target\\n\\t\\t\\t\\t.closest( this.options.items );\\n\\n\\t\\t// No element to show a tooltip for or the tooltip is already open\\n\\t\\tif ( !target.length || target.data( \\\"ui-tooltip-id\\\" ) ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif ( target.attr( \\\"title\\\" ) ) {\\n\\t\\t\\ttarget.data( \\\"ui-tooltip-title\\\", target.attr( \\\"title\\\" ) );\\n\\t\\t}\\n\\n\\t\\ttarget.data( \\\"ui-tooltip-open\\\", true );\\n\\n\\t\\t// kill parent tooltips, custom or native, for hover\\n\\t\\tif ( event && event.type === \\\"mouseover\\\" ) {\\n\\t\\t\\ttarget.parents().each(function() {\\n\\t\\t\\t\\tvar parent = $( this ),\\n\\t\\t\\t\\t\\tblurEvent;\\n\\t\\t\\t\\tif ( parent.data( \\\"ui-tooltip-open\\\" ) ) {\\n\\t\\t\\t\\t\\tblurEvent = $.Event( \\\"blur\\\" );\\n\\t\\t\\t\\t\\tblurEvent.target = blurEvent.currentTarget = this;\\n\\t\\t\\t\\t\\tthat.close( blurEvent, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( parent.attr( \\\"title\\\" ) ) {\\n\\t\\t\\t\\t\\tparent.uniqueId();\\n\\t\\t\\t\\t\\tthat.parents[ this.id ] = {\\n\\t\\t\\t\\t\\t\\telement: this,\\n\\t\\t\\t\\t\\t\\ttitle: parent.attr( \\\"title\\\" )\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\tparent.attr( \\\"title\\\", \\\"\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis._updateContent( target, event );\\n\\t},\\n\\n\\t_updateContent: function( target, event ) {\\n\\t\\tvar content,\\n\\t\\t\\tcontentOption = this.options.content,\\n\\t\\t\\tthat = this,\\n\\t\\t\\teventType = event ? event.type : null;\\n\\n\\t\\tif ( typeof contentOption === \\\"string\\\" ) {\\n\\t\\t\\treturn this._open( event, target, contentOption );\\n\\t\\t}\\n\\n\\t\\tcontent = contentOption.call( target[0], function( response ) {\\n\\t\\t\\t// ignore async response if tooltip was closed already\\n\\t\\t\\tif ( !target.data( \\\"ui-tooltip-open\\\" ) ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// IE may instantly serve a cached response for ajax requests\\n\\t\\t\\t// delay this call to _open so the other call to _open runs first\\n\\t\\t\\tthat._delay(function() {\\n\\t\\t\\t\\t// jQuery creates a special event for focusin when it doesn't\\n\\t\\t\\t\\t// exist natively. To improve performance, the native event\\n\\t\\t\\t\\t// object is reused and the type is changed. Therefore, we can't\\n\\t\\t\\t\\t// rely on the type being correct after the event finished\\n\\t\\t\\t\\t// bubbling, so we set it back to the previous value. (#8740)\\n\\t\\t\\t\\tif ( event ) {\\n\\t\\t\\t\\t\\tevent.type = eventType;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthis._open( event, target, response );\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\tif ( content ) {\\n\\t\\t\\tthis._open( event, target, content );\\n\\t\\t}\\n\\t},\\n\\n\\t_open: function( event, target, content ) {\\n\\t\\tvar tooltip, events, delayedShow,\\n\\t\\t\\tpositionOption = $.extend( {}, this.options.position );\\n\\n\\t\\tif ( !content ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Content can be updated multiple times. If the tooltip already\\n\\t\\t// exists, then just update the content and bail.\\n\\t\\ttooltip = this._find( target );\\n\\t\\tif ( tooltip.length ) {\\n\\t\\t\\ttooltip.find( \\\".ui-tooltip-content\\\" ).html( content );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// if we have a title, clear it to prevent the native tooltip\\n\\t\\t// we have to check first to avoid defining a title if none exists\\n\\t\\t// (we don't want to cause an element to start matching [title])\\n\\t\\t//\\n\\t\\t// We use removeAttr only for key events, to allow IE to export the correct\\n\\t\\t// accessible attributes. For mouse events, set to empty string to avoid\\n\\t\\t// native tooltip showing up (happens only when removing inside mouseover).\\n\\t\\tif ( target.is( \\\"[title]\\\" ) ) {\\n\\t\\t\\tif ( event && event.type === \\\"mouseover\\\" ) {\\n\\t\\t\\t\\ttarget.attr( \\\"title\\\", \\\"\\\" );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttarget.removeAttr( \\\"title\\\" );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttooltip = this._tooltip( target );\\n\\t\\taddDescribedBy( target, tooltip.attr( \\\"id\\\" ) );\\n\\t\\ttooltip.find( \\\".ui-tooltip-content\\\" ).html( content );\\n\\n\\t\\tfunction position( event ) {\\n\\t\\t\\tpositionOption.of = event;\\n\\t\\t\\tif ( tooltip.is( \\\":hidden\\\" ) ) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\ttooltip.position( positionOption );\\n\\t\\t}\\n\\t\\tif ( this.options.track && event && /^mouse/.test( event.type ) ) {\\n\\t\\t\\tthis._on( this.document, {\\n\\t\\t\\t\\tmousemove: position\\n\\t\\t\\t});\\n\\t\\t\\t// trigger once to override element-relative positioning\\n\\t\\t\\tposition( event );\\n\\t\\t} else {\\n\\t\\t\\ttooltip.position( $.extend({\\n\\t\\t\\t\\tof: target\\n\\t\\t\\t}, this.options.position ) );\\n\\t\\t}\\n\\n\\t\\ttooltip.hide();\\n\\n\\t\\tthis._show( tooltip, this.options.show );\\n\\t\\t// Handle tracking tooltips that are shown with a delay (#8644). As soon\\n\\t\\t// as the tooltip is visible, position the tooltip using the most recent\\n\\t\\t// event.\\n\\t\\tif ( this.options.show && this.options.show.delay ) {\\n\\t\\t\\tdelayedShow = this.delayedShow = setInterval(function() {\\n\\t\\t\\t\\tif ( tooltip.is( \\\":visible\\\" ) ) {\\n\\t\\t\\t\\t\\tposition( positionOption.of );\\n\\t\\t\\t\\t\\tclearInterval( delayedShow );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, $.fx.interval );\\n\\t\\t}\\n\\n\\t\\tthis._trigger( \\\"open\\\", event, { tooltip: tooltip } );\\n\\n\\t\\tevents = {\\n\\t\\t\\tkeyup: function( event ) {\\n\\t\\t\\t\\tif ( event.keyCode === $.ui.keyCode.ESCAPE ) {\\n\\t\\t\\t\\t\\tvar fakeEvent = $.Event(event);\\n\\t\\t\\t\\t\\tfakeEvent.currentTarget = target[0];\\n\\t\\t\\t\\t\\tthis.close( fakeEvent, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tremove: function() {\\n\\t\\t\\t\\tthis._removeTooltip( tooltip );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tif ( !event || event.type === \\\"mouseover\\\" ) {\\n\\t\\t\\tevents.mouseleave = \\\"close\\\";\\n\\t\\t}\\n\\t\\tif ( !event || event.type === \\\"focusin\\\" ) {\\n\\t\\t\\tevents.focusout = \\\"close\\\";\\n\\t\\t}\\n\\t\\tthis._on( true, target, events );\\n\\t},\\n\\n\\tclose: function( event ) {\\n\\t\\tvar that = this,\\n\\t\\t\\ttarget = $( event ? event.currentTarget : this.element ),\\n\\t\\t\\ttooltip = this._find( target );\\n\\n\\t\\t// disabling closes the tooltip, so we need to track when we're closing\\n\\t\\t// to avoid an infinite loop in case the tooltip becomes disabled on close\\n\\t\\tif ( this.closing ) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t// Clear the interval for delayed tracking tooltips\\n\\t\\tclearInterval( this.delayedShow );\\n\\n\\t\\t// only set title if we had one before (see comment in _open())\\n\\t\\tif ( target.data( \\\"ui-tooltip-title\\\" ) ) {\\n\\t\\t\\ttarget.attr( \\\"title\\\", target.data( \\\"ui-tooltip-title\\\" ) );\\n\\t\\t}\\n\\n\\t\\tremoveDescribedBy( target );\\n\\n\\t\\ttooltip.stop( true );\\n\\t\\tthis._hide( tooltip, this.options.hide, function() {\\n\\t\\t\\tthat._removeTooltip( $( this ) );\\n\\t\\t});\\n\\n\\t\\ttarget.removeData( \\\"ui-tooltip-open\\\" );\\n\\t\\tthis._off( target, \\\"mouseleave focusout keyup\\\" );\\n\\t\\t// Remove 'remove' binding only on delegated targets\\n\\t\\tif ( target[0] !== this.element[0] ) {\\n\\t\\t\\tthis._off( target, \\\"remove\\\" );\\n\\t\\t}\\n\\t\\tthis._off( this.document, \\\"mousemove\\\" );\\n\\n\\t\\tif ( event && event.type === \\\"mouseleave\\\" ) {\\n\\t\\t\\t$.each( this.parents, function( id, parent ) {\\n\\t\\t\\t\\t$( parent.element ).attr( \\\"title\\\", parent.title );\\n\\t\\t\\t\\tdelete that.parents[ id ];\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t\\tthis.closing = true;\\n\\t\\tthis._trigger( \\\"close\\\", event, { tooltip: tooltip } );\\n\\t\\tthis.closing = false;\\n\\t},\\n\\n\\t_tooltip: function( element ) {\\n\\t\\tvar id = \\\"ui-tooltip-\\\" + increments++,\\n\\t\\t\\ttooltip = $( \\\"<div>\\\" )\\n\\t\\t\\t\\t.attr({\\n\\t\\t\\t\\t\\tid: id,\\n\\t\\t\\t\\t\\trole: \\\"tooltip\\\"\\n\\t\\t\\t\\t})\\n\\t\\t\\t\\t.addClass( \\\"ui-tooltip ui-widget ui-corner-all ui-widget-content \\\" +\\n\\t\\t\\t\\t\\t( this.options.tooltipClass || \\\"\\\" ) );\\n\\t\\t$( \\\"<div>\\\" )\\n\\t\\t\\t.addClass( \\\"ui-tooltip-content\\\" )\\n\\t\\t\\t.appendTo( tooltip );\\n\\t\\ttooltip.appendTo( this.document[0].body );\\n\\t\\tthis.tooltips[ id ] = element;\\n\\t\\treturn tooltip;\\n\\t},\\n\\n\\t_find: function( target ) {\\n\\t\\tvar id = target.data( \\\"ui-tooltip-id\\\" );\\n\\t\\treturn id ? $( \\\"#\\\" + id ) : $();\\n\\t},\\n\\n\\t_removeTooltip: function( tooltip ) {\\n\\t\\ttooltip.remove();\\n\\t\\tdelete this.tooltips[ tooltip.attr( \\\"id\\\" ) ];\\n\\t},\\n\\n\\t_destroy: function() {\\n\\t\\tvar that = this;\\n\\n\\t\\t// close open tooltips\\n\\t\\t$.each( this.tooltips, function( id, element ) {\\n\\t\\t\\t// Delegate to close method to handle common cleanup\\n\\t\\t\\tvar event = $.Event( \\\"blur\\\" );\\n\\t\\t\\tevent.target = event.currentTarget = element[0];\\n\\t\\t\\tthat.close( event, true );\\n\\n\\t\\t\\t// Remove immediately; destroying an open tooltip doesn't use the\\n\\t\\t\\t// hide animation\\n\\t\\t\\t$( \\\"#\\\" + id ).remove();\\n\\n\\t\\t\\t// Restore the title\\n\\t\\t\\tif ( element.data( \\\"ui-tooltip-title\\\" ) ) {\\n\\t\\t\\t\\telement.attr( \\\"title\\\", element.data( \\\"ui-tooltip-title\\\" ) );\\n\\t\\t\\t\\telement.removeData( \\\"ui-tooltip-title\\\" );\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n});\\n\\n}( jQuery ) );\\n\";","export default \"/*! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */\\n!function(a,b){\\\"object\\\"==typeof module&&\\\"object\\\"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error(\\\"jQuery requires a window with a document\\\");return b(a)}:b(a)}(\\\"undefined\\\"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k=\\\"\\\".trim,l={},m=\\\"1.11.0\\\",n=function(a,b){return new n.fn.init(a,b)},o=/^[\\\\s\\\\uFEFF\\\\xA0]+|[\\\\s\\\\uFEFF\\\\xA0]+$/g,p=/^-ms-/,q=/-([\\\\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:\\\"\\\",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for(\\\"boolean\\\"==typeof g&&(j=g,g=arguments[h]||{},h++),\\\"object\\\"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:\\\"jQuery\\\"+(m+Math.random()).replace(/\\\\D/g,\\\"\\\"),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return\\\"function\\\"===n.type(a)},isArray:Array.isArray||function(a){return\\\"array\\\"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){return a-parseFloat(a)>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||\\\"object\\\"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!j.call(a,\\\"constructor\\\")&&!j.call(a.constructor.prototype,\\\"isPrototypeOf\\\"))return!1}catch(c){return!1}if(l.ownLast)for(b in a)return j.call(a,b);for(b in a);return void 0===b||j.call(a,b)},type:function(a){return null==a?a+\\\"\\\":\\\"object\\\"==typeof a||\\\"function\\\"==typeof a?h[i.call(a)]||\\\"object\\\":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,\\\"ms-\\\").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:k&&!k.call(\\\"\\\\ufeff\\\\xa0\\\")?function(a){return null==a?\\\"\\\":k.call(a)}:function(a){return null==a?\\\"\\\":(a+\\\"\\\").replace(o,\\\"\\\")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,\\\"string\\\"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(g)return g.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return\\\"string\\\"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=d.call(arguments,2),e=function(){return a.apply(b||this,c.concat(d.call(arguments)))},e.guid=a.guid=a.guid||n.guid++,e):void 0},now:function(){return+new Date},support:l}),n.each(\\\"Boolean Number String Function Array Date RegExp Object Error\\\".split(\\\" \\\"),function(a,b){h[\\\"[object \\\"+b+\\\"]\\\"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return\\\"function\\\"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:\\\"array\\\"===c||0===b||\\\"number\\\"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s=\\\"sizzle\\\"+-new Date,t=a.document,u=0,v=0,w=eb(),x=eb(),y=eb(),z=function(a,b){return a===b&&(j=!0),0},A=\\\"undefined\\\",B=1<<31,C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=D.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},J=\\\"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\\\",K=\\\"[\\\\\\\\x20\\\\\\\\t\\\\\\\\r\\\\\\\\n\\\\\\\\f]\\\",L=\\\"(?:\\\\\\\\\\\\\\\\.|[\\\\\\\\w-]|[^\\\\\\\\x00-\\\\\\\\xa0])+\\\",M=L.replace(\\\"w\\\",\\\"w#\\\"),N=\\\"\\\\\\\\[\\\"+K+\\\"*(\\\"+L+\\\")\\\"+K+\\\"*(?:([*^$|!~]?=)\\\"+K+\\\"*(?:(['\\\\\\\"])((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\])*?)\\\\\\\\3|(\\\"+M+\\\")|)|)\\\"+K+\\\"*\\\\\\\\]\\\",O=\\\":(\\\"+L+\\\")(?:\\\\\\\\(((['\\\\\\\"])((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\])*?)\\\\\\\\3|((?:\\\\\\\\\\\\\\\\.|[^\\\\\\\\\\\\\\\\()[\\\\\\\\]]|\\\"+N.replace(3,8)+\\\")*)|.*)\\\\\\\\)|)\\\",P=new RegExp(\\\"^\\\"+K+\\\"+|((?:^|[^\\\\\\\\\\\\\\\\])(?:\\\\\\\\\\\\\\\\.)*)\\\"+K+\\\"+$\\\",\\\"g\\\"),Q=new RegExp(\\\"^\\\"+K+\\\"*,\\\"+K+\\\"*\\\"),R=new RegExp(\\\"^\\\"+K+\\\"*([>+~]|\\\"+K+\\\")\\\"+K+\\\"*\\\"),S=new RegExp(\\\"=\\\"+K+\\\"*([^\\\\\\\\]'\\\\\\\"]*?)\\\"+K+\\\"*\\\\\\\\]\\\",\\\"g\\\"),T=new RegExp(O),U=new RegExp(\\\"^\\\"+M+\\\"$\\\"),V={ID:new RegExp(\\\"^#(\\\"+L+\\\")\\\"),CLASS:new RegExp(\\\"^\\\\\\\\.(\\\"+L+\\\")\\\"),TAG:new RegExp(\\\"^(\\\"+L.replace(\\\"w\\\",\\\"w*\\\")+\\\")\\\"),ATTR:new RegExp(\\\"^\\\"+N),PSEUDO:new RegExp(\\\"^\\\"+O),CHILD:new RegExp(\\\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\\\\\(\\\"+K+\\\"*(even|odd|(([+-]|)(\\\\\\\\d*)n|)\\\"+K+\\\"*(?:([+-]|)\\\"+K+\\\"*(\\\\\\\\d+)|))\\\"+K+\\\"*\\\\\\\\)|)\\\",\\\"i\\\"),bool:new RegExp(\\\"^(?:\\\"+J+\\\")$\\\",\\\"i\\\"),needsContext:new RegExp(\\\"^\\\"+K+\\\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\\\\\(\\\"+K+\\\"*((?:-\\\\\\\\d)?\\\\\\\\d*)\\\"+K+\\\"*\\\\\\\\)|)(?=[^-]|$)\\\",\\\"i\\\")},W=/^(?:input|select|textarea|button)$/i,X=/^h\\\\d$/i,Y=/^[^{]+\\\\{\\\\s*\\\\[native \\\\w/,Z=/^(?:#([\\\\w-]+)|(\\\\w+)|\\\\.([\\\\w-]+))$/,$=/[+~]/,_=/'|\\\\\\\\/g,ab=new RegExp(\\\"\\\\\\\\\\\\\\\\([\\\\\\\\da-f]{1,6}\\\"+K+\\\"?|(\\\"+K+\\\")|.)\\\",\\\"ig\\\"),bb=function(a,b,c){var d=\\\"0x\\\"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{G.apply(D=H.call(t.childNodes),t.childNodes),D[t.childNodes.length].nodeType}catch(cb){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function db(a,b,d,e){var f,g,h,i,j,m,p,q,u,v;if((b?b.ownerDocument||b:t)!==l&&k(b),b=b||l,d=d||[],!a||\\\"string\\\"!=typeof a)return d;if(1!==(i=b.nodeType)&&9!==i)return[];if(n&&!e){if(f=Z.exec(a))if(h=f[1]){if(9===i){if(g=b.getElementById(h),!g||!g.parentNode)return d;if(g.id===h)return d.push(g),d}else if(b.ownerDocument&&(g=b.ownerDocument.getElementById(h))&&r(b,g)&&g.id===h)return d.push(g),d}else{if(f[2])return G.apply(d,b.getElementsByTagName(a)),d;if((h=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(h)),d}if(c.qsa&&(!o||!o.test(a))){if(q=p=s,u=b,v=9===i&&a,1===i&&\\\"object\\\"!==b.nodeName.toLowerCase()){m=ob(a),(p=b.getAttribute(\\\"id\\\"))?q=p.replace(_,\\\"\\\\\\\\$&\\\"):b.setAttribute(\\\"id\\\",q),q=\\\"[id='\\\"+q+\\\"'] \\\",j=m.length;while(j--)m[j]=q+pb(m[j]);u=$.test(a)&&mb(b.parentNode)||b,v=m.join(\\\",\\\")}if(v)try{return G.apply(d,u.querySelectorAll(v)),d}catch(w){}finally{p||b.removeAttribute(\\\"id\\\")}}}return xb(a.replace(P,\\\"$1\\\"),b,d,e)}function eb(){var a=[];function b(c,e){return a.push(c+\\\" \\\")>d.cacheLength&&delete b[a.shift()],b[c+\\\" \\\"]=e}return b}function fb(a){return a[s]=!0,a}function gb(a){var b=l.createElement(\\\"div\\\");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function hb(a,b){var c=a.split(\\\"|\\\"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function ib(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||B)-(~a.sourceIndex||B);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function jb(a){return function(b){var c=b.nodeName.toLowerCase();return\\\"input\\\"===c&&b.type===a}}function kb(a){return function(b){var c=b.nodeName.toLowerCase();return(\\\"input\\\"===c||\\\"button\\\"===c)&&b.type===a}}function lb(a){return fb(function(b){return b=+b,fb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function mb(a){return a&&typeof a.getElementsByTagName!==A&&a}c=db.support={},f=db.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?\\\"HTML\\\"!==b.nodeName:!1},k=db.setDocument=function(a){var b,e=a?a.ownerDocument||a:t,g=e.defaultView;return e!==l&&9===e.nodeType&&e.documentElement?(l=e,m=e.documentElement,n=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener(\\\"unload\\\",function(){k()},!1):g.attachEvent&&g.attachEvent(\\\"onunload\\\",function(){k()})),c.attributes=gb(function(a){return a.className=\\\"i\\\",!a.getAttribute(\\\"className\\\")}),c.getElementsByTagName=gb(function(a){return a.appendChild(e.createComment(\\\"\\\")),!a.getElementsByTagName(\\\"*\\\").length}),c.getElementsByClassName=Y.test(e.getElementsByClassName)&&gb(function(a){return a.innerHTML=\\\"<div class='a'></div><div class='a i'></div>\\\",a.firstChild.className=\\\"i\\\",2===a.getElementsByClassName(\\\"i\\\").length}),c.getById=gb(function(a){return m.appendChild(a).id=s,!e.getElementsByName||!e.getElementsByName(s).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==A&&n){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){return a.getAttribute(\\\"id\\\")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ab,bb);return function(a){var c=typeof a.getAttributeNode!==A&&a.getAttributeNode(\\\"id\\\");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==A?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if(\\\"*\\\"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==A&&n?b.getElementsByClassName(a):void 0},p=[],o=[],(c.qsa=Y.test(e.querySelectorAll))&&(gb(function(a){a.innerHTML=\\\"<select t=''><option selected=''></option></select>\\\",a.querySelectorAll(\\\"[t^='']\\\").length&&o.push(\\\"[*^$]=\\\"+K+\\\"*(?:''|\\\\\\\"\\\\\\\")\\\"),a.querySelectorAll(\\\"[selected]\\\").length||o.push(\\\"\\\\\\\\[\\\"+K+\\\"*(?:value|\\\"+J+\\\")\\\"),a.querySelectorAll(\\\":checked\\\").length||o.push(\\\":checked\\\")}),gb(function(a){var b=e.createElement(\\\"input\\\");b.setAttribute(\\\"type\\\",\\\"hidden\\\"),a.appendChild(b).setAttribute(\\\"name\\\",\\\"D\\\"),a.querySelectorAll(\\\"[name=d]\\\").length&&o.push(\\\"name\\\"+K+\\\"*[*^$|!~]?=\\\"),a.querySelectorAll(\\\":enabled\\\").length||o.push(\\\":enabled\\\",\\\":disabled\\\"),a.querySelectorAll(\\\"*,:x\\\"),o.push(\\\",.*:\\\")})),(c.matchesSelector=Y.test(q=m.webkitMatchesSelector||m.mozMatchesSelector||m.oMatchesSelector||m.msMatchesSelector))&&gb(function(a){c.disconnectedMatch=q.call(a,\\\"div\\\"),q.call(a,\\\"[s!='']:x\\\"),p.push(\\\"!=\\\",O)}),o=o.length&&new RegExp(o.join(\\\"|\\\")),p=p.length&&new RegExp(p.join(\\\"|\\\")),b=Y.test(m.compareDocumentPosition),r=b||Y.test(m.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},z=b?function(a,b){if(a===b)return j=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===t&&r(t,a)?-1:b===e||b.ownerDocument===t&&r(t,b)?1:i?I.call(i,a)-I.call(i,b):0:4&d?-1:1)}:function(a,b){if(a===b)return j=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],k=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:i?I.call(i,a)-I.call(i,b):0;if(f===g)return ib(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)k.unshift(c);while(h[d]===k[d])d++;return d?ib(h[d],k[d]):h[d]===t?-1:k[d]===t?1:0},e):l},db.matches=function(a,b){return db(a,null,null,b)},db.matchesSelector=function(a,b){if((a.ownerDocument||a)!==l&&k(a),b=b.replace(S,\\\"='$1']\\\"),!(!c.matchesSelector||!n||p&&p.test(b)||o&&o.test(b)))try{var d=q.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return db(b,l,null,[a]).length>0},db.contains=function(a,b){return(a.ownerDocument||a)!==l&&k(a),r(a,b)},db.attr=function(a,b){(a.ownerDocument||a)!==l&&k(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!n):void 0;return void 0!==f?f:c.attributes||!n?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},db.error=function(a){throw new Error(\\\"Syntax error, unrecognized expression: \\\"+a)},db.uniqueSort=function(a){var b,d=[],e=0,f=0;if(j=!c.detectDuplicates,i=!c.sortStable&&a.slice(0),a.sort(z),j){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return i=null,a},e=db.getText=function(a){var b,c=\\\"\\\",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if(\\\"string\\\"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=db.selectors={cacheLength:50,createPseudo:fb,match:V,attrHandle:{},find:{},relative:{\\\">\\\":{dir:\\\"parentNode\\\",first:!0},\\\" \\\":{dir:\\\"parentNode\\\"},\\\"+\\\":{dir:\\\"previousSibling\\\",first:!0},\\\"~\\\":{dir:\\\"previousSibling\\\"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ab,bb),a[3]=(a[4]||a[5]||\\\"\\\").replace(ab,bb),\\\"~=\\\"===a[2]&&(a[3]=\\\" \\\"+a[3]+\\\" \\\"),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),\\\"nth\\\"===a[1].slice(0,3)?(a[3]||db.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*(\\\"even\\\"===a[3]||\\\"odd\\\"===a[3])),a[5]=+(a[7]+a[8]||\\\"odd\\\"===a[3])):a[3]&&db.error(a[0]),a},PSEUDO:function(a){var b,c=!a[5]&&a[2];return V.CHILD.test(a[0])?null:(a[3]&&void 0!==a[4]?a[2]=a[4]:c&&T.test(c)&&(b=ob(c,!0))&&(b=c.indexOf(\\\")\\\",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ab,bb).toLowerCase();return\\\"*\\\"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=w[a+\\\" \\\"];return b||(b=new RegExp(\\\"(^|\\\"+K+\\\")\\\"+a+\\\"(\\\"+K+\\\"|$)\\\"))&&w(a,function(a){return b.test(\\\"string\\\"==typeof a.className&&a.className||typeof a.getAttribute!==A&&a.getAttribute(\\\"class\\\")||\\\"\\\")})},ATTR:function(a,b,c){return function(d){var e=db.attr(d,a);return null==e?\\\"!=\\\"===b:b?(e+=\\\"\\\",\\\"=\\\"===b?e===c:\\\"!=\\\"===b?e!==c:\\\"^=\\\"===b?c&&0===e.indexOf(c):\\\"*=\\\"===b?c&&e.indexOf(c)>-1:\\\"$=\\\"===b?c&&e.slice(-c.length)===c:\\\"~=\\\"===b?(\\\" \\\"+e+\\\" \\\").indexOf(c)>-1:\\\"|=\\\"===b?e===c||e.slice(0,c.length+1)===c+\\\"-\\\":!1):!0}},CHILD:function(a,b,c,d,e){var f=\\\"nth\\\"!==a.slice(0,3),g=\\\"last\\\"!==a.slice(-4),h=\\\"of-type\\\"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?\\\"nextSibling\\\":\\\"previousSibling\\\",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),t=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p=\\\"only\\\"===a&&!o&&\\\"nextSibling\\\"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&t){k=q[s]||(q[s]={}),j=k[a]||[],n=j[0]===u&&j[1],m=j[0]===u&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[u,n,m];break}}else if(t&&(j=(b[s]||(b[s]={}))[a])&&j[0]===u)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(t&&((l[s]||(l[s]={}))[a]=[u,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||db.error(\\\"unsupported pseudo: \\\"+a);return e[s]?e(b):e.length>1?(c=[a,a,\\\"\\\",b],d.setFilters.hasOwnProperty(a.toLowerCase())?fb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:fb(function(a){var b=[],c=[],d=g(a.replace(P,\\\"$1\\\"));return d[s]?fb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:fb(function(a){return function(b){return db(a,b).length>0}}),contains:fb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:fb(function(a){return U.test(a||\\\"\\\")||db.error(\\\"unsupported lang: \\\"+a),a=a.replace(ab,bb).toLowerCase(),function(b){var c;do if(c=n?b.lang:b.getAttribute(\\\"xml:lang\\\")||b.getAttribute(\\\"lang\\\"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+\\\"-\\\");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===m},focus:function(a){return a===l.activeElement&&(!l.hasFocus||l.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return\\\"input\\\"===b&&!!a.checked||\\\"option\\\"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return\\\"input\\\"===b&&\\\"button\\\"===a.type||\\\"button\\\"===b},text:function(a){var b;return\\\"input\\\"===a.nodeName.toLowerCase()&&\\\"text\\\"===a.type&&(null==(b=a.getAttribute(\\\"type\\\"))||\\\"text\\\"===b.toLowerCase())},first:lb(function(){return[0]}),last:lb(function(a,b){return[b-1]}),eq:lb(function(a,b,c){return[0>c?c+b:c]}),even:lb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:lb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:lb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:lb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=jb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=kb(b);function nb(){}nb.prototype=d.filters=d.pseudos,d.setFilters=new nb;function ob(a,b){var c,e,f,g,h,i,j,k=x[a+\\\" \\\"];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=Q.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P,\\\" \\\")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?db.error(a):x(a,i).slice(0)}function pb(a){for(var b=0,c=a.length,d=\\\"\\\";c>b;b++)d+=a[b].value;return d}function qb(a,b,c){var d=b.dir,e=c&&\\\"parentNode\\\"===d,f=v++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[u,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[s]||(b[s]={}),(h=i[d])&&h[0]===u&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function rb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function sb(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function tb(a,b,c,d,e,f){return d&&!d[s]&&(d=tb(d)),e&&!e[s]&&(e=tb(e,f)),fb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||wb(b||\\\"*\\\",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:sb(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=sb(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=sb(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ub(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],i=g||d.relative[\\\" \\\"],j=g?1:0,k=qb(function(a){return a===b},i,!0),l=qb(function(a){return I.call(b,a)>-1},i,!0),m=[function(a,c,d){return!g&&(d||c!==h)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>j;j++)if(c=d.relative[a[j].type])m=[qb(rb(m),c)];else{if(c=d.filter[a[j].type].apply(null,a[j].matches),c[s]){for(e=++j;f>e;e++)if(d.relative[a[e].type])break;return tb(j>1&&rb(m),j>1&&pb(a.slice(0,j-1).concat({value:\\\" \\\"===a[j-2].type?\\\"*\\\":\\\"\\\"})).replace(P,\\\"$1\\\"),c,e>j&&ub(a.slice(j,e)),f>e&&ub(a=a.slice(e)),f>e&&pb(a))}m.push(c)}return rb(m)}function vb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,i,j,k){var m,n,o,p=0,q=\\\"0\\\",r=f&&[],s=[],t=h,v=f||e&&d.find.TAG(\\\"*\\\",k),w=u+=null==t?1:Math.random()||.1,x=v.length;for(k&&(h=g!==l&&g);q!==x&&null!=(m=v[q]);q++){if(e&&m){n=0;while(o=a[n++])if(o(m,g,i)){j.push(m);break}k&&(u=w)}c&&((m=!o&&m)&&p--,f&&r.push(m))}if(p+=q,c&&q!==p){n=0;while(o=b[n++])o(r,s,g,i);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=E.call(j));s=sb(s)}G.apply(j,s),k&&!f&&s.length>0&&p+b.length>1&&db.uniqueSort(j)}return k&&(u=w,h=t),r};return c?fb(f):f}g=db.compile=function(a,b){var c,d=[],e=[],f=y[a+\\\" \\\"];if(!f){b||(b=ob(a)),c=b.length;while(c--)f=ub(b[c]),f[s]?d.push(f):e.push(f);f=y(a,vb(e,d))}return f};function wb(a,b,c){for(var d=0,e=b.length;e>d;d++)db(a,b[d],c);return c}function xb(a,b,e,f){var h,i,j,k,l,m=ob(a);if(!f&&1===m.length){if(i=m[0]=m[0].slice(0),i.length>2&&\\\"ID\\\"===(j=i[0]).type&&c.getById&&9===b.nodeType&&n&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(ab,bb),b)||[])[0],!b)return e;a=a.slice(i.shift().value.length)}h=V.needsContext.test(a)?0:i.length;while(h--){if(j=i[h],d.relative[k=j.type])break;if((l=d.find[k])&&(f=l(j.matches[0].replace(ab,bb),$.test(i[0].type)&&mb(b.parentNode)||b))){if(i.splice(h,1),a=f.length&&pb(i),!a)return G.apply(e,f),e;break}}}return g(a,m)(f,b,!n,e,$.test(a)&&mb(b.parentNode)||b),e}return c.sortStable=s.split(\\\"\\\").sort(z).join(\\\"\\\")===s,c.detectDuplicates=!!j,k(),c.sortDetached=gb(function(a){return 1&a.compareDocumentPosition(l.createElement(\\\"div\\\"))}),gb(function(a){return a.innerHTML=\\\"<a href='#'></a>\\\",\\\"#\\\"===a.firstChild.getAttribute(\\\"href\\\")})||hb(\\\"type|href|height|width\\\",function(a,b,c){return c?void 0:a.getAttribute(b,\\\"type\\\"===b.toLowerCase()?1:2)}),c.attributes&&gb(function(a){return a.innerHTML=\\\"<input/>\\\",a.firstChild.setAttribute(\\\"value\\\",\\\"\\\"),\\\"\\\"===a.firstChild.getAttribute(\\\"value\\\")})||hb(\\\"value\\\",function(a,b,c){return c||\\\"input\\\"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),gb(function(a){return null==a.getAttribute(\\\"disabled\\\")})||hb(J,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),db}(a);n.find=t,n.expr=t.selectors,n.expr[\\\":\\\"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/,w=/^.[^:#\\\\[\\\\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if(\\\"string\\\"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=\\\":not(\\\"+a+\\\")\\\"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if(\\\"string\\\"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+\\\" \\\"+a:a,c},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,\\\"string\\\"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=a.document,A=/^(?:\\\\s*(<[\\\\w\\\\W]+>)[^>]*|#([\\\\w-]*))$/,B=n.fn.init=function(a,b){var c,d;if(!a)return this;if(\\\"string\\\"==typeof a){if(c=\\\"<\\\"===a.charAt(0)&&\\\">\\\"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:A.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:z,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}if(d=z.getElementById(c[2]),d&&d.parentNode){if(d.id!==c[2])return y.find(a);this.length=1,this[0]=d}return this.context=z,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?\\\"undefined\\\"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};B.prototype=n.fn,y=n(z);var C=/^(?:parents|prev(?:Until|All))/,D={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=a[b];while(e&&9!==e.nodeType&&(void 0===c||1!==e.nodeType||!n(e).is(c)))1===e.nodeType&&d.push(e),e=e[b];return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||\\\"string\\\"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?\\\"string\\\"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function E(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,\\\"parentNode\\\")},parentsUntil:function(a,b,c){return n.dir(a,\\\"parentNode\\\",c)},next:function(a){return E(a,\\\"nextSibling\\\")},prev:function(a){return E(a,\\\"previousSibling\\\")},nextAll:function(a){return n.dir(a,\\\"nextSibling\\\")},prevAll:function(a){return n.dir(a,\\\"previousSibling\\\")},nextUntil:function(a,b,c){return n.dir(a,\\\"nextSibling\\\",c)},prevUntil:function(a,b,c){return n.dir(a,\\\"previousSibling\\\",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return n.nodeName(a,\\\"iframe\\\")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return\\\"Until\\\"!==a.slice(-5)&&(d=c),d&&\\\"string\\\"==typeof d&&(e=n.filter(d,e)),this.length>1&&(D[a]||(e=n.unique(e)),C.test(a)&&(e=e.reverse())),this.pushStack(e)}});var F=/\\\\S+/g,G={};function H(a){var b=G[a]={};return n.each(a.match(F)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a=\\\"string\\\"==typeof a?G[a]||H(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(c=a.memory&&l,d=!0,f=g||0,g=0,e=h.length,b=!0;h&&e>f;f++)if(h[f].apply(l[0],l[1])===!1&&a.stopOnFalse){c=!1;break}b=!1,h&&(i?i.length&&j(i.shift()):c?h=[]:k.disable())},k={add:function(){if(h){var d=h.length;!function f(b){n.each(b,function(b,c){var d=n.type(c);\\\"function\\\"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&\\\"string\\\"!==d&&f(c)})}(arguments),b?e=h.length:c&&(g=d,j(c))}return this},remove:function(){return h&&n.each(arguments,function(a,c){var d;while((d=n.inArray(c,h,d))>-1)h.splice(d,1),b&&(e>=d&&e--,f>=d&&f--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],e=0,this},disable:function(){return h=i=c=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,c||k.disable(),this},locked:function(){return!i},fireWith:function(a,c){return!h||d&&!i||(c=c||[],c=[a,c.slice?c.slice():c],b?i.push(c):j(c)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!d}};return k},n.extend({Deferred:function(a){var b=[[\\\"resolve\\\",\\\"done\\\",n.Callbacks(\\\"once memory\\\"),\\\"resolved\\\"],[\\\"reject\\\",\\\"fail\\\",n.Callbacks(\\\"once memory\\\"),\\\"rejected\\\"],[\\\"notify\\\",\\\"progress\\\",n.Callbacks(\\\"memory\\\")]],c=\\\"pending\\\",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+\\\"With\\\"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+\\\"With\\\"](this===e?d:this,arguments),this},e[f[0]+\\\"With\\\"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){if(a===!0?!--n.readyWait:!n.isReady){if(!z.body)return setTimeout(n.ready);n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(z,[n]),n.fn.trigger&&n(z).trigger(\\\"ready\\\").off(\\\"ready\\\"))}}});function J(){z.addEventListener?(z.removeEventListener(\\\"DOMContentLoaded\\\",K,!1),a.removeEventListener(\\\"load\\\",K,!1)):(z.detachEvent(\\\"onreadystatechange\\\",K),a.detachEvent(\\\"onload\\\",K))}function K(){(z.addEventListener||\\\"load\\\"===event.type||\\\"complete\\\"===z.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),\\\"complete\\\"===z.readyState)setTimeout(n.ready);else if(z.addEventListener)z.addEventListener(\\\"DOMContentLoaded\\\",K,!1),a.addEventListener(\\\"load\\\",K,!1);else{z.attachEvent(\\\"onreadystatechange\\\",K),a.attachEvent(\\\"onload\\\",K);var c=!1;try{c=null==a.frameElement&&z.documentElement}catch(d){}c&&c.doScroll&&!function e(){if(!n.isReady){try{c.doScroll(\\\"left\\\")}catch(a){return setTimeout(e,50)}J(),n.ready()}}()}return I.promise(b)};var L=\\\"undefined\\\",M;for(M in n(l))break;l.ownLast=\\\"0\\\"!==M,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c=z.getElementsByTagName(\\\"body\\\")[0];c&&(a=z.createElement(\\\"div\\\"),a.style.cssText=\\\"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\\\",b=z.createElement(\\\"div\\\"),c.appendChild(a).appendChild(b),typeof b.style.zoom!==L&&(b.style.cssText=\\\"border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1\\\",(l.inlineBlockNeedsLayout=3===b.offsetWidth)&&(c.style.zoom=1)),c.removeChild(a),a=b=null)}),function(){var a=z.createElement(\\\"div\\\");if(null==l.deleteExpando){l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}}a=null}(),n.acceptData=function(a){var b=n.noData[(a.nodeName+\\\" \\\").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute(\\\"classid\\\")===b};var N=/^(?:\\\\{[\\\\w\\\\W]*\\\\}|\\\\[[\\\\w\\\\W]*\\\\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d=\\\"data-\\\"+b.replace(O,\\\"-$1\\\").toLowerCase();if(c=a.getAttribute(d),\\\"string\\\"==typeof c){try{c=\\\"true\\\"===c?!0:\\\"false\\\"===c?!1:\\\"null\\\"===c?null:+c+\\\"\\\"===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0}return c}function Q(a){var b;for(b in a)if((\\\"data\\\"!==b||!n.isEmptyObject(a[b]))&&\\\"toJSON\\\"!==b)return!1;return!0}function R(a,b,d,e){if(n.acceptData(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||\\\"string\\\"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),(\\\"object\\\"==typeof b||\\\"function\\\"==typeof b)&&(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),\\\"string\\\"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f\\n}}function S(a,b,c){if(n.acceptData(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(\\\" \\\")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=null)}}}n.extend({cache:{},noData:{\\\"applet \\\":!0,\\\"embed \\\":!0,\\\"object \\\":\\\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\\\"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,\\\"parsedAttrs\\\"))){c=g.length;while(c--)d=g[c].name,0===d.indexOf(\\\"data-\\\")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d]));n._data(f,\\\"parsedAttrs\\\",!0)}return e}return\\\"object\\\"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||\\\"fx\\\")+\\\"queue\\\",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||\\\"fx\\\";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};\\\"inprogress\\\"===e&&(e=c.shift(),d--),e&&(\\\"fx\\\"===b&&c.unshift(\\\"inprogress\\\"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+\\\"queueHooks\\\";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks(\\\"once memory\\\").add(function(){n._removeData(a,b+\\\"queue\\\"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return\\\"string\\\"!=typeof a&&(b=a,a=\\\"fx\\\",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),\\\"fx\\\"===a&&\\\"inprogress\\\"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||\\\"fx\\\",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};\\\"string\\\"!=typeof a&&(b=a,a=void 0),a=a||\\\"fx\\\";while(g--)c=n._data(f[g],a+\\\"queueHooks\\\"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var T=/[+-]?(?:\\\\d*\\\\.|)\\\\d+(?:[eE][+-]?\\\\d+|)/.source,U=[\\\"Top\\\",\\\"Right\\\",\\\"Bottom\\\",\\\"Left\\\"],V=function(a,b){return a=b||a,\\\"none\\\"===n.css(a,\\\"display\\\")||!n.contains(a.ownerDocument,a)},W=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if(\\\"object\\\"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},X=/^(?:checkbox|radio)$/i;!function(){var a=z.createDocumentFragment(),b=z.createElement(\\\"div\\\"),c=z.createElement(\\\"input\\\");if(b.setAttribute(\\\"className\\\",\\\"t\\\"),b.innerHTML=\\\"  <link/><table></table><a href='/a'>a</a>\\\",l.leadingWhitespace=3===b.firstChild.nodeType,l.tbody=!b.getElementsByTagName(\\\"tbody\\\").length,l.htmlSerialize=!!b.getElementsByTagName(\\\"link\\\").length,l.html5Clone=\\\"<:nav></:nav>\\\"!==z.createElement(\\\"nav\\\").cloneNode(!0).outerHTML,c.type=\\\"checkbox\\\",c.checked=!0,a.appendChild(c),l.appendChecked=c.checked,b.innerHTML=\\\"<textarea>x</textarea>\\\",l.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue,a.appendChild(b),b.innerHTML=\\\"<input type='radio' checked='checked' name='t'/>\\\",l.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!0,b.attachEvent&&(b.attachEvent(\\\"onclick\\\",function(){l.noCloneEvent=!1}),b.cloneNode(!0).click()),null==l.deleteExpando){l.deleteExpando=!0;try{delete b.test}catch(d){l.deleteExpando=!1}}a=b=c=null}(),function(){var b,c,d=z.createElement(\\\"div\\\");for(b in{submit:!0,change:!0,focusin:!0})c=\\\"on\\\"+b,(l[b+\\\"Bubbles\\\"]=c in a)||(d.setAttribute(c,\\\"t\\\"),l[b+\\\"Bubbles\\\"]=d.attributes[c].expando===!1);d=null}();var Y=/^(?:input|select|textarea)$/i,Z=/^key/,$=/^(?:mouse|contextmenu)|click/,_=/^(?:focusinfocus|focusoutblur)$/,ab=/^([^.]*)(?:\\\\.(.+)|)$/;function bb(){return!0}function cb(){return!1}function db(){try{return z.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return typeof n===L||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||\\\"\\\").match(F)||[\\\"\\\"],h=b.length;while(h--)f=ab.exec(b[h])||[],o=q=f[1],p=(f[2]||\\\"\\\").split(\\\".\\\").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(\\\".\\\")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent(\\\"on\\\"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||\\\"\\\").match(F)||[\\\"\\\"],j=b.length;while(j--)if(h=ab.exec(b[j])||[],o=q=h[1],p=(h[2]||\\\"\\\").split(\\\".\\\").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp(\\\"(^|\\\\\\\\.)\\\"+p.join(\\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\")+\\\"(\\\\\\\\.|$)\\\"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&(\\\"**\\\"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,\\\"events\\\"))}},trigger:function(b,c,d,e){var f,g,h,i,k,l,m,o=[d||z],p=j.call(b,\\\"type\\\")?b.type:b,q=j.call(b,\\\"namespace\\\")?b.namespace.split(\\\".\\\"):[];if(h=l=d=d||z,3!==d.nodeType&&8!==d.nodeType&&!_.test(p+n.event.triggered)&&(p.indexOf(\\\".\\\")>=0&&(q=p.split(\\\".\\\"),p=q.shift(),q.sort()),g=p.indexOf(\\\":\\\")<0&&\\\"on\\\"+p,b=b[n.expando]?b:new n.Event(p,\\\"object\\\"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=q.join(\\\".\\\"),b.namespace_re=b.namespace?new RegExp(\\\"(^|\\\\\\\\.)\\\"+q.join(\\\"\\\\\\\\.(?:.*\\\\\\\\.|)\\\")+\\\"(\\\\\\\\.|$)\\\"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),k=n.event.special[p]||{},e||!k.trigger||k.trigger.apply(d,c)!==!1)){if(!e&&!k.noBubble&&!n.isWindow(d)){for(i=k.delegateType||p,_.test(i+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),l=h;l===(d.ownerDocument||z)&&o.push(l.defaultView||l.parentWindow||a)}m=0;while((h=o[m++])&&!b.isPropagationStopped())b.type=m>1?i:k.bindType||p,f=(n._data(h,\\\"events\\\")||{})[b.type]&&n._data(h,\\\"handle\\\"),f&&f.apply(h,c),f=g&&h[g],f&&f.apply&&n.acceptData(h)&&(b.result=f.apply(h,c),b.result===!1&&b.preventDefault());if(b.type=p,!e&&!b.isDefaultPrevented()&&(!k._default||k._default.apply(o.pop(),c)===!1)&&n.acceptData(d)&&g&&d[p]&&!n.isWindow(d)){l=d[g],l&&(d[g]=null),n.event.triggered=p;try{d[p]()}catch(r){}n.event.triggered=void 0,l&&(d[g]=l)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(n._data(this,\\\"events\\\")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,g=0;while((e=f.handlers[g++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(e.namespace))&&(a.handleObj=e,a.data=e.data,c=((n.event.special[e.origType]||{}).handle||e.handler).apply(f.elem,i),void 0!==c&&(a.result=c)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||\\\"click\\\"!==a.type))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||\\\"click\\\"!==a.type)){for(e=[],f=0;h>f;f++)d=b[f],c=d.selector+\\\" \\\",void 0===e[c]&&(e[c]=d.needsContext?n(c,this).index(i)>=0:n.find(c,this,null,[i]).length),e[c]&&e.push(d);e.length&&g.push({elem:i,handlers:e})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=$.test(e)?this.mouseHooks:Z.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=f.srcElement||z),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,g.filter?g.filter(a,f):a},props:\\\"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\\\".split(\\\" \\\"),fixHooks:{},keyHooks:{props:\\\"char charCode key keyCode\\\".split(\\\" \\\"),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:\\\"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\\\".split(\\\" \\\"),filter:function(a,b){var c,d,e,f=b.button,g=b.fromElement;return null==a.pageX&&null!=b.clientX&&(d=a.target.ownerDocument||z,e=d.documentElement,c=d.body,a.pageX=b.clientX+(e&&e.scrollLeft||c&&c.scrollLeft||0)-(e&&e.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(e&&e.scrollTop||c&&c.scrollTop||0)-(e&&e.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&g&&(a.relatedTarget=g===a.target?b.toElement:g),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==db()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:\\\"focusin\\\"},blur:{trigger:function(){return this===db()&&this.blur?(this.blur(),!1):void 0},delegateType:\\\"focusout\\\"},click:{trigger:function(){return n.nodeName(this,\\\"input\\\")&&\\\"checkbox\\\"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,\\\"a\\\")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=z.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d=\\\"on\\\"+b;a.detachEvent&&(typeof a[d]===L&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&(a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault())?bb:cb):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:cb,isPropagationStopped:cb,isImmediatePropagationStopped:cb,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=bb,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=bb,a&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=bb,this.stopPropagation()}},n.each({mouseenter:\\\"mouseover\\\",mouseleave:\\\"mouseout\\\"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submitBubbles||(n.event.special.submit={setup:function(){return n.nodeName(this,\\\"form\\\")?!1:void n.event.add(this,\\\"click._submit keypress._submit\\\",function(a){var b=a.target,c=n.nodeName(b,\\\"input\\\")||n.nodeName(b,\\\"button\\\")?b.form:void 0;c&&!n._data(c,\\\"submitBubbles\\\")&&(n.event.add(c,\\\"submit._submit\\\",function(a){a._submit_bubble=!0}),n._data(c,\\\"submitBubbles\\\",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&n.event.simulate(\\\"submit\\\",this.parentNode,a,!0))},teardown:function(){return n.nodeName(this,\\\"form\\\")?!1:void n.event.remove(this,\\\"._submit\\\")}}),l.changeBubbles||(n.event.special.change={setup:function(){return Y.test(this.nodeName)?((\\\"checkbox\\\"===this.type||\\\"radio\\\"===this.type)&&(n.event.add(this,\\\"propertychange._change\\\",function(a){\\\"checked\\\"===a.originalEvent.propertyName&&(this._just_changed=!0)}),n.event.add(this,\\\"click._change\\\",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),n.event.simulate(\\\"change\\\",this,a,!0)})),!1):void n.event.add(this,\\\"beforeactivate._change\\\",function(a){var b=a.target;Y.test(b.nodeName)&&!n._data(b,\\\"changeBubbles\\\")&&(n.event.add(b,\\\"change._change\\\",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate(\\\"change\\\",this.parentNode,a,!0)}),n._data(b,\\\"changeBubbles\\\",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||\\\"radio\\\"!==b.type&&\\\"checkbox\\\"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,\\\"._change\\\"),!Y.test(this.nodeName)}}),l.focusinBubbles||n.each({focus:\\\"focusin\\\",blur:\\\"focusout\\\"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if(\\\"object\\\"==typeof a){\\\"string\\\"!=typeof b&&(c=c||b,b=void 0);for(f in a)this.on(f,b,c,a[f],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&(\\\"string\\\"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=cb;else if(!d)return this;return 1===e&&(g=d,d=function(a){return n().off(a),g.apply(this,arguments)},d.guid=g.guid||(g.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+\\\".\\\"+d.namespace:d.origType,d.selector,d.handler),this;if(\\\"object\\\"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||\\\"function\\\"==typeof b)&&(c=b,b=void 0),c===!1&&(c=cb),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});function eb(a){var b=fb.split(\\\"|\\\"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}var fb=\\\"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\\\",gb=/ jQuery\\\\d+=\\\"(?:null|\\\\d+)\\\"/g,hb=new RegExp(\\\"<(?:\\\"+fb+\\\")[\\\\\\\\s/>]\\\",\\\"i\\\"),ib=/^\\\\s+/,jb=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/gi,kb=/<([\\\\w:]+)/,lb=/<tbody/i,mb=/<|&#?\\\\w+;/,nb=/<(?:script|style|link)/i,ob=/checked\\\\s*(?:[^=]|=\\\\s*.checked.)/i,pb=/^$|\\\\/(?:java|ecma)script/i,qb=/^true\\\\/(.*)/,rb=/^\\\\s*<!(?:\\\\[CDATA\\\\[|--)|(?:\\\\]\\\\]|--)>\\\\s*$/g,sb={option:[1,\\\"<select multiple='multiple'>\\\",\\\"</select>\\\"],legend:[1,\\\"<fieldset>\\\",\\\"</fieldset>\\\"],area:[1,\\\"<map>\\\",\\\"</map>\\\"],param:[1,\\\"<object>\\\",\\\"</object>\\\"],thead:[1,\\\"<table>\\\",\\\"</table>\\\"],tr:[2,\\\"<table><tbody>\\\",\\\"</tbody></table>\\\"],col:[2,\\\"<table><tbody></tbody><colgroup>\\\",\\\"</colgroup></table>\\\"],td:[3,\\\"<table><tbody><tr>\\\",\\\"</tr></tbody></table>\\\"],_default:l.htmlSerialize?[0,\\\"\\\",\\\"\\\"]:[1,\\\"X<div>\\\",\\\"</div>\\\"]},tb=eb(z),ub=tb.appendChild(z.createElement(\\\"div\\\"));sb.optgroup=sb.option,sb.tbody=sb.tfoot=sb.colgroup=sb.caption=sb.thead,sb.th=sb.td;function vb(a,b){var c,d,e=0,f=typeof a.getElementsByTagName!==L?a.getElementsByTagName(b||\\\"*\\\"):typeof a.querySelectorAll!==L?a.querySelectorAll(b||\\\"*\\\"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,vb(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function wb(a){X.test(a.type)&&(a.defaultChecked=a.checked)}function xb(a,b){return n.nodeName(a,\\\"table\\\")&&n.nodeName(11!==b.nodeType?b:b.firstChild,\\\"tr\\\")?a.getElementsByTagName(\\\"tbody\\\")[0]||a.appendChild(a.ownerDocument.createElement(\\\"tbody\\\")):a}function yb(a){return a.type=(null!==n.find.attr(a,\\\"type\\\"))+\\\"/\\\"+a.type,a}function zb(a){var b=qb.exec(a.type);return b?a.type=b[1]:a.removeAttribute(\\\"type\\\"),a}function Ab(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,\\\"globalEval\\\",!b||n._data(b[d],\\\"globalEval\\\"))}function Bb(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Cb(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}\\\"script\\\"===c&&b.text!==a.text?(yb(b).text=a.text,zb(b)):\\\"object\\\"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):\\\"input\\\"===c&&X.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):\\\"option\\\"===c?b.defaultSelected=b.selected=a.defaultSelected:(\\\"input\\\"===c||\\\"textarea\\\"===c)&&(b.defaultValue=a.defaultValue)}}n.extend({clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!hb.test(\\\"<\\\"+a.nodeName+\\\">\\\")?f=a.cloneNode(!0):(ub.innerHTML=a.outerHTML,ub.removeChild(f=ub.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=vb(f),h=vb(a),g=0;null!=(e=h[g]);++g)d[g]&&Cb(e,d[g]);if(b)if(c)for(h=h||vb(a),d=d||vb(f),g=0;null!=(e=h[g]);g++)Bb(e,d[g]);else Bb(a,f);return d=vb(f,\\\"script\\\"),d.length>0&&Ab(d,!i&&vb(a,\\\"script\\\")),d=h=e=null,f},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k,m=a.length,o=eb(b),p=[],q=0;m>q;q++)if(f=a[q],f||0===f)if(\\\"object\\\"===n.type(f))n.merge(p,f.nodeType?[f]:f);else if(mb.test(f)){h=h||o.appendChild(b.createElement(\\\"div\\\")),i=(kb.exec(f)||[\\\"\\\",\\\"\\\"])[1].toLowerCase(),k=sb[i]||sb._default,h.innerHTML=k[1]+f.replace(jb,\\\"<$1></$2>\\\")+k[2],e=k[0];while(e--)h=h.lastChild;if(!l.leadingWhitespace&&ib.test(f)&&p.push(b.createTextNode(ib.exec(f)[0])),!l.tbody){f=\\\"table\\\"!==i||lb.test(f)?\\\"<table>\\\"!==k[1]||lb.test(f)?0:h:h.firstChild,e=f&&f.childNodes.length;while(e--)n.nodeName(j=f.childNodes[e],\\\"tbody\\\")&&!j.childNodes.length&&f.removeChild(j)}n.merge(p,h.childNodes),h.textContent=\\\"\\\";while(h.firstChild)h.removeChild(h.firstChild);h=o.lastChild}else p.push(b.createTextNode(f));h&&o.removeChild(h),l.appendChecked||n.grep(vb(p,\\\"input\\\"),wb),q=0;while(f=p[q++])if((!d||-1===n.inArray(f,d))&&(g=n.contains(f.ownerDocument,f),h=vb(o.appendChild(f),\\\"script\\\"),g&&Ab(h),c)){e=0;while(f=h[e++])pb.test(f.type||\\\"\\\")&&c.push(f)}return h=null,o},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.deleteExpando,m=n.event.special;null!=(d=a[h]);h++)if((b||n.acceptData(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k?delete d[i]:typeof d.removeAttribute!==L?d.removeAttribute(i):d[i]=null,c.push(f))}}}),n.fn.extend({text:function(a){return W(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||z).createTextNode(a))},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=xb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(vb(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&Ab(vb(c,\\\"script\\\")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(vb(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,\\\"select\\\")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return W(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(gb,\\\"\\\"):void 0;if(!(\\\"string\\\"!=typeof a||nb.test(a)||!l.htmlSerialize&&hb.test(a)||!l.leadingWhitespace&&ib.test(a)||sb[(kb.exec(a)||[\\\"\\\",\\\"\\\"])[1].toLowerCase()])){a=a.replace(jb,\\\"<$1></$2>\\\");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(vb(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(vb(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,k=this.length,m=this,o=k-1,p=a[0],q=n.isFunction(p);if(q||k>1&&\\\"string\\\"==typeof p&&!l.checkClone&&ob.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(k&&(i=n.buildFragment(a,this[0].ownerDocument,!1,this),c=i.firstChild,1===i.childNodes.length&&(i=c),c)){for(g=n.map(vb(i,\\\"script\\\"),yb),f=g.length;k>j;j++)d=i,j!==o&&(d=n.clone(d,!0,!0),f&&n.merge(g,vb(d,\\\"script\\\"))),b.call(this[j],d,j);if(f)for(h=g[g.length-1].ownerDocument,n.map(g,zb),j=0;f>j;j++)d=g[j],pb.test(d.type||\\\"\\\")&&!n._data(d,\\\"globalEval\\\")&&n.contains(h,d)&&(d.src?n._evalUrl&&n._evalUrl(d.src):n.globalEval((d.text||d.textContent||d.innerHTML||\\\"\\\").replace(rb,\\\"\\\")));i=c=null}return this}}),n.each({appendTo:\\\"append\\\",prependTo:\\\"prepend\\\",insertBefore:\\\"before\\\",insertAfter:\\\"after\\\",replaceAll:\\\"replaceWith\\\"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],g=n(a),h=g.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(g[d])[b](c),f.apply(e,c.get());return this.pushStack(e)}});var Db,Eb={};function Fb(b,c){var d=n(c.createElement(b)).appendTo(c.body),e=a.getDefaultComputedStyle?a.getDefaultComputedStyle(d[0]).display:n.css(d[0],\\\"display\\\");return d.detach(),e}function Gb(a){var b=z,c=Eb[a];return c||(c=Fb(a,b),\\\"none\\\"!==c&&c||(Db=(Db||n(\\\"<iframe frameborder='0' width='0' height='0'/>\\\")).appendTo(b.documentElement),b=(Db[0].contentWindow||Db[0].contentDocument).document,b.write(),b.close(),c=Fb(a,b),Db.detach()),Eb[a]=c),c}!function(){var a,b,c=z.createElement(\\\"div\\\"),d=\\\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0\\\";c.innerHTML=\\\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\\\",a=c.getElementsByTagName(\\\"a\\\")[0],a.style.cssText=\\\"float:left;opacity:.5\\\",l.opacity=/^0.5/.test(a.style.opacity),l.cssFloat=!!a.style.cssFloat,c.style.backgroundClip=\\\"content-box\\\",c.cloneNode(!0).style.backgroundClip=\\\"\\\",l.clearCloneStyle=\\\"content-box\\\"===c.style.backgroundClip,a=c=null,l.shrinkWrapBlocks=function(){var a,c,e,f;if(null==b){if(a=z.getElementsByTagName(\\\"body\\\")[0],!a)return;f=\\\"border:0;width:0;height:0;position:absolute;top:0;left:-9999px\\\",c=z.createElement(\\\"div\\\"),e=z.createElement(\\\"div\\\"),a.appendChild(c).appendChild(e),b=!1,typeof e.style.zoom!==L&&(e.style.cssText=d+\\\";width:1px;padding:1px;zoom:1\\\",e.innerHTML=\\\"<div></div>\\\",e.firstChild.style.width=\\\"5px\\\",b=3!==e.offsetWidth),a.removeChild(c),a=c=e=null}return b}}();var Hb=/^margin/,Ib=new RegExp(\\\"^(\\\"+T+\\\")(?!px)[a-z%]+$\\\",\\\"i\\\"),Jb,Kb,Lb=/^(top|right|bottom|left)$/;a.getComputedStyle?(Jb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(\\\"\\\"!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),Ib.test(g)&&Hb.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+\\\"\\\"}):z.documentElement.currentStyle&&(Jb=function(a){return a.currentStyle},Kb=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Jb(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Ib.test(g)&&!Lb.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left=\\\"fontSize\\\"===b?\\\"1em\\\":g,g=h.pixelLeft+\\\"px\\\",h.left=d,f&&(e.left=f)),void 0===g?g:g+\\\"\\\"||\\\"auto\\\"});function Mb(a,b){return{get:function(){var c=a();if(null!=c)return c?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d,e,f,g,h=z.createElement(\\\"div\\\"),i=\\\"border:0;width:0;height:0;position:absolute;top:0;left:-9999px\\\",j=\\\"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;padding:0;margin:0;border:0\\\";h.innerHTML=\\\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\\\",b=h.getElementsByTagName(\\\"a\\\")[0],b.style.cssText=\\\"float:left;opacity:.5\\\",l.opacity=/^0.5/.test(b.style.opacity),l.cssFloat=!!b.style.cssFloat,h.style.backgroundClip=\\\"content-box\\\",h.cloneNode(!0).style.backgroundClip=\\\"\\\",l.clearCloneStyle=\\\"content-box\\\"===h.style.backgroundClip,b=h=null,n.extend(l,{reliableHiddenOffsets:function(){if(null!=c)return c;var a,b,d,e=z.createElement(\\\"div\\\"),f=z.getElementsByTagName(\\\"body\\\")[0];if(f)return e.setAttribute(\\\"className\\\",\\\"t\\\"),e.innerHTML=\\\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\\\",a=z.createElement(\\\"div\\\"),a.style.cssText=i,f.appendChild(a).appendChild(e),e.innerHTML=\\\"<table><tr><td></td><td>t</td></tr></table>\\\",b=e.getElementsByTagName(\\\"td\\\"),b[0].style.cssText=\\\"padding:0;margin:0;border:0;display:none\\\",d=0===b[0].offsetHeight,b[0].style.display=\\\"\\\",b[1].style.display=\\\"none\\\",c=d&&0===b[0].offsetHeight,f.removeChild(a),e=f=null,c},boxSizing:function(){return null==d&&k(),d},boxSizingReliable:function(){return null==e&&k(),e},pixelPosition:function(){return null==f&&k(),f},reliableMarginRight:function(){var b,c,d,e;if(null==g&&a.getComputedStyle){if(b=z.getElementsByTagName(\\\"body\\\")[0],!b)return;c=z.createElement(\\\"div\\\"),d=z.createElement(\\\"div\\\"),c.style.cssText=i,b.appendChild(c).appendChild(d),e=d.appendChild(z.createElement(\\\"div\\\")),e.style.cssText=d.style.cssText=j,e.style.marginRight=e.style.width=\\\"0\\\",d.style.width=\\\"1px\\\",g=!parseFloat((a.getComputedStyle(e,null)||{}).marginRight),b.removeChild(c)}return g}});function k(){var b,c,h=z.getElementsByTagName(\\\"body\\\")[0];h&&(b=z.createElement(\\\"div\\\"),c=z.createElement(\\\"div\\\"),b.style.cssText=i,h.appendChild(b).appendChild(c),c.style.cssText=\\\"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;display:block;padding:1px;border:1px;width:4px;margin-top:1%;top:1%\\\",n.swap(h,null!=h.style.zoom?{zoom:1}:{},function(){d=4===c.offsetWidth}),e=!0,f=!1,g=!0,a.getComputedStyle&&(f=\\\"1%\\\"!==(a.getComputedStyle(c,null)||{}).top,e=\\\"4px\\\"===(a.getComputedStyle(c,null)||{width:\\\"4px\\\"}).width),h.removeChild(b),c=h=null)}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var Nb=/alpha\\\\([^)]*\\\\)/i,Ob=/opacity\\\\s*=\\\\s*([^)]*)/,Pb=/^(none|table(?!-c[ea]).+)/,Qb=new RegExp(\\\"^(\\\"+T+\\\")(.*)$\\\",\\\"i\\\"),Rb=new RegExp(\\\"^([+-])=(\\\"+T+\\\")\\\",\\\"i\\\"),Sb={position:\\\"absolute\\\",visibility:\\\"hidden\\\",display:\\\"block\\\"},Tb={letterSpacing:0,fontWeight:400},Ub=[\\\"Webkit\\\",\\\"O\\\",\\\"Moz\\\",\\\"ms\\\"];function Vb(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=Ub.length;while(e--)if(b=Ub[e]+c,b in a)return b;return d}function Wb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,\\\"olddisplay\\\"),c=d.style.display,b?(f[g]||\\\"none\\\"!==c||(d.style.display=\\\"\\\"),\\\"\\\"===d.style.display&&V(d)&&(f[g]=n._data(d,\\\"olddisplay\\\",Gb(d.nodeName)))):f[g]||(e=V(d),(c&&\\\"none\\\"!==c||!e)&&n._data(d,\\\"olddisplay\\\",e?c:n.css(d,\\\"display\\\"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&\\\"none\\\"!==d.style.display&&\\\"\\\"!==d.style.display||(d.style.display=b?f[g]||\\\"\\\":\\\"none\\\"));return a}function Xb(a,b,c){var d=Qb.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||\\\"px\\\"):b}function Yb(a,b,c,d,e){for(var f=c===(d?\\\"border\\\":\\\"content\\\")?4:\\\"width\\\"===b?1:0,g=0;4>f;f+=2)\\\"margin\\\"===c&&(g+=n.css(a,c+U[f],!0,e)),d?(\\\"content\\\"===c&&(g-=n.css(a,\\\"padding\\\"+U[f],!0,e)),\\\"margin\\\"!==c&&(g-=n.css(a,\\\"border\\\"+U[f]+\\\"Width\\\",!0,e))):(g+=n.css(a,\\\"padding\\\"+U[f],!0,e),\\\"padding\\\"!==c&&(g+=n.css(a,\\\"border\\\"+U[f]+\\\"Width\\\",!0,e)));return g}function Zb(a,b,c){var d=!0,e=\\\"width\\\"===b?a.offsetWidth:a.offsetHeight,f=Jb(a),g=l.boxSizing()&&\\\"border-box\\\"===n.css(a,\\\"boxSizing\\\",!1,f);if(0>=e||null==e){if(e=Kb(a,b,f),(0>e||null==e)&&(e=a.style[b]),Ib.test(e))return e;d=g&&(l.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Yb(a,b,c||(g?\\\"border\\\":\\\"content\\\"),d,f)+\\\"px\\\"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Kb(a,\\\"opacity\\\");return\\\"\\\"===c?\\\"1\\\":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{\\\"float\\\":l.cssFloat?\\\"cssFloat\\\":\\\"styleFloat\\\"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=Vb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&\\\"get\\\"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,\\\"string\\\"===f&&(e=Rb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f=\\\"number\\\"),null!=c&&c===c&&(\\\"number\\\"!==f||n.cssNumber[h]||(c+=\\\"px\\\"),l.clearCloneStyle||\\\"\\\"!==c||0!==b.indexOf(\\\"background\\\")||(i[b]=\\\"inherit\\\"),!(g&&\\\"set\\\"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=\\\"\\\",i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Vb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&\\\"get\\\"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Kb(a,b,d)),\\\"normal\\\"===f&&b in Tb&&(f=Tb[b]),\\\"\\\"===c||c?(e=parseFloat(f),c===!0||n.isNumeric(e)?e||0:f):f}}),n.each([\\\"height\\\",\\\"width\\\"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?0===a.offsetWidth&&Pb.test(n.css(a,\\\"display\\\"))?n.swap(a,Sb,function(){return Zb(a,b,d)}):Zb(a,b,d):void 0},set:function(a,c,d){var e=d&&Jb(a);return Xb(a,c,d?Yb(a,b,d,l.boxSizing()&&\\\"border-box\\\"===n.css(a,\\\"boxSizing\\\",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Ob.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||\\\"\\\")?.01*parseFloat(RegExp.$1)+\\\"\\\":b?\\\"1\\\":\\\"\\\"},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?\\\"alpha(opacity=\\\"+100*b+\\\")\\\":\\\"\\\",f=d&&d.filter||c.filter||\\\"\\\";c.zoom=1,(b>=1||\\\"\\\"===b)&&\\\"\\\"===n.trim(f.replace(Nb,\\\"\\\"))&&c.removeAttribute&&(c.removeAttribute(\\\"filter\\\"),\\\"\\\"===b||d&&!d.filter)||(c.filter=Nb.test(f)?f.replace(Nb,e):f+\\\" \\\"+e)}}),n.cssHooks.marginRight=Mb(l.reliableMarginRight,function(a,b){return b?n.swap(a,{display:\\\"inline-block\\\"},Kb,[a,\\\"marginRight\\\"]):void 0}),n.each({margin:\\\"\\\",padding:\\\"\\\",border:\\\"Width\\\"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f=\\\"string\\\"==typeof c?c.split(\\\" \\\"):[c];4>d;d++)e[a+U[d]+b]=f[d]||f[d-2]||f[0];return e}},Hb.test(a)||(n.cssHooks[a+b].set=Xb)}),n.fn.extend({css:function(a,b){return W(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Jb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)\\n},a,b,arguments.length>1)},show:function(){return Wb(this,!0)},hide:function(){return Wb(this)},toggle:function(a){return\\\"boolean\\\"==typeof a?a?this.show():this.hide():this.each(function(){V(this)?n(this).show():n(this).hide()})}});function $b(a,b,c,d,e){return new $b.prototype.init(a,b,c,d,e)}n.Tween=$b,$b.prototype={constructor:$b,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||\\\"swing\\\",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?\\\"\\\":\\\"px\\\")},cur:function(){var a=$b.propHooks[this.prop];return a&&a.get?a.get(this):$b.propHooks._default.get(this)},run:function(a){var b,c=$b.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):$b.propHooks._default.set(this),this}},$b.prototype.init.prototype=$b.prototype,$b.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,\\\"\\\"),b&&\\\"auto\\\"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},$b.propHooks.scrollTop=$b.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=$b.prototype.init,n.fx.step={};var _b,ac,bc=/^(?:toggle|show|hide)$/,cc=new RegExp(\\\"^(?:([+-])=|)(\\\"+T+\\\")([a-z%]*)$\\\",\\\"i\\\"),dc=/queueHooks$/,ec=[jc],fc={\\\"*\\\":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=cc.exec(b),f=e&&e[3]||(n.cssNumber[a]?\\\"\\\":\\\"px\\\"),g=(n.cssNumber[a]||\\\"px\\\"!==f&&+d)&&cc.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||\\\".5\\\",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function gc(){return setTimeout(function(){_b=void 0}),_b=n.now()}function hc(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=U[e],d[\\\"margin\\\"+c]=d[\\\"padding\\\"+c]=a;return b&&(d.opacity=d.width=a),d}function ic(a,b,c){for(var d,e=(fc[b]||[]).concat(fc[\\\"*\\\"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function jc(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&V(a),r=n._data(a,\\\"fxshow\\\");c.queue||(h=n._queueHooks(a,\\\"fx\\\"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,\\\"fx\\\").length||h.empty.fire()})})),1===a.nodeType&&(\\\"height\\\"in b||\\\"width\\\"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,\\\"display\\\"),k=Gb(a.nodeName),\\\"none\\\"===j&&(j=k),\\\"inline\\\"===j&&\\\"none\\\"===n.css(a,\\\"float\\\")&&(l.inlineBlockNeedsLayout&&\\\"inline\\\"!==k?p.zoom=1:p.display=\\\"inline-block\\\")),c.overflow&&(p.overflow=\\\"hidden\\\",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],bc.exec(e)){if(delete b[d],f=f||\\\"toggle\\\"===e,e===(q?\\\"hide\\\":\\\"show\\\")){if(\\\"show\\\"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}if(!n.isEmptyObject(o)){r?\\\"hidden\\\"in r&&(q=r.hidden):r=n._data(a,\\\"fxshow\\\",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,\\\"fxshow\\\");for(b in o)n.style(a,b,o[b])});for(d in o)g=ic(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start=\\\"width\\\"===d||\\\"height\\\"===d?1:0))}}function kc(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&\\\"expand\\\"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function lc(a,b,c){var d,e,f=0,g=ec.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=_b||gc(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:_b||gc(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(kc(k,j.opts.specialEasing);g>f;f++)if(d=ec[f].call(j,a,k,j.opts))return d;return n.map(k,ic,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(lc,{tweener:function(a,b){n.isFunction(a)?(b=a,a=[\\\"*\\\"]):a=a.split(\\\" \\\");for(var c,d=0,e=a.length;e>d;d++)c=a[d],fc[c]=fc[c]||[],fc[c].unshift(b)},prefilter:function(a,b){b?ec.unshift(a):ec.push(a)}}),n.speed=function(a,b,c){var d=a&&\\\"object\\\"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:\\\"number\\\"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue=\\\"fx\\\"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(V).css(\\\"opacity\\\",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=lc(this,n.extend({},a),f);(e||n._data(this,\\\"finish\\\"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return\\\"string\\\"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||\\\"fx\\\",[]),this.each(function(){var b=!0,e=null!=a&&a+\\\"queueHooks\\\",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&dc.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||\\\"fx\\\"),this.each(function(){var b,c=n._data(this),d=c[a+\\\"queue\\\"],e=c[a+\\\"queueHooks\\\"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each([\\\"toggle\\\",\\\"show\\\",\\\"hide\\\"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||\\\"boolean\\\"==typeof a?c.apply(this,arguments):this.animate(hc(b,!0),a,d,e)}}),n.each({slideDown:hc(\\\"show\\\"),slideUp:hc(\\\"hide\\\"),slideToggle:hc(\\\"toggle\\\"),fadeIn:{opacity:\\\"show\\\"},fadeOut:{opacity:\\\"hide\\\"},fadeToggle:{opacity:\\\"toggle\\\"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(_b=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),_b=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ac||(ac=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(ac),ac=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||\\\"fx\\\",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a,b,c,d,e=z.createElement(\\\"div\\\");e.setAttribute(\\\"className\\\",\\\"t\\\"),e.innerHTML=\\\"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\\\",a=e.getElementsByTagName(\\\"a\\\")[0],c=z.createElement(\\\"select\\\"),d=c.appendChild(z.createElement(\\\"option\\\")),b=e.getElementsByTagName(\\\"input\\\")[0],a.style.cssText=\\\"top:1px\\\",l.getSetAttribute=\\\"t\\\"!==e.className,l.style=/top/.test(a.getAttribute(\\\"style\\\")),l.hrefNormalized=\\\"/a\\\"===a.getAttribute(\\\"href\\\"),l.checkOn=!!b.value,l.optSelected=d.selected,l.enctype=!!z.createElement(\\\"form\\\").enctype,c.disabled=!0,l.optDisabled=!d.disabled,b=z.createElement(\\\"input\\\"),b.setAttribute(\\\"value\\\",\\\"\\\"),l.input=\\\"\\\"===b.getAttribute(\\\"value\\\"),b.value=\\\"t\\\",b.setAttribute(\\\"type\\\",\\\"radio\\\"),l.radioValue=\\\"t\\\"===b.value,a=b=c=d=e=null}();var mc=/\\\\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e=\\\"\\\":\\\"number\\\"==typeof e?e+=\\\"\\\":n.isArray(e)&&(e=n.map(e,function(a){return null==a?\\\"\\\":a+\\\"\\\"})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&\\\"set\\\"in b&&void 0!==b.set(this,e,\\\"value\\\")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&\\\"get\\\"in b&&void 0!==(c=b.get(e,\\\"value\\\"))?c:(c=e.value,\\\"string\\\"==typeof c?c.replace(mc,\\\"\\\"):null==c?\\\"\\\":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,\\\"value\\\");return null!=b?b:n.text(a)}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f=\\\"select-one\\\"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(l.optDisabled?c.disabled:null!==c.getAttribute(\\\"disabled\\\"))||c.parentNode.disabled&&n.nodeName(c.parentNode,\\\"optgroup\\\"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each([\\\"radio\\\",\\\"checkbox\\\"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute(\\\"value\\\")?\\\"on\\\":a.value})});var nc,oc,pc=n.expr.attrHandle,qc=/^(?:checked|selected)$/i,rc=l.getSetAttribute,sc=l.input;n.fn.extend({attr:function(a,b){return W(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===L?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?oc:nc)),void 0===c?d&&\\\"get\\\"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&\\\"set\\\"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+\\\"\\\"),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(F);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?sc&&rc||!qc.test(c)?a[d]=!1:a[n.camelCase(\\\"default-\\\"+c)]=a[d]=!1:n.attr(a,c,\\\"\\\"),a.removeAttribute(rc?c:d)},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&\\\"radio\\\"===b&&n.nodeName(a,\\\"input\\\")){var c=a.value;return a.setAttribute(\\\"type\\\",b),c&&(a.value=c),b}}}}}),oc={set:function(a,b,c){return b===!1?n.removeAttr(a,c):sc&&rc||!qc.test(c)?a.setAttribute(!rc&&n.propFix[c]||c,c):a[n.camelCase(\\\"default-\\\"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\\\\w+/g),function(a,b){var c=pc[b]||n.find.attr;pc[b]=sc&&rc||!qc.test(b)?function(a,b,d){var e,f;return d||(f=pc[b],pc[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,pc[b]=f),e}:function(a,b,c){return c?void 0:a[n.camelCase(\\\"default-\\\"+b)]?b.toLowerCase():null}}),sc&&rc||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,\\\"input\\\")?void(a.defaultValue=b):nc&&nc.set(a,b,c)}}),rc||(nc={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+=\\\"\\\",\\\"value\\\"===c||b===a.getAttribute(c)?b:void 0}},pc.id=pc.name=pc.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&\\\"\\\"!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:nc.set},n.attrHooks.contenteditable={set:function(a,b,c){nc.set(a,\\\"\\\"===b?!1:b,c)}},n.each([\\\"width\\\",\\\"height\\\"],function(a,b){n.attrHooks[b]={set:function(a,c){return\\\"\\\"===c?(a.setAttribute(b,\\\"auto\\\"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+\\\"\\\"}});var tc=/^(?:input|select|textarea|button|object)$/i,uc=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return W(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({propFix:{\\\"for\\\":\\\"htmlFor\\\",\\\"class\\\":\\\"className\\\"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&\\\"set\\\"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&\\\"get\\\"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,\\\"tabindex\\\");return b?parseInt(b,10):tc.test(a.nodeName)||uc.test(a.nodeName)&&a.href?0:-1}}}}),l.hrefNormalized||n.each([\\\"href\\\",\\\"src\\\"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),n.each([\\\"tabIndex\\\",\\\"readOnly\\\",\\\"maxLength\\\",\\\"cellSpacing\\\",\\\"cellPadding\\\",\\\"rowSpan\\\",\\\"colSpan\\\",\\\"useMap\\\",\\\"frameBorder\\\",\\\"contentEditable\\\"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype=\\\"encoding\\\");var vc=/[\\\\t\\\\r\\\\n\\\\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=\\\"string\\\"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(j)for(b=(a||\\\"\\\").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(\\\" \\\"+c.className+\\\" \\\").replace(vc,\\\" \\\"):\\\" \\\")){f=0;while(e=b[f++])d.indexOf(\\\" \\\"+e+\\\" \\\")<0&&(d+=e+\\\" \\\");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0,i=this.length,j=0===arguments.length||\\\"string\\\"==typeof a&&a;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(j)for(b=(a||\\\"\\\").match(F)||[];i>h;h++)if(c=this[h],d=1===c.nodeType&&(c.className?(\\\" \\\"+c.className+\\\" \\\").replace(vc,\\\" \\\"):\\\"\\\")){f=0;while(e=b[f++])while(d.indexOf(\\\" \\\"+e+\\\" \\\")>=0)d=d.replace(\\\" \\\"+e+\\\" \\\",\\\" \\\");g=a?n.trim(d):\\\"\\\",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return\\\"boolean\\\"==typeof b&&\\\"string\\\"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if(\\\"string\\\"===c){var b,d=0,e=n(this),f=a.match(F)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===L||\\\"boolean\\\"===c)&&(this.className&&n._data(this,\\\"__className__\\\",this.className),this.className=this.className||a===!1?\\\"\\\":n._data(this,\\\"__className__\\\")||\\\"\\\")})},hasClass:function(a){for(var b=\\\" \\\"+a+\\\" \\\",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(\\\" \\\"+this[c].className+\\\" \\\").replace(vc,\\\" \\\").indexOf(b)>=0)return!0;return!1}}),n.each(\\\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\\\".split(\\\" \\\"),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,\\\"**\\\"):this.off(b,a||\\\"**\\\",c)}});var wc=n.now(),xc=/\\\\?/,yc=/(,)|(\\\\[|{)|(}|])|\\\"(?:[^\\\"\\\\\\\\\\\\r\\\\n]|\\\\\\\\[\\\"\\\\\\\\\\\\/bfnrt]|\\\\\\\\u[\\\\da-fA-F]{4})*\\\"\\\\s*:?|true|false|null|-?(?!0\\\\d)\\\\d+(?:\\\\.\\\\d+|)(?:[eE][+-]?\\\\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+\\\"\\\");var c,d=null,e=n.trim(b+\\\"\\\");return e&&!n.trim(e.replace(yc,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,\\\"\\\")}))?Function(\\\"return \\\"+e)():n.error(\\\"Invalid JSON: \\\"+b)},n.parseXML=function(b){var c,d;if(!b||\\\"string\\\"!=typeof b)return null;try{a.DOMParser?(d=new DOMParser,c=d.parseFromString(b,\\\"text/xml\\\")):(c=new ActiveXObject(\\\"Microsoft.XMLDOM\\\"),c.async=\\\"false\\\",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName(\\\"parsererror\\\").length||n.error(\\\"Invalid XML: \\\"+b),c};var zc,Ac,Bc=/#.*$/,Cc=/([?&])_=[^&]*/,Dc=/^(.*?):[ \\\\t]*([^\\\\r\\\\n]*)\\\\r?$/gm,Ec=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Fc=/^(?:GET|HEAD)$/,Gc=/^\\\\/\\\\//,Hc=/^([\\\\w.+-]+:)(?:\\\\/\\\\/(?:[^\\\\/?#]*@|)([^\\\\/?#:]*)(?::(\\\\d+)|)|)/,Ic={},Jc={},Kc=\\\"*/\\\".concat(\\\"*\\\");try{Ac=location.href}catch(Lc){Ac=z.createElement(\\\"a\\\"),Ac.href=\\\"\\\",Ac=Ac.href}zc=Hc.exec(Ac.toLowerCase())||[];function Mc(a){return function(b,c){\\\"string\\\"!=typeof b&&(c=b,b=\\\"*\\\");var d,e=0,f=b.toLowerCase().match(F)||[];if(n.isFunction(c))while(d=f[e++])\\\"+\\\"===d.charAt(0)?(d=d.slice(1)||\\\"*\\\",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nc(a,b,c,d){var e={},f=a===Jc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return\\\"string\\\"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e[\\\"*\\\"]&&g(\\\"*\\\")}function Oc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Pc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while(\\\"*\\\"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader(\\\"Content-Type\\\"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+\\\" \\\"+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Qc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if(\\\"*\\\"===f)f=i;else if(\\\"*\\\"!==i&&i!==f){if(g=j[i+\\\" \\\"+f]||j[\\\"* \\\"+f],!g)for(e in j)if(h=e.split(\\\" \\\"),h[1]===f&&(g=j[i+\\\" \\\"+h[0]]||j[\\\"* \\\"+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a[\\\"throws\\\"])b=g(b);else try{b=g(b)}catch(l){return{state:\\\"parsererror\\\",error:g?l:\\\"No conversion from \\\"+i+\\\" to \\\"+f}}}return{state:\\\"success\\\",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Ac,type:\\\"GET\\\",isLocal:Ec.test(zc[1]),global:!0,processData:!0,async:!0,contentType:\\\"application/x-www-form-urlencoded; charset=UTF-8\\\",accepts:{\\\"*\\\":Kc,text:\\\"text/plain\\\",html:\\\"text/html\\\",xml:\\\"application/xml, text/xml\\\",json:\\\"application/json, text/javascript\\\"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:\\\"responseXML\\\",text:\\\"responseText\\\",json:\\\"responseJSON\\\"},converters:{\\\"* text\\\":String,\\\"text html\\\":!0,\\\"text json\\\":n.parseJSON,\\\"text xml\\\":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Oc(Oc(a,n.ajaxSettings),b):Oc(n.ajaxSettings,a)},ajaxPrefilter:Mc(Ic),ajaxTransport:Mc(Jc),ajax:function(a,b){\\\"object\\\"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks(\\\"once memory\\\"),q=k.statusCode||{},r={},s={},t=0,u=\\\"canceled\\\",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!j){j={};while(b=Dc.exec(f))j[b[1].toLowerCase()]=b[2]}b=j[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?f:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return i&&i.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||Ac)+\\\"\\\").replace(Bc,\\\"\\\").replace(Gc,zc[1]+\\\"//\\\"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||\\\"*\\\").toLowerCase().match(F)||[\\\"\\\"],null==k.crossDomain&&(c=Hc.exec(k.url.toLowerCase()),k.crossDomain=!(!c||c[1]===zc[1]&&c[2]===zc[2]&&(c[3]||(\\\"http:\\\"===c[1]?\\\"80\\\":\\\"443\\\"))===(zc[3]||(\\\"http:\\\"===zc[1]?\\\"80\\\":\\\"443\\\")))),k.data&&k.processData&&\\\"string\\\"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),Nc(Ic,k,b,v),2===t)return v;h=k.global,h&&0===n.active++&&n.event.trigger(\\\"ajaxStart\\\"),k.type=k.type.toUpperCase(),k.hasContent=!Fc.test(k.type),e=k.url,k.hasContent||(k.data&&(e=k.url+=(xc.test(e)?\\\"&\\\":\\\"?\\\")+k.data,delete k.data),k.cache===!1&&(k.url=Cc.test(e)?e.replace(Cc,\\\"$1_=\\\"+wc++):e+(xc.test(e)?\\\"&\\\":\\\"?\\\")+\\\"_=\\\"+wc++)),k.ifModified&&(n.lastModified[e]&&v.setRequestHeader(\\\"If-Modified-Since\\\",n.lastModified[e]),n.etag[e]&&v.setRequestHeader(\\\"If-None-Match\\\",n.etag[e])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader(\\\"Content-Type\\\",k.contentType),v.setRequestHeader(\\\"Accept\\\",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+(\\\"*\\\"!==k.dataTypes[0]?\\\", \\\"+Kc+\\\"; q=0.01\\\":\\\"\\\"):k.accepts[\\\"*\\\"]);for(d in k.headers)v.setRequestHeader(d,k.headers[d]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u=\\\"abort\\\";for(d in{success:1,error:1,complete:1})v[d](k[d]);if(i=Nc(Jc,k,b,v)){v.readyState=1,h&&m.trigger(\\\"ajaxSend\\\",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort(\\\"timeout\\\")},k.timeout));try{t=1,i.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,\\\"No Transport\\\");function x(a,b,c,d){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),i=void 0,f=d||\\\"\\\",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,c&&(u=Pc(k,v,c)),u=Qc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader(\\\"Last-Modified\\\"),w&&(n.lastModified[e]=w),w=v.getResponseHeader(\\\"etag\\\"),w&&(n.etag[e]=w)),204===a||\\\"HEAD\\\"===k.type?x=\\\"nocontent\\\":304===a?x=\\\"notmodified\\\":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x=\\\"error\\\",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+\\\"\\\",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,h&&m.trigger(j?\\\"ajaxSuccess\\\":\\\"ajaxError\\\",[v,k,j?r:s]),p.fireWith(l,[v,x]),h&&(m.trigger(\\\"ajaxComplete\\\",[v,k]),--n.active||n.event.trigger(\\\"ajaxStop\\\")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,\\\"json\\\")},getScript:function(a,b){return n.get(a,void 0,b,\\\"script\\\")}}),n.each([\\\"get\\\",\\\"post\\\"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each([\\\"ajaxStart\\\",\\\"ajaxStop\\\",\\\"ajaxComplete\\\",\\\"ajaxError\\\",\\\"ajaxSuccess\\\",\\\"ajaxSend\\\"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:\\\"GET\\\",dataType:\\\"script\\\",async:!1,global:!1,\\\"throws\\\":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,\\\"body\\\")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0||!l.reliableHiddenOffsets()&&\\\"none\\\"===(a.style&&a.style.display||n.css(a,\\\"display\\\"))},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var Rc=/%20/g,Sc=/\\\\[\\\\]$/,Tc=/\\\\r?\\\\n/g,Uc=/^(?:submit|button|image|reset|file)$/i,Vc=/^(?:input|select|textarea|keygen)/i;function Wc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||Sc.test(a)?d(a,e):Wc(a+\\\"[\\\"+(\\\"object\\\"==typeof e?b:\\\"\\\")+\\\"]\\\",e,c,d)});else if(c||\\\"object\\\"!==n.type(b))d(a,b);else for(e in b)Wc(a+\\\"[\\\"+e+\\\"]\\\",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?\\\"\\\":b,d[d.length]=encodeURIComponent(a)+\\\"=\\\"+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Wc(c,a[c],b,e);return d.join(\\\"&\\\").replace(Rc,\\\"+\\\")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,\\\"elements\\\");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(\\\":disabled\\\")&&Vc.test(this.nodeName)&&!Uc.test(a)&&(this.checked||!X.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(Tc,\\\"\\\\r\\\\n\\\")}}):{name:b.name,value:c.replace(Tc,\\\"\\\\r\\\\n\\\")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return!this.isLocal&&/^(get|post|head|put|delete|options)$/i.test(this.type)&&$c()||_c()}:$c;var Xc=0,Yc={},Zc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on(\\\"unload\\\",function(){for(var a in Yc)Yc[a](void 0,!0)}),l.cors=!!Zc&&\\\"withCredentials\\\"in Zc,Zc=l.ajax=!!Zc,Zc&&n.ajaxTransport(function(a){if(!a.crossDomain||l.cors){var b;return{send:function(c,d){var e,f=a.xhr(),g=++Xc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c[\\\"X-Requested-With\\\"]||(c[\\\"X-Requested-With\\\"]=\\\"XMLHttpRequest\\\");for(e in c)void 0!==c[e]&&f.setRequestHeader(e,c[e]+\\\"\\\");f.send(a.hasContent&&a.data||null),b=function(c,e){var h,i,j;if(b&&(e||4===f.readyState))if(delete Yc[g],b=void 0,f.onreadystatechange=n.noop,e)4!==f.readyState&&f.abort();else{j={},h=f.status,\\\"string\\\"==typeof f.responseText&&(j.text=f.responseText);try{i=f.statusText}catch(k){i=\\\"\\\"}h||!a.isLocal||a.crossDomain?1223===h&&(h=204):h=j.text?200:404}j&&d(h,i,j,f.getAllResponseHeaders())},a.async?4===f.readyState?setTimeout(b):f.onreadystatechange=Yc[g]=b:b()},abort:function(){b&&b(void 0,!0)}}}});function $c(){try{return new a.XMLHttpRequest}catch(b){}}function _c(){try{return new a.ActiveXObject(\\\"Microsoft.XMLHTTP\\\")}catch(b){}}n.ajaxSetup({accepts:{script:\\\"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\\\"},contents:{script:/(?:java|ecma)script/},converters:{\\\"text script\\\":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter(\\\"script\\\",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type=\\\"GET\\\",a.global=!1)}),n.ajaxTransport(\\\"script\\\",function(a){if(a.crossDomain){var b,c=z.head||n(\\\"head\\\")[0]||z.documentElement;return{send:function(d,e){b=z.createElement(\\\"script\\\"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||e(200,\\\"success\\\"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var ad=[],bd=/(=)\\\\?(?=&|$)|\\\\?\\\\?/;n.ajaxSetup({jsonp:\\\"callback\\\",jsonpCallback:function(){var a=ad.pop()||n.expando+\\\"_\\\"+wc++;return this[a]=!0,a}}),n.ajaxPrefilter(\\\"json jsonp\\\",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(bd.test(b.url)?\\\"url\\\":\\\"string\\\"==typeof b.data&&!(b.contentType||\\\"\\\").indexOf(\\\"application/x-www-form-urlencoded\\\")&&bd.test(b.data)&&\\\"data\\\");return h||\\\"jsonp\\\"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(bd,\\\"$1\\\"+e):b.jsonp!==!1&&(b.url+=(xc.test(b.url)?\\\"&\\\":\\\"?\\\")+b.jsonp+\\\"=\\\"+e),b.converters[\\\"script json\\\"]=function(){return g||n.error(e+\\\" was not called\\\"),g[0]},b.dataTypes[0]=\\\"json\\\",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,ad.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),\\\"script\\\"):void 0}),n.parseHTML=function(a,b,c){if(!a||\\\"string\\\"!=typeof a)return null;\\\"boolean\\\"==typeof b&&(c=b,b=!1),b=b||z;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var cd=n.fn.load;n.fn.load=function(a,b,c){if(\\\"string\\\"!=typeof a&&cd)return cd.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(\\\" \\\");return h>=0&&(d=a.slice(h,a.length),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&\\\"object\\\"==typeof b&&(f=\\\"POST\\\"),g.length>0&&n.ajax({url:a,type:f,dataType:\\\"html\\\",data:b}).done(function(a){e=arguments,g.html(d?n(\\\"<div>\\\").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,e||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var dd=a.document.documentElement;function ed(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,\\\"position\\\"),l=n(a),m={};\\\"static\\\"===k&&(a.style.position=\\\"relative\\\"),h=l.offset(),f=n.css(a,\\\"top\\\"),i=n.css(a,\\\"left\\\"),j=(\\\"absolute\\\"===k||\\\"fixed\\\"===k)&&n.inArray(\\\"auto\\\",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),\\\"using\\\"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?(typeof e.getBoundingClientRect!==L&&(d=e.getBoundingClientRect()),c=ed(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return\\\"fixed\\\"===n.css(d,\\\"position\\\")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],\\\"html\\\")||(c=a.offset()),c.top+=n.css(a[0],\\\"borderTopWidth\\\",!0),c.left+=n.css(a[0],\\\"borderLeftWidth\\\",!0)),{top:b.top-c.top-n.css(d,\\\"marginTop\\\",!0),left:b.left-c.left-n.css(d,\\\"marginLeft\\\",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||dd;while(a&&!n.nodeName(a,\\\"html\\\")&&\\\"static\\\"===n.css(a,\\\"position\\\"))a=a.offsetParent;return a||dd})}}),n.each({scrollLeft:\\\"pageXOffset\\\",scrollTop:\\\"pageYOffset\\\"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return W(this,function(a,d,e){var f=ed(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each([\\\"top\\\",\\\"left\\\"],function(a,b){n.cssHooks[b]=Mb(l.pixelPosition,function(a,c){return c?(c=Kb(a,b),Ib.test(c)?n(a).position()[b]+\\\"px\\\":c):void 0})}),n.each({Height:\\\"height\\\",Width:\\\"width\\\"},function(a,b){n.each({padding:\\\"inner\\\"+a,content:b,\\\"\\\":\\\"outer\\\"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||\\\"boolean\\\"!=typeof d),g=c||(d===!0||e===!0?\\\"margin\\\":\\\"border\\\");return W(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement[\\\"client\\\"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body[\\\"scroll\\\"+a],e[\\\"scroll\\\"+a],b.body[\\\"offset\\\"+a],e[\\\"offset\\\"+a],e[\\\"client\\\"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,\\\"function\\\"==typeof define&&define.amd&&define(\\\"jquery\\\",[],function(){return n});var fd=a.jQuery,gd=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=gd),b&&a.jQuery===n&&(a.jQuery=fd),n},typeof b===L&&(a.jQuery=a.$=n),n});\\n\";","export default \"/**\\n * jQuery-csv (jQuery Plugin)\\n *\\n * This document is licensed as free software under the terms of the\\n * MIT License: http://www.opensource.org/licenses/mit-license.php\\n *\\n * Acknowledgements:\\n * The original design and influence to implement this library as a jquery\\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\\n * If you're looking to use native JSON.Stringify but want additional backwards\\n * compatibility for browsers that don't support it, I highly recommend you\\n * check it out.\\n *\\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\\n * feedback to the project including the core for the new FSM\\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\\n\\n * For legal purposes I'll include the \\\"NO WARRANTY EXPRESSED OR IMPLIED.\\n * USE AT YOUR OWN RISK.\\\". Which, in 'layman's terms' means, by using this\\n * library you are accepting responsibility if it breaks your code.\\n *\\n * Legal jargon aside, I will do my best to provide a useful and stable core\\n * that can effectively be built on.\\n *\\n * Copyrighted 2012 by Evan Plaice.\\n */\\n\\nRegExp.escape= function(s) {\\n    return s.replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g, '\\\\\\\\$&');\\n};\\n\\n(function (undefined) {\\n  'use strict';\\n\\n  var $;\\n\\n  // to keep backwards compatibility\\n  if (typeof jQuery !== 'undefined' && jQuery) {\\n    $ = jQuery;\\n  } else {\\n    $ = {};\\n  }\\n\\n\\n  /**\\n   * jQuery.csv.defaults\\n   * Encapsulates the method paramater defaults for the CSV plugin module.\\n   */\\n\\n  $.csv = {\\n    defaults: {\\n      separator:',',\\n      delimiter:'\\\"',\\n      headers:true\\n    },\\n\\n    hooks: {\\n      castToScalar: function(value, state) {\\n        var hasDot = /\\\\./;\\n        if (isNaN(value)) {\\n          return value;\\n        } else {\\n          if (hasDot.test(value)) {\\n            return parseFloat(value);\\n          } else {\\n            var integer = parseInt(value);\\n            if(isNaN(integer)) {\\n              return null;\\n            } else {\\n              return integer;\\n            }\\n          }\\n        }\\n      }\\n    },\\n\\n    parsers: {\\n      parse: function(csv, options) {\\n        // cache settings\\n        var separator = options.separator;\\n        var delimiter = options.delimiter;\\n\\n        // set initial state if it's missing\\n        if(!options.state.rowNum) {\\n          options.state.rowNum = 1;\\n        }\\n        if(!options.state.colNum) {\\n          options.state.colNum = 1;\\n        }\\n\\n        // clear initial state\\n        var data = [];\\n        var entry = [];\\n        var state = 0;\\n        var value = '';\\n        var exit = false;\\n\\n        function endOfEntry() {\\n          // reset the state\\n          state = 0;\\n          value = '';\\n\\n          // if 'start' hasn't been met, don't output\\n          if(options.start && options.state.rowNum < options.start) {\\n            // update global state\\n            entry = [];\\n            options.state.rowNum++;\\n            options.state.colNum = 1;\\n            return;\\n          }\\n          \\n          if(options.onParseEntry === undefined) {\\n            // onParseEntry hook not set\\n            data.push(entry);\\n          } else {\\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\\n            // false skips the row, configurable through a hook\\n            if(hookVal !== false) {\\n              data.push(hookVal);\\n            }\\n          }\\n          //console.log('entry:' + entry);\\n          \\n          // cleanup\\n          entry = [];\\n\\n          // if 'end' is met, stop parsing\\n          if(options.end && options.state.rowNum >= options.end) {\\n            exit = true;\\n          }\\n          \\n          // update global state\\n          options.state.rowNum++;\\n          options.state.colNum = 1;\\n        }\\n\\n        function endOfValue() {\\n          if(options.onParseValue === undefined) {\\n            // onParseValue hook not set\\n            entry.push(value);\\n          } else {\\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\\n            // false skips the row, configurable through a hook\\n            if(hook !== false) {\\n              entry.push(hook);\\n            }\\n          }\\n          //console.log('value:' + value);\\n          // reset the state\\n          value = '';\\n          state = 0;\\n          // update global state\\n          options.state.colNum++;\\n        }\\n\\n        // escape regex-specific control chars\\n        var escSeparator = RegExp.escape(separator);\\n        var escDelimiter = RegExp.escape(delimiter);\\n\\n        // compile the regEx str using the custom delimiter/separator\\n        var match = /(D|S|\\\\r\\\\n|\\\\n|\\\\r|[^DS\\\\r\\\\n]+)/;\\n        var matchSrc = match.source;\\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\\n        match = new RegExp(matchSrc, 'gm');\\n\\n        // put on your fancy pants...\\n        // process control chars individually, use look-ahead on non-control chars\\n        csv.replace(match, function (m0) {\\n          if(exit) {\\n            return;\\n          }\\n          switch (state) {\\n            // the start of a value\\n            case 0:\\n              // null last value\\n              if (m0 === separator) {\\n                value += '';\\n                endOfValue();\\n                break;\\n              }\\n              // opening delimiter\\n              if (m0 === delimiter) {\\n                state = 1;\\n                break;\\n              }\\n              // null last value\\n              if (/^(\\\\r\\\\n|\\\\n|\\\\r)$/.test(m0)) {\\n                endOfValue();\\n                endOfEntry();\\n                break;\\n              }\\n              // un-delimited value\\n              value += m0;\\n              state = 3;\\n              break;\\n\\n            // delimited input\\n            case 1:\\n              // second delimiter? check further\\n              if (m0 === delimiter) {\\n                state = 2;\\n                break;\\n              }\\n              // delimited data\\n              value += m0;\\n              state = 1;\\n              break;\\n\\n            // delimiter found in delimited input\\n            case 2:\\n              // escaped delimiter?\\n              if (m0 === delimiter) {\\n                value += m0;\\n                state = 1;\\n                break;\\n              }\\n              // null value\\n              if (m0 === separator) {\\n                endOfValue();\\n                break;\\n              }\\n              // end of entry\\n              if (/^(\\\\r\\\\n|\\\\n|\\\\r)$/.test(m0)) {\\n                endOfValue();\\n                endOfEntry();\\n                break;\\n              }\\n              // broken paser?\\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n\\n            // un-delimited input\\n            case 3:\\n              // null last value\\n              if (m0 === separator) {\\n                endOfValue();\\n                break;\\n              }\\n              // end of entry\\n              if (/^(\\\\r\\\\n|\\\\n|\\\\r)$/.test(m0)) {\\n                endOfValue();\\n                endOfEntry();\\n                break;\\n              }\\n              if (m0 === delimiter) {\\n              // non-compliant data\\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n              }\\n              // broken parser?\\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n            default:\\n              // shenanigans\\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n          }\\n          //console.log('val:' + m0 + ' state:' + state);\\n        });\\n\\n        // submit the last entry\\n        // ignore null last line\\n        if(entry.length !== 0) {\\n          endOfValue();\\n          endOfEntry();\\n        }\\n\\n        return data;\\n      },\\n\\n      // a csv-specific line splitter\\n      splitLines: function(csv, options) {\\n        // cache settings\\n        var separator = options.separator;\\n        var delimiter = options.delimiter;\\n\\n        // set initial state if it's missing\\n        if(!options.state.rowNum) {\\n          options.state.rowNum = 1;\\n        }\\n\\n        // clear initial state\\n        var entries = [];\\n        var state = 0;\\n        var entry = '';\\n        var exit = false;\\n\\n        function endOfLine() {          \\n          // reset the state\\n          state = 0;\\n          \\n          // if 'start' hasn't been met, don't output\\n          if(options.start && options.state.rowNum < options.start) {\\n            // update global state\\n            entry = '';\\n            options.state.rowNum++;\\n            return;\\n          }\\n          \\n          if(options.onParseEntry === undefined) {\\n            // onParseEntry hook not set\\n            entries.push(entry);\\n          } else {\\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\\n            // false skips the row, configurable through a hook\\n            if(hookVal !== false) {\\n              entries.push(hookVal);\\n            }\\n          }\\n\\n          // cleanup\\n          entry = '';\\n\\n          // if 'end' is met, stop parsing\\n          if(options.end && options.state.rowNum >= options.end) {\\n            exit = true;\\n          }\\n          \\n          // update global state\\n          options.state.rowNum++;\\n        }\\n\\n        // escape regex-specific control chars\\n        var escSeparator = RegExp.escape(separator);\\n        var escDelimiter = RegExp.escape(delimiter);\\n\\n        // compile the regEx str using the custom delimiter/separator\\n        var match = /(D|S|\\\\n|\\\\r|[^DS\\\\r\\\\n]+)/;\\n        var matchSrc = match.source;\\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\\n        match = new RegExp(matchSrc, 'gm');\\n\\n        // put on your fancy pants...\\n        // process control chars individually, use look-ahead on non-control chars\\n        csv.replace(match, function (m0) {\\n          if(exit) {\\n            return;\\n          }\\n          switch (state) {\\n            // the start of a value/entry\\n            case 0:\\n              // null value\\n              if (m0 === separator) {\\n                entry += m0;\\n                state = 0;\\n                break;\\n              }\\n              // opening delimiter\\n              if (m0 === delimiter) {\\n                entry += m0;\\n                state = 1;\\n                break;\\n              }\\n              // end of line\\n              if (m0 === '\\\\n') {\\n                endOfLine();\\n                break;\\n              }\\n              // phantom carriage return\\n              if (/^\\\\r$/.test(m0)) {\\n                break;\\n              }\\n              // un-delimit value\\n              entry += m0;\\n              state = 3;\\n              break;\\n\\n            // delimited input\\n            case 1:\\n              // second delimiter? check further\\n              if (m0 === delimiter) {\\n                entry += m0;\\n                state = 2;\\n                break;\\n              }\\n              // delimited data\\n              entry += m0;\\n              state = 1;\\n              break;\\n\\n            // delimiter found in delimited input\\n            case 2:\\n              // escaped delimiter?\\n              var prevChar = entry.substr(entry.length - 1);\\n              if (m0 === delimiter && prevChar === delimiter) {\\n                entry += m0;\\n                state = 1;\\n                break;\\n              }\\n              // end of value\\n              if (m0 === separator) {\\n                entry += m0;\\n                state = 0;\\n                break;\\n              }\\n              // end of line\\n              if (m0 === '\\\\n') {\\n                endOfLine();\\n                break;\\n              }\\n              // phantom carriage return\\n              if (m0 === '\\\\r') {\\n                break;\\n              }\\n              // broken paser?\\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\\n\\n            // un-delimited input\\n            case 3:\\n              // null value\\n              if (m0 === separator) {\\n                entry += m0;\\n                state = 0;\\n                break;\\n              }\\n              // end of line\\n              if (m0 === '\\\\n') {\\n                endOfLine();\\n                break;\\n              }\\n              // phantom carriage return\\n              if (m0 === '\\\\r') {\\n                break;\\n              }\\n              // non-compliant data\\n              if (m0 === delimiter) {\\n                throw new Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\\n              }\\n              // broken parser?\\n              throw new Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\\n            default:\\n              // shenanigans\\n              throw new Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\\n          }\\n          //console.log('val:' + m0 + ' state:' + state);\\n        });\\n\\n        // submit the last entry\\n        // ignore null last line\\n        if(entry !== '') {\\n          endOfLine();\\n        }\\n\\n        return entries;\\n      },\\n\\n      // a csv entry parser\\n      parseEntry: function(csv, options) {\\n        // cache settings\\n        var separator = options.separator;\\n        var delimiter = options.delimiter;\\n        \\n        // set initial state if it's missing\\n        if(!options.state.rowNum) {\\n          options.state.rowNum = 1;\\n        }\\n        if(!options.state.colNum) {\\n          options.state.colNum = 1;\\n        }\\n\\n        // clear initial state\\n        var entry = [];\\n        var state = 0;\\n        var value = '';\\n\\n        function endOfValue() {\\n          if(options.onParseValue === undefined) {\\n            // onParseValue hook not set\\n            entry.push(value);\\n          } else {\\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\\n            // false skips the value, configurable through a hook\\n            if(hook !== false) {\\n              entry.push(hook);\\n            }\\n          }\\n          // reset the state\\n          value = '';\\n          state = 0;\\n          // update global state\\n          options.state.colNum++;\\n        }\\n\\n        // checked for a cached regEx first\\n        if(!options.match) {\\n          // escape regex-specific control chars\\n          var escSeparator = RegExp.escape(separator);\\n          var escDelimiter = RegExp.escape(delimiter);\\n          \\n          // compile the regEx str using the custom delimiter/separator\\n          var match = /(D|S|\\\\n|\\\\r|[^DS\\\\r\\\\n]+)/;\\n          var matchSrc = match.source;\\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\\n          options.match = new RegExp(matchSrc, 'gm');\\n        }\\n\\n        // put on your fancy pants...\\n        // process control chars individually, use look-ahead on non-control chars\\n        csv.replace(options.match, function (m0) {\\n          switch (state) {\\n            // the start of a value\\n            case 0:\\n              // null last value\\n              if (m0 === separator) {\\n                value += '';\\n                endOfValue();\\n                break;\\n              }\\n              // opening delimiter\\n              if (m0 === delimiter) {\\n                state = 1;\\n                break;\\n              }\\n              // skip un-delimited new-lines\\n              if (m0 === '\\\\n' || m0 === '\\\\r') {\\n                break;\\n              }\\n              // un-delimited value\\n              value += m0;\\n              state = 3;\\n              break;\\n\\n            // delimited input\\n            case 1:\\n              // second delimiter? check further\\n              if (m0 === delimiter) {\\n                state = 2;\\n                break;\\n              }\\n              // delimited data\\n              value += m0;\\n              state = 1;\\n              break;\\n\\n            // delimiter found in delimited input\\n            case 2:\\n              // escaped delimiter?\\n              if (m0 === delimiter) {\\n                value += m0;\\n                state = 1;\\n                break;\\n              }\\n              // null value\\n              if (m0 === separator) {\\n                endOfValue();\\n                break;\\n              }\\n              // skip un-delimited new-lines\\n              if (m0 === '\\\\n' || m0 === '\\\\r') {\\n                break;\\n              }\\n              // broken paser?\\n              throw new Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n\\n            // un-delimited input\\n            case 3:\\n              // null last value\\n              if (m0 === separator) {\\n                endOfValue();\\n                break;\\n              }\\n              // skip un-delimited new-lines\\n              if (m0 === '\\\\n' || m0 === '\\\\r') {\\n                break;\\n              }\\n              // non-compliant data\\n              if (m0 === delimiter) {\\n                throw new Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n              }\\n              // broken parser?\\n              throw new Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n            default:\\n              // shenanigans\\n              throw new Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\\n          }\\n          //console.log('val:' + m0 + ' state:' + state);\\n        });\\n\\n        // submit the last value\\n        endOfValue();\\n\\n        return entry;\\n      }\\n    },\\n\\n    helpers: {\\n\\n      /**\\n       * $.csv.helpers.collectPropertyNames(objectsArray)\\n       * Collects all unique property names from all passed objects.\\n       *\\n       * @param {Array} objects Objects to collect properties from.\\n       *\\n       * Returns an array of property names (array will be empty,\\n       * if objects have no own properties).\\n       */\\n      collectPropertyNames: function (objects) {\\n\\n        var o, propName, props = [];\\n        for (o in objects) {\\n          for (propName in objects[o]) {\\n            if ((objects[o].hasOwnProperty(propName)) &&\\n                (props.indexOf(propName) < 0) && \\n                (typeof objects[o][propName] !== 'function')) {\\n\\n              props.push(propName);\\n            }\\n          }\\n        }\\n        return props;\\n      }\\n    },\\n\\n    /**\\n     * $.csv.toArray(csv)\\n     * Converts a CSV entry string to a javascript array.\\n     *\\n     * @param {Array} csv The string containing the CSV data.\\n     * @param {Object} [options] An object containing user-defined options.\\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\\\").\\n     *\\n     * This method deals with simple CSV strings only. It's useful if you only\\n     * need to parse a single entry. If you need to parse more than one line,\\n     * use $.csv2Array instead.\\n     */\\n    toArray: function(csv, options, callback) {\\n      options = (options !== undefined ? options : {});\\n      var config = {};\\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\\n      var state = (options.state !== undefined ? options.state : {});\\n\\n      // setup\\n      options = {\\n        delimiter: config.delimiter,\\n        separator: config.separator,\\n        onParseEntry: options.onParseEntry,\\n        onParseValue: options.onParseValue,\\n        state: state\\n      };\\n\\n      var entry = $.csv.parsers.parseEntry(csv, options);\\n\\n      // push the value to a callback if one is defined\\n      if(!config.callback) {\\n        return entry;\\n      } else {\\n        config.callback('', entry);\\n      }\\n    },\\n\\n    /**\\n     * $.csv.toArrays(csv)\\n     * Converts a CSV string to a javascript array.\\n     *\\n     * @param {String} csv The string containing the raw CSV data.\\n     * @param {Object} [options] An object containing user-defined options.\\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\\\").\\n     *\\n     * This method deals with multi-line CSV. The breakdown is simple. The first\\n     * dimension of the array represents the line (or entry/row) while the second\\n     * dimension contains the values (or values/columns).\\n     */\\n    toArrays: function(csv, options, callback) {\\n      options = (options !== undefined ? options : {});\\n      var config = {};\\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\\n\\n      // setup\\n      var data = [];\\n      options = {\\n        delimiter: config.delimiter,\\n        separator: config.separator,\\n        onPreParse: options.onPreParse,\\n        onParseEntry: options.onParseEntry,\\n        onParseValue: options.onParseValue,\\n        onPostParse: options.onPostParse,\\n        start: options.start,\\n        end: options.end,\\n        state: {\\n          rowNum: 1,\\n          colNum: 1\\n        }\\n      };\\n\\n      // onPreParse hook\\n      if(options.onPreParse !== undefined) {\\n        options.onPreParse(csv, options.state);\\n      }\\n\\n      // parse the data\\n      data = $.csv.parsers.parse(csv, options);\\n\\n      // onPostParse hook\\n      if(options.onPostParse !== undefined) {\\n        options.onPostParse(data, options.state);\\n      }\\n\\n      // push the value to a callback if one is defined\\n      if(!config.callback) {\\n        return data;\\n      } else {\\n        config.callback('', data);\\n      }\\n    },\\n\\n    /**\\n     * $.csv.toObjects(csv)\\n     * Converts a CSV string to a javascript object.\\n     * @param {String} csv The string containing the raw CSV data.\\n     * @param {Object} [options] An object containing user-defined options.\\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\\\").\\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\\n     *\\n     * This method deals with multi-line CSV strings. Where the headers line is\\n     * used as the key for each value per entry.\\n     */\\n    toObjects: function(csv, options, callback) {\\n      options = (options !== undefined ? options : {});\\n      var config = {};\\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\\n      options.start = 'start' in options ? options.start : 1;\\n      \\n      // account for headers\\n      if(config.headers) {\\n        options.start++;\\n      }\\n      if(options.end && config.headers) {\\n        options.end++;\\n      }\\n\\n      // setup\\n      var lines = [];\\n      var data = [];\\n\\n      options = {\\n        delimiter: config.delimiter,\\n        separator: config.separator,\\n        onPreParse: options.onPreParse,\\n        onParseEntry: options.onParseEntry,\\n        onParseValue: options.onParseValue,\\n        onPostParse: options.onPostParse,\\n        start: options.start,\\n        end: options.end,\\n        state: {\\n          rowNum: 1,\\n          colNum: 1\\n        },\\n        match: false,\\n        transform: options.transform\\n      };\\n\\n      // fetch the headers\\n      var headerOptions = {\\n        delimiter: config.delimiter,\\n        separator: config.separator,\\n        start: 1,\\n        end: 1,\\n        state: {\\n          rowNum:1,\\n          colNum:1\\n        }\\n      };\\n\\n      // onPreParse hook\\n      if(options.onPreParse !== undefined) {\\n        options.onPreParse(csv, options.state);\\n      }\\n\\n      // parse the csv\\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\\n      var headers = $.csv.toArray(headerLine[0], options);\\n\\n      // fetch the data\\n      lines = $.csv.parsers.splitLines(csv, options);\\n\\n      // reset the state for re-use\\n      options.state.colNum = 1;\\n      if(headers){\\n        options.state.rowNum = 2;\\n      } else {\\n        options.state.rowNum = 1;\\n      }\\n      \\n      // convert data to objects\\n      for(var i=0, len=lines.length; i<len; i++) {\\n        var entry = $.csv.toArray(lines[i], options);\\n        var object = {};\\n        for(var j=0; j <headers.length; j++) {\\n          object[headers[j]] = entry[j];\\n        }\\n        if (options.transform !== undefined) {\\n          data.push(options.transform.call(undefined, object));\\n        } else {\\n          data.push(object);\\n        }\\n        \\n        // update row state\\n        options.state.rowNum++;\\n      }\\n\\n      // onPostParse hook\\n      if(options.onPostParse !== undefined) {\\n        options.onPostParse(data, options.state);\\n      }\\n\\n      // push the value to a callback if one is defined\\n      if(!config.callback) {\\n        return data;\\n      } else {\\n        config.callback('', data);\\n      }\\n    },\\n\\n     /**\\n     * $.csv.fromArrays(arrays)\\n     * Converts a javascript array to a CSV String.\\n     *\\n     * @param {Array} arrays An array containing an array of CSV entries.\\n     * @param {Object} [options] An object containing user-defined options.\\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\\\").\\n     *\\n     * This method generates a CSV file from an array of arrays (representing entries).\\n     */\\n    fromArrays: function(arrays, options, callback) {\\n      options = (options !== undefined ? options : {});\\n      var config = {};\\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\\n\\n      var output = '',\\n          line,\\n          lineValues,\\n          i, j;\\n\\n      for (i = 0; i < arrays.length; i++) {\\n        line = arrays[i];\\n        lineValues = [];\\n        for (j = 0; j < line.length; j++) {\\n          var strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString();\\n          if (strValue.indexOf(config.delimiter) > -1) {\\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\\n          }\\n\\n          var escMatcher = '\\\\n|\\\\r|S|D';\\n          escMatcher = escMatcher.replace('S', config.separator);\\n          escMatcher = escMatcher.replace('D', config.delimiter);\\n\\n          if (strValue.search(escMatcher) > -1) {\\n            strValue = config.delimiter + strValue + config.delimiter;\\n          }\\n          lineValues.push(strValue);\\n        }\\n        output += lineValues.join(config.separator) + '\\\\r\\\\n';\\n      }\\n\\n      // push the value to a callback if one is defined\\n      if(!config.callback) {\\n        return output;\\n      } else {\\n        config.callback('', output);\\n      }\\n    },\\n\\n    /**\\n     * $.csv.fromObjects(objects)\\n     * Converts a javascript dictionary to a CSV string.\\n     *\\n     * @param {Object} objects An array of objects containing the data.\\n     * @param {Object} [options] An object containing user-defined options.\\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\\\").\\n     * @param {Character} [sortOrder] Sort order of columns (named after\\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\\n     *   which means, that properties will _probably_ appear in order they were\\n     *   declared for the object. But without any guarantee.\\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\\n     * a strin in a same csv format as an output or an array of header names\\n     * (array items won't be parsed). All the properties, not present in\\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\\n     * option. So the `manualOrder` always takes preference, if present.\\n     *\\n     * This method generates a CSV file from an array of objects (name:value pairs).\\n     * It starts by detecting the headers and adding them as the first line of\\n     * the CSV file, followed by a structured dump of the data.\\n     */\\n    fromObjects: function(objects, options, callback) {\\n      options = (options !== undefined ? options : {});\\n      var config = {};\\n      config.callback = ((callback !== undefined && typeof(callback) === 'function') ? callback : false);\\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\\n      config.transform = options.transform;\\n\\n      if (typeof config.manualOrder === 'string') {\\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\\n      }\\n\\n      if (config.transform !== undefined) {\\n        var origObjects = objects;\\n        objects = [];\\n\\n        var i;\\n        for (i = 0; i < origObjects.length; i++) {\\n          objects.push(config.transform.call(undefined, origObjects[i]));\\n        }\\n      }\\n\\n      var props = $.csv.helpers.collectPropertyNames(objects);\\n\\n      if (config.sortOrder === 'alpha') {\\n        props.sort();\\n      } // else {} - nothing to do for 'declare' order\\n\\n      if (config.manualOrder.length > 0) {\\n\\n        var propsManual = [].concat(config.manualOrder);\\n        var p;\\n        for (p = 0; p < props.length; p++) {\\n          if (propsManual.indexOf( props[p] ) < 0) {\\n            propsManual.push( props[p] );\\n          }\\n        }\\n        props = propsManual;\\n      }\\n\\n      var o, p, line, output = [], propName;\\n      if (config.headers) {\\n        output.push(props);\\n      }\\n\\n      for (o = 0; o < objects.length; o++) {\\n        line = [];\\n        for (p = 0; p < props.length; p++) {\\n          propName = props[p];\\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\\n            line.push(objects[o][propName]);\\n          } else {\\n            line.push('');\\n          }\\n        }\\n        output.push(line);\\n      }\\n\\n      // push the value to a callback if one is defined\\n      return $.csv.fromArrays(output, options, config.callback);\\n    }\\n  };\\n\\n  // Maintenance code to maintain backward-compatibility\\n  // Will be removed in release 1.0\\n  $.csvEntry2Array = $.csv.toArray;\\n  $.csv2Array = $.csv.toArrays;\\n  $.csv2Dictionary = $.csv.toObjects;\\n\\n  // CommonJS module is defined\\n  if (typeof module !== 'undefined' && module.exports) {\\n    module.exports = $.csv;\\n  }\\n\\n}).call( this );\\n\";","//     Underscore.js 1.9.2\n//     https://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this ||\n            {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if (typeof exports != 'undefined' && !exports.nodeType) {\n    if (typeof module != 'undefined' && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.2';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because were not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result  either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the functions\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6s \"rest parameter\".\n  var restArguments = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var has = function(obj, path) {\n    return obj != null && hasOwnProperty.call(obj, path);\n  }\n\n  var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/FisherYates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](https://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, path) {\n    if (!_.isArray(path)) {\n      return has(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  // Creates a function that, when passed an object, will traverse that objects\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    if (obj == null) {\n      return function(){};\n    }\n    return function(path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function(obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define == 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}());\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","import * as later from \"later\";\n\nimport { Messages } from \"../common/messages\";\nimport { HelenaConsole } from \"../common/utils/helena_console\";\nimport { ScheduledRun } from \"../common/scheduled_run\";\nimport { MiscUtilities } from \"../common/misc_utilities\";\nimport { HelenaServer, KnownRelationRequest,\n  KnownRelationResponse } from \"../mainpanel/utils/server\";\n\nexport class HelenaBackground {\n  private alreadyScheduled: {\n    [key: string]: later.Timer;\n  } = {};\n  private panelWindow?: chrome.windows.Window;\n\n  constructor() {\n    this.initMainpanelListeners();\n\n    Messages.listenForMessage(\"content\", \"background\", \"requestTabID\",\n        (msg: Messages.MessageContentWithTab) => {\n      chrome.tabs.get(msg.tab_id, (tab) => {\n        const tabIdsInclude = [];\n        if (tab.id) {\n          tabIdsInclude.push(tab.id);\n        }\n        Messages.sendMessage(\"background\", \"content\", \"tabID\",\n          {\n            tab_id: tab.id,\n            window_id: tab.windowId,\n            top_frame_url: tab.url\n          }, undefined, undefined, tabIdsInclude);\n      });\n    });\n\n    // one of our background services is also running http requests for content\n    //   scripts because modern chrome doesn't allow https pages to do it directly\n    Messages.listenForMessage(\"content\", \"background\", \"getKnownRelations\",\n        (msg: KnownRelationRequest & Messages.MessageContentWithTab) => {\n      HelenaServer.getKnownRelations(msg, (resp: KnownRelationResponse) => { \n        HelenaConsole.log(\"resp:\", resp);\n        Messages.sendMessage(\"background\", \"content\", \"getKnownRelations\", resp,\n          undefined, undefined, [ msg.tab_id ]);\n      });\n    });\n\n    // first, set the time zone\n    later.date.localTime();\n  \n    this.scheduleScrapes();\n    Messages.listenForMessage(\"mainpanel\", \"background\", \"scheduleScrapes\",\n      this.scheduleScrapes.bind(this));\n  }\n\n  private initMainpanelListeners() {\n    const self = this;\n    chrome.browserAction.onClicked.addListener(() => {\n      self.openMainPanel();\n    });\n\n    chrome.windows.onRemoved.addListener((winId) => {\n      if (typeof this.panelWindow == 'object' && this.panelWindow.id == winId) {\n        this.panelWindow = undefined;\n      }\n    });\n  }\n\n  public openMainPanel() {\n    // check if panel is already open\n    if (this.panelWindow === undefined) {\n      chrome.tabs.query({\n        active: true,\n        currentWindow: true\n      }, (tabs) => {\n        if (tabs.length > 1) {\n          throw new ReferenceError(\"How is there more than one active tab?\");\n        }\n  \n        // identify the url on which the user is currently focused, start a new\n        //   recording with the same url loaded\n        // now that we know the url...\n        let recordingUrl = <string> tabs[0].url;\n  \n        // now let's make the mainpanel\n        chrome.windows.create({\n          url: chrome.extension.getURL('pages/mainpanel.html?starturl=' +\n              encodeURIComponent(recordingUrl)), \n            width: 600, height: 800, left: 0, top: 0, \n            focused: true,\n            type: 'panel'\n          }, \n          (winInfo) => {\n            this.panelWindow = winInfo;\n          }\n        );\n      });\n    } else {\n      chrome.windows.update(this.panelWindow.id, {focused: true});\n    }\n  }\n\n  private scheduleScrapes(){\n    const self = this;\n    chrome.storage.sync.get(\"scheduledRuns\", (obj) => {\n      let runs: ScheduledRun[] = obj.scheduledRuns;\n      if (!runs) { return; }\n\n      console.log(\"scheduling scrapes\", obj);\n      const currentRunKeys = runs.map((run) => scheduledRunKey(run));\n\n      // first let's go through and make sure we don't have any things scheduled\n      //   that have been canceled, so that we need to clear them\n      for (const key in self.alreadyScheduled){\n        if (!currentRunKeys.includes(key)){\n          // ok, this is one we want to cancel\n          const laterId = self.alreadyScheduled[key];\n          laterId.clear();\n          console.log(\"unscheduled a run\", key);\n        }\n      }\n\n      // now let's go through and start any schedules that haven't yet been\n      //   scheduled\n      for (const run of runs) {\n        const schedule = run.schedule;\n        const progId = run.progId;\n        const key = scheduledRunKey(run);\n        if (!(key in self.alreadyScheduled)){\n          console.log(\"scheduled a run\", key);\n          const sched = later.parse.text(schedule);\n          const laterId = later.setInterval(() => {\n            self.runScheduledScript(progId);\n          }, sched);\n          self.alreadyScheduled[key] = laterId;\n        }\n      }\n    });\n  }\n\n  private runScheduledScript(id: string) {\n    const self = this;\n    // we'll have to actually open the control panel if we don't have it open\n    //   already\n    this.openMainPanel(); // this will only open it if it's currently closed\n    const panelWindowId = <number> this.panelWindow?.id;\n    \n    // and for cases where it's actually already running a script, we want to\n    //   tell it to wrap up whatever it's doing (send the data to server) and\n    //   then refresh the page so we're not bloating it all up with a bunch of\n    //   memory given over to the prior task\n    // the protocol here is:\n    // B -> M pleasePrepareForRefresh\n    // M -> B readyToRefresh\n    // B -> M runScheduledScript\n    // M -> B runningScheduledScript\n    let readyForRefresh = false;\n    Messages.listenForMessageOnce(\"mainpanel\", \"background\", \"readyToRefresh\",\n      () => {\n        readyForRefresh = true;\n        // ok, the mainpanel is ready to be refreshed\n        chrome.windows.get(panelWindowId, { populate: true }, (winData) => {\n          if (!winData.tabs || winData.tabs.length > 1) {\n            throw new ReferenceError(\"There should be exactly one tab.\");\n          }\n\n          const tab = winData.tabs[0];\n          chrome.tabs.update(<number> tab.id, { url: 'pages/mainpanel.html' },\n            () => {\n            // ok, now that we've reloaded the mainpanel, let's go for it\n            // but let's wait one sec, because it turns out even when this\n            //   continuation runs, sometimes the old page is still loaded in\n            //   and trying to respond, and sometimes it gets the response out\n            //   even though it's about to be reloaded and of course can't do\n            //   the real response\n            // todo: a more robust way for this please\n            setTimeout(() => {\n              console.log(\"running scheduled script\", id);\n              let runRequestReceived = false;\n              Messages.listenForMessageOnce(\"mainpanel\", \"background\",\n                \"runningScheduledScript\", () => { runRequestReceived = true; });\n              const sendRunRequest = () => {\n                Messages.sendMessage(\"background\", \"mainpanel\",\n                  \"runScheduledScript\", { progId: id });\n              };\n              MiscUtilities.repeatUntil(sendRunRequest,\n                () => runRequestReceived,\n                () => {\n                  HelenaConsole.log(\"mainpanel received run request\");\n                }, 500, true);\n            }, 1000);\n          });\n        }\n      );\n    });\n    const sendRefreshRequest = () => {\n      Messages.sendMessage(\"background\", \"mainpanel\", \"pleasePrepareForRefresh\",\n        {});\n    };\n    MiscUtilities.repeatUntil(sendRefreshRequest, () => readyForRefresh,\n      () => {}, 500, true);\n  }\n}\n\nfunction scheduledRunKey(run: ScheduledRun){\n  return run.schedule + \"_\" + run.progId;\n}\n","export namespace HelenaConfig {\n  export let helenaServerUrl =\n    \"http://helena-backend.us-west-2.elasticbeanstalk.com\";\n  export const nextButtonAttemptsThreshold = 4;\n  export let numRowsToSendInOneSlice = 10;\n  export const relationFindingTimeoutThreshold = 15000;\n  export const relationScrapeWait = 1000;\n}","import { XPath } from \"../content/utils/xpath\";\n\nexport namespace MainpanelNode {\n  export interface Interface {\n    text?: string;\n    textContent?: string;\n    link?: string;\n    xpath?: string;\n    value?: string;\n    frame?: number;\n    source_url?: string;\n    top_frame_source_url?: string;\n    date?: number;\n    linkScraping?: boolean;\n    scraped_attribute?: string;\n  }\n\n  /**\n   * Get a {@link MainpanelNode.Interface} from a DOM node.\n   * @param node DOM node\n   */\n  export function fromDOMNode(node: Node | null): Interface {\n    const frameId = window.ringerContent.frameId;\n    if (node === null) {\n\t    return {\n\t    \ttext: \"\", \n\t    \ttextContent: \"\",\n\t    \tlink: \"\", \n\t    \txpath: \"\", \n\t    \tvalue: \"\",\n\t    \tframe: frameId? frameId : undefined, \n\t\t\t  source_url: window.location.href,\n\t    \ttop_frame_source_url: window.helenaContent.tabTopUrl,\n\t    \tdate: (new Date()).getTime()\n\t    };\n\t  }\n\t  return {\n      text: getNodeText(node),\n\n      // it's ok if this is null or whatever.\n      //   we won't show this to the user.\n      //   just need it for aligning with ringer-scraped nodes\n      textContent: node.textContent? node.textContent : undefined,\n      \n\t  \tlink: getNodeLink(node), \n\t  \txpath: XPath.fromNode(node), \n\t  \tvalue: 'value' in node? node['value'] : undefined,\n\t  \tframe: frameId? frameId : undefined,\n    \tsource_url: window.location.href,\n    \ttop_frame_source_url: window.helenaContent.tabTopUrl,\n\t\t  date: (new Date()).getTime()\n\t  };\n  }\n\n  function getNodeTextHelper(node: Node) {\n    if (node.nodeValue && (node.nodeType === Node.TEXT_NODE ||\n          node.nodeType === Node.CDATA_SECTION_NODE)) {\n      return node.nodeValue.trim();\n\t\t} else if (node.nodeType === 1) {\n      // If node is an element (1)\n      let el = <Element> node;\n\t\t  let text = \"\";\n\n\t\t\t// Traverse children unless this is a script or style element\n\t\t\tif (!el.tagName.match(/^(script|style)$/i)) {\n        let children = [].slice.call(el.childNodes);\n        for (const child of children) {\n          let newText = getNodeTextHelper(child);\n          if (newText) {\n            text += newText + \"\\n\";\n          }\n\t\t\t\t}\n\t\t\t}\n\n      // If img, input[type=image], or area element, return its alt text\n\t\t\tif (el.tagName.toLowerCase() == 'img' ||\n\t\t\t\t\tel.tagName.toLowerCase() == 'area' ||\n          (el.tagName.toLowerCase() == 'input'\n             && el.getAttribute('type')?.toLowerCase() == 'image')) {\n\t\t\t\ttext += el.getAttribute('alt') || \"\";\n\t\t\t}\n\n\t\t\tif (el.tagName.toLowerCase() == 'img') {\n        let imageEl = <HTMLImageElement> el;\n\t\t\t\ttext += \" image(\" + imageEl.src + \")\";\n      }\n      \n\t\t\tlet compStyle = window.getComputedStyle(el, null);\n      if (compStyle.backgroundImage &&\n          compStyle.backgroundImage.includes(\"url\")) {\n\t\t\t\ttext += \" image\" + compStyle.backgroundImage; // \"image url(the_url)\"\n\t\t\t}\n\n\t\t\tlet title = el.getAttribute('title');\n\t\t\tif (title) {\n\t\t\t\ttext += \" \" + title;\n\t\t\t}\n\t\n\t\t\ttext = text.trim();\n\t\t\treturn text; // debugging checks\n\t\t}\n\n\t\treturn null; // debugging check\n  }\n\n  /**\n   * Given a DOM node, get the relevant text for Helena purposes.\n   * @param node the node\n   * @param recurse whether we should recurse or not\n   */\n  export function getNodeText(node: Node, recurse = true): string {\n    let text = getNodeTextHelper(node);\n    // should empty text also be null?\n\t  if (!text) {\n      // for the case where we get null text because it's an input with a value,\n      //   should scrape the value\n\t  \tif ('value' in node) {\n        let inputEl = <HTMLInputElement> node;\n\t  \t\ttext = inputEl.value;\n\t  \t} else {\n\t  \t\tif (recurse && node.parentNode) {\n          // desperate times call for desperate measures;\n          //   if we're about to return null, try returning the parent instead\n\t  \t\t\treturn getNodeText(node.parentNode, false);\n        }\n        throw new ReferenceError(`Could not find text for ${node}`);\n\t    }\n\t  }\n\t  text = text.trim();\n\t  return text;\n  }\n\n  /**\n   * Get the link referred to by the node, if any.\n   * @param node the node\n   */\n  function getNodeLink(node: Node) {\n\t  if ('href' in node) {\n\t    return node['href'];\n\t  }\n    \n    if (node.parentNode) {\n      let parent = <Node> node.parentNode;\n      if ('href' in parent) {\n        return parent['href'];\n      }\n    }\n    return \"\";\n  }\n\n  /**\n   * Converts {@link HTMLElement}s in a relation into {@link MainpanelNode}s.\n   * @param relation the relation of elements\n   */\n  export function convertRelation(relation: (HTMLElement | null)[][]) {\n    return relation.map((row) =>\n      row.map((cell) => fromDOMNode(cell))\n    );\n  }\n}","import { HelenaConsole } from \"./utils/helena_console\";\n\nimport { MainpanelNode } from \"./mainpanel_node\";\nimport MainpanelNodeI = MainpanelNode.Interface;\n\nimport { Features } from \"../content/utils/features\";\nimport GenericFeatureSet = Features.GenericFeatureSet;\n\nimport { XPath } from \"../content/utils/xpath\";\nimport SuffixXPathList = XPath.SuffixXPathList;\n\nimport { INextButtonSelector, IColumnSelector } from \"../content/selector/interfaces\";\n\nexport interface ColumnSelectorMessage {\n  xpath: string;\n  suffix: SuffixXPathList | SuffixXPathList[];\n  name?: string;\n  id: number | null;\n  index?: string;\n}\n\nexport interface TabDetailsMessage {\n  tab_id: number;\n  window_id: number;\n  top_frame_url: string;\n}\n\nexport interface WindowIdMessage {\n  window: number;\n}\n\nexport interface WindowsMessage {\n  window_ids: number[];\n}\n\nexport interface ColumnIndexMessage {\n  index: number;\n}\n\nexport interface LikelyRelationMessage {\n  xpaths: string[];\n  pageVarName: string;\n  serverSuggestedRelations: (RelationMessage | null)[];\n}\n\nexport interface FreshRelationItemsMessage {\n  type: number;\n  relation: MainpanelNodeI[][];\n}\n\nexport interface EditRelationMessage {\n  relation: null;\n  demonstration_time_relation: MainpanelNodeI[][];\n  colors: string[];\n}\n\nexport interface NextButtonSelectorMessage {\n  selector: INextButtonSelector;\n}\n\nexport interface RelationMessage {\n  id: string;\n  name: string;\n  selector: GenericFeatureSet | GenericFeatureSet[];\n  selector_version: number;\n  exclude_first: number,\n  columns: (IColumnSelector | ColumnSelectorMessage)[],\n  url: string;\n  next_type?: number;\n  next_button_selector?: INextButtonSelector | null;\n  num_rows_in_demonstration?: number;\n  relation_scrape_wait: number;\n  prior_next_button_text?: string;\n}\n\nexport interface NextButtonTextMessage {\n  text: string;\n}\n\nexport interface FastModeMessage {\n  use: boolean;\n}\n\nexport interface SkipBlockResponse {\n  exists: boolean;\n  task_yours: boolean;\n}\n\nexport interface ServerSaveResponse {\n  program: {\n    id: string;\n  }\n}\n\nexport interface SavedProgramMessage {\n  id: string;\n  date: number;\n  name: string;\n  serialized_program: string;\n}\n\nexport interface ScheduledScriptMessage {\n  progId: string;\n}\n\nexport interface DatasetSliceRequest {\n  nodes: string;\n  pass_start_time: number;\n  position_lists: string;\n  run_id?: number;\n  sub_run_id?: number;\n}\n\nexport interface RelationResponse {\n  columns: IColumnSelector[];\n  exclude_first: number;\n  first_page_relation: MainpanelNode.Interface[][];\n  frame: number;\n  name: string;\n  next_button_selector: INextButtonSelector;\n  next_type: number;\n  num_rows_in_demonstration: number;\n  page_var_name: string;\n  pulldown_relations: RelationResponse[];\n  relation_id: string;\n  selector: GenericFeatureSet[];\n  selector_version: number;\n  url: string;\n}\n\nenum SendTypes {\n  NORMAL = 0,\n  FRAMESPECIFIC = 1\n}\n\nexport namespace Messages {\n  let listenerCounter = 1;\n  let oneOffListenerCounter = 1;\n  \n  const listeners: {\n    [key: string]: Function\n  } = {};\n\n  interface Message {\n    content: MessageContent;\n    frame_ids_exclude?: number[];\n    frame_ids_include?: number[];\n    from: string;\n    send_type: SendTypes;\n    subject: string;\n  }\n\n  interface FrameSpecificMessage extends Message {\n    frame_specific_subject: string;\n  }\n\n  interface MessageContent {\n    [key: string]: any;\n  }\n\n  export interface MessageContentWithTab {\n    tab_id: number;\n  }\n\n  interface Sender {\n    tab: chrome.tabs.Tab;\n  }\n  \n  /* cjbaik: extension.onMessage is deprecated, move everything to runtime?\n  const extensionListeners: {\n    [key: string]: Function\n  } = {}; */\n\n  chrome.runtime.onMessage.addListener((msg, sender) => {\n    for (const key in listeners){\n      const wasRightHandler = listeners[key](msg, sender);\n      if (wasRightHandler) {\n        return;\n      }\n    }\n    HelenaConsole.namedLog(\"tooCommon\", \"couldn't find right handler\", msg,\n      sender);\n  });\n\n  /*\n  chrome.extension.onMessage.addListener((msg, sender) => {\n    // HelenaConsole.log(\"keys\", Object.keys(extensionListeners));\n    for (var key in extensionListeners){\n      // HelenaConsole.log(\"key\", key);\n      var wasRightHandler = extensionListeners[key](msg, sender);\n      if (wasRightHandler){\n        return;\n      }\n    }\n    HelenaConsole.namedLog(\"tooCommon\", \"Couldn't find right handler\", msg,\n      sender);\n  });*/\n\n  export function listenForMessage(from: string, to: string, subject: string,\n      fn: Function, key: string | number = listenerCounter) {\n    HelenaConsole.log(`Listening for messages: ${from} : ${to} : ${subject}`);\n    listenerCounter += 1;\n    if (to === \"background\" || to === \"mainpanel\") {\n      listeners[key] = (msg: Message, sender: Sender) => {\n        if (msg.from && msg.from === from &&\n            msg.subject && msg.subject === subject &&\n            msg.send_type === SendTypes.NORMAL) {\n          if (sender.tab && sender.tab.id){\n            // add a tab id iff it's from content, and thus has sender.tab and\n            //   sender.tab.id\n            if (!msg.content) {\n              msg.content = {};\n            }\n            msg.content.tab_id = sender.tab.id;\n          }\n          HelenaConsole.log(\"Receiving message: \", msg);\n          HelenaConsole.log(\"from tab id: \", msg.content.tab_id);\n          fn(msg.content);\n          return true;\n        }\n        HelenaConsole.log(\"No subject match: \", msg.subject, subject);\n        return false;\n      };\n    } else if (to === \"content\") {\n      // HelenaConsole.log(\"content listener\", key, subject);\n      listeners[key] = (msg: Message, sender: Sender) => {\n        // HelenaConsole.log(msg, sender);\n        const frame_id = window.ringerContent.frameId;\n        if (!frame_id) {\n          throw new ReferenceError(\"frameId not set!\");\n        }\n        if (msg.frame_ids_include &&\n            !msg.frame_ids_include.includes(frame_id)){\n          HelenaConsole.log(\"Msg for frames with ids \"+ msg.frame_ids_include +\n            \", but this frame has id \" + frame_id + \".\");\n          return false;\n        } else if (msg.frame_ids_exclude &&\n                   msg.frame_ids_exclude.includes(frame_id)){\n          HelenaConsole.log(\"Msg for frames w/o ids \" + msg.frame_ids_exclude +\n            \", but this frame has id \" + frame_id + \".\");\n          return false;\n        } else if (msg.from && msg.from === from &&\n                   msg.subject && msg.subject === subject &&\n                   msg.send_type === SendTypes.NORMAL) {\n          HelenaConsole.log(\"Receiving message: \", msg);\n          fn(msg.content);\n          return true;\n        } else {\n          // HelenaConsole.log(\"Received message, but not a match for current listener.\");\n          // HelenaConsole.log(msg.from, from, (msg.from === from), msg.subject, subject, (msg.subject === subject), (msg.send_type === sendTypes.NORMAL));\n          return false;\n        }\n      };\n    } else {\n      console.log(\"Bad to field in msg:\", to);\n    }\n  }\n\n  // note that this frameSpecificMessage assume we'll have a response handler,\n  //   so fn should provide a return value, rather than sending its own messages\n  export function listenForFrameSpecificMessage(from: string, to: string,\n      subject: string, fn: Function){\n    HelenaConsole.log(`Listening for frame-specific messages: ${from} : ${to} : ${subject}`);\n    chrome.runtime.onMessage.addListener((msg: Message, sender: Sender) => {\n      if (msg.subject === subject &&\n          msg.send_type === SendTypes.FRAMESPECIFIC){\n        const frameMsg = <FrameSpecificMessage> msg;\n        const key = frameMsg.frame_specific_subject;\n        const sendResponse = (content: MessageContent) => {\n          sendMessage(to, from, key, content);\n        };\n        HelenaConsole.log(\"Receiving frame-specific message: \", frameMsg);\n        fn(frameMsg.content, sendResponse);\n\n        // must return true so that the sendResponse channel remains open\n        //   (indicates we'll use sendResponse asynchronously. may not always,\n        //   but have the option)\n        return true;\n      }\n      return;\n    });\n  }\n\n  export function listenForMessageOnce(from: string, to: string,\n      subject: string, fn: Function) {\n    HelenaConsole.log(`Listening once for message: ${from} : ${to} : ${subject}`);\n    const key = `oneoff_${oneOffListenerCounter}`;\n    let newfunc = null;\n    oneOffListenerCounter += 1;\n    newfunc = (msg: Message) => {\n      delete listeners[key];\n      fn(msg);\n    };\n    listenForMessage(from, to, subject, newfunc, key);\n  }\n\n  export function listenForMessageWithKey(from: string, to: string,\n      subject: string, key: string, fn: Function){\n    HelenaConsole.log(`Listening for message with key: ${from} : ${to} : ${subject}`);\n    listenForMessage(from, to, subject, fn, key);\n  }\n\n  /*\n  export function stopListeningForMessageWithKey(from: string, to: string, subject, key){\n    // HelenaConsole.log(\"deleting key\", key);\n    if (to === \"background\" || to === \"mainpanel\"){\n      delete runtimeListeners[key];\n    }\n    else if (to === \"content\"){\n      delete extensionListeners[key];\n    }\n  }*/\n\n  // note: \n  /**\n   * \n   * @param from \n   * @param to \n   * @param subject \n   * @param content \n   * @param frameIdsInclude frame_ids are our own internal frame ids, not chrome\n   *   frame ids\n   * @param frameIdsExclude frame_ids are our own internal frame ids, not chrome\n   *   frame ids\n   * @param tabIdsInclude \n   * @param tabIdsExclude \n   */\n  export function sendMessage(from: string, to: string, subject: string,\n      content: MessageContent, frameIdsInclude?: number[],\n      frameIdsExclude?: number[], tabIdsInclude?: number[],\n      tabIdsExclude?: number[]) {\n    if ((from === \"background\" || from === \"mainpanel\") && to === \"content\") {\n      const msg: Message = {\n        from: from,\n        subject: subject,\n        content: content,\n        frame_ids_include: frameIdsInclude,\n        frame_ids_exclude: frameIdsExclude,\n        send_type: SendTypes.NORMAL\n      };\n      HelenaConsole.log(\"Sending message: \", msg);\n      HelenaConsole.log(tabIdsInclude, tabIdsExclude);\n      if (tabIdsInclude) {\n        for (const tabId of tabIdsInclude) {\n          if (tabId) {\n            chrome.tabs.sendMessage(tabId, msg); \n          } else {\n            console.warn(\"Tried to send message to undefined tab, very bad.\");\n            const err = new Error();\n            console.warn(err.stack);\n          }\n        }\n        HelenaConsole.log(\"(Sent to \", tabIdsInclude.length, \" tabs: \",\n          tabIdsInclude, \" )\");\n      } else {\n        chrome.tabs.query({ windowType: \"normal\" }, (tabs) => {\n          let tabsMessaged = 0;\n          for (const tab of tabs) {\n            if (tab.id && !(tabIdsExclude && tabIdsExclude.includes(tab.id))) {\n              try {\n                chrome.tabs.sendMessage(tab.id, msg); \n              } catch(err) {\n                // console.warn(\"failure to send message:\", msg);\n              }\n              tabsMessaged++;\n            }\n          }\n          HelenaConsole.log(\"(Sent to \"+tabsMessaged+\" tabs.)\");\n        });\n      }\n    } else if (to === \"background\" || to === \"mainpanel\") {\n      const msg: Message = {\n        from: from,\n        subject: subject,\n        content: content,\n        send_type: SendTypes.NORMAL\n      };\n      HelenaConsole.log(\"Sending message: \", msg);\n      chrome.runtime.sendMessage(msg);\n    } else {\n      console.warn(\"Bad from field in msg:\", from);\n    }\n  };\n\n  // \n  /**\n   * Make a channel based on the frame id and the subject, and anything that\n   *   comes from that frame with that subject will go to that channel.\n   * @param from \n   * @param to \n   * @param subject \n   * @param content \n   * @param chromeTabId \n   * @param chromeFrameId not the same as our internal frame ids\n   * @param handler \n   */\n  export function sendFrameSpecificMessage(from: string, to: string,\n      subject: string, content: MessageContent, chromeTabId: number,\n      chromeFrameId: number, handler: Function){\n    const key = subject+\"_\"+chromeFrameId;\n    const msg: FrameSpecificMessage = {\n      from: from,\n      subject: subject,\n      content: content,\n      send_type: SendTypes.FRAMESPECIFIC,\n      frame_specific_subject: key\n    };\n    HelenaConsole.log(\"Sending frame-specific message: \", msg);\n    const newResponseHandler = (data: any) => {\n      //console.log(\"in response handler\", data);\n      handler(data);\n    }\n    // let's register what to do when we actually get a response\n    // and remember, multiple frames might be sending this, so we need to make\n    //   sure we'll always get the right handler (a different one for each\n    //   frame), so we'll use the new frame-specific key as the 'subject'\n    listenForMessage(to, from, key, newResponseHandler, key);\n\n    // only send to the correct tab!\n    chrome.tabs.sendMessage(chromeTabId, msg, {frameId: chromeFrameId});\n  }\n}","import * as stringify from \"json-stable-stringify\";\n\nimport { HelenaConsole } from \"./utils/helena_console\";\n\nexport namespace MiscUtilities {\n  let currentResponseRequested: {\n    [key: string]: boolean\n  } = {};\n  let currentResponseHandler: {\n    [key: string]: Function\n  } = {};\n\n  export function makeNewRecordReplayWindow(cont: Function,\n      specifiedUrl?: string, winWidth?: number, winHeight?: number) {\n    chrome.windows.getCurrent((curWindow) => {\n      const right = <number> curWindow.left + <number> curWindow.width;\n      let width = null;\n      let height = null;\n      chrome.system.display.getInfo(function(displayInfoLs){\n        for (var i = 0; i < displayInfoLs.length; i++){\n          const bounds = displayInfoLs[i].bounds;\n          const rightBound = bounds.left + bounds.width;\n          HelenaConsole.log(bounds);\n          if (bounds.left <= right && rightBound >= right){\n            // we've found the right display\n            // - 40 because it doesn't seem to count the menu bar and I'm not\n            //   looking for a more accurate solution at the moment\n            var top = <number> curWindow.top - 40;\n            var left = right; // let's have it adjacent to the control panel\n            console.log(rightBound - right, bounds.top + bounds.height - top);\n            if (!winWidth || !winHeight){\n              width = rightBound - right;\n              height = bounds.top + bounds.height - top;\n            } else {\n              width = winWidth;\n              height = winHeight;\n            }\n\n            // for now let's actually make width and height fixed for stability\n            //   across different ways of running (diff machines, diff panel\n            //   sizes at start)\n            // 1419 1185\n            //var width = 1419;\n            //var height = 1185;\n            let url = specifiedUrl;\n            if (!url) {\n              url = \"pages/newRecordingWindow.html\"\n            }\n            chrome.windows.create({\n              url: url,\n              focused: true,\n              left: left,\n              top: top,\n              width: width,\n              height: height\n            }, (win) => {\n              HelenaConsole.log(\"new record/replay window created.\");\n            \n              // todo: should probably still send this for some cases\n              //pub.sendCurrentRecordingWindow();\n\n              if (win) {\n                cont(win.id);\n              }\n            });\n          }\n        }\n      });\n    });\n  }\n\n  export function depthOf(object: any) {\n    let level = 1;\n    for (const key in object) {\n      if (!object.hasOwnProperty(key)) continue;\n\n      if(typeof object[key] === 'object'){\n        const depth = depthOf(object[key]) + 1;\n        level = Math.max(depth, level);\n      }\n    }\n    return level;\n  }\n\n  // note that this does not handle cyclic objects!\n  export function removeAttributeRecursive(obj: { [key: string]: any },\n    attribute: string) {\n    if (typeof obj !== \"object\" || obj === null){ \n      return; // nothing to do here\n    } else {\n      // ok, it's an object\n      if (attribute in obj) {\n        // ok, we actually want to remove\n        delete obj[attribute];\n      }\n      // time to descend\n      for (const prop in obj) {\n        removeAttributeRecursive(obj[prop], attribute);\n      }\n    }\n  }\n\n  export function repeatUntil(repeatFunction: Function, untilFunction: Function,\n    afterFunction: Function, interval: number, grow = false) {\n    if (untilFunction()){\n      afterFunction();\n      return;\n    }\n    repeatFunction();\n    let nextInterval = interval;\n    if (grow) {\n      // is this really how we want to grow it? should a strategy be passed in?\n      nextInterval = nextInterval * 2;\n    }\n    HelenaConsole.log(\"grow\", grow);\n    HelenaConsole.log(\"interval\", nextInterval);\n    setTimeout(() => {\n      repeatUntil(repeatFunction, untilFunction, afterFunction, nextInterval,\n        grow);\n    }, interval);\n  }\n\n  /**\n   * Get the current, most up-to-date response from a message sent from the\n   *   mainpanel to content script, to avoid having a backlog of repeated\n   *   messages sent.\n   * Caveat: If anything changes about the message, this is a bad way to handle\n   *   it; e.g. if we have a counter in the message saying how many times it's\n   *   been sent.\n   * @param message message to send\n   * @param handler handler for response\n   */\n  export function registerCurrentResponseRequested(message: object,\n      handler: Function) {\n    const key = stringify(message);\n    HelenaConsole.namedLog(\"getRelationItems\",\n      \"registering new handler for key\", key.slice(0, 40));\n    currentResponseRequested[key] = true;\n    currentResponseHandler[key] = (msg: object) => {\n      HelenaConsole.namedLog(\"getRelationItems\",\n        \"running the current handler for key:\", key.slice(0, 40));\n      handler(msg);\n    };\n\n    // Add to end of message queue, such that each message is responded to only\n    //   once, and any additional calls are ignored.\n    setTimeout(() => {\n      const key = stringify(message);\n      if (currentResponseRequested[key]) {\n        currentResponseRequested[key] = false;\n        // now call the actual function\n        currentResponseHandler[key](message);\n        HelenaConsole.namedLog(\"getRelationItems\",\n          \"we successfully did handleRegisterCurrentResponseRequested for key\",\n          key.slice(0, 40));\n      } else {\n        HelenaConsole.namedLog(\"getRelationItems\",\n          \"we tried to do handleRegisterCurrentResponseRequested for key\",\n          key.slice(0, 40),\n          \"but there was nothing registered.  throwing it out.\");\n      }\n      // handleRegisterCurrentResponseRequested(message);\n    }, 0);\n  }\n\n  export function dirtyDeepcopy(obj: object) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  export function urlMatch(text: string, currentUrl: string) {\n    return urlMatchSymmetryHelper(text, currentUrl) ||\n           urlMatchSymmetryHelper(currentUrl, text);\n  }\n\n  function urlMatchSymmetryHelper(t1: string, t2: string) {\n    // todo: there might be other ways that we could match the url. don't need to\n    //   match the whole thing\n    \n    // don't need www, etc, any lingering bits on the end that get added...\n    if (t1.replace(\"http://\", \"https://\") === t2) {\n      return true;\n    }\n    return false;\n  }\n}","import * as _ from \"underscore\";\n\nexport namespace DOMCreation {\n  export function replaceContent(div1: JQuery<HTMLElement>,\n      div2: JQuery<HTMLElement>){\n    const div2clone = div2.clone();\n    div1.html(div2clone.html());\n  }\n\n  export function arrayOfTextsToTableRow(array: string[]) {\n    const $tr = $(\"<tr></tr>\");\n    for (const item of array) {\n      var $td = $(\"<td></td>\");\n      $td.html(_.escape(item).replace(/\\n/g,\"<br>\"));\n      $tr.append($td);\n    }\n    return $tr;\n  }\n\n  export function arrayOfArraysToTable(arrayOfArrays: string[][]) {\n    const $table = $(\"<table></table>\");\n    for (const array of arrayOfArrays) {\n      $table.append(arrayOfTextsToTableRow(array));\n    }\n    return $table;\n  }\n\n  export function toggleDisplay(node: JQuery<HTMLElement>) {\n    console.log(node);\n    if (node.css(\"display\") === \"none\") {\n      node.css(\"display\", \"inline\");\n    } else {\n      node.css(\"display\", \"none\");\n    }\n  }\n}","export namespace HelenaConsole {\n  export let debugging = false;\n  export let showWarnings = true;\n  export let namedDebugging: string[] = []; //[\"nextInteraction\"]; //[\"getRelationItems\"]; // [\"prinfo\"]; //[\"duplicates\"]; //[\"rbb\"];//[\"getRelationItems\", \"nextInteraction\"];\n  export let styleMinimal = true;\n\n  function callerName(origArgs: any) {\n    console.log(\"origArgs\", origArgs);\n    try {\n      return origArgs.callee.caller.name;\n    } catch(e) {\n      return \"unknown caller\";\n    }\n  }\n\n  function loggingGuts(args: any, origArgs: any) {\n    let prefix: string[] = [];\n    if (!styleMinimal){\n      const caller = callerName(origArgs);\n      prefix = [`[${caller}]`];\n    }\n    const newArgs = prefix.concat(Array.prototype.slice.call(args));\n    Function.apply.call(console.log, console, newArgs);\n  }\n\n  export function log(...args: any) {\n    if (debugging){\n      loggingGuts(arguments, arguments);\n    }\n  }\n\n  export function namedLog(...args: any) {\n    const name = arguments[0];\n    if (debugging || namedDebugging.includes(name)) {\n      const args = Array.prototype.slice.call(arguments);\n      loggingGuts(args.slice(1, arguments.length), arguments);\n    }\n  }\n\n  export function warn(...args: any) {\n    if (showWarnings){\n      const args = Array.prototype.slice.call(arguments);\n      const newArgs = [\"Warning: \"].concat(args);\n      loggingGuts(newArgs, arguments);\n    }\n  }\n}\n","import { HelenaConsole } from \"./helena_console\";\nimport { PageVariable } from \"../../mainpanel/variables/page_variable\";\nimport { StatementTypes } from \"../../mainpanel/lang/statements/statement_types\";\nimport {\n  RingerEvents,\n  RecordedRingerEvent,\n  DOMRingerEvent,\n} from \"../../ringer-record-replay/common/event\";\nimport { Utilities } from \"../../ringer-record-replay/common/utils\";\n\nexport type Trace = RecordedRingerEvent[];\n\ninterface EventDisplayInfo {\n  causedBy?: RecordedRingerEvent;\n  causesLoads?: RecordedRingerEvent[];\n  inputPageVar?: PageVariable;\n  manual?: boolean;\n  pageVar?: PageVariable;\n  pageVarId?: PageVariable; // older implementations use this for tests\n  visible?: boolean;\n}\n\nexport interface DisplayTraceEvent extends RecordedRingerEvent {\n  additionalDataTmp: {\n    display: EventDisplayInfo;\n  };\n}\n\n/**\n * Handling a trace (i.e. a list of Ringer events).\n */\nexport namespace Traces {\n  const statementToEventMapping = {\n    mouse: [\n      \"click\",\n      \"dblclick\",\n      \"mousedown\",\n      \"mousemove\",\n      \"mouseout\",\n      \"mouseover\",\n      \"mouseup\",\n    ],\n    keyboard: [\"keydown\", \"keyup\", \"keypress\", \"textinput\", \"paste\", \"input\"],\n    dontcare: [\"blur\"],\n  };\n\n  export function lastTopLevelCompletedEvent(trace: Trace) {\n    for (let i = trace.length - 1; i >= 0; i--) {\n      const ev = trace[i];\n      if (RingerEvents.isComplete(ev)) {\n        return ev;\n      }\n    }\n    throw new ReferenceError(\"No top level completed event!\");\n  }\n\n  export function tabId(ev: RecordedRingerEvent | undefined) {\n    if (!ev) {\n      return undefined;\n    }\n    return ev.data.tabId;\n  }\n\n  export function frameId(ev: RecordedRingerEvent) {\n    return ev.data.frameId;\n  }\n\n  export function lastTopLevelCompletedEventTabId(trace: Trace) {\n    const ev = lastTopLevelCompletedEvent(trace);\n    return ev?.data.tabId;\n  }\n\n  export function tabsInTrace(trace: Trace) {\n    const tabs: number[] = [];\n    for (const ev of trace) {\n      if (RingerEvents.isComplete(ev)) {\n        if (!tabs.includes(ev.data.tabId)) {\n          tabs.push(ev.data.tabId);\n        }\n      }\n    }\n    return tabs;\n  }\n\n  /**\n   * Add display information placeholder to event.\n   * @param ev\n   */\n  export function prepareForDisplay(ev: RecordedRingerEvent) {\n    let dispEv: DisplayTraceEvent = {\n      ...ev,\n      additionalDataTmp: {\n        display: {},\n      },\n    };\n    return dispEv;\n  }\n\n  export function getLoadURL(ev: RecordedRingerEvent) {\n    const url = ev.data.url;\n    // to canonicalize urls that'd be treated the same, remove slash at end\n    return strip(url, \"/\");\n  }\n\n  export function getDOMURL(ev: RecordedRingerEvent) {\n    const url = <string>ev.frame.topURL;\n\n    // to canonicalize urls that'd be treated the same, remove slash at end\n    return strip(url, \"/\");\n  }\n\n  export function getTabId(ev: RecordedRingerEvent) {\n    if (ev.type === \"dom\") {\n      console.warn(\"yo, this function isn't for dom events\");\n    }\n    const tabId = ev.data.tabId;\n    return tabId;\n  }\n\n  export function getDOMPort(ev: RecordedRingerEvent) {\n    return ev.frame.port;\n  }\n\n  export function getVisible(ev: RecordedRingerEvent) {\n    return ev.additionalDataTmp?.display?.visible;\n  }\n\n  export function setVisible(ev: DisplayTraceEvent, val: boolean) {\n    ev.additionalDataTmp.display.visible = val;\n  }\n\n  export function getManual(ev: DisplayTraceEvent) {\n    return ev.additionalDataTmp.display.manual;\n  }\n\n  export function setManual(ev: DisplayTraceEvent, val: boolean) {\n    ev.additionalDataTmp.display.manual = val;\n  }\n\n  export function getLoadOutputPageVar(ev: DisplayTraceEvent) {\n    if (ev.additionalDataTmp.display.pageVar) {\n      return ev.additionalDataTmp.display.pageVar;\n    } else if (ev.additionalDataTmp.display.pageVarId) {\n      return ev.additionalDataTmp.display.pageVarId;\n    }\n    return undefined;\n  }\n\n  export function setLoadOutputPageVar(\n    ev: DisplayTraceEvent,\n    val: PageVariable\n  ) {\n    ev.additionalDataTmp.display.pageVar = val;\n  }\n\n  export function getDOMInputPageVar(ev: DisplayTraceEvent): PageVariable {\n    if (!ev.additionalDataTmp.display.inputPageVar) {\n      throw new ReferenceError(\"DOM Input page variable undefined\");\n    }\n    return ev.additionalDataTmp.display.inputPageVar;\n  }\n\n  export function setDOMInputPageVar(ev: DisplayTraceEvent, val: PageVariable) {\n    ev.additionalDataTmp.display.inputPageVar = val;\n  }\n\n  export function getDOMOutputLoadEvents(ev: DisplayTraceEvent) {\n    if (ev.type !== \"dom\") {\n      return;\n    }\n    return ev.additionalDataTmp.display.causesLoads;\n  }\n\n  export function setDOMOutputLoadEvents(\n    ev: DisplayTraceEvent,\n    val: RecordedRingerEvent[]\n  ) {\n    if (ev.type !== \"dom\") {\n      return;\n    }\n    ev.additionalDataTmp.display.causesLoads = val;\n  }\n\n  export function addDOMOutputLoadEvent(\n    ev: DisplayTraceEvent,\n    val: RecordedRingerEvent\n  ) {\n    if (!ev.additionalDataTmp.display.causesLoads) {\n      ev.additionalDataTmp.display.causesLoads = [];\n    }\n    ev.additionalDataTmp.display.causesLoads.push(val);\n  }\n\n  export function getLoadCausedBy(ev: DisplayTraceEvent) {\n    return ev.additionalDataTmp.display.causedBy;\n  }\n\n  export function setLoadCausedBy(\n    ev: DisplayTraceEvent,\n    val: RecordedRingerEvent\n  ) {\n    ev.additionalDataTmp.display.causedBy = val;\n  }\n\n  export function getDisplayInfo(ev: DisplayTraceEvent) {\n    return ev.additionalDataTmp.display;\n  }\n\n  function cleanEvent(ev: DisplayTraceEvent): DisplayTraceEvent {\n    const displayData = Traces.getDisplayInfo(ev);\n    Traces.clearDisplayInfo(ev);\n    const cleanEvent = Utilities.clone(ev);\n    // now restore the true trace object\n    Traces.setDisplayInfo(ev, displayData);\n    return cleanEvent;\n  }\n\n  export function cleanTrace(trace: Trace) {\n    const cleanTrace = [];\n    for (const event of trace) {\n      cleanTrace.push(cleanEvent(<DisplayTraceEvent>event));\n    }\n    return cleanTrace;\n  }\n\n  export function clearDisplayInfo(ev: DisplayTraceEvent) {\n    delete ev.additionalDataTmp.display;\n  }\n\n  export function setDisplayInfo(\n    ev: DisplayTraceEvent,\n    displayInfo: EventDisplayInfo\n  ) {\n    ev.additionalDataTmp.display = displayInfo;\n  }\n\n  export function setTemporaryStatementIdentifier(\n    ev: RecordedRingerEvent,\n    id: number\n  ) {\n    if (!ev.additional) {\n      // not a dom event, can't copy this stuff around\n      return;\n    }\n    // this is where the r+r layer lets us store data that will actually be\n    //   copied over to the new events (for dom events);  recall that it's\n    //   somewhat unreliable because of cascading events; sufficient for us\n    //   because cascading events will appear in the same statement, so can\n    //   have same statement id, but be careful\n    if (!ev.additional.___additionalData___) {\n      ev.additional.___additionalData___ = {};\n    }\n    ev.additional.___additionalData___.temporaryStatementIdentifier = id;\n  }\n\n  export function firstScrapedContentEventInTrace(trace: Trace) {\n    for (const event of trace) {\n      if (\n        event.additional &&\n        event.additional.scrape &&\n        event.additional.scrape.text\n      ) {\n        return event;\n      }\n    }\n    return null;\n  }\n\n  export function getTemporaryStatementIdentifier(ev: RecordedRingerEvent) {\n    if (!ev.additional) {\n      // not a dom event, can't copy this stuff around\n      return null;\n    }\n    return ev.additional.___additionalData___.temporaryStatementIdentifier;\n  }\n\n  export function statementType(ev: RecordedRingerEvent) {\n    if (\n      ev.type === \"completed\" ||\n      ev.type === \"manualload\" ||\n      ev.type === \"webnavigation\"\n    ) {\n      if (!Traces.getVisible(ev)) {\n        return null; // invisible, so we don't care where this goes\n      }\n      return StatementTypes.LOAD;\n    } else if (ev.type === \"dom\") {\n      const domEv = <DOMRingerEvent & RecordedRingerEvent>ev;\n      if (statementToEventMapping.dontcare.includes(domEv.data.type)) {\n        return null; // who cares where blur events go\n      }\n      let lowerXPath = domEv.target.xpath.toLowerCase();\n      if (lowerXPath.indexOf(\"/select[\") > -1) {\n        // this was some kind of interaction with a pulldown, so we have\n        //   something special for this\n        return StatementTypes.PULLDOWNINTERACTION;\n      } else if (statementToEventMapping.mouse.includes(ev.data.type)) {\n        const domEv = <DOMRingerEvent>ev;\n        if (domEv.additional.scrape) {\n          if (domEv.additional.scrape.linkScraping) {\n            return StatementTypes.SCRAPELINK;\n          }\n          return StatementTypes.SCRAPE;\n        }\n        return StatementTypes.MOUSE;\n      } else if (statementToEventMapping.keyboard.includes(ev.data.type)) {\n        /*\n        if (ev.data.type === \"keyup\") {\n          return StatementTypes.KEYUP;\n        }\n        */\n        //if ([16, 17, 18].indexOf(ev.data.keyCode) > -1) {\n        //  // this is just shift, ctrl, or alt key.  don't need to show these to the user\n        //  return null;\n        //}\n        return StatementTypes.KEYBOARD;\n      }\n    }\n    // these events don't matter to the user, so we don't care where this goes\n    return null;\n  }\n\n  export function firstVisibleEvent(trace: Trace) {\n    for (const ev of trace) {\n      const st = statementType(ev);\n      if (st !== null) {\n        return <DisplayTraceEvent>ev;\n      }\n    }\n    throw new ReferenceError(\"No visible events in trace!\");\n  }\n}\n\nfunction strip(str: string, remove: string) {\n  while (str.length > 0 && remove.includes(str.charAt(0))) {\n    str = str.substr(1);\n  }\n  while (str.length > 0 && remove.includes(str.charAt(str.length - 1))) {\n    str = str.substr(0, str.length - 1);\n  }\n  return str;\n}\n","/**\n * DOM events to filter (i.e. ignore) during recording.\n */\nexport namespace RecordingModeFilters {\n  /**\n   * Because Windows has this habit of producing multiple keypress, keydown\n   *   events for a continued key press, we want to throw out events that are\n   *   repeats of events we've already seen. This change fixes a major issue\n   *   with running Helena on Windows, in that the top-level tool chooses to\n   *   ignore events that can be accomplished without running Ringer (e.g.\n   *   scraping relation items), but keydown events can only be accomplished by\n   *   Ringer.  So replay gets slow because of having to replay all the Ringer\n   *   events for each row of the relation.\n   * Note: if we run into issues where holding a key down in a recording\n   *   produces a bad replay, look here first.\n   */\n  export function ignoreExtraKeydowns(event: KeyboardEvent) {\n    if (!window.helenaContent || !window.helenaContent.currentlyPressedKeys) {\n      throw new ReferenceError(\"HelenaContent not loaded correctly.\");\n    }\n    \n    // for now, we'll ignore multiple keypresses for all keys\n    //   (not just ctrl and alt)\n    if (event.type === \"keypress\" || event.type === \"keydown\") { \n      // first seen, record that it's being pressed down\n      if (!window.helenaContent.currentlyPressedKeys[event.keyCode]) { \n        window.helenaContent.currentlyPressedKeys[event.keyCode] = true;\n        return false;\n      } else {  // not first seen, ignore\n        return true;\n      }\n    } else if (event.type === \"keyup\") {\n      // key is no longer being pressed, no longer need to keep track of it\n      window.helenaContent.currentlyPressedKeys[event.keyCode] = false;\n      return false;\n    }\n    return false;\n  }\n}","/**\n * DOM events to filter (i.e. ignore) during scrape mode (e.g. when the Alt\n *   button is pressed down).\n */\nexport namespace ScrapeModeFilters {\n  /**\n   * Filter out extra Ctrl or Alt key events from being recorded, specifically\n   *   for Chrome on Windows in which repeated events are fired when key is\n   *   held down, whereas it is a single event on Mac.\n   */\n  export function ignoreExtraCtrlAlt(event: KeyboardEvent) {\n    // key code 18: alt; key code 17: ctrl\n    return (event.keyCode === 18 || event.keyCode === 17) &&\n        (event.type === \"keypress\" || event.type === \"keydown\");\n  };\n}","import { ScrapeModeHandlers } from \"./scrape_mode_handlers\";\nimport { ScrapingTooltip } from \"../ui/scraping_tooltip\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Highlight } from \"../ui/highlight\";\n\n/**\n * Handlers for user events on the content side while recording.\n */\nexport namespace RecordingModeHandlers {\n  /**\n   * Prevents the right-click menu from opening during recording. Important\n   *   because interactions with the context menu won't be recorded, and\n   *   Helena won't be able to replay them.\n   * @param event context menu event\n   */\n  export function preventOpeningContextMenu(event: MouseEvent) {\n    if (window.helenaContent.currentlyRecording()) {\n      // prevents right click from working\n      event.preventDefault();\n      if (navigator.appVersion.toLocaleLowerCase().indexOf(\"win\") !== -1) {\n        alert(\"Trying to open a new tab? Try CTRL+click instead!\");\n      } else if (\n        navigator.appVersion.toLocaleLowerCase().indexOf(\"mac\") !== -1\n      ) {\n        alert(\"Trying to open a new tab? Try CMD+click instead!\");\n      } else {\n        // linux or unix, depends on computer\n        alert(\n          \"Trying to open a new tab? Use a keyboard shortcut (like CTRL+click) instead!\"\n        );\n      }\n    }\n  }\n\n  /**\n   * Handler for mouseover events.\n   * @param event mouseover event\n   */\n  export function mouseoverHandler(event: MouseEvent) {\n    if (window.helenaContent.currentlyRecording()) {\n      new ScrapingTooltip(<HTMLElement>event.target);\n      window.helenaContent.highlightRelevantRelation(<HTMLElement>event.target);\n    }\n    // just a backup in case the checks on keydown and keyup fail to run, as\n    //   seems to happen sometimes with focus issues\n    updateScraping(event);\n    if (\n      window.helenaContent.currentlyScraping() &&\n      window.helenaContent.currentlyRecording()\n    ) {\n      ScrapeModeHandlers.highlightMouseinElement(event);\n    }\n  }\n\n  /**\n   * Handler for mouseout events.\n   * @param event mouseout event\n   */\n  export function mouseoutHandler(event: MouseEvent) {\n    if (window.helenaContent.currentlyRecording()) {\n      ScrapingTooltip.destroy(<HTMLElement>event.target);\n      window.helenaContent.unhighlightRelation();\n    }\n    // just a backup in case the checks on keydown and keyup fail to run, as\n    //   seems to happen sometimes with focus issues\n    updateScraping(event);\n    if (\n      window.helenaContent.currentlyScraping() &&\n      window.helenaContent.currentlyRecording()\n    ) {\n      ScrapeModeHandlers.unhighlightMouseoutElement(event);\n    }\n  }\n\n  let altDown = false;\n\n  export function updateScraping(event: MouseEvent) {\n    updateScrapingTrackingVars(event);\n    checkScrapingOn();\n    checkScrapingOff();\n  }\n\n  function updateScrapingTrackingVars(event: MouseEvent) {\n    if (event.altKey) {\n      altDown = true;\n    } else {\n      altDown = false;\n    }\n  }\n\n  function checkScrapingOn() {\n    if (!window.helenaContent.currentlyScraping() && altDown) {\n      window.helenaContent.activateScrapeMode();\n\n      if (!window.helenaContent.currentlyRecording()) {\n        // don't want to run this visualization stuff if we're in replay mode\n        //   rather than recording mode, even though of course we're recording\n        //   during replay\n        return;\n      }\n      // want highlight shown now, want clicks to fall through\n      if (window.helenaContent.mostRecentMousemoveTarget) {\n        window.helenaContent.highlightedElement = Highlight.highlightNode(\n          <HTMLElement>window.helenaContent.mostRecentMousemoveTarget,\n          \"#E04343\",\n          true,\n          false\n        );\n      }\n    }\n  }\n\n  function checkScrapingOff() {\n    if (\n      window.helenaContent.currentlyScraping() &&\n      // window.helenaContent.currentlyRecording() &&\n      !altDown\n    ) {\n      window.helenaContent.disableScrapeMode();\n      Highlight.clearHighlight(window.helenaContent.highlightedElement);\n    }\n  }\n\n  function addOverlayDiv(observer: MutationObserver) {\n    // TODO: cjbaik: move to separate file/use some form of templating framework\n    let overlay = $(\n      \"<div id='helena_overlay' style='position: fixed; width: 100%; height: 100%; \\\n                                    top: 0; left: 0; right: 0; bottom: 0; \\\n                                    background-color: rgba(0,0,0,0); \\\n                                    z-index: 2147483647; cursor: pointer;'></div>\"\n    );\n    let messageDiv = $(\n      \"<div style='background-color: rgba(0,255,0,0.85); padding: 10px;'>\\\n        <div style='font-size:20px'>This page is being controlled by Helena.</div>\\\n        If you want to interact with this page anyway, click here to remove the overlay. Keep in mind that navigating away from the current page may disrupt the Helena process.\\\n        </div>\"\n    );\n    overlay.append(messageDiv);\n\n    // if the user clicks on the box with the warning, go ahead and remove the\n    //   whole overlay but stop the observer first, becuase we don't want to add\n    //   it again because of the user's click and resultant removal\n    messageDiv.click(function () {\n      observer.disconnect();\n      overlay.remove();\n    });\n\n    $(\"body\").append(overlay);\n  }\n\n  let addedOverlay = false;\n  export function applyReplayOverlayIfAppropriate(replayWindowId: number) {\n    HelenaConsole.namedLog(\n      \"tooCommon\",\n      \"applyReplayOverlayIfAppropriate\",\n      replayWindowId,\n      window.helenaContent.windowId,\n      addedOverlay\n    );\n\n    // only apply it if we're in the replay window, if we haven't already\n    //   applied it, and if we're the top-level frame\n    if (\n      window.helenaContent.windowId &&\n      replayWindowId === window.helenaContent.windowId &&\n      !addedOverlay &&\n      self === top\n    ) {\n      // ok, we're a page in the current replay window.  put in an overlay\n\n      // and remember, don't add the overlay again in future\n      addedOverlay = true;\n\n      // ok, now one weird thing about this is this alters the structure of the\n      // page if other nodes are added later which can prevent us from finding\n      // things like, say, relations.  so we have to make sure to put it back at\n      // the end of the body nodes list whenever new stuff gets added\n\n      // select the target node\n      let target = document.body;\n      // create an observer instance\n      // configuration of the observer:\n      let config = { childList: true };\n      let observer = new MutationObserver(function (mutations) {\n        mutations.forEach(function (mutation) {\n          // stop observing while we edit it ourself\n          console.log(\"paused observing\");\n          observer.disconnect();\n          $(\"#helena_overlay\").remove();\n          addOverlayDiv(observer);\n          // and start again\n          observer.observe(target, config);\n        });\n      });\n      // pass in the target node, as well as the observer options\n      observer.observe(target, config);\n\n      // now actually add the overlay\n      addOverlayDiv(observer);\n    }\n  }\n}\n","import { Messages } from \"../../common/messages\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport MainpanelNodeI = MainpanelNode.Interface;\nimport { Highlight } from \"../ui/highlight\";\nimport { DOMRingerEvent } from \"../../ringer-record-replay/common/event\";\n\n/**\n * Handlers during \"scrape mode\" when scraping is activated (e.g. when the Alt\n *   button is pressed down).\n */\nexport namespace ScrapeModeHandlers {\n  /**\n   * Send scraped data to the mainpanel for visualization. This line must run\n   *   after the Ringer content script runs so that the\n   *   additional_recording_handlers object exists.\n   */\n  export function sendScrapedDataToMainpanel(node: Node, ev: DOMRingerEvent) {\n    let data: MainpanelNodeI = MainpanelNode.fromDOMNode(node);\n    // convention is SHIFT means we want to scrape the link, not the text \n    let linkScraping = ev.data.shiftKey || ev.data.metaKey;\n    data.linkScraping = linkScraping;\n    if (ev.data.type === \"click\") {\n      Messages.sendMessage(\"content\", \"mainpanel\", \"scrapedData\", data);\n    } // send it to the mainpanel for visualization\n    return data;\n  };\n\n  /**\n   * Updates {@link HelenaContent.mostRecentMousemoveTarget} on mousemove.\n   * @param event mousemove event\n   */\n  export function updateMousemoveTarget(event: Event) {\n    window.helenaContent.mostRecentMousemoveTarget = event.target;\n  }\n\n  /**\n   * Highlights element that triggered a mousein event.\n   * @param event mousein event\n   */\n  export function highlightMouseinElement(event: Event) {\n    if (!window.helenaContent.currentlyRecording()) {\n      // don't want to run this visualization stuff if we're in replay mode\n      //   rather than recording mode, even though of course we're recording\n      //   during replay\n      return;\n    }\n    Highlight.clearHighlight(window.helenaContent.highlightedElement);\n    window.helenaContent.highlightedElement = Highlight.highlightNode(\n      <HTMLElement> event.target, \"#E04343\", true, false);\n  }\n\n  /**\n   * Clears highlight on mouseout.\n   * @param event mouseout event\n   */\n  export function unhighlightMouseoutElement(event: Event) {\n    Highlight.clearHighlight(window.helenaContent.highlightedElement);\n  }\n\n  /**\n   * Prevents click from propagating such that links won't be followed, etc.\n   * @param event click event\n   */\n  export function preventClickPropagation(event: Event) {\n    if (window.helenaContent.currentlyScraping()) {\n      event.stopImmediatePropagation();\n      event.preventDefault();\n    }\n  }\n}","import { ScrapeModeFilters } from \"./filters/scrape_mode_filters\";\nimport { RecordingModeHandlers } from \"./handlers/recording_mode_handlers\";\nimport { ScrapeModeHandlers } from \"./handlers/scrape_mode_handlers\";\nimport { TabDetailsMessage, WindowsMessage, WindowIdMessage, Messages,\n  FastModeMessage, ColumnIndexMessage, LikelyRelationMessage,\n  FreshRelationItemsMessage,\n  RelationMessage} from \"../common/messages\";\nimport { RecordingModeFilters } from \"./filters/recording_mode_filters\";\nimport { RelationHighlighter } from \"./ui/relation_highlighter\";\nimport { Screenshot } from \"./utils/screenshot\";\nimport { MiscUtilities } from \"../common/misc_utilities\";\nimport { RecordState } from \"../ringer-record-replay/common/messages\";\nimport { ContentSelector, RelationSelector } from \"./selector/relation_selector\";\nimport { RelationFinder } from \"./selector/relation_finding\";\nimport { NextButtonSelector } from \"./selector/next_button_selector\";\nimport { HelenaConsole } from \"../common/utils/helena_console\";\n\n/**\n * Stores Helena's global state variables for the content scripts.\n */\nexport class HelenaContent {\n  /** \n   * Whether scraping is enabled/disabled.\n   */\n  public scrapeMode: boolean;\n\n  /**\n   * Information about the Tab in which the content script is running.\n   */\n  public tabId?: number;\n  public windowId?: number;\n  public tabTopUrl?: string;\n\n  /**\n   * Keep track of the last Element the user was hovering over so that it can be\n   *   highlighted when the user enters scrape mode.\n   */\n  public mostRecentMousemoveTarget?: EventTarget | null;\n\n  /**\n   * Keep track of keys currently being pressed down as a map from keyCode to\n   *   boolean (true means pressed).\n   */\n  public currentlyPressedKeys?: { [key: number]: boolean };\n\n  /**\n   * Highlighted element when in scrape mode.\n   */\n  public highlightedElement?: JQuery<HTMLElement>;\n\n  /**\n   * Record and replay state.\n   */\n  public currentRecordingWindows?: number[];\n  public currentReplayWindowId?: number;\n\n  public currentSelectorToEdit: ContentSelector | null;\n  public relationHighlighter: RelationHighlighter;\n\n\n  /**\n   * Fast mode: good for speed, bad for evolving webpages.\n   */\n  ringerUseXpathFastMode = false;\n\n  public currentlyRecording() {\n    // `recording` is defined in scripts/lib/record-replay/content_script.js,\n    //   tells whether r+r layer currently recording\n    return window.ringerContent.recording === RecordState.RECORDING\n      && this.windowId && this.currentRecordingWindows\n      && this.currentRecordingWindows.indexOf(this.windowId) > -1;\n  }\n\n  /**\n   * Returns true if currently scraping (e.g. Alt key held down).\n   */\n  public currentlyScraping() {\n    return this.scrapeMode;\n  }\n\n  /**\n   * Activates Helena's scrape mode.\n   */\n  public activateScrapeMode() {\n    this.scrapeMode = true;\n\n    window.ringerContent.additional_recording_handlers_on.scrape = true;\n    window.ringerContent.additional_recording_filters_on.ignoreExtraCtrlAlt =\n      true;\n  }\n\n  /**\n   * Disables Helena's scrape mode.\n   */\n  public disableScrapeMode() {\n    this.scrapeMode = false;\n\n    window.ringerContent.additional_recording_handlers_on.scrape = false;\n    window.ringerContent.additional_recording_filters_on.ignoreExtraCtrlAlt =\n      false;\n  }\n\n  /**\n   * Highlights relevant relation to element.\n   * @param element element\n   */\n  public highlightRelevantRelation(element: HTMLElement) {\n    this.relationHighlighter.highlightRelevantRelation(element);\n  }\n\n  /**\n   * Unhighlights highlighted relation.\n   */\n  public unhighlightRelation() {\n    this.relationHighlighter.unhighlight();\n  }\n\n  constructor() {\n    this.scrapeMode = false;\n    this.currentlyPressedKeys = {};\n    this.relationHighlighter = new RelationHighlighter();\n\n    this.pollForState();\n\n    this.initializeStartRecordingHooks();\n\n    this.initializeRecordingModeFilters();\n    this.initializeScrapeModeFilters();\n\n    this.initializeRecordingModeHandlers();\n    this.initializeScrapeModeHandlers();\n\n    this.listenForMainpanelMessages();\n  }\n\n  /**\n   * Polls mainpanel and background for state, presumably because you can't\n   *   directly access this information in content scripts.\n   */\n  private pollForState() {\n    const self = this;\n\n    /*\n     * 1. Set up initial listeners.\n     */\n    Messages.listenForMessage(\"background\", \"content\", \"tabID\",\n    function (msg: TabDetailsMessage) {\n        self.tabId = msg.tab_id;\n        self.windowId = msg.window_id;\n        self.tabTopUrl = msg.top_frame_url;\n        console.log(\"tabId info\", self.tabId, self.windowId,\n            self.tabTopUrl);\n      }\n    );\n    Messages.listenForMessage(\"mainpanel\", \"content\",\n      \"currentRecordingWindows\", function (msg: WindowsMessage) {\n        self.currentRecordingWindows = msg.window_ids;\n    });\n\n    Messages.listenForMessage(\"mainpanel\", \"content\",\n      \"currentReplayWindowId\", function (msg: WindowIdMessage) {\n        self.currentReplayWindowId = msg.window; \n        RecordingModeHandlers.applyReplayOverlayIfAppropriate(msg.window);\n    });\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"ringerUseXpathFastMode\", \n      (msg: FastModeMessage) => { self.ringerUseXpathFastMode = msg.use; });\n\n    /*\n     * 2. Poll mainpanel and background.\n     * TODO: cjbaik: switch this pattern to a port connection rather than\n     *   doing this polling\n     * TODO: cjbaik: also, the ordering of these matters; requestTabID has to\n     *   happen first...\n     */\n    MiscUtilities.repeatUntil(\n      function() {\n          Messages.sendMessage(\"content\", \"background\",\n              \"requestTabID\", {});\n      },\n      function() {\n          return (self.tabId && self.windowId);\n      },\n      function() {},\n      1000, true);\n\n    MiscUtilities.repeatUntil(\n      function () {\n          Messages.sendMessage(\"content\", \"mainpanel\",\n              \"requestCurrentRecordingWindows\", {});\n      },\n      function () {\n          return !!self.currentRecordingWindows;\n      },\n      function () {},\n      1000, true);\n\n    MiscUtilities.repeatUntil(\n      function () {\n          Messages.sendMessage(\"content\", \"mainpanel\",\n              \"currentReplayWindowId\", {});\n      },\n      function () {\n          return !!self.currentReplayWindowId;\n      },\n      function () {},\n      1000, true);\n    \n    Messages.sendMessage(\"content\", \"mainpanel\",\n      \"requestRingerUseXpathFastMode\", {});\n  }\n  \n  /**\n   * Initialize hooks for when recording starts.\n   */\n  private initializeStartRecordingHooks() {\n    window.ringerContent.addonStartRecording.push(\n      // Without the `bind` call, `getKnownRelations` seems to reference the\n      //   wrong `this` object.\n      this.relationHighlighter.getKnownRelations.bind(\n        this.relationHighlighter));\n  }\n\n  /**\n   * Initializes recording mode handlers.\n   */\n  private initializeRecordingModeHandlers() {\n    window.ringerContent.additional_recording_handlers_on.visualization = true;\n    window.ringerContent.additional_recording_handlers.visualization =\n      Screenshot.take;\n\n    document.addEventListener('contextmenu',\n      RecordingModeHandlers.preventOpeningContextMenu, true);\n    document.addEventListener('mouseover',\n      RecordingModeHandlers.mouseoverHandler, true);\n    document.addEventListener('mouseout',\n      RecordingModeHandlers.mouseoutHandler, true);\n    document.addEventListener('keydown',\n      RecordingModeHandlers.updateScraping, true);\n    document.addEventListener('keyup',\n      RecordingModeHandlers.updateScraping, true);\n  }\n\n  /**\n   * Initializes recording mode filters (i.e. things not to record).\n   */\n  private initializeRecordingModeFilters() {\n    window.ringerContent.additional_recording_filters_on.ignoreExtraKeydowns =\n      true;\n    window.ringerContent.additional_recording_filters.ignoreExtraKeydowns = \n      RecordingModeFilters.ignoreExtraKeydowns;\n  }\n\n  /**\n   * Initializes scrape mode filters (i.e. things not to record).\n   */\n  private initializeScrapeModeFilters() {\n    window.ringerContent.additional_recording_filters.ignoreExtraCtrlAlt =\n      ScrapeModeFilters.ignoreExtraCtrlAlt;\n  }\n\n  /**\n   * Initializes scrape mode (e.g. when Alt button pressed) handlers.\n   */\n  private initializeScrapeModeHandlers() {\n    window.ringerContent.additional_recording_handlers.scrape =\n      ScrapeModeHandlers.sendScrapedDataToMainpanel;\n  \n    document.addEventListener('mousemove',\n      ScrapeModeHandlers.updateMousemoveTarget, true);\n    document.addEventListener('click',\n      ScrapeModeHandlers.preventClickPropagation, true);\n  }\n\n  private listenForMainpanelMessages() {\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"getRelationItems\",\n      (msg: RelationMessage) => {\n        const selector = RelationSelector.fromMessage(msg);\n        RelationFinder.sendMatchingRelationToMainpanel(selector);\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"getFreshRelationItems\",\n      (msg: RelationMessage) => {\n        const selector = RelationSelector.fromMessage(msg);\n        RelationFinder.getFreshRelationItems(selector);\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"editRelation\",\n      (msg: RelationMessage) => {\n        const selector = RelationSelector.fromMessage(msg);\n        RelationFinder.editRelation(selector);\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"nextButtonSelector\",\n      () => {\n        NextButtonSelector.listenForNextButtonClick();\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"clearNextButtonSelector\",\n      () => {\n        NextButtonSelector.unhighlightNextButton();\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"backButton\", () => {\n      history.back();\n    });\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"pageStats\", () => {\n      Messages.sendMessage(\"content\", \"mainpanel\", \"pageStats\", {\n        numNodes: document.querySelectorAll('*').length\n      });\n    });\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"runNextInteraction\",\n      (msg: RelationMessage) => {\n        // let selector = RelationSelector.fromMessage(msg);\n        RelationFinder.getNextPage(msg);\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"currentColumnIndex\",\n      (msg: ColumnIndexMessage) => {\n        RelationFinder.setEditRelationIndex(msg.index);\n      }\n    );\n\n    Messages.listenForMessage(\"mainpanel\", \"content\", \"clearRelationInfo\",\n      (msg: RelationMessage) => {\n        // let selector = RelationSelector.fromMessage(msg);\n        RelationFinder.clearRelationInfo(msg);\n      }\n    );\n\n    Messages.listenForFrameSpecificMessage(\"mainpanel\", \"content\",\n      \"likelyRelation\", (msg: object, sendResponse: Function) => {\n        MiscUtilities.registerCurrentResponseRequested(msg,\n          (m: LikelyRelationMessage) => {\n            let likelyRel = RelationFinder.likelyRelation(m);\n            console.log('likelyRel', likelyRel);\n            if (likelyRel) {\n              sendResponse(likelyRel);\n            }\n          }\n        );\n      }\n    );\n\n    Messages.listenForFrameSpecificMessage(\"mainpanel\", \"content\",\n    \"getFreshRelationItems\", (msg: object, sendResponse: Function) => {\n      MiscUtilities.registerCurrentResponseRequested(msg, \n        (msg: RelationMessage) => {\n          const selector = RelationSelector.fromMessage(msg);\n          RelationFinder.getFreshRelationItemsHelper(selector,\n            (freshRelationItems: FreshRelationItemsMessage) => {\n              HelenaConsole.namedLog(\"getRelationItems\",\n                'freshRelationItems, about to send', freshRelationItems.type,\n                freshRelationItems);\n              sendResponse(freshRelationItems);\n            }\n          );\n        });\n      }\n    );\n  }\n}","import { XPath } from \"../utils/xpath\";\nimport SuffixXPathList = XPath.SuffixXPathList;\nimport { ColumnSelectorMessage } from \"../../common/messages\";\nimport { MiscUtilities } from \"../../common/misc_utilities\";\nimport { IColumnSelector } from \"./interfaces\";\n\n/**\n  * A selector describing how to extract a column of a relation with respect to\n  *   some kind of common ancestor describing a row.\n  */\nexport namespace ColumnSelector {\n  export function fromMessage(\n      msgCols: (ColumnSelectorMessage | IColumnSelector)[]) {\n    let result: IColumnSelector[] = [];\n\n    for (const msgCol of msgCols) {\n      if (MiscUtilities.depthOf(msgCol.suffix) < 3) {\n        result.push({\n          xpath: msgCol.xpath,\n          suffix: [<SuffixXPathList> msgCol.suffix],\n          name: msgCol.name,\n          id: msgCol.id,\n          index: msgCol.index\n        });\n      } else {\n        result.push({\n          xpath: msgCol.xpath,\n          suffix: <SuffixXPathList[]> msgCol.suffix,\n          name: msgCol.name,\n          id: msgCol.id,\n          index: msgCol.index\n        });\n      }\n    }\n    return result;\n  }\n  \n  /**\n   * Gets array of {@link IColumnSelector} of each descendant element\n   *   given the ancestor element.\n   * @param ancestor ancestor element\n   * @param descendants descendant elements\n   */\n  export function compute(ancestor: HTMLElement,\n    descendants: (HTMLElement | null)[]) {\n    let columns: IColumnSelector[] = [];\n    for (const descendant of descendants) {\n      if (!descendant) {\n        throw new ReferenceError('TODO: This descendant is null. Handle it?');\n      }\n      let xpath = <string> XPath.fromNode(descendant);\n      let suffix = XPath.suffixFromAncestor(ancestor, descendant);\n      columns.push({\n        xpath: xpath,\n        suffix: [suffix],\n        id: null\n      });\n    }\n    return columns;\n  }\n}","import { XPath } from \"../utils/xpath\";\nimport SuffixXPathList = XPath.SuffixXPathList;\n\n/**\n * Types of next or more buttons.\n */\nexport enum NextButtonTypes {\n  NONE = 1,\n  NEXTBUTTON,\n  MOREBUTTON,\n  SCROLLFORMORE\n}\n\nexport interface INextButtonSelector {\n  id: string;\n  class: string;\n  src: string | null;\n  frame_id?: number;\n  tag: string;\n  text: string | null;\n  xpath: string;\n}\n\nexport interface IColumnSelector {\n  xpath?: string;\n  suffix?: SuffixXPathList[]; // not single suffix, but a list of candidates\n  name?: string;\n  id?: number | null;\n  index?: string;\n  scraped?: boolean;\n\n  firstRowXpath?: string;\n  firstRowText?: string;\n  firstRowValue?: string;\n}","import { XPath } from \"../utils/xpath\";\nimport { NextButtonSelectorMessage, Messages } from \"../../common/messages\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Highlight } from \"../ui/highlight\";\nimport { Utilities } from \"../../ringer-record-replay/common/utils\";\nimport { INextButtonSelector } from \"./interfaces\";\n\n/**\n * Methods for selecting a next/pagination button on a page.\n */\nexport namespace NextButtonSelector {\n  export let listeningForNextButtonClick = false;\n  /**\n   * Activate state of listening for a click on the next button.\n   */\n  export function listenForNextButtonClick() {\n    // ok, now we're listening for a next button click\n    listeningForNextButtonClick = true;\n    unhighlightNextButton(); // unhighlight existing one if present\n    \n    // in case the highlighting of cells blocks the next button, hide this\n    window.helenaContent.relationHighlighter.clearCurrentlyHighlighted(); \n  }\n\n  /**\n   * Records the event target as the next button by sending information about it\n   *   to the mainpanel.\n   * @param event the click event\n   */\n  export function record(event: MouseEvent) {\n    listeningForNextButtonClick = false;\n\n    event.stopPropagation();\n    event.preventDefault();\n\n    if (!event.target) {\n      throw new ReferenceError('Event has no target!');\n    }\n    \n    let nextOrMoreButton = <HTMLElement> event.target;\n    let data: INextButtonSelector = {\n      tag: nextOrMoreButton.tagName,\n      text: nextOrMoreButton.textContent,\n      id: nextOrMoreButton.id,\n      class: nextOrMoreButton.className,\n      src: nextOrMoreButton.getAttribute('src'),\n      xpath: <string> XPath.fromNode(nextOrMoreButton),\n      frame_id: window.ringerContent.frameId\n    }\n    \n    const msg: NextButtonSelectorMessage = { selector: data };\n    Messages.sendMessage(\"content\", \"mainpanel\", \"nextButtonSelector\", msg);\n    highlightNextButton(data);\n\n    if (window.helenaContent.currentSelectorToEdit) {\n      window.helenaContent.currentSelectorToEdit.highlight();\n    }\n  }\n\n  /**\n   * Determines whether a candidate element is a promising next button\n   * @param nextSelector selector for the next button\n   * @param candEl the candidate element to check\n   * @param priorPageIndexText if traversing to pagination, the string of the\n   *   last page index clicked\n   */\n  function isPromisingNextButton(nextSelector: INextButtonSelector,\n    candEl: HTMLElement, priorPageIndexText?: string) {\n    // either there's an actual image and it's the same, or the text is the same\n    if (nextSelector.src) {\n      return (candEl.getAttribute('src') === nextSelector.src);\n    }\n    if (!priorPageIndexText || isNaN(+priorPageIndexText)) {\n      // we don't have a past next button or the past next button wasn't numeric\n      //   so just look for the exact text\n      return (candEl.textContent === nextSelector.text);\n    } else {\n      // it was a number!  so we're looking for the next number bigger than this\n      //   one...\n      // oh cool, there's been a prior next button, and it had a number text\n      //   we'd better look for a button like it but that has a bigger number...\n      // todo: make this more robust\n      let prior = parseInt(priorPageIndexText);\n      let currNodeText = candEl.textContent;\n      if (!currNodeText) {\n        throw new ReferenceError('Current element has no textContent.');\n      }\n      if (isNaN(+currNodeText)){\n        return false;\n      }\n      let curr = parseInt(currNodeText);\n      if (curr > prior){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Finds the next button for the current page given a next button selector.\n   * @param selector next button selector\n   * @param priorPageIndexText if page button, a string indicating the number of\n   *   the last page index\n   */\n  export function findNextButton(selector: INextButtonSelector,\n    priorPageIndexText?: string): HTMLElement | null {\n    HelenaConsole.log(selector);\n\n    let next_or_more_button_text = selector.text;\n    let candButtons = [].slice.call(\n      document.querySelectorAll(selector.tag)\n    );\n    candButtons = candButtons.filter((button: HTMLElement) =>\n      isPromisingNextButton(selector, button, priorPageIndexText)\n    );\n    HelenaConsole.namedLog(\"findNextButton\", \"candidate_buttons\",\n      candButtons);\n\n    let doNumberVersion = priorPageIndexText && !isNaN(+priorPageIndexText);\n\n    // hope there's only one button\n    if (candButtons.length === 1 && !doNumberVersion) {\n      HelenaConsole.namedLog(\"findNextButton\", \"only one button\");\n      return candButtons[0];\n    }\n    \n    // if not and demo button had id, try using the id\n    if (selector.id && selector.id !== \"\" && !doNumberVersion) {\n      HelenaConsole.namedLog(\"findNextButton\", \"we had an id\")\n      let idElement = document.getElementById(selector.id);\n      if (idElement) {\n        return idElement;\n      }\n    }\n\n    // if not and demo button had class, try using the class\n    let cbuttons = candButtons.filter((cand: HTMLElement) => \n      cand.className === selector.class);\n    if (cbuttons.length === 1 && !doNumberVersion) {\n      HelenaConsole.namedLog(\"findNextButton\",\n        \"filtered by class and there was only one\");\n      return cbuttons[0];\n    }\n    // ok, another case where we probably want to decide based on sharing class\n    // is the case where we have numeric next buttons\n    let lowestNodeSoFar = null\n    if (priorPageIndexText && !isNaN(+priorPageIndexText)) {\n      HelenaConsole.namedLog(\"findNextButton\",\n        \"filtered by class and now trying to do numeric\");\n      \n      // let's go through and just figure out which one has the next highest number relative to the prior next button text\n      let lsToSearch = cbuttons;\n      if (cbuttons.length < 1) {\n        lsToSearch = candButtons;\n      }\n      let priorButtonNum = parseInt(priorPageIndexText);\n      let lowestNumSoFar = Number.MAX_VALUE;\n      HelenaConsole.namedLog(\"findNextButton\", \"potential buttons\",\n        lsToSearch);\n      for (const button of lsToSearch) {\n        let buttonText = button.textContent;\n        console.log(\"button\", button, buttonText);\n        var buttonNum = parseInt(buttonText);\n        console.log(\"comparison\", buttonNum, lowestNumSoFar, priorButtonNum,\n          buttonNum < lowestNumSoFar, buttonNum > priorButtonNum);\n        if (buttonNum < lowestNumSoFar && buttonNum > priorButtonNum){\n          lowestNumSoFar = buttonNum;\n          lowestNodeSoFar = button;\n        }\n      }\n    }\n\n    if (lowestNodeSoFar) {\n      HelenaConsole.namedLog(\"findNextButton\", \"numeric worked\");\n      return lowestNodeSoFar;\n    } else {\n      //see which candidate has the right text and closest xpath\n      let min_distance = 999999;\n      let min_candidate = null;\n      for (const candButton of candButtons) {\n        let candXPath = XPath.fromNode(candButton);\n        let distance = Utilities.levenshteinDistance(candXPath,\n          selector.xpath);\n        if (distance < min_distance){\n          min_distance = distance;\n          min_candidate = candButton;\n        }\n      }\n      if (min_candidate === null) {\n        HelenaConsole.log(\"couldn't find an appropriate 'more' button\");\n        HelenaConsole.log(selector.tag, selector.id,\n          next_or_more_button_text, selector.xpath);\n      }\n      return min_candidate;\n    }\n  }\n\n  let nextOrMoreButtonHighlight: JQuery<HTMLElement> | undefined = undefined;\n  /**\n   * Highlights the next button given by the selector.\n   * @param selector the next button selector\n   */\n  export function highlightNextButton(selector: INextButtonSelector) {\n    HelenaConsole.log(selector);\n    let button = findNextButton(selector);\n    if (button) {\n      nextOrMoreButtonHighlight = Highlight.highlightNode(button, \"#E04343\",\n        true);\n    }\n  }\n\n  /**\n   * Clears highlighted next button, if any.\n   */\n  export function unhighlightNextButton() {\n    if (nextOrMoreButtonHighlight !== undefined) {\n      Highlight.clearHighlight(nextOrMoreButtonHighlight);\n    }\n  }\n}","import { Messages, RelationMessage } from \"../../common/messages\";\n\nimport { PulldownSelector, ContentSelector, ComparisonSelector,\n  RelationSelector, TableSelector } from \"./relation_selector\";\n\nimport { NextButtonSelector } from \"./next_button_selector\";\n\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport MainpanelNodeI = MainpanelNode.Interface;\n\nimport { XPath } from \"../utils/xpath\";\nimport SuffixXPathList = XPath.SuffixXPathList;\n\nimport { EditRelationMessage, LikelyRelationMessage,\n  FreshRelationItemsMessage } from \"../../common/messages\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { HelenaConfig } from \"../../common/config/config\";\nimport { Highlight } from \"../ui/highlight\";\nimport { ScrapedRelationState } from \"../../mainpanel/relation/relation\";\nimport { NextButtonTypes, INextButtonSelector, IColumnSelector } from \"./interfaces\";\nimport { ColumnSelector } from \"./column_selector\";\n\nexport interface ScrapedElement extends HTMLElement {\n  ___relationFinderId___?: number;\n}\n\nexport namespace RelationFinder {\n\n/**********************************************************************\n * How to actually synthesize the selectors used by the relation-finder above\n **********************************************************************/\n\n  /**\n   * Returns the XPath expression in xpaths that are not a component of any of\n   *   the xpaths of the cells.\n   * @param xpaths XPath expressions\n   * @param cells cells in mainpanel representation\n   */\n  function unmatchedXpaths(xpaths: string[], cells: MainpanelNodeI[]) {\n    let cellXPaths = cells.map((cell) => cell.xpath);\n    return xpaths.filter((xpath) => !cellXPaths.includes(xpath));\n  }\n\n  let processedCount = 0;\n  let processedLikelyRelationRequest = false;\n  /**\n   * Retrieve the {@link RelationSelector} of the most likely relation given\n   *   the information in the message.\n   * @param msg message about likely relation\n   */\n  export function likelyRelation(msg: LikelyRelationMessage) {\n    if (processedLikelyRelationRequest) {\n      // should only even send a likely relation once from one page, since it\n      //   gets closed after we get the answer we wanted may end up sending\n      //   multiples if we're sent the inciting message multiple times because\n      //   the page loads slowly\n      return;\n    }\n\n    let xpaths = msg.xpaths;\n\n    // we're going to do something a little different for the case where one or\n    //   more nodes come from pulldown menus\n    let pulldownxpaths: string[] = [];\n    if (xpaths) {\n      for (const xpath of xpaths) {\n        if (xpath.toLowerCase().includes(\"/select[\")) {\n          // ok, we've grabbed something from a pulldown\n          pulldownxpaths.push(xpath);\n        }\n      }      \n    }\n\n    // for pulldown xpaths, we'll do something different\n    let pulldownRelations = PulldownSelector.fromXPaths(msg, pulldownxpaths);\n\n    // for the non-pulldown xpaths, we'll proceed with normal processing\n    let nonPulldownXPaths = xpaths.filter((xpath) =>\n      !pulldownxpaths.includes(xpath));\n\n    let elements = XPath.getFirstElementOfEach(nonPulldownXPaths);\n\n    let maxNodesCoveredByServerRelations = 0;\n    let serverSuggestedRelations = msg.serverSuggestedRelations;\n    if (serverSuggestedRelations){\n      for (const rel of serverSuggestedRelations) {\n        if (!rel) {\n          continue;\n        }\n        let columns = rel.columns;\n        let relXpaths = columns.map((col: IColumnSelector) => col.xpath);\n        HelenaConsole.log(relXpaths);\n\n        let matched = 0;\n        for (const xpath of nonPulldownXPaths) {\n          if (relXpaths.includes(xpath)) {\n            matched += 1;\n          }\n        }\n\n        if (matched > maxNodesCoveredByServerRelations){\n          maxNodesCoveredByServerRelations = matched;\n        }\n      }\n      HelenaConsole.log(\"maxNodesCoveredByServerRelations\",\n        maxNodesCoveredByServerRelations);\n    }\n\n    // if this is actually in an html table, let's take a shortcut, since some\n    //   sites use massive tables and trying to run the other approach would\n    //   take forever\n    let selector: TableSelector | ContentSelector | null =\n      TableSelector.fromTableRow(elements);\n\n    if (selector === null) {\n      // ok, no table, we have to do the standard, possibly slow approach\n      selector = ContentSelector.fromLargestRowSubset(elements,\n        maxNodesCoveredByServerRelations + 1);\n    }\n    if (selector === null) {\n      selector = new ContentSelector({}, 0, []);\n      selector.relation = [];\n      console.warn(\"Generated empty selector, not sure what it means.\");\n    }\n\n    // this (above) is the candidate we auto-generate from the page, but want to\n    //   compare to the relations the server-suggested criteria.\n    let bestSelectorIsNew = true;\n    let curBestSelector = selector.toComparisonSelector(\n      MainpanelNode.convertRelation(selector.relation),\n      xpaths);\n\n    if (serverSuggestedRelations) {\n      for (const serverSelectorMsg of serverSuggestedRelations) {\n        if (serverSelectorMsg === null) {\n          continue;\n        }\n        // let serverSelector = RelationSelector.fromMessage(serverRel);\n\n        const serverSelector = new RelationSelector(serverSelectorMsg.selector,\n          serverSelectorMsg.exclude_first,\n          ColumnSelector.fromMessage(serverSelectorMsg.columns),\n          serverSelectorMsg.selector_version);\n        serverSelector.next_button_selector =\n          serverSelectorMsg.next_button_selector;\n        let relationNodes = serverSelector.getMatchingRelation();\n        if (relationNodes.length === 0){\n          // no need to consider empty one\n          continue;\n        }\n        \n        let compServerSel = serverSelector.toComparisonSelector(\n          MainpanelNode.convertRelation(relationNodes), xpaths);\n\n        // use the server-provided rel as our default, since that'll make the\n        //   server-side processing when we save the relation easier, and also\n        //   gives us the nice names\n        let newBestSelector = ComparisonSelector.bestOf(compServerSel,\n          curBestSelector);\n        if (newBestSelector !== curBestSelector){\n          curBestSelector = newBestSelector;\n          bestSelectorIsNew = false;\n        }\n      }\n    }\n\n    // ok, we've picked our best selector.  of course, it's possible it doesn't\n    //   cover all columns if it doesn't cover all columns, we're willing to add\n    //   up to one more supplementary selector\n    // todo: in future, consider adding more than one additional selector --\n    //   may need up to one selector per column but for now, we'll try one\n    let uncoveredSoFar = unmatchedXpaths(xpaths, curBestSelector.relation[0]);\n    HelenaConsole.log(\"uncoveredSoFar\", uncoveredSoFar);\n    if (uncoveredSoFar.length > 0) {\n      // let's see if we can cover as many as possible of the remaining nodes\n      let uncoveredNodes = XPath.getFirstElementOfEach(uncoveredSoFar);\n      let newSelector = ContentSelector.fromLargestRowSubset(uncoveredNodes, 0);\n      \n      // now reason about the length of the lists and whether it even makes\n      //   sense to pair them\n      if (newSelector &&\n        curBestSelector.relation?.length === newSelector.relation?.length){\n        HelenaConsole.log(\"We're adding an additional selector.\", newSelector);\n        curBestSelector.merge(newSelector);\n        let rel = curBestSelector.getMatchingRelation();\n        curBestSelector.relation = MainpanelNode.convertRelation(rel);\n        HelenaConsole.log(\"currBestSelector.relation\", curBestSelector.relation);\n      }\n    }\n\n    // this pageVarName is used by the mainpanel to keep track of which pages\n    //   have been handled already\n    let resultSelector = new RelationSelector(curBestSelector.selector,\n      curBestSelector.exclude_first, curBestSelector.columns);\n    resultSelector.first_page_relation = curBestSelector.relation;\n    resultSelector.num_rows_in_demonstration = curBestSelector.relation.length;\n    resultSelector.page_var_name = msg.pageVarName;\n    resultSelector.url = window.location.href;\n\n    if (bestSelectorIsNew) {\n      resultSelector.relation_id = null;\n      resultSelector.name = null;\n      // we always guess that there are no more items (no more pages), and user\n      //   has to correct it if this is not the case\n      resultSelector.next_type = NextButtonTypes.NONE;\n      resultSelector.next_button_selector = null;\n    } else {\n      resultSelector.relation_id = curBestSelector.id;\n      resultSelector.name = curBestSelector.name;\n      resultSelector.next_type = curBestSelector.next_type;\n      resultSelector.next_button_selector =\n        curBestSelector.next_button_selector;\n    }\n    HelenaConsole.log(\"currBestSelector\", curBestSelector);\n\n    if (pulldownRelations.length > 0){\n      resultSelector.pulldown_relations = pulldownRelations;\n    }\n\n    if (curBestSelector.relation.length < 1 && pulldownRelations.length < 1) {\n      processedCount += 1;\n      if (processedCount < 10) {\n        // ok, looks like we don't actually have any data yet.  might be because\n        // data hasn't fully loaded on page yet the mainpanel will keep asking\n        // for likelyrelations, so let's wait a while, see if the next time\n        // works; try 10 times\n        // todo: not sure this is where we want to deal with this?\n        return null;\n      }\n    }\n\n    //Messages.sendMessage(\"content\", \"mainpanel\", \"likelyRelation\", newMsg);\n    processedLikelyRelationRequest = true;\n    return resultSelector; // return rather than sendmessage because it's a builtin response handler one\n  }\n\n  /**\n   * Send relation matching selector to mainpanel.\n   * @param selector selector\n   */\n  export function sendMatchingRelationToMainpanel(selector: RelationSelector) {\n    if (!selector.selector_version){\n      console.error(\"No selector version!!!\");\n    }\n    let relation = selector.getMatchingRelation();\n    let relationData = MainpanelNode.convertRelation(relation);\n    Messages.sendMessage(\"content\", \"mainpanel\", \"relationItems\", \n      { relation: relationData });\n    return relationData;\n  }\n\n/**********************************************************************\n * Everything we need for editing a relation selector\n **********************************************************************/\n\n  let currentSelectorEmptyOnThisPage = false;\n  export function editRelation(selector: RelationSelector) {\n    if (window.helenaContent.currentSelectorToEdit !== null) {\n      // we've already set up to edit a selector, and we should never use the\n      //   same tab to edit multiples always close tab and reload.  so don't run\n      //   setup again\n      return;\n    }\n    // Messages.sendMessage(\"mainpanel\", \"content\", \"editRelation\", {selector: this.selector, selector_version: this.selectorVersion, exclude_first: this.excludeFirst, columns: this.columns}, null, null, [tab.id]);};\n    window.helenaContent.currentSelectorToEdit = <ContentSelector> selector;\n\n    // TODO: cjbaik: do we need to remove this listener at any point?\n    document.addEventListener('click', editingClick, true);\n\n    // don't try to process the page till it's loaded!  jquery onloaded stuff\n    //   will run immediately if page already loaded, once loaded else\n    let editingSetup = function() {\n      if (!window.helenaContent.currentSelectorToEdit) {\n        throw new ReferenceError('Current selector to edit is null!');\n      }\n\n      let contentSelector = window.helenaContent.currentSelectorToEdit.toContentSelector();\n      if (contentSelector.relation.length < 1) {\n        // ugh, but maybe the page just hasn't really finished loading, so try again in a sec\n        // setTimeout(editingSetup, 1000);\n\t      // but also need to send the editing colors just in case\n\t      sendEditedSelectorToMainpanel(contentSelector);\n        currentSelectorEmptyOnThisPage = true;\n        return;\n      }\n      contentSelector.highlight();\n      // start with the assumption that the first row should definitely be included\n      selector.positive_nodes = [\n        XPath.findCommonAncestor(contentSelector.relation[0]),\n        XPath.findCommonAncestor(contentSelector.relation[1])\n      ];\n      selector.negative_nodes = [];\n      sendEditedSelectorToMainpanel(contentSelector);\n      if (selector.next_type === NextButtonTypes.NEXTBUTTON ||\n          selector.next_type === NextButtonTypes.MOREBUTTON) {\n        NextButtonSelector.highlightNextButton(\n          <INextButtonSelector> selector.next_button_selector);\n      }\n\n      // we want to highlight the currently hovered node\n      // TODO: cjbaik: move this document event listener? esp if editRelation\n      //   gets called multiple times...\n      document.addEventListener('mouseenter', highlightHovered, true);\n\n      // also, if we have a selector highlighted, and the user scrolls, we're\n      //   going to need to update...\n      // TODO: cjbaik: move this too\n      let didScroll = false;\n      document.addEventListener('scroll', (e) => didScroll = true );\n      \n      // cjbaik: formerly, I don't think the '*' was desired behavior?\n      // $('*').scroll(function () {\n      //   didScroll = true;\n      // });\n\n      setInterval(function () {\n        if ( didScroll ) {\n          didScroll = false;\n          // Ok, we're ready to redo the relation highlighting with new page\n          //   situation\n          HelenaConsole.log(\"scroll updating\");\n          newSelectorGuess(contentSelector);\n        }\n        }, 250);\n    };\n\n    $(editingSetup);\n  }\n\n  export function setEditRelationIndex(index: number) {\n    if (!window.helenaContent.currentSelectorToEdit) {\n      throw new ReferenceError('No selector to edit!');\n    }\n    window.helenaContent.currentSelectorToEdit.editingClickColumnIndex = index;\n  }\n\n  let currentHoverHighlight: JQuery<HTMLElement> | undefined = undefined;\n  function highlightHovered(event: Event) {\n    let prevHoverHighlight = currentHoverHighlight;\n    let color = \"#9D00FF\";\n    if (NextButtonSelector.listeningForNextButtonClick) {\n      color = \"#E04343\";\n    }\n    if (prevHoverHighlight) {\n      prevHoverHighlight.remove();\n      prevHoverHighlight = undefined;\n    }\n    if (event.target && event.target instanceof HTMLElement) {\n      currentHoverHighlight = Highlight.highlightNode(event.target, color);\n    }\n  }\n\n  // let currentSelectorHighlightNodes: JQuery<HTMLElement>[] = [];\n  /*export function highlightSelector(selector: ContentSelector) {\n    // we want to allow clicks on the highlights (see editingClick)\n    currentSelectorHighlightNodes =\n      window.helenaContent.relationHighlighter.highlightRelation(\n        selector.relation, true, true);\n  };*/\n\n  /**\n   * Send edited selector to the mainpanel.\n   * @param selector selector\n   */\n  export function sendEditedSelectorToMainpanel(selector: RelationSelector) {\n    if (!selector.relation) {\n      throw new ReferenceError(\"Relation not set on selector.\");\n    }\n\n    let mainpanelSelector = <RelationSelector & EditRelationMessage> selector;\n\n    mainpanelSelector.demonstration_time_relation =\n      MainpanelNode.convertRelation(\n        <(HTMLElement | null)[][]> selector.relation\n    );\n    mainpanelSelector.relation = null;\n    mainpanelSelector.colors =\n      window.helenaContent.relationHighlighter.highlightColors;\n\n    Messages.sendMessage(\"content\", \"mainpanel\", \"editRelation\",\n      mainpanelSelector);\n  }\n\n  /*\n  export function clearCurrentSelectorHighlight(){\n    for (var i = 0; i < currentSelectorHighlightNodes.length; i++) {\n      Highlight.clearHighlight(currentSelectorHighlightNodes[i]);\n    }\n    currentSelectorHighlightNodes = [];\n  };*/\n\n  export function newSelectorGuess(selector: RelationSelector) {\n    let contentSelector = selector.toContentSelector();\n    window.helenaContent.relationHighlighter.clearCurrentlyHighlighted();\n    contentSelector.highlight();\n    sendEditedSelectorToMainpanel(contentSelector);\n  }\n\n  function findAncestorLikeSpec(specAncestor: HTMLElement,\n    element: HTMLElement) {\n    //will return exactly the same node if there's only one item in first_row_items\n    HelenaConsole.log(\"findAncestorLikeSpec\", specAncestor, element);\n    let spec_xpath_list = XPath.toXPathNodeList(\n      <string> XPath.fromNode(specAncestor));\n    let xpath_list = XPath.toXPathNodeList(<string> XPath.fromNode(element));\n    let ancestor_xpath_list = xpath_list.slice(0,spec_xpath_list.length);\n    let ancestor_xpath_string = XPath.toString(ancestor_xpath_list);\n    let ancestor_xpath_nodes = XPath.getNodes(ancestor_xpath_string);\n    return <HTMLElement> ancestor_xpath_nodes[0];\n  }\n\n  let targetsSoFar: HTMLElement[] = [];\n  function editingClick(event: MouseEvent) {\n    if (!window.helenaContent.currentSelectorToEdit) {\n      throw new ReferenceError('No selector to edit!');\n    }\n\n    if (NextButtonSelector.listeningForNextButtonClick) {\n      // don't want to do normal editing click...\n      NextButtonSelector.record(event);\n      return;\n    }\n\n    event.stopPropagation();\n    event.preventDefault();\n\n    let target = <HTMLElement> event.target;\n\n    if (currentSelectorEmptyOnThisPage) {\n      // ok, it's empty right now, need to make a new one\n      if (window.helenaContent.currentSelectorToEdit.origSelector === undefined) {\n        // deepcopy\n        window.helenaContent.currentSelectorToEdit.origSelector = JSON.parse(\n          JSON.stringify(window.helenaContent.currentSelectorToEdit)\n        );\n      }\n      targetsSoFar.push(target);\n\n      let newSelector = ContentSelector.fromRow(targetsSoFar);\n      // just the individual selector that we want to play with\n      window.helenaContent.currentSelectorToEdit.currentIndividualSelector = newSelector;\n      window.helenaContent.currentSelectorToEdit.origSelector!.merge(newSelector);\n      window.helenaContent.currentSelectorToEdit.selector = window.helenaContent.currentSelectorToEdit.origSelector!.selector;\n      window.helenaContent.currentSelectorToEdit.columns = window.helenaContent.currentSelectorToEdit.origSelector!.columns;\n      //window.helenaContent.currentSelectorToEdit = newSelector;\n      newSelectorGuess(window.helenaContent.currentSelectorToEdit);\n      // and let's go back to using .selector as the current one we want to edit and play with\n      window.helenaContent.currentSelectorToEdit.selector =\n        window.helenaContent.currentSelectorToEdit.currentIndividualSelector;\n      window.helenaContent.currentSelectorToEdit.positive_nodes = [ target ];\n      currentSelectorEmptyOnThisPage = false;\n      return;\n    }\n\n    if (!window.helenaContent.currentSelectorToEdit.positive_nodes) {\n      throw new ReferenceError('Selector contains no positive_nodes.');\n    }\n\n    let removalClick = false;\n    // it's only a removal click if the clicked item is a highlight\n    if (Highlight.isHighlight(target)) {\n      removalClick = true;\n      // actual target is the one associated with the highlight\n      const hiliteEl = Highlight.getHighlightedElement(target);\n      // recall the target itself may be the positive example, as when there's\n      //   only one column\n      let nodeToRemove = hiliteEl; \n      if (!window.helenaContent.currentSelectorToEdit.positive_nodes.includes(target)) {\n        // ok it's not the actual node, better check the parents\n        let parents = $(target).parents(); \n        for (let i = parents.length - 1; i > 0; i--){\n          let parent = parents[i];\n          let index = window.helenaContent.currentSelectorToEdit.positive_nodes.indexOf(parent);\n          if (index > -1) {\n            // ok, so this click is for removing a node.  removing the row?\n            //   removing the column? not that useful to remove a column, so \n            //   probably for removing a row...\n            nodeToRemove = parent;\n            break;\n          }\n        }\n      }\n      if (nodeToRemove) {\n        // actually remove the node from positive, add to negative\n        let ind = window.helenaContent.currentSelectorToEdit.positive_nodes.indexOf(nodeToRemove);\n        window.helenaContent.currentSelectorToEdit.positive_nodes.splice(ind, 1);\n        if (!window.helenaContent.currentSelectorToEdit.negative_nodes){\n          window.helenaContent.currentSelectorToEdit.negative_nodes = [];\n        }\n        window.helenaContent.currentSelectorToEdit.negative_nodes.push(nodeToRemove);\n      }\n    }\n    // we've done all our highlight stuff, know we no longer need that\n    // dehighlight our old list\n    window.helenaContent.relationHighlighter.clearCurrentlyHighlighted();\n\n    if (!removalClick) {\n      // ok, so we're trying to add a node.  is the node another cell in an\n      //   existing row?  or another row?  could be either.\n      // for now we're assuming it's always about adding rows, since it's\n      //   already possible to add columns by demonstrating first row\n\n      let newCellInExistingRow = false;\n      if (newCellInExistingRow) {\n        // for now, assume it's another cell in an existing row\n        // todo: give the user an interaction that allows him or her say it's\n        //   actually another row\n        // todo: put some kind of outline around the ones we think of the user\n        //   as having actually demonstrated to us?  the ones we're actually\n        //   using to generate the selector?  so that he/she knows which to\n        //   actually click on to change things\n        // maybe green outlines (or color-corresponding outlines) around the\n        //   ones we're trying to include, red outlines around the ones we're\n        //   trying to exclude.\n\n        // let's figure out which row it should be\n        // go through all rows, find common ancestor of the cells in the row +\n        //   our new item, pick whichever row produces an ancestor deepest in\n        //   the tree\n        let currRelation = window.helenaContent.currentSelectorToEdit.relation;\n        let deepestCommonAncestor = null;\n        let deepestCommonAncestorDepth = 0;\n        let currRelationIndex = 0;\n        for (let i = 0; i < currRelation.length; i++){\n          let nodes = currRelation[i];\n          let ancestor = XPath.findCommonAncestor(nodes.concat([target]));\n          let depth = $(ancestor).parents().length;\n          if (depth > deepestCommonAncestorDepth){\n            deepestCommonAncestor = ancestor;\n            deepestCommonAncestorDepth = depth;\n            currRelationIndex = i;\n          }\n        }\n\n        if (!deepestCommonAncestor) {\n          throw new ReferenceError('No deepestCommonAncestor found.');\n        }\n\n        let columns = ColumnSelector.compute(deepestCommonAncestor,\n          currRelation[currRelationIndex].concat([ target ]));\n        window.helenaContent.currentSelectorToEdit.columns = columns;\n\n        // let's check whether the common ancestor has actually changed.\n        //   if no, this is easy and we can just change the columns\n        //   if yes, it gets more complicated\n        let origAncestor = XPath.findCommonAncestor(\n          currRelation[currRelationIndex]);\n        let newAncestor = XPath.findCommonAncestor(\n          currRelation[currRelationIndex].concat([target]));\n        if (origAncestor === newAncestor) {\n          // we've already updated the columns, so we're ready\n          newSelectorGuess(window.helenaContent.currentSelectorToEdit);\n          return;\n        }\n        // drat, the ancestor has actually changed.\n        // let's assume that all the items in our current positive nodes list\n        //   will have *corresponding* parent nodes...  (based on difference in\n        //   depth.  not really a good assumption, but we already assume that we\n        //   have fixed xpaths to get to subcomponents, so we're already making\n        //   that assumption)\n        let xpath = <string> XPath.fromNode(newAncestor);\n        let xpathlen = xpath.split(\"/\").length;\n        let xpathO = <string> XPath.fromNode(origAncestor);\n        let xpathlenO = xpathO.split(\"/\").length;\n        let depthDiff = xpathlenO - xpathlen;\n        for (let i = 0; i < window.helenaContent.currentSelectorToEdit.positive_nodes.length; i++) {\n          let ixpath = <string> XPath.fromNode(\n            window.helenaContent.currentSelectorToEdit.positive_nodes[i]);\n          let components = ixpath.split(\"/\");\n          components = components.slice(0, components.length - depthDiff);\n          let newxpath = components.join(\"/\");\n          window.helenaContent.currentSelectorToEdit.positive_nodes[i] =\n            <HTMLElement> XPath.getNodes(newxpath)[0];\n        }\n        if (!window.helenaContent.currentSelectorToEdit.positive_nodes.includes(\n          deepestCommonAncestor)) {\n          window.helenaContent.currentSelectorToEdit.positive_nodes.push(deepestCommonAncestor);\n        }\n      } else {\n        // this one's the easy case!  the click is telling us to add a row,\n        //   rather than to add a cell to an existing row or it may be telling\n        //   us to add a cell in an existing row to an existing column, which\n        //   also should not require us to change the ancestor node.  if it does\n        //   require changing the ancestor node,then we will run into trouble\n        //   bc won't find appropriate ancestor\n        // TODO: better structure available here?  maybe merge this and the above?\n        let appropriateAncestor = findAncestorLikeSpec(\n          window.helenaContent.currentSelectorToEdit.positive_nodes[0], target);\n        if (!window.helenaContent.currentSelectorToEdit.editingClickColumnIndex) {\n          throw new ReferenceError('editingClickColumnIndex not set');\n        }\n        let currColumnObj = window.helenaContent.currentSelectorToEdit.columns[\n          window.helenaContent.currentSelectorToEdit.editingClickColumnIndex];\n        let currSuffixes = <XPath.SuffixXPathList[]> currColumnObj.suffix;\n\n        // is this suffix already in our suffixes?  if yes, we can just add the\n        //   ancestor/row node, don't need to mess with columns\n        let newSuffix = XPath.suffixFromAncestor(appropriateAncestor, target);\n        let newSuffixAlreadyPresent = currSuffixes.some(\n          (suffix: SuffixXPathList) => {\n            if (suffix.length !== newSuffix.length) { return false; }\n            for (let i = 0; i < newSuffix.length; i++) {\n              if (newSuffix[i].nodeName !== suffix[i].nodeName ||\n                  newSuffix[i].iterable !== suffix[i].iterable ||\n                  newSuffix[i].index !== suffix[i].index) {\n                return false;\n              }\n            }\n            return true;\n          }\n        );\n\n        if (!newSuffixAlreadyPresent) {\n          // ok it's not in our current suffixes, so we'll have to make the new\n          //   suffixes list\n          currSuffixes.push(newSuffix);     \n          currColumnObj.suffix = currSuffixes;     \n        }\n    \n        // is this ancestor node already in our positive_nodes?  if no, make new\n        //   selector.  if yes, we're already set\n        if (!window.helenaContent.currentSelectorToEdit.positive_nodes.includes(\n          appropriateAncestor)) {\n          // this ancestor node (row node) is new to us, better add it to the\n          //   positive examples\n          window.helenaContent.currentSelectorToEdit.positive_nodes.push(appropriateAncestor);\n        }\n      }\n    }\n\n    if (!window.helenaContent.currentSelectorToEdit.negative_nodes) {\n      throw new ReferenceError('Selector does not contain any negative nodes.');\n    }\n\n    let newSelector = RelationSelector.fromPositiveAndNegativeElements(\n      window.helenaContent.currentSelectorToEdit.positive_nodes,\n      window.helenaContent.currentSelectorToEdit.negative_nodes,\n      window.helenaContent.currentSelectorToEdit.columns);\n    newSelector.next_type = window.helenaContent.currentSelectorToEdit.next_type;\n    newSelector.next_button_selector =\n      window.helenaContent.currentSelectorToEdit.next_button_selector;\n    newSelector.name = window.helenaContent.currentSelectorToEdit.name;\n    newSelector.id = window.helenaContent.currentSelectorToEdit.id;\n    newSelector.url = window.helenaContent.currentSelectorToEdit.url;\n    \n    newSelectorGuess(newSelector);\n    window.helenaContent.currentSelectorToEdit = <ContentSelector> newSelector;\n  }\n\n/**********************************************************************\n * Handling everything we need for actually running the next interactions during replays\n **********************************************************************/\n\n  let currentRelationData: {\n    [key: string]: MainpanelNodeI[][];\n  } = {};\n  // this will be adjusted when we're in the midst of running next button\n  //   interactions\n  let nextInteractionSinceLastGetFreshRelationItems: {\n    [key: string]: boolean;\n  } = {};\n  let currentRelationSeenNodes: {\n    [key: string]: number[]\n  } = {};\n  let noMoreItemsAvailable: {\n    [key: string]: boolean;\n  } = {};\n\n  function scrollThroughRows(relation: MainpanelNodeI[][]) {\n    //console.log(\"scrolling through the rows based on crd\", crd);\n    let knowTheLastElement = false;\n    for (let i = 0; i < relation.length; i++){\n      let row = relation[i];\n      for (let j = 0; j < row.length; j++){\n        let elem = row[j];\n        if (!elem.xpath) {\n          continue;\n        }\n        let elemNodes = <HTMLElement[]> XPath.getNodes(elem.xpath);\n        if (elemNodes.length > 0){\n          let elemNode = elemNodes[0];\n          elemNode.scrollIntoView(true);\n          knowTheLastElement = true;\n        }\n      }\n    }\n    return knowTheLastElement;\n  }\n\n  function scrollThroughRowsOrSpace(relation: MainpanelNodeI[][]) {\n    // let's try scrolling to last element if we know it\n    // sometimes it's important to scroll through the range of data, not go\n    //   directly to the end, so we'll try scrolling to each in turn\n    let knowTheLastElement = null;\n    if (relation) {\n      knowTheLastElement = scrollThroughRows(relation);\n    }\n    // but if we don't know it, just try scrolling window to the bottom\n    //   sadly, this doesn't work for everything.  (for instance, if have an\n    //   overlay with a relation, the overlay may not get scrolled w window\n    //   scroll)\n    if (!knowTheLastElement) {\n      // go past 1 because sometimes the page is still working on loading\n      //   content, getting longer\n      for (let i = 0; i < 1.1; i+= 0.01) { \n        window.scrollTo(0, document.body.scrollHeight * i);\n      }\n    }\n  }\n\n  export function clearRelationInfo(msg: RelationMessage) {\n    HelenaConsole.namedLog(\"nextInteraction\", \"clearing relation info\",\n      msg);\n    let sid = RelationSelector.hash(msg);\n    delete nextInteractionSinceLastGetFreshRelationItems[sid];\n    delete currentRelationData[sid];\n    delete currentRelationSeenNodes[sid];\n    delete noMoreItemsAvailable[sid];\n    Messages.sendMessage(\"content\", \"mainpanel\", \"clearedRelationInfo\",\n      {});\n  }\n\n  /**\n   * Run the interaction needed to retrieve the next page of results (using the\n   *   next/more/pagination buttons). If there are no more items to retrieved,\n   *   the information is stored for the next time {@link getFreshRelationItems}\n   *   is called.\n   * @param msg relation selector\n   */\n  export function getNextPage(msg: RelationMessage) {\n    HelenaConsole.namedLog(\"nextInteraction\", \"running next interaction\",\n      msg);\n\n    // todo: will this always reach the page?  if not, big trouble\n    Messages.sendMessage(\"content\", \"mainpanel\",\n      \"runningNextInteraction\", {});\n\n    let sid = RelationSelector.hash(msg);\n    if (sid in currentRelationData) {\n      HelenaConsole.namedLog(\"nextInteraction\",\n        \"sid in currentRelationData\");\n    } else {\n      HelenaConsole.namedLog(\"nextInteraction\",\n        \"sid not in currentRelationData\");\n      HelenaConsole.namedLog(\"nextInteraction\", currentRelationData);\n      HelenaConsole.namedLog(\"nextInteraction\", \"----\");\n      HelenaConsole.namedLog(\"nextInteraction\", sid);\n      for (const key in currentRelationData){\n        console.log(key === sid);\n        console.log(key.slice(20));\n        console.log(sid.slice(20));\n      }\n    }\n\n    // note that we're assuming that the next interaction for a given relation\n    //   only affects that relation\n    nextInteractionSinceLastGetFreshRelationItems[sid] = true; \n\n    let nextButtonType = msg.next_type;\n\n    if (nextButtonType === NextButtonTypes.SCROLLFORMORE) {\n      HelenaConsole.namedLog(\"nextInteraction\", \"scrolling for more\");\n      let crd = currentRelationData[sid];\n      scrollThroughRowsOrSpace(crd);\n    } else if (nextButtonType === NextButtonTypes.MOREBUTTON ||\n      nextButtonType === NextButtonTypes.NEXTBUTTON) {\n      HelenaConsole.namedLog(\"nextInteraction\", \"msg.next_button_selector\",\n        msg.next_button_selector);\n\n      let crd = currentRelationData[sid];\n      if (nextButtonType === NextButtonTypes.MOREBUTTON) {\n        // for user understanding what's happening, it's convenient if we're using the more button for us to actually scroll through the elements\n        // this isn't critical, but probably can't hurt\n        scrollThroughRowsOrSpace(crd);\n      }\n\n      let button = NextButtonSelector.findNextButton(\n        <INextButtonSelector> msg.next_button_selector,\n        msg.prior_next_button_text);\n      if (button) {\n        Messages.sendMessage(\"content\", \"mainpanel\", \"nextButtonText\",\n          { text: button.textContent });\n        HelenaConsole.namedLog(\"nextInteraction\",\n          \"clicked next or more button\");\n        console.log(\"About to click on node\", button, button.textContent);\n        button.click();\n      } else {\n        HelenaConsole.namedLog(\"nextInteraction\",\n          \"next or more button was null\");\n        noMoreItemsAvailable[sid] = true;\n      }\n    } else if (nextButtonType === NextButtonTypes.NONE) {\n      // there's no next button, so it's usually safe to assume there are no\n      //   more items exception is when we have, for instance, a dropdown that\n      //   gets updated because of other dropdowns when that happens, don't want\n      //   to say there are no more items available. current idea for dealing\n      //   with this...just don't ask to run the next interaction in the case\n      //   where we know there's no next button, so this won't get set, and we\n      //   can just come back and ask after doing whatever causes new items, ask\n      //   for new items and be pleasantly surprised that some are there\n      noMoreItemsAvailable[sid] = true;\n    } else {\n      HelenaConsole.namedLog(\"nextInteraction\",\n        \"Failure. Don't know how to produce items because don't know next button type.  Guessing we just want the current page items.\");\n      noMoreItemsAvailable[sid] = true;\n    }\n  }\n\n  export function getFreshRelationItems(selector: RelationSelector) {\n    getFreshRelationItemsHelper(selector,\n      (respMsg: FreshRelationItemsMessage) => {\n        HelenaConsole.log('respMsg', respMsg);\n        Messages.sendMessage(\"content\", \"mainpanel\", \"freshRelationItems\",\n          respMsg);\n    });\n  }\n\n  function extractFromRelationRep(rel: MainpanelNodeI[][]) {\n    return rel.map((row) =>\n      // TODO: cjbaik: is text & frame the correct attributes to use?\n      row.map((cell) => [cell.text, cell.frame])\n    );\n  }\n\n  function mainpanelRepresentationOfRelationsEqual(r1: MainpanelNodeI[][],\n    r2: MainpanelNodeI[][]): boolean {\n    let r1Visible = extractFromRelationRep(r1);\n    let r2Visible = extractFromRelationRep(r2);\n    \n    if (r1Visible.length !== r2Visible.length) {\n      return false;\n    }\n\n    for (let rowIndex = 0; rowIndex < r1Visible.length; rowIndex++) {\n      let r1Row = r1Visible[rowIndex];\n      let r2Row = r2Visible[rowIndex];\n      \n      if (r1Row.length !== r2Row.length) {\n        return false;\n      }\n      for (let cellIndex = 0; cellIndex < r1Row.length; cellIndex++) {\n        let r1CellAttrs = r1Row[cellIndex];\n        let r2CellAttrs = r2Row[cellIndex];\n        for (let attrIndex = 0; attrIndex < r1CellAttrs.length; attrIndex++) {\n          if (r1CellAttrs[attrIndex] !== r2CellAttrs[attrIndex]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  let relationFinderIdCounter = 0;\n  let waitingOnPriorGetFreshRelationItemsHelper = false;\n  export function getFreshRelationItemsHelper(selector: RelationSelector,\n    continuation: Function, doData = false) {\n    if (waitingOnPriorGetFreshRelationItemsHelper && doData === false){\n      return;\n    }\n\n    const sid = selector.hash();\n    HelenaConsole.log(\"noMoreItemsAvailable\", noMoreItemsAvailable[sid],\n      noMoreItemsAvailable);\n  \n    if (noMoreItemsAvailable[sid]) {\n      // that's it, we're done.  last use of the next interaction revealed there's nothing left\n      HelenaConsole.log(\"no more items at all, because noMoreItemsAvailable was set.\");\n      continuation({\n        type: ScrapedRelationState.NO_MORE_ITEMS,\n        relation: null\n      });\n    }\n    // below is commented out in case there are cases where after first load, it may take a while for the data to all get there (get empty list first, that kind of deal)  Does that happen or is this a wasted opportunity to cache?\n    /*\n    if (!nextInteractionSinceLastGetFreshRelationItems[strMsg] && (strMsg in currentRelationData)){\n      // we have a cached version and the data shouldn't have changed since we cached it\n      Messages.sendMessage(\"content\", \"mainpanel\", \"freshRelationItems\", {type: RelationItemsOutputs.NEWITEMS, relation: currentRelationData[strMsg]});\n      return;\n    }\n    */\n    // ok, don't have a cached version, either because never collected before, or bc done a next interaction since then.  better grab the data afresh\n\n    let relationNodes = selector.getMatchingRelation();\n    HelenaConsole.log(\"relationNodes\", relationNodes);\n\n    // ok, let's go through these nodes and give them ids if they've never been\n    //   scraped for a node before. then we want to figure out whether we're in\n    //   a next interaction or a more interaction, so we know how to deal with\n    //   info about whether we've scraped already\n    let relationNodesIds: number[][] = [];\n    for (const row of relationNodes) {\n      let rowIds: number[] = [];\n      for (const rawCell of row) {\n        let cell = <ScrapedElement> rawCell;\n        let id;\n        if (cell === null || cell === undefined) { \n          // can't save an id on null\n          continue;\n        } else if (cell.___relationFinderId___ === undefined) {\n          // can be 0, so check for undefined rather than truthiness\n          // have to add the relationFinderId\n          id = relationFinderIdCounter;\n          cell.___relationFinderId___ = id;\n          relationFinderIdCounter += 1;\n        } else {\n          // already have relationFinderId saved\n          id = cell.___relationFinderId___;\n        }\n        rowIds.push(id);\n\n        // now, it's nice that we're able to track these rows and all, but if\n        //   the page gets updated by javascript or some such thing, we might\n        //   keep this id and think we've already scraped something even if we\n        //   haven't so use mutationobserver\n\n        // todo: might be better to do this for relationNodes items (row-by-row)\n        //   rather than on a cell-by-cell basis. that way if any of the cells\n        //   change, we believe the whole row has been updated\n        // of course, this still doesn't fix the case where the list has been\n        //   ajax-updated, but one of the rows is the same\n        // todo: handle that\n         \n        // create an observer instance\n        let observer = new MutationObserver((mutations) => {\n          // get rid of the old id, now that it's essentially a different node\n          delete cell.___relationFinderId___;\n          // stop observing\n          observer.disconnect();\n        });\n    \n        // configuration of the observer:\n        let config = { attributes: true, childList: true, characterData: true };\n        // pass in the target node, as well as the observer options\n        try {\n          observer.observe(cell, config);\n        } catch (err) {\n          console.warn(\"woah, couldn't observe mutations. are we getting all data?\");\n        }  \n      }\n      relationNodesIds.push(rowIds);\n    }\n\n    if (!(sid in currentRelationSeenNodes)) {\n      currentRelationSeenNodes[sid] = [];\n    }\n    // if there's supposed to be a next button or more button, or scroll for\n    //   more, we have to do some special processing\n    if (selector.next_type === NextButtonTypes.NEXTBUTTON ||\n        selector.next_type === NextButtonTypes.MOREBUTTON ||\n        selector.next_type === NextButtonTypes.SCROLLFORMORE) {\n      // retrieve the list of ids we've already scraped\n      let alreadySeenRelationNodeIds = currentRelationSeenNodes[sid];\n      // figure out if the new rows include nodes that were already scraped\n      let newRows = [];\n      let newRowsIds = [];\n      for (let rowIndex = 0; rowIndex < relationNodesIds.length; rowIndex++) {\n        let row = relationNodesIds[rowIndex];\n        // todo: should we be looking for whether some are new, or all?\n        //   requiring all can fail with ajax-updated pages\n        // ex: say we're scraping a bunch of papers from a single conference.\n        //   conference cell of row will stay the same,\n        //   so conference node won't get updated and its id won't get wiped.\n        //   in this case, even requiring some to be new could be a problem if\n        //   we're only scraping that single column\n        // so todo: come up with a better solution\n        let someNew = row.some((cell) =>\n          !alreadySeenRelationNodeIds.includes(cell));\n        if (someNew) {\n          newRows.push(relationNodes[rowIndex]);\n          newRowsIds.push(row);\n        }\n      }\n\n      // ok, now that we know which rows are actually new, what do we want to do\n      //   with that information?\n      if (selector.next_type === NextButtonTypes.NEXTBUTTON) {\n        // this is a next interaction, so we should never have overlap.\n        //   wait until everything is new\n        if (relationNodes.length !== newRows.length) {\n      \t  HelenaConsole.log(\"sending no new items yet because we found some repeated items and it's a next button.  is that bad?\");\n          HelenaConsole.log(\"alreadySeenRelationNodeIds\",\n            alreadySeenRelationNodeIds.length, alreadySeenRelationNodeIds);\n          HelenaConsole.log(\"relationNodes\", relationNodes.length,\n            relationNodes);\n      \t  HelenaConsole.log(\"newRows\", newRows.length, newRows);\n          // looks like some of our rows weren't new, so next button hasn't happened yet\n\n          HelenaConsole.log(\"newRows\", newRows);\n          continuation({type: ScrapedRelationState.NO_NEW_ITEMS_YET, relation: null});\n        }\n        // otherwise we can just carry on, since the relationNodes has the right set\n      } else {\n        // ok, we're in a more-style interaction, either morebutton or scrollformore\n        // the newrows are the new rows, so let's use those!\n        relationNodes = newRows;\n        relationNodesIds = newRowsIds;\n      }\n    }\n\n    // ok, we're about to try to figure out if our new data is actual new data\n    //   and consider sending it along to mainpanel we know some nodes exist,\n    //   but we don't know that they've loaded/finished updating yet to be on\n    //   the safe side, let's give them a sec.\n    // in fact, ideally we'd like to do better, check if they've stopped\n    //   updating; todo: look into this\n\n    if (!doData) {\n      // call this function again in a sec, but with doData set to true\n      waitingOnPriorGetFreshRelationItemsHelper = true;\n      let wait = selector.relation_scrape_wait;\n      if (!wait) {\n        wait = HelenaConfig.relationScrapeWait;\n      }\n      console.log(\"wait time\", wait);\n      setTimeout(function(){\n        getFreshRelationItemsHelper(selector, continuation, true);\n      }, wait);\n    } else {\n      // great, we've waited our time and it's time to go\n      waitingOnPriorGetFreshRelationItemsHelper = false;\n      console.log(\"relationNodes\", relationNodes);\n      let relationData = MainpanelNode.convertRelation(relationNodes);\n      let crd = currentRelationData[sid];\n      // we can also have the problem where everything looks new, because everything technically gets updated, \n      // even though some of it is old data, didn't need to be redrawn. so need to do a text check too\n      // so that's why we'll compare to the crd, figure out whether the head looks like it's actually old data\n      if (crd && crd.length === relationData.length &&\n          mainpanelRepresentationOfRelationsEqual(crd, relationData)){\n        // data still looks the same as it looked before.  no new items yet.\n        HelenaConsole.log(\"No new items yet because the data is actualy equal\");\n        HelenaConsole.log(crd, relationData);\n        continuation({\n          type: ScrapedRelationState.NO_NEW_ITEMS_YET,\n          relation: null\n        });\n      }\n\n      // whee, we have some new stuff.  we can update the state\n      nextInteractionSinceLastGetFreshRelationItems[sid] = false;\n      // we only want the fresh ones!\n      let newItems = relationData; // start by assuming that's everything\n      if (crd) {\n        // HelenaConsole.log(\"crd, relationData, relationData slice\", crd,\n        //   relationData, relationData.slice(0,crd.length),\n        //   _.isEqual(crd, relationData.slice(0, crd.length)))\n      }\n      if (crd && mainpanelRepresentationOfRelationsEqual(crd,\n        relationData.slice(0, crd.length))){\n        // cool, this is a case of loading more into the same page, so we want to just grab the end\n        newItems = relationData.slice(crd.length, relationData.length);\n      }\n\n      // it's important that we don't wipe out the currentRelationdata[strMsg]\n      //   unless we actually have new data. if we're doing a more interaction,\n      //   might have 0 rows in an intermediate state, but then still need to\n      //   trim the top off the list based on having already collected the data\n      if (newItems.length > 0) {\n        HelenaConsole.namedLog(\"nextInteraction\", \"setting relation info\",\n          selector);\n        currentRelationData[sid] = relationData;\n        let newRelationSeenNodes = currentRelationSeenNodes[sid].concat(\n          (<number[]> []).concat(...relationNodesIds));\n        currentRelationSeenNodes[sid] = newRelationSeenNodes.filter(\n          (nodeId) => nodeId);\n        HelenaConsole.log(\"actual new items\", newItems);\n        continuation({\n          type: ScrapedRelationState.NEW_ITEMS,\n          relation: newItems\n        });\n      }\n    }\n\n  };\n}\n","import * as stringify from \"json-stable-stringify\";\n\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport MainpanelNodeI = MainpanelNode.Interface;\n\nimport { LikelyRelationMessage, RelationMessage } from \"../../common/messages\";\n\nimport { ColumnSelector } from \"./column_selector\";\n\nimport { Features } from \"../utils/features\";\nimport GenericFeatureSet = Features.GenericFeatureSet;\nimport FeatureSet = Features.FeatureSet;\nimport PulldownFeatureSet = Features.PulldownFeatureSet;\nimport TableFeatureSet = Features.TableFeatureSet;\n\nimport { XPath } from \"../utils/xpath\";\nimport XPathList = XPath.XPathList;\nimport SuffixXPathList = XPath.SuffixXPathList;\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Utilities } from \"../../ringer-record-replay/common/utils\";\nimport { INextButtonSelector, NextButtonTypes,\n  IColumnSelector } from \"./interfaces\";\nimport { ServerRelationMessage } from \"../../mainpanel/utils/server\";\n\n/**\n * Produce the powerset of the array.\n * @param arr the array\n * @param descSize true if descending size\n */\nfunction powerset(arr: any[], descSize = false) {\n  let ps = [[]];\n  for (let i = 0; i < arr.length; i++) {\n    let prevLength = ps.length;\n    for (let j = 0; j < prevLength; j++) {\n        ps.push(ps[j].concat(arr[i]));\n    }\n  }\n  // ok, ps has them in order from smallest to largest.  let's reverse that\n  if (descSize) {\n    return ps.reverse();\n  } else {\n    return ps;\n  }\n}\n\n/**\n * Extract relation of child option elements given a select element.\n * @param selectEl select element\n */\nfunction extractOptionsRelationFromSelectElement(selectEl: HTMLElement){\n  let optionEls = [].slice.call(selectEl.querySelectorAll(\"option\"));\n  let optionsRelation = optionEls.map((el: HTMLElement) =>\n    [ MainpanelNode.fromDOMNode(el) ]);\n  return optionsRelation;\n}\n\n/**\n * Retrieve all candidate elements from the document.\n */\nfunction getAllCandidateElements() {\n  return <HTMLElement[]> [].slice.call(document.getElementsByTagName(\"*\"));\n}\n\n/**\n * Counts how many XPath expressions in xpaths intersects with the xpaths of\n *   the cells in the first row.\n * @param xpaths XPath expressions\n * @param firstRow cells in first row\n */\nfunction numMatchedXpaths(xpaths: string[], firstRow: MainpanelNodeI[]) {\n  let firstRowXpaths = firstRow.map((cell) => cell.xpath);\n  return xpaths.filter((xpath) => firstRowXpaths.includes(xpath)).length;\n}\n\n/**\n * Get cells in each of the candidateRowNodes matching the suffixes.\n * @param suffixes the tail end of each XPath for a column, which excludes the\n *   XPath up to the row element\n * @param candidateRowNodes candidate row nodes, or null if none found  \n */\nfunction getCellsInRowMatchingSuffixes(\n    suffixes: (SuffixXPathList[] | undefined)[],\n    candidateRowNodes: (HTMLElement | null)[]) {\n  let candidateSubitems = [];\n  let rowNodeXPaths = candidateRowNodes.map((candidateRow) =>\n    XPath.toXPathNodeList(<string> XPath.fromNode(candidateRow))\n  );\n  for (let j = 0; j < suffixes.length; j++){\n    let suffixLs = suffixes[j];\n\n    if (!suffixLs) {\n      continue;\n    }\n\n    let foundSubItem = null;\n    for (let k = 0; k < suffixLs.length; k++){\n      let rowNodeXPath = null;\n      let suffixListRep = null;\n      let selectorIndex = suffixLs[k].selectorIndex;\n\n      // selectorIndex can be 0, which is why we check for undefined\n      if (selectorIndex !== undefined) {\n        // we know exactly which of the candidate row nodes to use because a\n        //   selector index is provided\n        rowNodeXPath = rowNodeXPaths[selectorIndex];\n        suffixListRep = <XPathList> suffixLs[k].suffixRepresentation;\n      } else {\n        // this suffix isn't one of our selectorIndex-labeled objects. it is\n        //   the old array representation so we should have only one selector\n        //   and thus only one candidate row node\n        rowNodeXPath = rowNodeXPaths[0];\n        suffixListRep = suffixLs[k];\n        if (candidateRowNodes.length > 1){\n          console.warn(\"Woah, bad, we have no selector index associated \" +\n            \"with a column suffix, but we have multiple row nodes.\");\n        }\n      }\n      let xpath = rowNodeXPath.concat(suffixListRep);\n      let xpath_string = XPath.toString(xpath);\n      let nodes = <HTMLElement[]> XPath.getNodes(xpath_string);\n      if (nodes.length > 0){\n        foundSubItem = nodes[0];\n        break;\n      }\n    }\n    // either push the found subitem, or null if none found\n    candidateSubitems.push(foundSubItem);\n  }\n  let atLeastOneNonNullCandidate = candidateSubitems.some((item) => item);\n  if (candidateSubitems.length > 0 && atLeastOneNonNullCandidate){\n    return candidateSubitems;\n  }\n  return null;\n}\n\n/**\n   * Adds necessary information for {@link SuffixXPathNode} to a list of\n   *   {@link IColumnSelector}s.\n   * @param colSelectors column selectors \n   * @param selectorIndex selector index for suffix\n   */\n  function labelColumnSuffixesWithTheirSelectors(\n    colSelectors: IColumnSelector[], selectorIndex: number) {\n  \n    for (const col of colSelectors) {\n      let curSuffixes = col.suffix;\n      let outputSuffixLs: SuffixXPathList[] = [];\n      if (curSuffixes) {\n        for (const suffix of curSuffixes) {\n          if (suffix.selectorIndex) {\n            // it's already an object with a selector index, and we just need to\n            //   update the selectorIndex\n            suffix.selectorIndex = selectorIndex;\n            outputSuffixLs.push(suffix);\n          } else {\n            // ah, still just the old list representation of a selector.  need to\n            //   make it into a selectorIndex-labeled object\n            let newSuffix = new SuffixXPathList();\n            newSuffix.selectorIndex = selectorIndex;\n            newSuffix.suffixRepresentation = suffix;\n            outputSuffixLs.push(newSuffix);\n          }\n        }\n      }\n      col.suffix = outputSuffixLs;\n    }\n  }\n\nexport class RelationSelector {\n  selector_version: number;\n  selector: GenericFeatureSet | GenericFeatureSet[];\n  name?: string | null;\n  exclude_first: number;\n  id?: string;\n  columns: IColumnSelector[];\n  num_rows_in_demonstration?: number;\n  next_type?: number;\n  prior_next_button_text?: string;\n  next_button_selector?: INextButtonSelector | null;\n  url?: string;\n  \n  positive_nodes?: HTMLElement[];\n  negative_nodes?: HTMLElement[];\n\n  relation?: ((HTMLElement | MainpanelNodeI | null)[][]) | null;\n  page_var_name?: string;\n  relation_id?: string | null;\n  first_page_relation?: (HTMLElement | MainpanelNodeI | null)[][];\n  pulldown_relations?: RelationSelector[];\n\n  relation_scrape_wait?: number;\n\n  /** Properties used in {@link ComparisonSelector}. */\n  numMatchedXpaths?: number;\n  numRows?: number;\n  numRowsInDemo?: number;\n  numColumns?: number;\n\n  constructor(featureSet: GenericFeatureSet | GenericFeatureSet[],\n    exclude_first: number, columns: IColumnSelector[], selector_version = 1) {\n      this.selector_version = selector_version;\n      this.selector = featureSet;\n      this.exclude_first = exclude_first;\n      this.columns = columns;\n  }\n\n  public static fromJSON(msg: ServerRelationMessage): RelationSelector {\n    const columns: IColumnSelector[] = msg.columns.map((colMsg) => {\n      return {\n        id: colMsg.id,\n        name: colMsg.name,\n        suffix: JSON.parse(colMsg.suffix),\n        xpath: colMsg.xpath\n      };\n    });\n\n    const featureSet = JSON.parse(msg.selector);\n    let selector;\n    if (featureSet.table) {\n      selector = new TableSelector(featureSet, msg.exclude_first, columns,\n        msg.selector_version);\n    } else {\n      selector = new RelationSelector(featureSet, msg.exclude_first, columns,\n        msg.selector_version);\n    }\n\n    if (msg.next_button_selector) {\n      selector.next_button_selector = JSON.parse(msg.next_button_selector);\n    } else {\n      selector.next_button_selector = null;\n    }\n\n    return selector;\n  }\n\n  /**\n   * Get all the cells to be extracted given multiple rows where each row is\n   *   extracted from a selector.\n   * @param rows a collection of elements where each element represents a row\n   */\n  public getMatchingCells(rows: HTMLElement[][]) {\n    // now we'll use the columns info to actually get the cells\n    let suffixes = this.columns.map((col) => col.suffix);\n    \n    // only use multiple selectors up to the point where they have the same\n    //   number of rows\n    let allCells = [];\n    let maxRowCount = Math.max(...(rows.map(rows => rows.length)));\n    for (let rowIndex = 0; rowIndex < maxRowCount; rowIndex++) {\n      let curRowNodes = [];\n      for (let selIndex = 0; selIndex < rows.length; selIndex++) {\n        if (rows[selIndex].length > rowIndex) {\n          curRowNodes.push(rows[selIndex][rowIndex]);\n        } else {\n          curRowNodes.push(null);\n        }\n      }\n      let curRowCells = getCellsInRowMatchingSuffixes(suffixes, curRowNodes);\n      if (curRowCells !== null) {\n        allCells.push(curRowCells);\n      }\n    }\n    return allCells;\n  }\n\n  /**\n   * Gets elements representing the rows of the relation to be extracted.\n   */\n  public getMatchingRows(): HTMLElement[][] {\n    if (!this.selector){\n      return [];\n    }\n\n    if (Array.isArray(this.selector)) {\n      // the case where we need to recurse\n      let selectorArray = this.selector;\n      let rowNodeLists: HTMLElement[][] = [];\n      for (let i = 0; i < selectorArray.length; i++){\n        let possibleSelector = selectorArray[i];\n        this.selector = possibleSelector;\n        let newRowNodesLs = this.getMatchingRows();\n        rowNodeLists = rowNodeLists.concat(newRowNodesLs);\n      }\n      this.selector = selectorArray;\n      return rowNodeLists;\n    }\n\n    return this.getMatchingElements();\n  }\n\n  /**\n   * Gets the document elements matching the features specified in selector for\n   *   the general, non-table case.\n   * @param excludeFirst exclude this many rows from extraction (e.g. headers)\n   */\n  public getMatchingElements() {\n    const featureSet = <FeatureSet> this.selector;\n    \n    // HelenaConsole.log(\"interpretRelationSelectorHelper\", feature_dict,\n    //   excludeFirst, subcomponents_function);\n    let candidates = getAllCandidateElements();\n    let listOfRowNodes = [];\n    for (const candidate of candidates) {\n      let candidate_ok = true;\n      for (const feature in featureSet) {\n        const value = Features.computeFeatureFromElement(candidate, feature);\n        const acceptable_values = featureSet[feature].values;\n        if (!acceptable_values) {\n          // JSOG serialization includes a `__jsogObjectId` key, which is not\n          //   a feature and lacks acceptable_values\n          continue;\n        }\n        const pos = featureSet[feature].pos;\n        const candidate_feature_match = Features.featureMatches(feature, value,\n          acceptable_values);\n        if ((pos && !candidate_feature_match) ||\n           (!pos && candidate_feature_match)) {\n          candidate_ok = false;\n          break;\n        }\n      }\n      if (candidate_ok) {\n        listOfRowNodes.push(candidate);\n      }\n    }\n    if (this.exclude_first > 0 && listOfRowNodes.length > this.exclude_first){\n      return [listOfRowNodes.slice(this.exclude_first, listOfRowNodes.length)];\n    }\n    HelenaConsole.log(\"listOfRowNodes\", listOfRowNodes);\n    return [listOfRowNodes];\n  }\n\n\n  /**\n   * Get a relation from the document given the selector.\n   * @returns a relation (i.e. a 2d array) with the matching data\n   */\n  public getMatchingRelation(): (HTMLElement | null)[][] {\n    let rowNodeLists = this.getMatchingRows();\n    // now that we have some row nodes, time to extract the individual cells\n    let cells = this.getMatchingCells(rowNodeLists);\n    HelenaConsole.log(\"cells\", cells);\n    //cells = onlyDisplayedCellsAndRows(cells);\n    HelenaConsole.log(\"returning cells 1\", cells);\n    return cells;\n  }\n\n  /**\n   * Create a selector object from a message representing it.\n   * @param msg the message\n   */\n  public static fromMessage(msg: RelationMessage) {\n    let newSelector;\n    if (msg.selector && 'table' in msg.selector) {\n      newSelector = new TableSelector(msg.selector, msg.exclude_first,\n        ColumnSelector.fromMessage(msg.columns), msg.selector_version);\n    } else {\n      newSelector = new RelationSelector(msg.selector, msg.exclude_first,\n        ColumnSelector.fromMessage(msg.columns), msg.selector_version);\n    }\n    \n    newSelector.name = msg.name;\n    newSelector.id = msg.id;\n    newSelector.num_rows_in_demonstration = msg.num_rows_in_demonstration;\n    newSelector.next_type = msg.next_type;\n    newSelector.prior_next_button_text = msg.prior_next_button_text;\n    newSelector.next_button_selector = msg.next_button_selector;\n    newSelector.url = msg.url;\n    // newSelector.positive_nodes = msg.positive_nodes;\n    // newSelector.negative_nodes = msg.negative_nodes;\n    // newSelector.relation = msg.relation;\n    // newSelector.page_var_name = msg.page_var_name;\n    // newSelector.relation_id = msg.relation_id;\n    // newSelector.first_page_relation = msg.first_page_relation;\n    // newSelector.pulldown_relations = msg.pulldown_relations?.map(\n    //   (pulldownMsg) => RelationSelector.fromMessage(pulldownMsg)\n    // );\n    newSelector.relation_scrape_wait = msg.relation_scrape_wait;\n\n    return newSelector;\n  }\n\n  /**\n   * Create a {@link RelationSelector} given positive and negative elements.\n   * @param positiveEls positive elements to include\n   * @param negativeEls negative elements to exclude\n   * @param columns {@link IColumnSelector}s to include in selector\n   * @param features set of features to examine\n   */\n  public static fromPositiveAndNegativeElements(positiveEls: HTMLElement[],\n    negativeEls: HTMLElement[], columns: IColumnSelector[],\n    features = [\"tag\", \"xpath\"]): RelationSelector {\n      let featureSet = Features.getFeatureSet(features, positiveEls);\n\n      // If we can't shrink things down to less than 3 common XPaths, then\n      //   exclude XPath and use the other features.\n      if (featureSet[\"xpath\"]?.values.length > 3 &&\n          features !== Features.FEATURES_EXCEPT_XPATH) {\n        return RelationSelector.fromPositiveAndNegativeElements(positiveEls,\n          negativeEls, columns, Features.FEATURES_EXCEPT_XPATH);\n      }\n  \n      let relSel = new RelationSelector(featureSet, 0, columns);\n      let rows = relSel.getMatchingRelation();\n      \n      //now handle negative examples\n      let exclude_first = 0;\n      for (let rowIndex = 0; rowIndex < rows.length; rowIndex++){\n        let nodes = rows[rowIndex];\n        for (const node of nodes) {\n          if (node && negativeEls.includes(node)) {\n            if (rowIndex === 0) {\n              exclude_first = 1;\n            } else if (features !== Features.FEATURES_EXCEPT_XPATH) {\n              // xpaths weren't enough to exclude nodes we need to exclude\n              HelenaConsole.log(\"need to try more features.\");\n              return RelationSelector.fromPositiveAndNegativeElements(\n                positiveEls, negativeEls, columns,\n                Features.FEATURES_EXCEPT_XPATH);\n            }\n            else {\n              HelenaConsole.log(featureSet);\n              throw new Error(\"Failed to exclude all negative nodes \" + \n                \"even with all features.\");\n            }\n          }\n        }\n      }\n\n      relSel.exclude_first = exclude_first;\n      relSel.positive_nodes = positiveEls;\n      relSel.negative_nodes = negativeEls;\n      return relSel;\n  }\n\n  public highlight() {\n    return;\n  }\n  \n  /**\n   * Converts this to a content selector by setting the relation.\n   */\n  public toContentSelector(): ContentSelector {\n    this.relation = this.getMatchingRelation();\n    this.num_rows_in_demonstration = this.relation.length;\n    return <ContentSelector> this;\n  }\n\n  /**\n   * Converts this to a comparison selector for finding the best selector.\n   * @param relation relation in mainpanel format\n   * @param xpaths xpaths\n   */\n  public toComparisonSelector(rel: MainpanelNodeI[][], xpaths: string[]):\n    ComparisonSelector {\n    let compSel = <ComparisonSelector> this;\n    compSel.relation = rel;\n    compSel.numMatchedXpaths = rel.length === 0? 0 : numMatchedXpaths(xpaths, rel[0]);\n    compSel.numRows = rel.length;\n    compSel.numRowsInDemo = this.num_rows_in_demonstration? this.num_rows_in_demonstration : rel.length;\n    compSel.numColumns = rel.length === 0? 0 : rel[0].length;\n    return compSel;\n  }\n\n  /**\n   * Merges information from other selector into current selector.\n   * @param other selector to add\n   */\n  public merge(other: RelationSelector) {\n    if (Array.isArray(other)) {\n      throw new ReferenceError(\"This function only permits a singular value\" +\n        \" for `selectorToAdd.selector`\");\n    }\n    let featureSetToAdd = <GenericFeatureSet> other.selector;\n\n    let origFeatureSet = this.selector;\n    if (!origFeatureSet) { \n      // can happen that we have no selector to augment, if we're actually\n      //   demo-ing a new relation\n      origFeatureSet = [];\n      this.columns = [];\n    }\n    \n    if (Array.isArray(origFeatureSet)) {\n      // cool, no need to mess around with the current selector's columns\n      // let's just add the new selector to the list\n      this.selector = origFeatureSet.concat([ featureSetToAdd ]);\n    } else {\n      // ok, this selector used to have just one.  let's go ahead and turn it\n      //   into a list and make sure all its column objects have all their\n      //   suffixes labeled with index 0, since the current selector will be\n      //   the first in the list\n      this.selector = [origFeatureSet, featureSetToAdd];\n      labelColumnSuffixesWithTheirSelectors(this.columns, 0);\n    }\n    // and in either case, we need to add the new selectors columns to the prior\n    //   set of columns, and we need to label them with the position in the list\n    //   of selectors (len minus one)\n    labelColumnSuffixesWithTheirSelectors(other.columns,\n      (<GenericFeatureSet[]> this.selector).length - 1);\n    this.columns = this.columns.concat(other.columns);\n  }\n\n  /**\n   * Produces a stringified version of necessary keys on the relation selector.\n   */\n  public hash() {\n    return RelationSelector.hash(this);\n  }\n\n  /**\n   * Produces a stringified version of necessary keys on the relation message.\n   */\n  public static hash(msg: RelationMessage | RelationSelector) {\n    return stringify({\n      name: msg.name,\n      selector: msg.selector,\n      columns: msg.columns,\n      selector_version: msg.selector_version,\n      exclude_first: msg.exclude_first,\n      next_type: msg.next_type,\n      next_button_selector: msg.next_button_selector,\n      url: msg.url,\n      num_rows_in_demonstration: msg.num_rows_in_demonstration\n    });\n  }\n}\n\n/**\n * A selector with the relation referring to a 2d-array of DOM Elements.\n */\nexport class ContentSelector extends RelationSelector {\n  relation: (HTMLElement | null)[][];\n  editingClickColumnIndex?: number;\n  origSelector?: ContentSelector;\n  currentIndividualSelector?: ContentSelector;\n  \n  constructor(featureSet: GenericFeatureSet | GenericFeatureSet[],\n    exclude_first: number, columns: IColumnSelector[],\n    selector_version = 1) {\n      super(featureSet, exclude_first, columns, selector_version);\n  }\n\n  /**\n   * Create {@link ContentSelector} from a subset of cell elements comprising a\n   *   row such that the largest subsets are considered first, with the number\n   *   of rows found in the relation acting as a tiebreaker.\n   * @param cells list of cell elements in the row\n   * @param minSubsetSize minimum number of cell elements to consider\n   */\n  public static fromLargestRowSubset(cells: HTMLElement[],\n    minSubsetSize: number) {\n    // TODO: cjbaik: in future, can we just order the combos by number of\n    //   rowNodes included in the combo, stop once we get one that has a good\n    //   selector? could this avoid wasting so much time on this? even in cases\n    //   where we don't already have server-suggested to help us with\n    //   smallestSubsetToConsider?\n    let combos = powerset(cells, true);\n    HelenaConsole.log(\"combos\", combos);\n    let maxNumCells = -1;\n    let maxSelector: ContentSelector | null = null;\n    let maxComboSize = -1;\n    for (const combo of combos) {\n      HelenaConsole.log(\"working on a new combo\", combo);\n      // TODO: cjbaik: the if below is an inefficient way to do this!\n      //   do it better in future!  just make the smaller set of combos!\n      if (combo.length < minSubsetSize){\n        HelenaConsole.log(\"skipping a combo becuase it's smaller than the server-suggested combo\", combo, minSubsetSize);\n        continue;\n      }\n      if (combo.length < maxComboSize){\n        // remember, we're going through combinations in order from the largest\n        //   to smallest size so if we've already found one of a large size (a\n        //   large number of matched xpaths), there's no need to spend time\n        //   looking for smaller ones that we actually don't prefer\n        continue;\n      }\n      if (combo.length == 0) { break; }\n\n      let selector = ContentSelector.fromRow(combo);\n      HelenaConsole.log(\"selector\", selector);\n      if (selector.relation.length <= 1) {\n        // we're really not interested in relations of size one -- it's not\n        //   going to require parameterization at all\n        HelenaConsole.log(\"ignoring a combo because it produces a length 1 relation\", combo, selector.relation);\n        continue;\n      }\n\n      let numCells = combo.length * selector.relation.length;\n      if (numCells > maxNumCells) {\n        maxNumCells = numCells;\n        maxSelector = selector;\n        maxComboSize = combo.length;\n        HelenaConsole.log(\"maxselector so far\", maxSelector);\n        HelenaConsole.log(\"relation so far\", selector.relation);\n      }\n    }\n\n    if (!maxSelector){\n      HelenaConsole.log(\"No maxSelector\");\n      return null;\n    }\n    HelenaConsole.log(\"returning maxselector\", maxSelector);\n    return maxSelector;\n  }\n\n  /**\n   * Create {@link ContentSelector} given a list of cells comprising a row.\n   * @param cells list of cell elements in the row\n   */\n  public static fromRow(cells: HTMLElement[]) {\n    let ancestor = XPath.findCommonAncestor(cells);\n    let positiveNodes = [ancestor];\n    let columns = ColumnSelector.compute(ancestor, cells);\n    let suffixes = columns.map((col) => col.suffix);\n    let matchingDescendantSibling = \n      XPath.findDescendantSiblingMatchingSuffixes(ancestor, suffixes);\n    if (matchingDescendantSibling !== null){\n      positiveNodes.push(matchingDescendantSibling);\n    }\n    let selector = RelationSelector.fromPositiveAndNegativeElements(\n      positiveNodes, [], columns);\n    let relation = selector.getMatchingRelation();\n    selector.relation = relation;\n\n    for (let i = 0; i < relation.length; i++){\n      let relRow = relation[i];\n      // Find the first relation row that contains the first column node to find\n      //   how many header rows there are\n      if (relRow.some((cell: HTMLElement) => cells[0] === cell)) {\n        selector.exclude_first = i;\n        break;\n      }\n    }\n    return <ContentSelector> selector;\n  }\n\n  /**\n   * Highlight relation indicated by selector.\n   */\n  public highlight() {\n    window.helenaContent.relationHighlighter.highlightRelation(\n      this.relation, true, true);\n  }\n}\n\n/**\n * A selector specifically for handling tables.\n */\nexport class TableSelector extends ContentSelector {\n  selector: TableFeatureSet;\n\n  constructor(featureSet: TableFeatureSet, exclude_first: number,\n    columns: IColumnSelector[], selector_version = 1) {\n      super(featureSet, exclude_first, columns, selector_version);\n  }\n\n  /**\n   * Create a selector for cells residing in a <table> element.\n   * @param cells elements describing cells in the row\n   */\n  public static fromTableRow(cells: HTMLElement[]) {\n    HelenaConsole.log(cells);\n\n    let trs = [];\n\n    // Get ancestor <tr> elements\n    // TODO: cjbaik: currently only retrieving first one (i.e. does not consider\n    //   nested tables)\n    let closestTr = cells[0].closest(\"tr\");\n    if (closestTr && closestTr !== cells[0]) {\n      trs.push(closestTr);\n    }\n\n    if (trs.length === 0){\n      HelenaConsole.log(\"No tr parents.\");\n      return null;\n    }\n    \n    // Keep only <tr> elements which contain all the column elements\n    trs = trs.filter((tr) =>\n      cells.every((el) => tr.contains(el))\n    );\n\n    if (trs.length === 0){\n      HelenaConsole.log(\"No shared tr parents.\");\n      return null;\n    }\n\n    let bestScore = -1;\n    let bestSelector: TableSelector | null = null;\n    for (const tr of trs) {\n      let tableParent = tr.closest(\"table\");\n\n      if (!tableParent) {\n        throw new ReferenceError(\"<tr> has no <table> parent!\");\n      }\n\n      let siblingTrs = [].slice.call(tableParent.querySelectorAll(\"tr\"));\n      let index = siblingTrs.indexOf(tr);\n      let tableFeatureSet = Features.createTableFeatureSet(tableParent);\n      \n      let tdThCells = [].slice.call(tr.querySelectorAll(\"td, th\"));\n      // union of td/th cells and originally provided cells\n      let allCells = [...new Set([...tdThCells, ...cells])];\n      let selector = new TableSelector(tableFeatureSet, index,\n        ColumnSelector.compute(tr, allCells));\n      selector.positive_nodes = cells;\n      selector.negative_nodes = [];\n      let relation = selector.getMatchingRelation();\n      selector.relation = relation;\n      let score = relation.length * relation[0].length;\n      if (score > bestScore){\n        bestScore = score;\n        bestSelector = selector;\n      }\n    }\n\n    return bestSelector;\n  }\n\n  /**\n   * Gets the document elements matching the features specified in selector for\n   *   a table element.\n   * @param excludeFirst exclude this many rows from extraction (e.g. headers)\n   */\n  public getMatchingElements() {\n    let selector = <TableFeatureSet> this.selector;\n\n    // we don't use this for nested tables! this is just for very simple tables,\n    //   otherwise we'd graduate to the standard approach\n    let nodes = XPath.getNodes(selector.xpath);\n    let table = null;\n    if (nodes.length > 0) {\n      // awesome, we have something at the exact xpath\n      table = <HTMLElement> nodes[0];\n    } else {\n      // ok, I guess we'll have to see which table on the page is closest\n      let tables = [].slice.call(document.getElementsByTagName(\"table\"));\n      let bestTableScore = Number.POSITIVE_INFINITY;\n\n      for (const t of tables) {\n        let distance = Utilities.levenshteinDistance(XPath.fromNode(t),\n          selector.xpath);\n        if (distance < bestTableScore){\n          bestTableScore = distance;\n          table = t;\n        }\n      }\n    }\n\n    // ok, now we know which table to use\n\n    if (table === null) {\n      console.warn(`Could not find table matching ${JSON.stringify(selector)}`);\n      // todo: why is this arising?\n      return [];\n    }\n\n    let rows = [].slice.call(table.querySelectorAll(\"tr\"));\n    rows = rows.slice(this.exclude_first, rows.length);\n    return [rows];\n  }\n}\n\n/**\n * A selector for handling <select> elements.\n */\nexport class PulldownSelector extends RelationSelector {\n  /**\n   * cjbaik: Not sure what this does, or if it is even ever called.\n   * @param selector \n   */\n  public static getNodesForPulldownSelector(selector: PulldownFeatureSet) {\n    let allSelectNodes = document.getElementsByTagName(\"select\");\n    // then just index into it, because our current approach to pulldowns is\n    //   crazy simplistic\n    let selectorNode = allSelectNodes[selector.index];\n    console.log(\"selector: \", selector, selector.index, selectorNode);\n    if (!selectorNode.disabled) {\n      console.log(\"selector enabled\");\n      let optionNodes = [].slice.call(selectorNode.querySelectorAll(\"option\"));\n      console.log(\"option nodes\", optionNodes);\n      return optionNodes;\n    }\n    console.log(\"selector not enabled\");\n    // else, we know which pulldown we want, but it's disabled right now.\n    //   let's wait\n    return [];\n  }\n\n  /**\n   * Get a relation from the document given the selector.\n   * @returns a relation (i.e. a 2d array) with the matching data\n   */\n  public getMatchingRelation(): (HTMLElement | null)[][] {\n    let optionNodes = PulldownSelector.getNodesForPulldownSelector(\n      <PulldownFeatureSet> this.selector);\n    optionNodes = optionNodes.splice(this.exclude_first, optionNodes.length);\n    return optionNodes.map((o: HTMLElement[]) => [o]);\n  }\n\n  /**\n   * Create list of {@link PulldownSelector}s for XPaths of <select>\n   *   (i.e. pulldown) elements.\n   * @param msg message content from mainpanel\n   * @param pulldownXPaths xpaths containing pulldowns\n   */\n  public static fromXPaths(msg: LikelyRelationMessage,\n    pulldownXPaths: string[]) {\n      let pulldownSelectors = [];\n      let selectNodes = [].slice.call(document.querySelectorAll(\"select\"));\n      for (const pulldownXPath of pulldownXPaths) {\n        // pageVarName is used by the mainpanel to keep track of which pages have\n        //   been handled already\n        let featureSet: PulldownFeatureSet = {\n          type: \"pulldown\",\n          index: -1\n        };\n        let selector = new PulldownSelector(featureSet, 0, []);\n        selector.page_var_name = msg.pageVarName;\n        selector.url = window.location.href;\n        let node = XPath.getNodes(pulldownXPath)[0];\n        if (!node) {\n          continue; // TODO: right thing to do?\n        }\n        let index = selectNodes.indexOf(node);\n        let optionsRelation = extractOptionsRelationFromSelectElement(\n          <HTMLElement> node);\n        let firstRowXpath = optionsRelation[0][0].xpath;\n        \n        // cjbaik: this is a no-op so long as excludeFirst is always 0 above\n        // optionsRelation = optionsRelation.splice(selector.exclude_first,\n        // optionsRelation.length);\n  \n        selector.relation_id = null;\n        selector.name = \"pulldown_\" + (index + 1);\n        // for a pulldown menu, there better be no more items\n        selector.next_type = NextButtonTypes.NONE;\n        selector.next_button_selector = null;\n        selector.num_rows_in_demonstration = optionsRelation.length;\n        featureSet.index = index;\n        selector.columns.push({\n          id: null,\n          index: \"0\", // only one column\n          name: selector.name + \"_option\",\n          suffix: [],\n          xpath: firstRowXpath\n        });\n        selector.first_page_relation = optionsRelation;  \n  \n        pulldownSelectors.push(selector);\n      }\n      return pulldownSelectors;\n  }\n\n  constructor(featureSet: GenericFeatureSet | GenericFeatureSet[],\n    exclude_first: number, columns: IColumnSelector[]) {\n      // selector_version is always 2 for PulldownSelector\n      super(featureSet, exclude_first, columns, 2);\n\n  }\n}\n\n/**\n * Selector with additional metadata for selecting the \"best\" selector.\n */ \nexport class ComparisonSelector extends RelationSelector {\n  relation: MainpanelNodeI[][];\n  numMatchedXpaths: number;\n  numRows: number;\n  numRowsInDemo: number;\n  numColumns: number;\n\n  /**\n   * Selects the preferred selector among the two in order of:\n   *   1. largest number of target xpaths in the first row,\n   *   2. largest number of rows retrieved from the page,\n   *   3. largest num of rows in original demonstration,\n   *   4. largest number of columns associated with relation\n   *   5. other miscellaneous criteria\n   * @param first first selector\n   * @param second second selector\n   */\n  public static bestOf(first: ComparisonSelector, second: ComparisonSelector) {\n    // first things first, before we get into anything else, we always want a\n    //   relation with more than one row or else we don't really care about it.\n    //   so default or no, we're going to eliminate it if it only has one\n    if (first.numRowsInDemo > 1 && second.numRowsInDemo <= 1) {\n      return first;\n    }\n    else if (second.numRowsInDemo > 1 && first.numRowsInDemo <= 1) {\n      return second;\n    }\n\n    // normal processesing - just go through the features we care about, and\n    //   pick default if it wins on any of our ordered list of features, else\n    //   the alternative. we only really get into crazy tie breakers if we're\n    //   tied on num of matched xpaths, because whichever wins there can\n    //   automatically win the whole thing but if they're tied, we go into the\n    //   extra feature deciders\n    if (first.numMatchedXpaths > second.numMatchedXpaths){\n      return first;\n    }\n    else if (first.numMatchedXpaths === second.numMatchedXpaths){\n      if (first.numRows > second.numRows){\n        return first;\n      }\n      else if (first.numRows === second.numRows){\n        if (first.numRowsInDemo > second.numRowsInDemo){\n          return first;\n        }\n        else if (first.numRowsInDemo === second.numRowsInDemo){\n          if (first.numColumns > second.numColumns){\n            return first;\n          }\n          else if (first.numColumns === second.numColumns){\n            if (first.next_type !== null && second.next_type === null){\n              // first has a next button method, but second\n              //   doesn't, so first better\n              return first;\n            }\n            else if (!(second.next_type !== null && first.next_type === null)) {\n              // it's not the case that second has next method and first\n              //   doesn't, so either both have it or neither has it, so\n              //   they're the same, so just return the default one\n              return first;\n            }\n          }\n        }\n      }\n    }\n    return second;\n  }\n}","import { HelenaConsole } from \"../../common/utils/helena_console\";\n\ninterface Highlightable {\n  highlightElement?: HTMLElement;\n}\n\nexport namespace Highlight {\n  let counter = 0;\n  let highlights: JQuery<HTMLElement>[] = [];\n  \n  export function highlightNode(target: HTMLElement, color: string,\n      display = true, pointerEvents = false) {\n    if (!target){\n      HelenaConsole.log(\"Woah woah woah, why were you trying to highlight a \" +\n        \"null or undefined thing?\");\n      return $('<div/>');\n    }\n    counter += 1;\n    const $target = $(target);\n    const offset = $target.offset();\n    if (!target.getBoundingClientRect){\n      // document sometimes gets hovered, and there's no getboundingclientrect\n      //   for it\n      return;\n    }\n    const boundingBox = target.getBoundingClientRect();\n    const newDiv: JQuery<HTMLElement> & Highlightable = $('<div/>');\n    const idName = 'vpbd-hightlight-' + counter;\n    newDiv.attr('id', idName);\n    newDiv.css('width', boundingBox.width);\n    newDiv.css('height', boundingBox.height);\n    if (offset) {\n      newDiv.css('top', offset.top);\n      newDiv.css('left', offset.left);\n    }\n    newDiv.css('position', 'absolute');\n    newDiv.css('z-index', 2147483640);\n    newDiv.css('background-color', color);\n    newDiv.css('opacity', .4);\n    if (!display) {\n      newDiv.css('display', 'none');\n    }\n    if (!pointerEvents) {\n      newDiv.css('pointer-events', 'none');\n    }\n    $(document.body).append(newDiv);\n    highlights.push(newDiv);\n    (<Highlightable> newDiv.get(0)).highlightElement = target;\n    return newDiv;\n  }\n\n  export function isHighlight(node: HTMLElement){\n    var id = $(node).attr(\"id\");\n    return id !== null && id !== undefined &&\n           id.indexOf(\"vpbd-hightlight\") > -1;\n  }\n\n  export function getHighlightedElement(node: HTMLElement & Highlightable) {\n    return node.highlightElement;\n  }\n\n  export function clearHighlight(highlightNode?: JQuery<HTMLElement>) {\n    if (!highlightNode){\n      return;\n    }\n    highlights = highlights.filter((node) => node !== highlightNode);\n    highlightNode.remove();\n  }\n\n  export function clearAllHighlights() {\n    for (const highlight of highlights) {\n      highlight.remove();\n    }\n    highlights = [];\n  }\n}","import { RelationSelector, ContentSelector } from \"../selector/relation_selector\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Messages } from \"../../common/messages\";\nimport { Highlight } from \"./highlight\";\nimport { KnownRelationResponse, ServerRelationMessage } from \"../../mainpanel/utils/server\";\n\nexport interface KnownRelation {\n  selectorObj: RelationSelector;\n  nodes: (HTMLElement | null)[];\n  relationOutput: (HTMLElement | null)[][];\n  highlighted: boolean;\n  highlightNodesTime?: number;\n  highlightNodes?: JQuery<HTMLElement>[];\n}\n\n/**\n * Highlight relations that can be found on the page on hover.\n */\nexport class RelationHighlighter {\n  public currentlyHighlighted: JQuery<HTMLElement>[] = [];\n  public highlightColors: string[];\n  public knownRelations: KnownRelation[];\n\n  constructor () {\n    this.currentlyHighlighted = [];\n    this.knownRelations = [];\n    this.highlightColors = [\"#9EE4FF\",\"#9EB3FF\", \"#BA9EFF\", \"#9EFFEA\",\n      \"#E4FF9E\", \"#FFBA9E\", \"#FF8E61\"];\n  }\n\n  public clearCurrentlyHighlighted() {\n    for (const node of this.currentlyHighlighted) {\n      Highlight.clearHighlight(node);\n    }\n    this.currentlyHighlighted = [];\n  }\n\n  /**\n   * Retrieve known relations from the server.\n   */\n  public getKnownRelations() {\n    const self = this;\n    // TODO: cjbaik: switch this to a port rather than a one time msg\n\n    // have to ask background to make the extension make a POST\n    // request because modern Chrome won't let us request http content from\n    // https pages and we don't currently have ssl certificate for kaofang\n    Messages.sendMessage(\"content\", \"background\", \"getKnownRelations\",\n      { url: window.location.href });\n    Messages.listenForMessageOnce(\"background\", \"content\", \"getKnownRelations\",\n      (resp: KnownRelationResponse) => {\n        HelenaConsole.log(resp);\n        self.preprocessKnownRelations(resp.relations);\n      }\n    );\n  }\n\n  /**\n   * Massage and reformat server response about known relations.\n   * @param resp server response\n   */\n  private preprocessKnownRelations(resp: ServerRelationMessage[]) {\n    for (let i = 0; i < resp.length; i++) {\n      let selector = RelationSelector.fromJSON(resp[i]);\n      // first let's apply each of our possible relations to see which nodes\n      //   appear in them\n      try {\n        // let selector = RelationSelector.fromMessage(selectorMsg);\n        let relationOutput = selector.getMatchingRelation();\n        let nodes = relationOutput.reduce((memo, row) => memo.concat(row),\n          []);\n\n        // then let's make a set of highlight nodes for each relation, so we\n        //   can toggle them between hidden and displayed based on user's\n        //   hover behavior\n        this.knownRelations.push(\n          {\n            selectorObj: selector,\n            nodes: nodes,\n            relationOutput: relationOutput,\n            highlighted: false\n          }\n        );\n      } catch (err) {\n        console.error(err);\n        // console.warn(`Known relation ${JSON.stringify(resp[i])} failed.`);\n        continue;\n      }\n    }  \n  }\n\n  /**\n   * Given an element, find most relevant relation and highlight.\n   * @param element element to highlight\n   */\n  public highlightRelevantRelation(element: HTMLElement) {\n    // for now we'll just pick whichever node includes the current node and has\n    //   the largest number of nodes on the current page\n    let winningRelation = null;\n    let winningRelationSize = 0;\n    for (const relationInfo of this.knownRelations) {\n      if (relationInfo.nodes.includes(element)) {\n        if (relationInfo.nodes.length > winningRelationSize) {\n          winningRelation = relationInfo;\n          winningRelationSize = relationInfo.nodes.length;\n        }\n      }\n    }\n    if (winningRelation) {\n      // cool, we have a relation to highlight\n      winningRelation.highlighted = true;\n      \n      // important to make the highlight nodes now, since the nodes might be\n      // shifting around throughout interaction, especially if things still\n      // loading\n      let currTime = new Date().getTime();\n      let highlightNodes: JQuery<HTMLElement>[] | undefined = undefined;\n\n      if (winningRelation.highlightNodes &&\n        winningRelation.highlightNodesTime &&\n        ((currTime - winningRelation.highlightNodesTime) < 2000)) {\n        // cache the highlight nodes for up to two second, then go ahead and\n        //   recompute those positions\n        highlightNodes = winningRelation.highlightNodes;\n      } else {\n        highlightNodes = this.highlightRelation(\n          winningRelation.relationOutput, false, false);\n      }\n      winningRelation.highlightNodes = highlightNodes;\n      winningRelation.highlightNodesTime = new Date().getTime();\n\n      for (let i = 0; i < highlightNodes.length; i++) {\n        highlightNodes[i].css(\"display\", \"block\");\n      }\n    }\n  }\n\n  /**\n   * Highlight the relation.\n   * @param relation elements in relation\n   * @param display whether to show highlight nodes or not\n   * @param pointerEvents whether to enable or disable CSS pointer-events on\n   *   highlight nodes\n   * @returns highlighted nodes\n   */\n  public highlightRelation(relation: (HTMLElement | null)[][], display: boolean,\n    pointerEvents: boolean) {\n    let nodes = [];\n    for (const row of relation) {\n      for (let cellIndex = 0; cellIndex < row.length; cellIndex++) {\n        let cell = row[cellIndex];\n        if (cell === null){ continue; }\n        // first make sure there is a color at index j, add one if there isn't\n        if (cellIndex >= this.highlightColors.length) {\n          this.highlightColors.push(\n            \"#000000\".replace(/0/g,function () {\n              return (~~(Math.random()*16)).toString(16);\n            }));\n        }\n        let node = Highlight.highlightNode(cell,\n          this.highlightColors[cellIndex], display, pointerEvents);\n        if (node) {\n          nodes.push(node);\n        }\n      }\n    }\n    this.currentlyHighlighted = nodes;\n    return nodes;\n  }\n\n  /**\n   * Unhighlight the relation.\n   */\n  public unhighlight() {\n    for (let i = 0; i < this.knownRelations.length; i++) {\n      let relationInfo = this.knownRelations[i];\n      if (relationInfo.highlightNodes) {\n        for (let j = 0; j < relationInfo.highlightNodes.length; j++) {\n          relationInfo.highlightNodes[j].css(\"display\", \"none\");\n        }\n      }\n    }\n  };\n}","import { MainpanelNode } from \"../../common/mainpanel_node\";\n\n/**\n * Extend Element to allow tooltips to be attached.\n */\ninterface TooltipAdded {\n  scrapingTooltip?: ScrapingTooltip;\n}\n\n/**\n * Tooltip for giving user feedback about the element they're hovering over.\n */\nexport class ScrapingTooltip {\n  public static DEFAULT_TOOLTIP_COLOR = \"rgba(255, 255, 255, 0.9)\";\n\n  tooltipElement: JQuery<HTMLElement>;\n\n  /**\n   * Create a tooltip for giving user feedback about the element.\n   * @param element element to create tooltip for\n   * @param tooltipColor color of tooltip\n   */\n  constructor(element: HTMLElement,\n      tooltipColor = ScrapingTooltip.DEFAULT_TOOLTIP_COLOR) {\n    let nodeText = MainpanelNode.getNodeText(element);\n    if (nodeText) {\n      nodeText = nodeText.replace(/\\n/g, \"<br>\");\n      if (nodeText.length > 400) {\n        nodeText = nodeText.slice(0,200) + \"...\" +\n          nodeText.slice(nodeText.length - 200, nodeText.length);\n      }\n    }\n    let boundRect = element.getBoundingClientRect();\n    let newDiv = $('<div>'+nodeText+'<div/>');\n    let width = boundRect.width;\n    let threshold = 150;\n    if (width < threshold) { width = threshold; }\n\n    newDiv.attr('id', 'vpbd-hightlight');\n    newDiv.css('width', width);\n    newDiv.css('top', document.body.scrollTop + boundRect.top + boundRect.height);\n    newDiv.css('left', document.body.scrollLeft + boundRect.left);\n    newDiv.css('position', 'absolute');\n    newDiv.css('z-index', 2147483647);\n    newDiv.css('background-color', tooltipColor);\n    newDiv.css('box-shadow', '0px 0px 5px grey');\n    newDiv.css('padding', '3px');\n    newDiv.css('overflow', 'hidden');\n    newDiv.css('overflow-wrap', 'break-word');\n\n    $(document.body).append(newDiv);\n\n    this.tooltipElement = newDiv;\n    (<HTMLElement & TooltipAdded> element).scrapingTooltip = this;\n  }\n\n  /**\n   * Remove this ScrapingTooltip from the element it is attached to.\n   */\n  public destroy() {\n    this.tooltipElement.remove();\n  }\n\n  /**\n   * Remove scraping tooltip from the element.\n   */\n  public static destroy(element: HTMLElement & TooltipAdded) {\n    if (element.scrapingTooltip) {\n      element.scrapingTooltip.destroy();\n    }\n  }\n}","import { XPath } from \"./xpath\";\nimport XPathNode = XPath.XPathNode;\nimport XPathList = XPath.XPathList;\n\ninterface IndexableDOMRect extends DOMRect {\n  [key: string]: any;\n}\n\n/**\n * Interfaces and functions for creating and modifying features of DOM elements.\n */\nexport namespace Features {\n\n  /**\n   * All supported features.\n   */\n  const SUPPORTED_FEATURES = [\"tag\", \"class\", \"left\", \"bottom\", \"right\", \"top\",\n    \"width\", \"height\", \"font-size\", \"font-family\", \"font-style\", \"font-weight\",\n    \"color\", \"background-color\", \"preceding-text\", \"text\", \"xpath\"];\n\n  /**\n   * All supported features except XPath.\n   */\n  export const FEATURES_EXCEPT_XPATH = SUPPORTED_FEATURES.slice().filter(\n    (feature) => feature !== \"xpath\");\n\n  /**\n   * Contains information on what criteria to match for a certain feature.\n   */\n  interface FeatureCriteria {\n    /**\n     * Whether the criteria is positive or negative.\n     * true means positive; node should match this value\n     * false means negate; node should NOT match this value\n     */\n    pos: boolean;\n  \n    values: (string | XPathNode[])[];\n  }\n  \n  /**\n   * A generic interface to inherit specific feature sets from.\n   */\n  export interface GenericFeatureSet {\n  }\n  \n  /**\n   * A set of features describing how to find the rows for a relation.\n   */\n  export interface FeatureSet extends GenericFeatureSet {\n    [key: string]: FeatureCriteria;\n  }\n\n  /**\n   * A separate feature set for handling tables.\n   */\n  export interface TableFeatureSet extends GenericFeatureSet {\n    table: boolean;\n    xpath: string;\n  }\n\n  export interface PulldownFeatureSet extends GenericFeatureSet {\n    type: string;\n    index: number;\n  }\n\n  /**\n   * Computes the value of a feature from an element.\n   * @param element element\n   * @param feature feature name\n   */\n  export function computeFeatureFromElement(element: HTMLElement,\n    feature: string) {\n    if (feature === \"xpath\") {\n      return XPath.toXPathNodeList(<string> XPath.fromNode(element));\n    } else if (feature === \"preceding-text\") {\n      return element.previousElementSibling?.textContent;\n    } else if (feature === \"text\") {\n      return element.textContent;\n    } else if (feature === \"tag\") {\n      return element.tagName;\n    } else if (feature === \"class\") {\n      return element.className;\n    } else if ([\"top\", \"right\", \"bottom\", \n                \"left\", \"width\", \"height\"].includes(feature)) {\n      let rect = <IndexableDOMRect> element.getBoundingClientRect();\n      return rect[feature];\n    } else {\n      return window.getComputedStyle(element, null).getPropertyValue(feature);\n    }\n  }\n\n  /**\n   * Checks if feature value is within acceptable values.\n   * @param feature feature type\n   * @param value feature value\n   * @param acceptable_values acceptable feature values to match to\n   * @returns true if feature value is within acceptable values\n   */\n  export function featureMatches(feature: string, value: string | XPathList,\n    acceptable_values: (string | XPathList)[]) {\n    if (feature === \"xpath\") {\n      return acceptable_values.some((av: XPathList) =>\n        XPath.matches(av, <XPathList> value)\n      );\n    } else if (feature === \"class\") {\n      // class doesn't have to be same, just has to include the target class\n      // TODO: Decide if that's really how we want it\n      return acceptable_values.some(\n        (av: string) => (<string> value).includes(av));\n    } else {\n      return acceptable_values.includes(value);\n    }\n  }\n\n\n  /**\n   * Merges feature values from multiple elements to find common feature values.\n   *   Removes any features for which there are no common feature values or the\n   *   maximum common feature values is exceeded.\n   * For general arrays, deduplicate feature value arrays.\n   * For xpath arrays, multiple xpaths with overlapping sections are merged\n   *   using wildcard (*)s where possible.\n   * @param featureSet the unmerged feature set\n   * @param maxFeatureValues the maximum number of common feature values\n   */\n  export function mergeFeatureValues(featureSet: FeatureSet,\n    maxFeatureValues = 3) {\n    for (const feature in featureSet) {\n      let featureValues = featureSet[feature].values;\n      if (feature === \"xpath\") {\n        featureSet[feature].values = XPath.condenseList(\n          <XPathList[]> featureValues);\n      } else {\n        let origFeatureCount = featureValues.length;\n        let mergedVals = [...new Set(featureValues)];   // de-duplicate\n        if (mergedVals.length <= maxFeatureValues &&\n            mergedVals.length < origFeatureCount) {\n          featureSet[feature].values = mergedVals; \n        } else {\n          delete featureSet[feature];\n        }\n      }\n    }\n  }\n\n\n  /**\n   * Creates a {@link FeatureSet} for features from matched elements.\n   * @param features list of features to use\n   * @param matchedEls matched elements\n   */\n  export function getFeatureSet(features: string[], matchedEls: HTMLElement[]) {\n    let featureSet: FeatureSet = {};\n\n    for (const feature of features) {\n      featureSet[feature] = { values: [], pos: true };\n\n      // add all positive nodes' values into the feature dict\n      for (const posNode of matchedEls) {\n        let value = computeFeatureFromElement(posNode, feature);\n        featureSet[feature].values.push(value);\n      }\n    }\n\n    mergeFeatureValues(featureSet);\n\n    return featureSet;\n  }\n\n\n  /**\n   * Create a {@link TableFeatureSet} from a table element.\n   * @param tableEl table element\n   */\n  export function createTableFeatureSet(tableEl: HTMLElement): TableFeatureSet {\n    return {\n      table: true,\n      xpath: <string> XPath.fromNode(tableEl)\n    };\n  }\n\n  /**\n   * Convert a server-retrieved message of a featureSet to a {@link FeatureSet}.\n   * @param featureSetMsg the message\n   */\n  /*\n  export function fromMessage(featureSetMsg: FeatureSetMessage) {\n    let featureSet: FeatureSet = {};\n    \n    for (const feature in featureSetMsg) {\n      if (feature === 'xpath') {\n        featureSet.xpath = {\n          pos: featureSetMsg.xpath.pos,\n          values: []\n        };\n        for (const value of featureSetMsg.xpath.values) {\n          let xpathList: XPathList = [];\n          let messageXPathList = <XPathNodeMessage[]> value;\n          for (const msgXPathNode of messageXPathList) {\n            xpathList.push({\n              nodeName: msgXPathNode.nodeName,\n              iterable: msgXPathNode.iterable,\n              index: parseInt(msgXPathNode.index)\n            });\n          };\n          featureSet.xpath.values.push(xpathList);\n        }\n      } else {\n        featureSet[feature] = <FeatureCriteria> featureSetMsg[feature];\n      }\n    }\n    return featureSet;\n  }*/\n}","import * as html2canvas from \"html2canvas\";\nimport { DOMRingerEvent } from \"../../ringer-record-replay/common/event\";\n\ninterface ScreenshotHTMLElement extends HTMLElement {\n  html2canvasDataUrl: string;\n  waitingForRender: boolean;\n}\n\n/**\n * Handles taking screenshots of nodes.\n */\nexport namespace Screenshot {\n  /**\n   * Identifies transparent edges.\n   * [cjbaik: Not completely sure what this means?]\n   * @param canvas the canvas element\n   */\n  function identifyTransparentEdges(canvas: HTMLCanvasElement) {\n    let context = canvas.getContext(\"2d\");\n\n    if (!context) {\n      throw new ReferenceError(\"Context does not exist for canvas element.\");\n    }\n\n    let imgData = context.getImageData(0, 0, canvas.width, canvas.height);\n    let data = imgData.data;\n\n    // what rows and columns are empty?\n\n    let columnsEmpty = [];\n    for (let i = 0; i < canvas.width; i++) {\n      columnsEmpty.push(true);\n    }\n    let rowsEmpty = [];\n    for (let i = 0; i < canvas.height; i++) {\n      rowsEmpty.push(true);\n    }\n\n    for(let i = 0; i < data.length; i += 4) {\n      let currX = (i / 4) % canvas.width,\n        currY = ((i / 4) - currX) / canvas.width;\n      let alpha = data[i+3];\n      if (alpha > 0) {\n        columnsEmpty[currX] = false;\n        rowsEmpty[currY] = false;\n      }\n    }\n\n    // how far should we crop?\n    let left = 0;\n    let left_i = left;\n    while (columnsEmpty[left_i]) {\n      left = left_i;\n      left_i += 1;\n    }\n\n    let right = canvas.width - 1;\n    let right_i = right;\n    while (columnsEmpty[right_i]) {\n      right = right_i;\n      right_i -= 1;\n    }\n\n    let top = 0;\n    let top_i = top;\n    while (rowsEmpty[top_i]) {\n      top = top_i;\n      top_i += 1;\n    }\n    \n    let bottom = canvas.height - 1;\n    let bottom_i = bottom;\n    while (rowsEmpty[bottom_i]) {\n      bottom = bottom_i;\n      bottom_i -= 1;\n    }\n\n    if (left === 0 && right === (canvas.width - 1) && top === 0 &&\n        bottom === (canvas.height - 1)) {\n      // no need to do any cropping\n      return canvas;\n    }\n\n    // use a temporary canvas to crop\n    let tempCanvas = document.createElement(\"canvas\");\n    let tContext = tempCanvas.getContext(\"2d\");\n    tempCanvas.width = (right - left);\n    tempCanvas.height = (bottom - top);\n\n    if (!tContext) {\n      throw new ReferenceError(\"Context does not exist for canvas element.\");\n    }\n    tContext.drawImage(canvas, left, top, tempCanvas.width, tempCanvas.height,\n      0, 0, tempCanvas.width, tempCanvas.height);\n\n    // HelenaConsole.log(canvas.width, canvas.height);\n    // HelenaConsole.log(left, right, top, bottom);\n    // HelenaConsole.log(tempCanvas.width, tempCanvas.height);\n\n    return tempCanvas;\n  }\n  /**\n   * Take a screenshot of the referenced element.\n   * @param element element\n   * @param traceEvent event message\n   */\n  export function take(element: ScreenshotHTMLElement,\n    traceEvent: DOMRingerEvent) {\n    if (!window.helenaContent.currentlyRecording()) {\n      // don't want to run this visualization stuff if we're in replay mode\n      //   rather than recording mode, even though of course we're recording\n      //   during replay\n      return;\n    }\n    if (traceEvent instanceof KeyboardEvent) {\n      // ignore below.  this was when we were also checking if there was no\n      // node.value;  but in general we're having issues with trying to\n      // screenshot things for keyboard events when we really shouldn't so for\n      // now changing presentation so that there is no 'target node' for\n      // typing in the user-facing representation of the script for now we're\n      // using this to determine whether the user is actually typing text into\n      // a particular node or not.  since no node.value, probably not, and we\n      // are likely to be 'focus'ed on something big, so don't want to freeze\n      // the page by screenshoting this is a weird case to include, but\n      // practical.  we'll still raise the events on the right nodes, but it\n      // will be easier for the user to interact with the recording phase if\n      // we don't show the node may want to send a different message in future\n      // updateExistingEvent(TraceEvent, \"additional.visualization\",\n      //   \"whole page\");\n      return \"whole page\";\n    }\n    if (element.html2canvasDataUrl) {\n      // yay, we've already done the 'screenshot', need not do it again\n      // updateExistingEvent(TraceEvent, \"additional.visualization\",\n      //   node.html2canvasDataUrl);\n      return element.html2canvasDataUrl;\n    }\n    if (element.waitingForRender) {\n      setTimeout(function() {\n        window.ringerContent.additional_recording_handlers.visualization(\n          element, traceEvent);\n      }, 100);\n      return;\n    }\n    if (element === document.body) {\n      // never want to screenshot the whole page...can really freeze the page,\n      //   and we have an easier way to refer to it\n      // updateExistingEvent(TraceEvent, \"additional.visualization\",\n      //   \"whole page\");\n      return \"whole page\";\n    }\n    // ok, looks like this is actually the first time seeing this, better\n    //   actually canvasize it\n    element.waitingForRender = true;\n    // HelenaConsole.log(\"going to render: \", node);\n\n    html2canvas(element).then(function(canvas: HTMLCanvasElement) {\n      canvas = identifyTransparentEdges(canvas);\n      let dataUrl = canvas.toDataURL();\n      element.html2canvasDataUrl = dataUrl;\n      window.ringerContent.updateExistingEvent(traceEvent,\n        \"additional.visualization\", dataUrl);\n    });\n    return null;\n  };\n}","export namespace XPath {\n  export interface XPathNode {\n    nodeName: string;\n    index: string;\n    iterable: boolean;\n  }\n\n  export type XPathList = Array<XPathNode>;\n\n  export class SuffixXPathList extends Array<XPathNode> {\n    selectorIndex?: number;\n    suffixRepresentation?: SuffixXPathList;\n  }\n\n  /**\n   * Find the common ancestor of multiple elements.\n   * @param elements elements\n   */\n  export function findCommonAncestor(elements: (HTMLElement | null)[]) {\n    if (elements.length === 0) {\n      throw new ReferenceError(\"Cannot get common ancestor of 0 nodes.\");\n    }\n\n    // this doesn't handle null nodes, so filter those out first\n    elements = elements.filter((el) => el && $(el).parents().length);\n    let xPathLists = elements.map((node) =>\n      toXPathNodeList(<string> fromNode(node)));\n    let firstXPathList = xPathLists[0];\n    let i: number;\n    for (i = 0; i < firstXPathList.length; i++) {\n      let all_match = xPathLists.every((curXPathList) =>\n        curXPathList[i].nodeName === firstXPathList[i].nodeName &&\n        curXPathList[i].index === firstXPathList[i].index &&\n        curXPathList[i].iterable === firstXPathList[i].iterable);\n      if (!all_match) {\n        break;\n      }\n    }\n    let last_matching = i - 1;\n    let ancestor_xpath_list = firstXPathList.slice(0, last_matching + 1);\n    let ancestor_nodes = getNodes(\n      XPath.toString(ancestor_xpath_list));\n    return <HTMLElement> ancestor_nodes[0];\n  }\n\n  /**\n   * Check whether node has at least one descendant matching each suffix.\n   * @param node node\n   * @param suffixes list of suffixes\n   */\n  function matchesAllSuffixes(node: Node,\n    suffixesList: (SuffixXPathList[] | undefined)[]){\n    let elXPath = XPath.toXPathNodeList(<string> fromNode(node));\n    //check whether this node has an entry for all desired suffixes\n    for (const suffixes of suffixesList) {\n      if (!suffixes) {\n        continue;\n      }\n      for (const suffix of suffixes) {\n        let suffixXPath = XPath.toString(elXPath.concat(suffix));\n        let suffixNodes = getNodes(suffixXPath);\n        if (suffixNodes.length === 0) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Finds a sibling of a descendant of given element matching suffixes.\n   * @param element element\n   * @param suffixes list of {@link SuffixXPathList}s\n   */\n  export function findDescendantSiblingMatchingSuffixes(element: HTMLElement,\n    suffixes: (SuffixXPathList[] | undefined)[]) {\n    let elXPath = XPath.toXPathNodeList(<string> fromNode(element));\n    \n    // start at the end of the xpath, move back towards root\n    for (let i = (elXPath.length - 1); i >= 0; i--) {\n      let index = parseInt(elXPath[i].index);\n      \n      elXPath[i].index = (index + 1).toString(); // modify XPath, try next sibling\n      let siblingNodes = getNodes(XPath.toString(elXPath));\n      elXPath[i].index = index.toString();     // return index to original value\n    \n      if (siblingNodes.length > 0) {\n        // [cjbaik: I presume it's not possible to have > 1 node here?]\n        let siblingNode = siblingNodes[0];\n        if (matchesAllSuffixes(siblingNode, suffixes)) {\n          return <HTMLElement> siblingNode;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the suffix of the descendant with respect to the ancestor.\n   * @param ancestor ancestor node\n   * @param descendant descendant node\n   */\n  export function suffixFromAncestor(ancestor: Node, descendant: Node):\n    XPathNode[] {\n    let ancestorList = XPath.toXPathNodeList(<string> fromNode(ancestor));\n    let descList = XPath.toXPathNodeList(<string> fromNode(descendant));\n    return descList.slice(ancestorList.length, descList.length);\n  }\n\n  /**\n   * Convert a DOM node to an XPath expression representing the path from the\n   *   document element.\n   * @param node the DOM node\n   */\n  export function fromNode(node?: Node | null): string {\n    // a special case for events that happen on document\n    if (node === document){\n      return \"document\";\n    }\n\n    if (node === null || node === undefined){\n      return \"\";\n    }\n\n    let element = <HTMLElement> node;\n\n    if (element.tagName.toLowerCase() === 'html') {\n      return element.tagName;\n    }\n\n    // if there is no parent node then this element has been disconnected\n    // from the root of the DOM tree\n    if (!element.parentElement) {\n      return '';\n    }\n\n    let ix = 0;\n    let siblings = element.parentElement.children;\n    for (let i = 0, ii = siblings.length; i < ii; i++) {\n      let sibling = siblings[i];\n      if (sibling === element) {\n        return fromNode(element.parentElement) + '/' + element.tagName +\n              '[' + (ix + 1) + ']';\n      }\n      if (sibling.nodeType === 1 && sibling.tagName === element.tagName) {\n        ix++;\n      }\n    }\n    throw new ReferenceError('Child node does not belong to its own parent!');\n  }\n\n  /**\n   * Get DOM nodes matching the XPath expression on the current document.\n   * @param xpath XPath expression\n   */\n  export function getNodes(xpath: string) {\n    // a special case for events that happen on document\n    if (xpath === \"document\") {\n      return [document];\n    }\n    try {\n      let lowerCaseXpath = xpath.toLowerCase();\n      if (lowerCaseXpath.indexOf(\"/svg\") > -1){\n        // ok, have to mess around with the prefixes for the svg components\n        let components = lowerCaseXpath.split(\"/\");\n        let foundSvg = false;\n        for (let i = 0; i < components.length; i++){\n          let c = components[i];\n          if (c.startsWith(\"svg\")){\n            foundSvg = true;\n          }\n          if (foundSvg){\n            components[i] = \"svg:\" + c;\n          }\n        }\n        xpath = components.join(\"/\");\n      }\n  \n      let q = document.evaluate(xpath, document, (prefix: string) => { \n          if (prefix === 'svg') {\n            return 'http://www.w3.org/2000/svg';\n          }\n          else {\n            return null; // the default namespace\n          }\n        }, XPathResult.ANY_TYPE, null);\n      let results = [];\n  \n      let next = q.iterateNext();\n      while (next) {\n        results.push(next);\n        next = q.iterateNext();\n      }\n      return results;\n    } catch (e) {\n      console.error('xPath throws error when evaluated:', xpath);\n    }\n    return [];\n  }\n\n  /**\n   * Returns the first {@link HTMLElement} corresponding to each supplied XPath\n   *   expression.\n   * @param xpaths XPath expressions\n   */\n  export function getFirstElementOfEach(xpaths: string[]) {\n    if (!xpaths || xpaths.length === 0){\n      console.warn(\"No xpaths supplied.\");\n      return [];\n    }\n    let elements = [];\n    for (const xpath of xpaths) {\n      let element = XPath.getNodes(xpath)[0];\n      if (!element) {\n        // todo: this may not be the right thing to do!\n        // for now we're assuming that if we can't find a node at this xpath,\n        //   it's because we jumbled in the nodes from a different page into the\n        //   relation for this page (becuase no updat to url or something); but\n        //   it may just mean that this page changed super super quickly, since\n        //   the recording\n        continue;\n      }\n      elements.push(<HTMLElement> element);\n    }\n    return elements;\n  }\n\n  /**\n   * Convert an XPath expression string to a list of {@link XPathNode}s.\n   * @param xpath XPath expression\n   */\n  export function toXPathNodeList(xpath: string) {\n    let xpathList: XPathNode[] = [];\n    if (!xpath) {\n      return xpathList;\n    }\n    for (let i = 0; i < xpath.length; i++) {\n      let char = xpath[i];\n      if (char === \"[\") {\n        let start = i;\n        let end = start + 1;\n        while (xpath[end] !== \"]\") {\n          end += 1;\n        }\n        let prefix = xpath.slice(0, start); //don't include brackets\n        let slashIndex = prefix.lastIndexOf(\"/\");\n        let nodeName = prefix.slice(slashIndex + 1, prefix.length);\n        let index = xpath.slice(start + 1, end);\n        xpathList.push({\n          nodeName: nodeName, \n          index: index,\n          iterable: false\n        });\n      }\n    }\n    return xpathList;\n  }\n\n  /**\n   * Check if `toCheck` is matchable by the {@link XPathList} `withIterables`\n   *   which contains iterables/wildcards.\n   * @param withIterables the list with iterables (i.e. generalized version)\n   * @param toCheck the specific xpath to check\n   * @returns true if matches, false otherwise\n   */\n  export function matches(withIterables: XPathList, toCheck: XPathList) {\n    if (withIterables.length !== toCheck.length){\n      return false;\n    }\n    for (let i = 0; i < withIterables.length; i++){\n      let targetNode = withIterables[i];\n      let node = toCheck[i];\n      if (targetNode.nodeName !== node.nodeName){\n        return false;\n      }\n      if (targetNode.iterable === false && targetNode.index !== node.index){\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Merge multiple {@link XPathList}s with overlapping sections using the\n   *   `iterable` key in the XPathNode. This is equivalent to a wildcard\n   *   in a XPath expression.\n   * @param withIterables the list with iterables (i.e. merged version)\n   * @param toMerge the xpath to merge in\n   * @returns true if successful, false if cannot be merged\n   */\n  export function merge(withIterables: XPathList, toMerge: XPathList) {\n    if (withIterables.length !== toMerge.length) {\n      return false;\n    }\n    let indicesToMarkIterable = [];\n    for (let i = 0; i < withIterables.length; i++) {\n      let targetNode = withIterables[i];\n      let node = toMerge[i];\n      if (targetNode.nodeName !== node.nodeName) {\n        return false;\n      }\n      if (targetNode.iterable === false && targetNode.index !== node.index) {\n        indicesToMarkIterable.push(i);\n      }\n    }\n    for (const index of indicesToMarkIterable) {\n      withIterables[index].iterable = true;\n    }\n    return true;\n  }\n\n  /**\n   * \"Shrink\" a list of {@link XPathList}s by merging them into the smallest\n   *   possible set.\n   * @param listOfXPathLists list of {@link XPathList}s\n   */\n  export function condenseList(listOfXPathLists: XPathList[]) {\n    if (listOfXPathLists.length < 2){\n      return listOfXPathLists;\n    }\n    let finalListOfXPathLists = [];\n    finalListOfXPathLists.push(listOfXPathLists[0]);\n    for (let i = 1; i < listOfXPathLists.length; i++) {\n      let newXPathList = listOfXPathLists[i];\n      let success = false;\n      for (let j = 0; j < finalListOfXPathLists.length; j++) {\n        let candidate = finalListOfXPathLists[j];\n        success = merge(candidate, newXPathList);\n        //in case of success, candidate_match will now contain the\n        //updated, merged xpath\n        if (success) {\n          break;\n        }\n      }\n      if (!success) {\n        //since couldn't match the new xpath with existing xpaths, add it\n        finalListOfXPathLists.push(newXPathList);\n      }\n    }\n    return finalListOfXPathLists;\n  }\n\n  /**\n   * Return the string representation of the {@link XPathList}.\n   * @param xPathList the XPath list\n   */\n  export function toString(xPathList: XPathList) {\n    let str = \"\";\n    for (const node of xPathList){\n      str += node.nodeName;\n      if (node.iterable) {\n        str += \"[*]/\";\n      } else {\n        str += \"[\" + node.index + \"]/\";\n      }\n    }\n    //add the HTML back to the beginning, remove the trailing slash\n    return \"HTML/\"+str.slice(0,str.length-1);\n  }\n}","import { HelenaBackground } from \"./background/helena_background\";\nimport { HelenaContent } from \"./content/helena_content\";\nimport { RingerContent } from \"./ringer-record-replay/content/ringer_content\";\nimport { HelenaMainpanel } from \"./mainpanel/helena_mainpanel\";\nimport { RecorderUI } from \"./mainpanel/ui/recorder_ui\";\nimport { RingerMainpanel } from \"./ringer-record-replay/mainpanel/ringer_mainpanel\";\n\n// TODO: cjbaik: a lot of classes depend on these global variables, which is bad\ndeclare global {\n  interface Window {\n    theModule: any;\n\n    helenaMainpanel: HelenaMainpanel;\n    ringerMainpanel: RingerMainpanel;\n    helenaContent: HelenaContent;\n    ringerContent: RingerContent;\n\n    // Used in test scripts, e.g. `runHelenaScript.py`\n    scrapingRunsCompleted: number;\n    datasetsScraped: (number | undefined)[];\n\n    JSOG: any;\n  }\n\n  interface JQueryStatic {\n    format: {\n      date: Function;\n    };\n    csv: {\n      toArrays: Function;\n    };\n  }\n}\n\n// TODO: cjbaik: all the global imports we couldn't get rid of, packaged in a\n//   bizarre Promise\nconst helenaIsReady = Promise.all([\n  import(\"!!raw-loader!./lib/jquery.js\"),\n  import(\"!!raw-loader!./lib/jquery-ui.js\"),\n  import(\"!!raw-loader!./lib/jquery-dateFormat.min.js\"),\n  import(\"!!raw-loader!./lib/jquery_csv.js\"),\n  import(\"!!raw-loader!./lib/JSOG.js\"),\n]).then((rawModules) => {\n  return new Promise((resolve) => {\n    for (const rawModule of rawModules) {\n      eval.call(null, rawModule.default);\n    }\n    resolve();\n  });\n});\n\nexport {\n  helenaIsReady,\n  HelenaBackground,\n  HelenaContent,\n  RingerContent,\n  HelenaMainpanel,\n  RingerMainpanel,\n  RecorderUI,\n};\n","import * as _ from \"underscore\";\n\nimport { HelenaConfig } from \"../common/config/config\";\nimport { MiscUtilities } from \"../common/misc_utilities\";\nimport { HelenaProgram } from \"./lang/program\";\nimport { DatasetSliceRequest } from \"../common/messages\";\nimport { HelenaServer, RunNewProgramResponse } from \"./utils/server\";\n\nexport class Dataset {\n  public currentDatasetNodes: object[];\n  public currentDatasetPositionLists: number[][][];\n  public currentDatasetSliceLength: number;\n  public fullDatasetLength: number;\n  public name: string;\n  public outstandingDataSaveRequests: number;\n  public pass_start_time: number;\n  public programId: string;\n  public programRunId?: number;\n  public programSubRunId?: number;\n\n  constructor(program: HelenaProgram, programRunId?: number) {\n    this.programRunId = programRunId;\n  \n    this.fullDatasetLength = 0;\n    this.currentDatasetNodes = [];\n    this.currentDatasetPositionLists = [];\n    this.currentDatasetSliceLength = 0;\n    this.outstandingDataSaveRequests = 0;\n  \n    this.name = program.name + \"_\" + currentDateString();\n  \n    this.pass_start_time = (new Date()).getTime();\n    \n    if (!program.id){\n      throw new ReferenceError(\"Program lacks id (is it saved yet?)\");\n    } else {\n      // we'll associate a program with a dataset even though the db-stored\n      //   program version may not be the same one used the scrape the dataset\n      this.programId = program.id;\n      this.getProgramRunAndSubRun();\n    }\n  }\n\n  public isReady(){\n    return this.programRunId;\n  }\n\n  public getProgramRunAndSubRun() {\n    // now let's actually make the new dataset on the server\n    if (this.programRunId === undefined) {\n      // this is a run we're about to start, not one that we've already started and are recovering or parallelizing or whatever\n      this.requestNewProgramRunId();\n    } else {\n      // this dataset is for a run that we already started before, but we're about to begin again from the start\n      this.requestNewProgramSubRunId();\n    }\n  }\n\n  public requestNewProgramRunId(){\n    const self = this;\n    HelenaServer.runNewProgram(this, (resp: RunNewProgramResponse) => {\n      self.handleDatasetId(resp)\n    });\n  }\n\n  public requestNewProgramSubRunId() {\n    const self = this;\n    HelenaServer.subRunNewProgram(this.programRunId,\n      (resp: RunNewProgramResponse) => {\n        self.handleDatasetId(resp);\n      }\n    );\n  }\n\n  public handleDatasetId(resp: RunNewProgramResponse) {\n    if (resp.run_id) {\n      this.programRunId = resp.run_id;\n    }\n    this.programSubRunId = resp.sub_run_id;\n  }\n\n  public appendToName(str: string) {\n    const self = this;\n    this.name = this.name + str;\n    if (this.programRunId){\n      // ok, we can go ahead and send the update now\n      this.updateRunNameOnServer();\n    } else {\n      // better wait a while until we actually have that id\n      setTimeout(() => {\n        self.updateRunNameOnServer();\n      }, 1000);\n    }\n  }\n\n  public updateRunNameOnServer(){\n    HelenaServer.updateDatasetRunName(this);\n  }\n\n\n  // how we'll grab out the components in the server\n  // nodes = JSON.parse(URI.decode(params[:nodes]))\n  // positionLists = JSON.parse(params[:position_lists])\n\n  public addRow(row: object[]) {\n    for (let i = 0; i < row.length; i++){\n      const cell_dict = row[i];\n      let node_index = null;\n\n      // let's just find if we've already seen this node before or not, so we\n      //   can figure out what info to update\n      // todo: is this fast enough.  we used to do a dict from text value to\n      //   positionsList, but now we want to save more info\n      // important to avoid eating up too much memory since it's easy for user\n      //   to be grabbing items that have a ton of text...\n\n      for (let j = 0; j < this.currentDatasetNodes.length; j++){\n        const candidate_dict = this.currentDatasetNodes[j];\n        if (_.isEqual(candidate_dict, cell_dict)) {\n          node_index = j;\n          break;\n        }\n      }\n      if (node_index === null){\n        // ok, we haven't seen this node before\n        this.currentDatasetNodes.push(cell_dict);\n        this.currentDatasetPositionLists.push([]);\n        node_index = this.currentDatasetNodes.length - 1;\n      }\n\n      // ok, now the node is stored in this.currentDatasetNodes\n      // let's store the current coords in the corresponding index for\n      //   this.currentDatasetPositionLists\n      const coords = [this.fullDatasetLength, i];\n      this.currentDatasetPositionLists[node_index].push(coords);\n    }\n\n    this.currentDatasetSliceLength += 1;\n    this.fullDatasetLength += 1;\n    if (this.currentDatasetSliceLength %\n        HelenaConfig.numRowsToSendInOneSlice === 0){\n      // note that the inclusion of this sendDatasetSlice call means that if we\n      //   have a transaction with 10 output calls, we can actually save output\n      //   without committing.  this definitely undermines the current stated\n      //   semantics of output in the presence of skip blocks.\n      // this will never happen in our auto-generated/synthesized scripts, so\n      //   it's not something that affects semantics now, but as we allow more\n      //   editing, it could\n      // todo: fix this\n      // however, also note that for cases where there are no skip block\n      //   constructs, this is the only time when we push the data to the server\n      // also, this was introduced for a reason, to make sure we don't eat up\n      //   too much memory on the client side and end up crashing the extension\n      this.sendDatasetSlice(); \n    }\n  };\n\n  // note!  calling this doesn't just get the server representation of the\n  //   current slice.  it also clears out the current cache\n  public datasetSlice() {\n    const msg: DatasetSliceRequest = {\n      run_id: this.programRunId,\n      sub_run_id: this.programSubRunId,\n      pass_start_time: this.pass_start_time,\n      position_lists: JSON.stringify(this.currentDatasetPositionLists),\n      nodes: encodeURIComponent(JSON.stringify(this.currentDatasetNodes))\n    };\n    this.currentDatasetNodes = [];\n    this.currentDatasetPositionLists = [];\n    this.currentDatasetSliceLength = 0;\n    return msg;\n  }\n\n  public sendDatasetSlice(handler = () => {}) {\n    const self = this;\n\n    if (this.currentDatasetSliceLength === 0) {\n      handler();\n      return; // no need to send/save rows if we have no rows\n    }\n\n    const slice = this.datasetSlice();\n    this.outstandingDataSaveRequests += 1;\n    HelenaServer.sendDatasetSlice(slice, () => {\n      self.outstandingDataSaveRequests -= 1;\n      handler();\n    });\n  }\n\n  public closeDataset() {\n    this.sendDatasetSlice();\n  }\n\n  // this is a variation on close dataset that won't return control until the\n  //   server has gotten the associated data\n  public closeDatasetWithCont(cont: Function) {\n    const self = this;\n\n    this.closeDataset();\n\n    // ok, now keep in mind we're not truly finished until all our data is\n    //   stored, which means the dataset must have no outstanding requests\n    MiscUtilities.repeatUntil(\n      () => {}, // repeatFunc is nothing.  just wait\n      () => self.outstandingDataSaveRequests === 0, \n      cont, 1000, false);\n  }\n\n  public downloadUrl() {\n    return `${HelenaConfig.helenaServerUrl}/datasets/run/${this.programRunId}`;\n  }\n\n  public downloadDataset() {\n    window.location.href = this.downloadUrl();\n  }\n\n  public downloadFullDatasetUrl() {\n    return `${HelenaConfig.helenaServerUrl}/datasets/${this.programId}`; \n  }\n\n  public static downloadFullDatasetUrl(program: HelenaProgram) {\n    return `${HelenaConfig.helenaServerUrl}/datasets/${program.id}`; \n  }\n\n  public downloadFullDataset(){\n    window.location.href = this.downloadFullDatasetUrl();\n  }\n\n  public getId() {\n    return this.programRunId;\n  }\n}\n\nfunction currentDateString() {\n  return basicDateString(new Date());\n}\n\nfunction basicDateString(d: Date) {\n  return d.getFullYear() + \"-\" + (d.getMonth()+1) + \"-\" + d.getDate() + \"-\" +\n    d.getHours() + \":\" + d.getMinutes();\n}\n","import { RecorderUI } from \"./ui/recorder_ui\";\n\nexport namespace Environment {\n  let UIObject: RecorderUI | null = null;\n\n  export function setUIObject(obj: RecorderUI) {\n    if (obj) {\n      UIObject = obj;\n    }\n  }\n\n  export class Frame {\n    public parent: Frame | null;\n    public map: {\n      [key: string]: any;\n    };\n\n    constructor(parent: Frame | null) {\n      this.parent = parent;\n      this.map = {};\n    }\n\n    /* Extends the environment. */\n    public envExtend() {\n      return new Frame(this); // current frame is the parent of the new frame\n    }\n\n    /**\n     * Binds a new value to the top frame.\n     */\n    public envBind(name: string, value: any) {\n      if (name in this.map) {\n        // Don't bind names twice --- you should never be doing this.\n        console.log(\"WARNING: The variable \" + name + \" was defined twice.\" +\n          \" Please rename one.\");\n      }\n      this.map[name] = value;\n    }\n\n    /**\n     * Looks up the value of a variable.\n     */\n    public envLookup(name: string): any {\n      if (this.map.hasOwnProperty(name)) {\n        return this.map[name];\n      } else {\n        if (this.parent) {\n          return this.parent.envLookup(name);\n        } else {\n          UIObject?.addDialog(\"Couldn't find item\", \"Tried to use something \" +\n            \"called \" + name + \", but we don't know anything about it.\", {});\n          // throw new ReferenceError(name + ' is not declared');\n        }\n      }\n    }\n  }\n\n  /* Creates a root environment. */\n  export function envRoot() {\n    // The root doesn't have a parent.\n    return new Frame(null);\n  }\n\n  /* Updates the value binding of a variable. */\n  /* currently only way to create a variable is to scrape it from a relation, and shouldn't do that twice for same variable, so we'll leave this out for now */\n  /*\n  pub.envUpdate = function _envUpdate(frame, name, value) {\n    if (frame.hasOwnProperty(name)) {\n      // frame.hasOwnProperty allows us to avoid accessing things like\n      // frame.toString, which are not defined in the environment but will\n      // exist anyway because of JS quirks.\n      frame[name] = value;\n      return value;\n    } else {\n      // If it isn't in this frame, check the parent, if it exists.\n      if (frame['*parent']) {\n        // Recursively check the parent. Remember we go towards the root for\n        // shadowing of names to work.\n        return pub.envUpdate(frame['*parent'], name, value);\n      } else {\n        // We have reached the root without finding the name. Panic.\n        throw new ExecError(name + ' is not declared');\n      }\n    }\n  };\n  */\n}","import * as _ from \"underscore\";\nimport * as Blockly from \"blockly\";\n\nimport { HelenaConsole } from \"../common/utils/helena_console\";\n\nimport { NodeVariable } from \"./variables/node_variable\";\n\nimport { HelenaLangObject } from \"./lang/helena_lang\";\n\nimport { LoadStatement } from \"./lang/statements/browser/load\";\nimport { LoopStatement } from \"./lang/statements/control_flow/loop\";\nimport { WaitStatement } from \"./lang/statements/control_flow/wait\";\nimport { TypeStatement } from \"./lang/statements/page_action/type\";\nimport { NodeVariableUse } from \"./lang/values/node_variable_use\";\n\nimport { RecorderUI } from \"./ui/recorder_ui\";\nimport { PageVariable } from \"./variables/page_variable\";\nimport { HelenaProgram, RunObject } from \"./lang/program\";\nimport { Revival } from \"./revival\";\nimport { Relation } from \"./relation/relation\";\nimport { TextRelation } from \"./relation/text_relation\";\nimport { Concatenate } from \"./lang/values/concatenate\";\nimport { HelenaNumber } from \"./lang/values/number\";\nimport { HelenaString } from \"./lang/values/string\";\nimport { BackStatement } from \"./lang/statements/browser/back\";\nimport { ClosePageStatement } from \"./lang/statements/browser/close_page\";\nimport { SkipBlock } from \"./lang/statements/control_flow/skip_block\";\nimport { ClickStatement } from \"./lang/statements/page_action/click\";\nimport { PulldownInteractionStatement } from \"./lang/statements/page_action/pulldown_interaction\";\nimport { ScrapeStatement } from \"./lang/statements/page_action/scrape\";\nimport { OutputRowStatement } from \"./lang/statements/output_row\";\nimport { Environment } from \"./environment\";\nimport { Messages } from \"../common/messages\";\n\ninterface HelenaBlock extends Blockly.Block {\n  helena: HelenaLangObject;\n}\n\nexport class HelenaMainpanel {\n  public static revivable: {\n    [key: string]: Revival.Prototype;\n  } = {\n    NodeVariable: NodeVariable,\n    PageVariable: PageVariable,\n    Relation: Relation,\n    TextRelation: TextRelation,\n    HelenaProgram: HelenaProgram,\n    Program: HelenaProgram,\n    Concatenate: Concatenate,\n    NodeVariableUse: NodeVariableUse,\n    HelenaNumber: HelenaNumber,\n    HelenaString: HelenaString,\n    String: HelenaString,\n    BackStatement: BackStatement,\n    ClosePageStatement: ClosePageStatement,\n    LoadStatement: LoadStatement,\n    LoopStatement: LoopStatement,\n    SkipBlock: SkipBlock,\n    WaitStatement: WaitStatement,\n    ClickStatement: ClickStatement,\n    PulldownInteractionStatement: PulldownInteractionStatement,\n    ScrapeStatement: ScrapeStatement,\n    TypeStatement: TypeStatement,\n    OutputRowStatement: OutputRowStatement,\n  };\n\n  public allNodeVariablesSeenSoFar: NodeVariable[];\n  public blocklyLabels: {\n    [key: string]: string[];\n  } = { text: [], numbers: [], other: [] };\n  public currentReplayWindowId: number | null;\n  public currentRunObjects: RunObject[];\n\n  public blocklyNames: string[] = [];\n\n  // when Blockly blocks are thrown away (in trash cah), you can undo it, but\n  //   undoing it doesn't bring back the walstatement property that we add\n  //   so...we'll keep track\n  public blocklyToHelenaDict: {\n    [key: string]: HelenaLangObject;\n  } = {};\n  public demoMode: boolean;\n\n  public recordingWindowIds: number[];\n  public toolId = null;\n  public UIObject: RecorderUI;\n\n  constructor(obj: RecorderUI) {\n    this.allNodeVariablesSeenSoFar = [];\n    this.currentReplayWindowId = null;\n    this.currentRunObjects = [];\n    this.demoMode = false;\n    this.recordingWindowIds = [];\n\n    this.setupBlocklyCustomBlocks();\n\n    this.addMessageListeners();\n\n    this.UIObject = obj;\n    Environment.setUIObject(obj);\n\n    // time to apply labels for revival purposes\n    for (const prop in HelenaMainpanel.revivable) {\n      HelenaConsole.log(\"making revival label for \", prop);\n      Revival.introduceRevivalLabel(prop, HelenaMainpanel.revivable[prop]);\n    }\n  }\n\n  private addMessageListeners() {\n    Messages.listenForMessage(\n      \"content\",\n      \"mainpanel\",\n      \"currentReplayWindowId\",\n      () => {\n        Messages.sendMessage(\"mainpanel\", \"content\", \"currentReplayWindowId\", {\n          window: this.currentReplayWindowId,\n        });\n      }\n    );\n  }\n\n  /**\n   * Initialization that has to happen after the HelenaMainpanel object is\n   *   created.\n   */\n  public afterInit() {\n    // make one so we'll add the blocklylabel\n    new WaitStatement();\n  }\n\n  // some of the things we do within the objects that represent the programs,\n  //   statements, and expressions should update the UI object that's serving\n  //   as the IDE.  the UI object should implement all of these functions, or\n  //   whatever subset of them the user will be able to trigger by using the\n  //   Helena language as the interface allows:\n  /*\n    UIObject.updateDisplayedScript(bool updateBlockly)\n    UIObject.updateDisplayedRelations(bool stillInProgress)\n    UIObject.addNewRowToOutput(str idOfProgramRunTab, array displayTextCells)\n    UIObject.updateRowsSoFar(str idOfProgramRunTab, int fullDatasetLength)\n    UIObject.addDialog(str title, str dialogText, dict buttonTextToHandlers)\n    UIObject.showRelationEditor(Relation rel, int chromeTabId)\n    UIObject.continueAfterDialogue(str text, str buttonText, cont continuation)\n    Tab tab = UIObject.newRunTab(RunObject ro)\n  */\n\n  public resetForNewScript() {\n    // if the user is going to be starting a fresh script, it shouldn't be\n    //   allowed to use variables from a past script or scripts\n    this.allNodeVariablesSeenSoFar = [];\n  }\n\n  // it's ok to just run with this unless you want to only load programs\n  //   associated with your own helena-using tool\n  /*\n  public static setHelenaToolId(tid) {\n    HelenaMainpanel.toolId = tid;\n    console.log(\"Setting toolId\", HelenaMainpanel.toolId);\n  }\n  public static getHelenaToolId() {\n    return HelenaMainpanel.toolId;\n  }\n  */\n\n  public static makeOpsDropdown(ops: { [key: string]: Function }) {\n    const opsDropdown = [];\n    for (const key in ops) {\n      opsDropdown.push([key, key]);\n    }\n    return opsDropdown;\n  }\n\n  public addToolboxLabel(label: string, category = \"other\") {\n    this.blocklyLabels[category].push(label);\n    this.blocklyLabels[category] = [...new Set(this.blocklyLabels[category])];\n  }\n\n  public blocklySeqToHelenaSeq(\n    blocklyBlock: Blockly.Block\n  ): HelenaLangObject[] {\n    if (!blocklyBlock) {\n      return [];\n    }\n\n    // grab the associated helena component and call the getHelena method\n    const thisNodeHelena = this.getHelenaStatement(blocklyBlock).getHelena();\n    let invisibleHead = thisNodeHelena.invisibleHead;\n    if (!invisibleHead) {\n      invisibleHead = [];\n    }\n    let invisibleTail = thisNodeHelena.invisibleTail;\n    if (!invisibleTail) {\n      invisibleTail = [];\n    }\n    const helenaSeqForThisBlock = invisibleHead\n      .concat(thisNodeHelena)\n      .concat(invisibleTail);\n\n    const nextBlocklyBlock = blocklyBlock.getNextBlock();\n    if (!nextBlocklyBlock) {\n      return helenaSeqForThisBlock;\n    }\n    const suffix = this.blocklySeqToHelenaSeq(nextBlocklyBlock);\n    return helenaSeqForThisBlock.concat(suffix);\n  }\n\n  public static getHelenaFromBlocklyRoot(blocklyBlock: Blockly.Block) {\n    return window.helenaMainpanel.blocklySeqToHelenaSeq(blocklyBlock);\n  }\n\n  public getInputSeq(blocklyBlock: Blockly.Block, inputName: string) {\n    const nextBlock = blocklyBlock.getInput(inputName).connection.targetBlock();\n    if (!nextBlock) {\n      return [];\n    }\n    return (<NodeVariableUse>this.getHelenaStatement(nextBlock)).getHelenaSeq();\n  }\n\n  public setHelenaStatement(\n    block: Blockly.Block,\n    helenaStmt: HelenaLangObject\n  ) {\n    let helenaBlock = <HelenaBlock>block;\n    helenaBlock.helena = helenaStmt;\n    helenaStmt.block = helenaBlock;\n    this.blocklyToHelenaDict[block.id] = helenaStmt;\n  }\n\n  public getHelenaStatement(block: Blockly.Block): HelenaLangObject {\n    let helenaBlock = <HelenaBlock>block;\n    if (!helenaBlock.helena) {\n      helenaBlock.helena = this.blocklyToHelenaDict[helenaBlock.id];\n      if (helenaBlock.helena) {\n        helenaBlock.helena.block = helenaBlock;\n        // the above line may look silly but when blockly drops blocks into the\n        //   trashcan, they're restored with the same id but with a fresh object\n        //   and the fresh object doesn't have Helena stored anymore, which is\n        //   why we have to look in the dict but that also means the block\n        //   object stored by the wal object is out of date, must be refreshed\n      }\n    }\n    return helenaBlock.helena;\n  }\n\n  public getNodeVariableByName(name: string) {\n    for (const nodeVar of this.allNodeVariablesSeenSoFar) {\n      if (nodeVar.getName() === name) {\n        return nodeVar;\n      }\n    }\n    return null;\n  }\n\n  private setupBlocklyCustomBlocks() {\n    Blockly.Blocks[\"scraping_for_each\"] = {\n      init: function () {\n        this.jsonInit({\n          type: \"scraping_for_each\",\n          message0: \"for each COLUMN_NAMES in %1 in %2 %3 do %4\",\n          args0: [\n            {\n              type: \"field_dropdown\",\n              name: \"list\",\n              options: [\n                [\"list1\", \"list1\"],\n                [\"list2\", \"list2\"],\n                [\"list3\", \"list3\"],\n              ],\n            },\n            {\n              type: \"field_dropdown\",\n              name: \"tab\",\n              options: [\n                [\"tab1\", \"tab1\"],\n                [\"tab2\", \"tab2\"],\n                [\"tab3\", \"tab3\"],\n              ],\n            },\n            {\n              type: \"input_dummy\",\n            },\n            {\n              type: \"input_statement\",\n              name: \"statements\",\n            },\n          ],\n          previousStatement: null,\n          nextStatement: null,\n          colour: 44,\n          tooltip: \"\",\n          helpUrl: \"\",\n        });\n      },\n    };\n  }\n  /**\n   * Updates blocks available for the toolbox based on our pageVars, relations,\n   *   and so on.\n   * @param program\n   */\n  public updateToolboxBlocks(program: HelenaProgram | null) {\n    // this is silly, but just making a new object for each of our statements is\n    //   an easy way to get access to the updateBlocklyBlock function and still\n    //   keep it an instance method/right next to the genBlockly function\n    // const toolBoxBlocks = [\"Number\", \"NodeVariableUse\", \"String\", \"Concatenate\",\n    //   \"IfStatement\", \"WhileStatement\", \"ContinueStatement\", \"BinOpString\",\n    //   \"BinOpNum\", \"LengthString\", \"BackStatement\", \"ClosePageStatement\",\n    //   \"WaitStatement\", \"WaitUntilUserReadyStatement\", \"SayStatement\"];\n\n    const toolBoxBlocks = [\n      \"HelenaNumber\",\n      \"NodeVariableUse\",\n      \"HelenaString\",\n      \"Concatenate\",\n      \"BackStatement\",\n      \"ClosePageStatement\",\n      \"WaitStatement\",\n    ];\n\n    // let's also add in other nodes which may not have been used in programs\n    // so far, but which we want to include in the toolbox no matter what\n    const origBlocks = this.blocklyNames;\n    const allDesiredBlocks = origBlocks.concat(toolBoxBlocks);\n    for (const prop of allDesiredBlocks) {\n      try {\n        const obj = HelenaMainpanel.revivable[prop].createDummy();\n\n        // if (obj && obj instanceof HelenaLangObject) {\n        if (obj && obj instanceof HelenaLangObject) {\n          if (program) {\n            obj.updateBlocklyBlock(\n              program,\n              program.pageVars,\n              program.relations\n            );\n          } else {\n            obj.updateBlocklyBlock();\n          }\n        }\n      } catch (err) {\n        console.log(\n          \"Couldn't create new object for prop:\",\n          prop,\n          \"probably by design.\"\n        );\n        console.log(err);\n      }\n    }\n\n    // let's just warn about what things (potentially blocks!) aren't being\n    //   included\n    for (const prop in HelenaMainpanel.revivable) {\n      if (!allDesiredBlocks.includes(prop)) {\n        HelenaConsole.log(\"NOT INCLUDING PROP:\", prop);\n      }\n    }\n    return;\n  }\n}\n\n/*\nfunction makeRelationsDropdown(relations) {\n  var relationsDropDown = [];\n  for (var i = 0; i < relations.length; i++) {\n    var relationStr = relations[i].name;\n    relationsDropDown.push([relationStr, relationStr]);\n  }\n  return relationsDropDown;\n}*/\n","import * as Blockly from \"blockly\";\n\nimport { GenericRelation } from \"../relation/generic\";\n\nimport { PageVariable } from \"../variables/page_variable\";\nimport { StatementContainer } from \"./statements/container\";\nimport { RunObject, RunOptions, HelenaProgram } from \"./program\";\nimport { Revival } from \"../revival\";\nimport { IColumnSelector } from \"../../content/selector/interfaces\";\n\nexport interface StatementParameter {\n  type: string;\n  value: any;\n}\n\nexport class HelenaLangObject implements Revival.Revivable {\n  public ___revivalLabel___: string;\n\n  public block: Blockly.Block;\n  public blocklyLabel: string;\n  public invisibleHead?: HelenaLangObject[];\n  public invisibleTail?: HelenaLangObject[];\n  public nullBlockly?: boolean;\n\n  public parent: StatementContainer;\n\n  public static createDummy() {\n    return new HelenaLangObject();\n  }\n\n  public clearRunningState() {\n    return;\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block | null,\n    workspace: Blockly.WorkspaceSvg): Blockly.Block | null {\n      return null;\n  }\n\n  public getHelena() {\n    return this;\n  }\n\n  public getLoopIterationCounters(acc: number[] = []): number[] {\n    if (this.parent === null || this.parent === undefined) {\n      return acc;\n    } else {\n      return this.parent.getLoopIterationCounters(acc);\n    }\n  }\n\n  public hasOutputPageVars() {\n    return false;\n  }\n\n  /**\n   * Returns whether this Helena statement is Ringer based.\n   */\n  public isRingerBased() {\n    return false;\n  }\n\n  public prepareToRun() {\n    return;\n  }\n\n  public remove() {\n    this.parent.removeChild(this);\n  }\n\n  /**\n   * Run this Helena statement.\n   * @param runObject \n   * @param rbbcontinuation run basic block continuation\n   * @param rbboptions run basic block options\n   */\n  public run(runObject: RunObject, rbbcontinuation: Function,\n    rbboptions: RunOptions) {\n      return;\n  }\n\n  public setBlocklyLabel(label: string) {\n    //console.log(\"setBlocklyLabel\", obj, label, obj.___revivalLabel___);\n    this.blocklyLabel = label;\n\n    // it's important that we keep track of what things within the\n    //   HelenaMainpanel object are blocks and which aren't\n    // this may be a convenient way to do it, since it's going to be obvious if\n    //   you introduce a new block but forget to call this whereas if you\n    //   introduce a new function and forget to add it to a blacklist, it'll get\n    //   called randomly, will be hard to debug\n    const name = this.___revivalLabel___;\n    if (!window.helenaMainpanel.blocklyNames.includes(name)) {\n      window.helenaMainpanel.blocklyNames.push(name);\n    }\n  }\n\n  public toStringLines() {\n    return [\"\"];\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    fn2(this);\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    return;\n  }\n\n  public usesRelation(rel: GenericRelation) {\n    return false;\n  }\n\n  public parameterizeForRelation(relation: GenericRelation):\n      (IColumnSelector | null)[] {\n    return [];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    return;\n  }\n}","import * as Blockly from \"blockly\";\nimport * as _ from \"underscore\";\n\nimport { ServerSaveResponse, RelationResponse,\n  Messages} from \"../../common/messages\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\n\nimport { SkipBlock, HashBasedParallel } from \"./statements/control_flow/skip_block\";\nimport { Relation } from \"../relation/relation\";\n\nimport { LoadStatement } from \"./statements/browser/load\";\nimport { LoopStatement } from \"./statements/control_flow/loop\";\nimport { ClickStatement } from \"./statements/page_action/click\";\nimport { PulldownInteractionStatement } from \"./statements/page_action/pulldown_interaction\";\nimport { ScrapeStatement } from \"./statements/page_action/scrape\";\nimport { TypeStatement } from \"./statements/page_action/type\";\n\nimport { OutputRowStatement } from \"./statements/output_row\";\n\nimport { NodeSources, NodeVariable } from \"../variables/node_variable\";\nimport { HelenaLangObject } from \"./helena_lang\";\nimport { PageVariable } from \"../variables/page_variable\";\nimport { GenericRelation } from \"../relation/generic\";\nimport { PageActionStatement } from \"./statements/page_action/page_action\";\nimport { StatementContainer } from \"./statements/container\";\nimport { BackStatement } from \"./statements/browser/back\";\nimport { ClosePageStatement } from \"./statements/browser/close_page\";\nimport { Revival } from \"../revival\";\nimport { RelationSelector } from \"../../content/selector/relation_selector\";\nimport { Traces, Trace, DisplayTraceEvent } from \"../../common/utils/trace\";\nimport { HelenaConfig } from \"../../common/config/config\";\nimport { MiscUtilities } from \"../../common/misc_utilities\";\nimport { Dataset } from \"../dataset\";\nimport { HelenaServer, RetrieveRelationsResponse } from \"../utils/server\";\nimport { StatementTypes } from \"./statements/statement_types\";\nimport { Environment } from \"../environment\";\nimport { RingerEvents } from \"../../ringer-record-replay/common/event\";\nimport { Replay } from \"../../ringer-record-replay/mainpanel/replay\";\nimport { ParameterizedTrace } from \"../parameterized_trace\";\nimport { NextButtonTypes, IColumnSelector } from \"../../content/selector/interfaces\";\nimport { RingerStatement, OutputPageVarStatement } from \"./types\";\nimport { HelenaBlocks } from \"../ui/blocks\";\n\ninterface LoopItem {\n  loopStatement: LoopStatement;\n  nodeVariables: NodeVariable[];\n  displayData: string[][];\n}\n\nexport enum TraceContributions {\n  NONE = 0,\n  FOCUS\n}\n\nexport interface RunObject {\n  dataset: Dataset;\n  environment: Environment.Frame;\n  program: HelenaProgram;\n\n  resumeContinuation?: Function;\n  tab: string;\n  userPaused?: boolean;\n  userStopped?: boolean;\n  window?: number;\n}\n\nexport interface RunOptions {\n  [key: string]: any;\n\n  breakAfterXDuplicatesInARow?: number;\n  breakMode?: boolean;\n  dataset_id?: number;\n  hashBasedParallel?: HashBasedParallel;\n  ignoreEntityScope?: boolean;\n  nameAddition?: string;\n  parallel?: boolean;\n  simulateError?: number[];\n  skipCommitInThisIteration?: boolean;\n  skipMode?: boolean;\n}\n\ninterface Parameters {\n  [key: string]: any;\n}\n\n// wonder if these shouldn't be moved to runObject instead of options.\n//   should do that.\nconst internalOptions = [\"skipMode\", \"breakMode\", \"skipCommitInThisIteration\"];\nconst recognizedOptions = [\"dataset_id\", \"ignoreEntityScope\",\n  \"breakAfterXDuplicatesInARow\", \"nameAddition\", \"simulateError\", \"parallel\",\n  \"hashBasedParallel\", \"restartOnFinish\"];\n\n/**\n * A Helena program.\n * @param statements \n * @param addOutputStatement \n */\nexport class HelenaProgram extends StatementContainer {\n  public static wrapperNodeCounter = 0;\n\n  public altRootBodyStatements?: HelenaLangObject[][];\n  public associatedString?: string;   // save to server some string metadata\n  public automaticLoopInsertionForbidden?: boolean;\n  public defaultParamVals: Parameters;\n  public id: string;\n  public mostRecentRow?: string[];\n  public name: string;\n  public nextButtonAttemptsThreshold?: number;\n  public pagesProcessed: {\n    [key: string]: boolean;\n  } = {};\n  public pagesToFrames: {\n    [key: string]: number[];\n  } = {};\n  public pagesToFrameUrls: {\n    [key: string]: string[];\n  } = {};\n  public pagesToNodes: {\n    [key: string]: string[];\n  } = {};\n  public pagesToUrls: {\n    [key: string]: string;\n  } = {};\n  public pageVars: PageVariable[];\n  public parameterNames?: string[];\n  public relationFindingTimeoutThreshold?: number;\n  public relations: GenericRelation[];\n  public restartOnFinish?: boolean;\n  public statements: HelenaLangObject[];\n  public windowHeight?: number;\n  public windowWidth?: number;\n\n  constructor(statements: HelenaLangObject[], addOutputStatement = true) {\n    super();\n\n    Revival.addRevivalLabel(this);\n\n    // cjbaik: added this because it doesn't seem to be initialized anywhere\n    this.defaultParamVals = {};\n    this.relations = [];\n\n    this.statements = statements;\n    this.pageVars =\n      statements.filter((s) => (s instanceof PageActionStatement ||\n                                s instanceof LoopStatement) && s.pageVar)\n                .map((s: PageActionStatement) => <PageVariable> s.pageVar)                                                                                                                                                                           \n    this.pageVars = [...new Set(this.pageVars)];\n    this.bodyStatements = statements;  \n    this.name = \"\";\n\n    // add an output statement to the end if there are any scrape statements in\n    //   the program.  should have a list of all scrape statements, treat them\n    //   as cells in one row\n    const scrapeStatements = <ScrapeStatement[]> this.statements.filter(\n      (s) => s instanceof ScrapeStatement\n    );\n    if (addOutputStatement && scrapeStatements.length > 0) {\n      this.statements.push(new OutputRowStatement(scrapeStatements));\n    }\n  }\n\n  public static createDummy() {\n    return new HelenaProgram([]);\n  }\n\n  public clone() {\n    const replacer = (key: string, value: any) => {\n      // filtering out the blockly block, which we can recreate from the rest of\n      //   the state\n      if (key === \"block\") {\n        return undefined;\n      }\n      return value;\n    }\n    // deepcopy\n    const programAttributes = window.JSOG.parse(\n      window.JSOG.stringify(this, replacer));\n    // copy all those fields back into a proper Program object\n    const program = Revival.revive(programAttributes);\n    return program;\n  }\n\n  /**\n   * Set attributes on this Program.\n   * @param attrs attributes\n   */\n  public setAttributes(attrs: { [key: string]: any }) {\n    _.extend(this, attrs);\n    if ('loopyStatements' in attrs) {\n      this.bodyStatements = attrs.loopyStatements;\n    }\n    if ('altRootLoopyStatements' in attrs) {\n      this.altRootBodyStatements = attrs.altRootLoopyStatements;\n    }\n  }\n\n  public static fromRingerTrace(trace: Trace, windowId?: number,\n      addOutputStatement?: boolean) {\n    let dispTrace = <DisplayTraceEvent[]> trace.filter((event) =>\n      // filter out stopped events\n      // cjbaik: I don't think this attribute actually exists\n      // event.state !== \"stopped\" &&\n\n      // strip out events that weren't performed in the recording window\n      (event.type === \"manualload\" || \n       (event.data && event.data.windowId === windowId) ||\n       (event.frame && event.frame.windowId === windowId))\n    ).map((event) =>\n      Traces.prepareForDisplay(event)\n    );\n    dispTrace = markUnnecessaryLoads(dispTrace);\n    dispTrace = associateNecessaryLoadsWithIDsAndParameterizePages(dispTrace);\n    dispTrace = addCausalLinks(dispTrace);\n    dispTrace = removeEventsBeforeFirstVisibleLoad(dispTrace);\n\n    const segmentedTrace = segment(dispTrace);\n    const prog = segmentedTraceToProgram(segmentedTrace, addOutputStatement);\n    return prog;\n  }\n\n  public static fromJSON(json: string) {\n    const programAttributes = window.JSOG.parse(json);\n\n    // copy all those fields back into a proper Program object\n    return <HelenaProgram> Revival.revive(programAttributes);\n  }\n\n  /**\n   * Could not name this `toJSON` because JSOG treats objects with `toJSON`\n   *   methods in a special way.\n   */\n  public convertToJSON() {\n    return window.JSOG.stringify(this.clone());\n  }\n\n  public setName(str: string) {\n    this.name = str;\n  }\n\n  public getName() {\n    return this.name;\n  }\n\n  public setAssociatedString(str: string) {\n    this.associatedString = str;\n  }\n\n  public getAssociatedString() {\n    return this.associatedString;\n  }\n\n  public setId(id: string) {\n    this.id = id;\n    window.helenaMainpanel.UIObject.programIdUpdated(this);\n  }\n\n  public toString() {\n    let statementLs = this.bodyStatements;\n    if (this.bodyStatements.length === 0) {\n      statementLs = this.statements;\n    }\n  \n    let scriptString = \"\";\n    for (const statement of statementLs) {\n      const strLines = statement.toStringLines();\n      if (strLines.length > 0) {\n        scriptString += strLines.join(\"<br>\") + \"<br>\";\n      }\n    }\n    return scriptString;\n  }\n\n  public currentStatementLs() {\n    let statementLs = this.bodyStatements;\n    if (this.bodyStatements.length === 0) {\n      statementLs = this.statements;\n    }\n    return statementLs;\n  }\n\n  public displayBlockly(workspace: Blockly.WorkspaceSvg) {\n    const statementLs = this.currentStatementLs();\n\n    // let's start with the real program, go through that\n    let coords = null;\n    if (statementLs[0].block) {\n      coords = statementLs[0].block.getRelativeToSurfaceXY();\n\n      // get rid of old version (discarding any unsaved blockly changes!)\n      statementLs[0].block.dispose(false);\n    }\n    \n    // now that we removed the real program, let's take this moment to grab all\n    //   the alternative roots\n    // we'll use these later\n    const rootBlocklyBlocks = workspace.getTopBlocks(false);\n\n    // add new version\n    const rt = HelenaBlocks.helenaSeqToBlocklySeq(statementLs, workspace);\n    if (coords) {\n      rt.moveBy(coords.x, coords.y); // make it show up in same spot as before\n    }\n\n    // now let's go through all the other stuff the user might have lying around\n    //   the workspace\n\n    // clear out the current list of other roots that we associate with the\n    //   program\n    this.altRootBodyStatements = [];\n    for (const block of rootBlocklyBlocks) {\n      const rootHelena = window.helenaMainpanel.getHelenaStatement(block);\n      if (!rootHelena) {\n        // no helena associated with this one. guess we'll just throw it out\n        continue;\n      }\n      const helenaSeq = window.helenaMainpanel.blocklySeqToHelenaSeq(block);\n      this.altRootBodyStatements.push(helenaSeq);\n\n      // delete the old version from the workspace\n      const coords = block.getRelativeToSurfaceXY();\n      block.dispose(false);\n      // now display the new version\n      const r = HelenaBlocks.helenaSeqToBlocklySeq(helenaSeq, workspace);\n      if (coords) {\n        r.moveBy(coords.x, coords.y); // make it show up in same spot as before\n      }\n    }  \n\n    // now go through and actually display all those nodes\n    // this will traverse all relevant nodes of this.bodyStatements and\n    //   this.allRootbodyStatements\n    this.traverse((stmt: HelenaLangObject) => {\n      if (stmt.block) {\n        const svgBlock = <Blockly.BlockSvg> stmt.block;\n        svgBlock.initSvg();\n        svgBlock.render();\n      }\n    }, () => {});\n  }\n\n  /**\n   * Saves a HelenaProgram to the server.\n   * @param afterId a callback handler that runs as soon as we have the\n   *   necessary program id, and let the saving continue in the background\n   *   because it takes a long time\n   * @param saveStarted a callback handler when the save begins\n   * @param saveDone a callback handler when the save completes\n   */\n  public saveToServer(afterId: Function, saveStarted: Function,\n      saveDone: Function) {\n    const self = this;\n    const req = {\n      id: this.id,\n      name: this.name,\n      tool_id: window.helenaMainpanel.toolId,\n      associated_string: this.associatedString\n    };\n  \n    HelenaConsole.log(\"about to post\", (new Date().getTime()/1000));\n    // this first request is just to get us the right program id to associate\n    //   any later stuff with.  it won't actually save the program saving the\n    //   program takes a long time, so we don't want other stuff to wait on it,\n    //   will do it in background\n    HelenaServer.saveProgram(req, (resp: ServerSaveResponse) => {\n      HelenaConsole.log(\"server responded to program save\");\n      const progId = resp.program.id;\n      self.setId(progId);\n      // ok, now that we know the right program id (in cases where there wasn't\n      //   one to begin with) we can save the actual program but it can take a\n      //   long time for programs to arrive at server, so don't make other stuff\n      //   wait on it.  just send it in the background\n      setTimeout(() => {\n        // todo: in future, don't filter.  actually save textrelations too\n        const relationObjsSerialized =\n          self.relations.filter((rel) => rel instanceof Relation)\n                        .map((rel) => rel.convertToJSON());\n        const serializedProg = self.convertToJSON();\n        // sometimes serializedProg becomes null because of errors. in those\n        //   cases, we don't want to overwrite the old, good program with the\n        //   bad one. so let's prevent us from saving null in place of existing\n        //   thing so that user can shut it off, load the saved program, start\n        //   over\n        if (serializedProg) {\n          const req = {\n            id: progId,\n            serialized_program: serializedProg,\n            relation_objects: relationObjsSerialized,\n            name: self.name,\n            associated_string: self.associatedString\n          };\n          HelenaServer.saveProgram(req, () => {\n            // we've finished the save thing, so tell the user\n            saveDone();\n          }, true, \" to save the program\");\n        }\n      }, 0);\n\n      // ok, we've set it up to do the actual program saving, but we already\n      //   have the id, so do the postIdRetrievalContinuation\n      if (afterId && typeof afterId === 'function') {\n        afterId(progId);\n      }\n    });\n    \n    // we've sent the save thing, so tell the user\n    saveStarted();\n  }\n\n  // a convenient way to traverse the statements of a program\n  // todo: currently no way to halt traversal, may ultimately want fn arg to\n  //   return boolean to do that\n  public traverse(fn: Function, fn2: Function) {\n    if (this.bodyStatements.length < 1) {\n      console.warn(\"Calling traverse on a program even though \" +\n        \"bodyStatements is empty.\");\n    }\n\n    // go through our actual programs\n    for (const stmt of this.bodyStatements) {\n      stmt.traverse(fn, fn2);\n    }\n\n    // go through the other roots that are also available to us (usually because\n    //   of blockly)\n    if (this.altRootBodyStatements) {\n      for (const statements of this.altRootBodyStatements) {\n        for (const stmt of statements) {\n          stmt.traverse(fn, fn2);\n        }\n      }\n    }\n  }\n\n  public containsStatement(stmt: HelenaLangObject) {\n    return firstTrueStatementTraverse(this.bodyStatements,\n      (s: HelenaLangObject) => s === stmt\n    );\n  }\n\n  public loadsUrl() {\n    return firstTrueStatementTraverse(this.bodyStatements,\n      (s: HelenaLangObject) => s instanceof LoadStatement\n    );\n  }\n\n  public insertAfter(stmtToInsert: HelenaLangObject,\n      stmtToInsertAfter: HelenaLangObject) {\n    const possibleNewbodyStatements = insertAfterHelper(this.bodyStatements,\n      stmtToInsert, stmtToInsertAfter);\n    if (!possibleNewbodyStatements) {\n      console.warn(\"Woah, tried to insert after a particular \" +\n        \"WALStatement, but that statement wasn't in our prog.\");\n    } else {\n      this.bodyStatements = possibleNewbodyStatements;\n    }\n  }\n\n  // go through the program, look for the movedStatement and any\n  //   statements/blocks that the Blockly UI would attach to it then remove those from the program\n  /*\n  public statementRemovedByUI(movedStatement, oldPriorStatement) {\n    //console.log(\"statementRemovedByUI\", movedStatement, oldPriorStatement);\n    var seq = removeStatementAndFollowing(this.bodyStatements, movedStatement);\n    //console.log(\"removed the seq:\". removedSeq);\n    if (!seq) {\n      console.warn(\"Woah, tried to remove a particular WALStatement, but that statement wasn't in our prog.\");\n    }\n\n    // now, if we end up pulling this same seq back in...better know about the seq\n    movedStatement.associatedStatementSequence = seq;\n    return seq;\n  };\n\n  this.statementAddedByUI = function(movedStatement, precedingStatement, inputName) {\n    // a quick precaution.  it's not ok for statements to appear in the same program twice.  so make sure it's not already in there...\n    // (this comes up when we're programmatically producing the blockly rep for an existing program)\n    if (this.containsStatement(movedStatement)) {\n      return;\n    }\n\n    // ok, we know which block is coming in, but don't necessarily know whether there's a sequence of blocks that should come with it\n    // if there's one associated with the block, we'll use that.  otherwise we'll assume it's just the block itself\n    // (as when the user has dragged in a brand new block, or even when we're programmatically buidling up the displayed program)\n    var addedSeq = movedStatement.seq;\n    if (!addedSeq) {\n      addedSeq = [movedStatement];\n    }\n\n    var added = addSeq(this.bodyStatements, addedSeq, precedingStatement, inputName);\n    if (!added) {\n      console.warn(\"Woah, tried to insert after a particular WALStatement, but that statement wasn't in our prog.\");\n    }\n    return added;\n  }\n\n  this.inputRemovedByUI = function() {\n\n  }\n  this.inputAddedByUI = function() {\n\n  }*/\n\n  public getDuplicateDetectionData() {\n    const loopData: LoopItem[] = [];\n    this.traverse((stmt: HelenaLangObject) => {\n      if (stmt instanceof LoopStatement) {\n        const newLoopItem: LoopItem = {\n          loopStatement: stmt,   // the data we're building up\n          nodeVariables: stmt.relationNodeVariables(),\n          displayData: [[], []]\n        };\n        // let nodeVars = stmt.relationNodeVariables();\n        const childStatements = stmt.getChildren();\n        const scrapeChildren = [];\n        for (const childStmt of childStatements) {\n          if (childStmt instanceof ScrapeStatement &&\n              !childStmt.scrapingRelationItem()) {\n            scrapeChildren.push(childStmt);\n          } else if (childStmt instanceof LoopStatement) {\n            // convention right now, since duplicate detection is for avoiding\n            //   repeat of unnecessary work, is that we make the judgment based\n            //   on variables available before any nested loops\n            break;\n          }\n        }\n        const scrapeChildrenNodeVars = scrapeChildren.map(\n          (scrapeS) => scrapeS.currentNode\n        );\n\n        // ok, newLoopItem.nodeVariables now has all our nodes\n        newLoopItem.nodeVariables =\n          newLoopItem.nodeVariables.concat(scrapeChildrenNodeVars);\n\n        // in addition to just sending along the nodeVar objects, we also want\n        //   to make the table of values\n        for (const nv of newLoopItem.nodeVariables) {\n          newLoopItem.displayData[0].push(nv.getName() + \" text\");\n          newLoopItem.displayData[1].push(<string> nv.recordTimeText());\n          newLoopItem.displayData[0].push(nv.getName() + \" link\");\n          newLoopItem.displayData[1].push(<string> nv.recordTimeLink());\n        }\n        loopData.push(newLoopItem);\n      }\n    }, () => {});\n    return loopData;\n  }\n\n  public getNodesFoundWithSimilarity() {\n    const nodeData: NodeVariable[] = [];\n    this.traverse((stmt: HelenaLangObject) => {\n      if (stmt instanceof PageActionStatement &&\n          stmt.currentNode.getSource() === NodeSources.RINGER) {\n        //var statementData = {name: statement.currentNode}\n        nodeData.push(stmt.currentNode);\n      }\n    }, () => {});\n    return nodeData;\n  }\n\n  // just for replaying the straight-line recording, primarily for debugging\n  public replayOriginal() {\n    let trace: Trace = [];\n    for (const stmt of this.statements) {\n      if (stmt instanceof PageActionStatement) {\n        trace = trace.concat(stmt.cleanTrace);\n      }\n    }\n    for (const ev of trace) {\n      Traces.clearDisplayInfo(<DisplayTraceEvent> ev);\n    }\n\n    window.ringerMainpanel.replayScript(trace, null, () => {\n      HelenaConsole.log(\"Done replaying.\");\n    });\n  }\n\n/*\n  function updatePageVars(recordTimeTrace, replayTimeTrace) {\n    // we should see corresponding 'completed' events in the traces\n    var recCompleted = _.filter(recordTimeTrace, function(ev) {return ev.type === \"completed\" && ev.data.type === \"main_frame\";}); // now only doing this for top-level completed events.  will see if this is sufficient\n    var repCompleted = _.filter(replayTimeTrace, function(ev) {return ev.type === \"completed\" && ev.data.type === \"main_frame\";});\n    HelenaConsole.log(recCompleted, repCompleted);\n    // should have same number of top-level load events.  if not, might be trouble\n    if (recCompleted.length !== repCompleted.length) {\n      HelenaConsole.log(\"Different numbers of completed events in record and replay: \", recCompleted, repCompleted);\n    }\n    // todo: for now aligning solely based on point at which the events appear in the trace.  if we get traces with many events, may need to do something more intelligent\n    var smallerLength = recCompleted.length;\n    if (repCompleted.length < smallerLength) { smallerLength = repCompleted.length;}\n    for (var i = 0; i < smallerLength; i++) {\n      var pageVar = Trace.getLoadOutputPageVar(recCompleted[i]);\n      if (pageVar === undefined) {\n        continue;\n      }\n      pageVar.setCurrentTabId(repCompleted[i].data.tabId);\n    }\n  }\n  */\n\n  private doTheReplay(runnableTrace: Trace, config: object,\n      basicBlockStmts: RingerStatement[], runObject: RunObject,\n      bodyStatements: HelenaLangObject[], nextBlockStartIndex: number,\n      callback: Function, options: RunOptions) {\n    const self = this;\n    // first let's throw out any wait time on the first event, since no need to\n    //   wait for that\n    if (runnableTrace.length > 0) {\n      runnableTrace[0].timing.waitTime = 0;\n    }\n    window.ringerMainpanel.replayScript(runnableTrace, config,\n        (replayObject: Replay) => {\n      // use what we've observed in the replay to update page variables\n      HelenaConsole.namedLog(\"rbb\", \"replayObject\", replayObject);\n\n      // based on the replay object, we need to update any pagevars involved in\n      //   the trace\n      let trace: Trace = [];\n      for (const stmt of basicBlockStmts) {\n        // want the trace with display data, not the clean trace\n        trace = trace.concat(stmt.trace);\n      }\n      \n      //updatePageVars(trace, replayObject.record.events);\n      // ok, it's time to update the pageVars, but remember that's going to\n      //   involve checking whether we got a reasonable page\n      const allPageVarsOk = () => {\n        // statements may need to do something based on this trace, so go ahead\n        //   and do any extra processing\n        for (let i = 0; i < basicBlockStmts.length; i++) {\n          HelenaConsole.namedLog(\"rbb\", \"calling postReplayProcessing on\",\n            basicBlockStmts[i]);\n          basicBlockStmts[i].postReplayProcessing(runObject,\n            replayObject.record.events, i);\n        }\n\n        // once we're done replaying, have to replay the remainder of the script\n        self.runBasicBlock(runObject, bodyStatements.slice(nextBlockStartIndex,\n          bodyStatements.length), callback, options);\n      };\n      // console.log('update page vars 1');\n      updatePageVars(trace, replayObject.record.events, allPageVarsOk);\n    },\n      // ok, we also want some error handling functions\n    {\n      findNodeWithoutRequiredFeatures: (replayObject: Replay,\n         ringerContinuation: Function | null) => {\n        // todo: note that continuation doesn't actually have a continuation yet\n        //   because of Ringer-level implementation if you decide to start using\n        //   it, you'll have to go back and fix that.\n        //   see record-replay/mainpanel_main.js\n\n        // for now, if we fail to find a node where the user has insisted it has\n        //   a certain set of features, we want to just skip the row.\n        // essentially want the continue action, so we want the callback that's\n        //   supposed to happen at the end of running the rest of the script for\n        //   this iteration\n        // so we'll skip doing\n        //   program.runBasicBlock(bodyStatements.slice(nextBlockStartIndex,\n        //     bodyStatements.length), callback) (as above)\n        // instead we'll just do the callback\n        console.warn(\"rbb: couldn't find a node based on \" +\n          \"user-required features.  skipping the rest of this row.\");\n\n        // even though couldn't complete the whole trace, still need to do\n        //   updatePageVars because that's how we figure out which tab is\n        //   associated with which pagevar, so that we can go ahead and do tab\n        //   closing and back button pressing at the end\n        \n        // this is partly the same as the other allPageVarsOk\n        const allPageVarsOk = () => {\n          // in the continuation, we'll do the actual move onto the next \n          //   statement\n          options.skipMode = true;\n\n          // for now we'll assume that this means we'd want to try again in\n          //   future in case something new is added\n          //options.skipCommitInThisIteration = true;\n\n          // once we're done replaying, have to replay the remainder of the\n          //   script want to skip the rest of the loop body, so go straight to\n          //   callback\n          callback();\n        };\n\n        let trace: Trace = [];\n        for (const stmt of basicBlockStmts) {\n          // want the trace with display data, not the clean trace\n          trace = trace.concat(stmt.trace);\n        }\n        updatePageVars(trace, replayObject.record.events, allPageVarsOk);\n      },\n      portFailure: (replayObject: Replay,\n          ringerContinuation: Function | null) => {\n        // for now I haven't seen enough of these failures in person to know a\n        //   good way to fix them\n        // for now just treat them like a node finding failure and continue\n\n        console.warn(\"rbb: port failure.  ugh.\");\n\n        // even though couldn't complete the whole trace, still need to do\n        //   updatePageVars because that's how we figure out which tab is\n        //   associated with which pagevar, so that we can go ahead and do tab\n        //   closing and back button pressing at the end\n        \n        // this is partly the same as the other allPageVarsOk\n        const allPageVarsOk = () => {\n          // in the continuation, we'll do the actual move onto the next\n          //   statement\n          options.skipMode = true;\n\n          // for now we'll assume that this means we'd want to try again in\n          //   future in case something new is added\n          //options.skipCommitInThisIteration = true;\n\n          // once we're done replaying, have to replay the remainder of the\n          //   script\n          // want to skip the rest of the loop body, so go straight to callback\n          callback();\n        };\n\n        let trace: Trace = [];\n        for (const stmt of basicBlockStmts) {\n          // want the trace with display data, not the clean trace\n          trace = trace.concat(stmt.trace);\n        }\n        updatePageVars(trace, replayObject.record.events, allPageVarsOk);\n      }\n    });\n  }\n\n  private runBasicBlockWithRinger(bodyStmts: HelenaLangObject[],\n      options: RunOptions, runObject: RunObject, callback: Function) {\n    const self = this;\n    const nextBlockStartIndex = determineNextBlockStartIndex(bodyStmts); \n    let basicBlockStmts = selectBasicBlockStatements(bodyStmts,\n      nextBlockStartIndex);\n    basicBlockStmts = markNonTraceContributingStatements(basicBlockStmts);\n\n    const haveAllNecessaryRelationNodes =\n      doWeHaveRealRelationNodesWhereNecessary(basicBlockStmts,\n        runObject.environment);\n    if (!haveAllNecessaryRelationNodes) {\n      // ok, we're going to have to skip this iteration, because we're supposed\n      //   to open a page and we just won't know how to\n      console.warn(\"Had to skip an iteration because of lacking \" +\n        \"the node we'd need to open a new page\");\n      // todo: should probably also warn the contents of the various relation\n      //   variables at this iteration that we're skipping\n\n      // we're essentially done 'replaying', have to replay the remainder of the\n      //   script and we're doing continue, so set the continue flag to true\n      options.skipMode = true;\n      self.runBasicBlock(runObject, bodyStmts.slice(nextBlockStartIndex,\n        bodyStmts.length), callback, options);\n      return;\n    }\n\n    // make the trace we'll replay\n    const trace = makeTraceFromStatements(basicBlockStmts);\n    if (trace.length < 1) {\n      // ok, no point actually running Ringer here...  let's skip straight to\n      //   the 'callback!'\n      // statements may need to do something as post-processing, even without a\n      //   replay so go ahead and do any extra processing\n      for (let i = 0; i < basicBlockStmts.length; i++) {\n        HelenaConsole.namedLog(\"rbb\", \"calling postReplayProcessing on\",\n          basicBlockStmts[i]);\n        basicBlockStmts[i].postReplayProcessing(runObject, [], i);\n      }\n      // once we're done replaying, have to replay the remainder of the script\n      self.runBasicBlock(runObject, bodyStmts.slice(nextBlockStartIndex,\n        bodyStmts.length), callback, options);\n      return;\n    }\n\n    // ok, passArguments below is going to clone the trace, and the trace is\n    //   huge so currently thinking this may often be the place where we get\n    //   close to running out of memory so let's check and make sure we have\n    //   enough memory\n    // and if we don't, let's make sure the user really wants to continue\n\n    let continueWithScriptExecuted = false;\n\n    const continueWithScript = () => {\n      continueWithScriptExecuted = true;\n\n      // first call the run methods for any statements that have run methods in\n      //   case it's needed for making the arguments\n      // todo: note that this should actually happen interspersed with the\n      //   ringer replay.  do that evenutally\n      for (const stmt of basicBlockStmts) {\n        if (stmt.run) {\n          stmt.run(runObject, () => {}, options);\n        }\n      }\n\n      // now that we have the trace, let's figure out how to parameterize it\n      // note that this should only be run once the current___ variables in the\n      //   statements have been updated!  otherwise won't know what needs to be\n      //   parameterized, will assume nothing\n      // should see in future whether this is a reasonable way to do it\n      HelenaConsole.namedLog(\"rbb\", \"trace\", trace);\n      const parameterizedTrace = pbv(trace, basicBlockStmts);\n      \n      // now that we've run parameterization-by-value, have a function, let's\n      //   put in the arguments we need for the current run\n      HelenaConsole.namedLog(\"rbb\", \"parameterizedTrace\",\n        parameterizedTrace);\n      const runnableTrace = passArguments(parameterizedTrace, basicBlockStmts,\n        runObject.environment);\n      const config = parameterizedTrace.getConfig();\n      config.targetWindowId = runObject.window;\n      HelenaConsole.namedLog(\"rbb\", \"runnableTrace\", runnableTrace, config);\n\n      // the above works because we've already put in VariableUses for statement\n      //   arguments that use relation items, for all statements within a loop,\n      //   so currNode for those statements will be a variableuse that uses the\n      //   relation\n      // however, because we're only running these basic blocks, any uses of\n      //   relation items (in invisible events) that happen before the for loop\n      //   will not get parameterized, since their statement arguments won't be\n      //   changed, and they won't be part of the trace that does have statement\n      //   arguments changed (and thus get the whole trace parameterized for\n      //   that)\n      // I don't see right now how this could cause issues, but it's worth\n      //   thinking about\n      \n      self.doTheReplay(runnableTrace, config, basicBlockStmts, runObject,\n        bodyStmts, nextBlockStartIndex, callback, options);\n    }\n\n    /*\n    splitOnEnoughMemoryToCloneTrace(trace,\n      function() { // if enough memory\n        // plenty of memory.  carry on.\n        continueWithScript();\n      },\n      function() { // if not enough memory\n        // yikes, there's a pretty small amount of memory available at this point.  are you sure you want to go on?\n    console.log(\"decided we don't have enough memory.  pause.\");\n        var text = \"Looks like we're pretty close to running out of memory.  If we keep going, the extension might crash.  Continue anyway?\";\n        var buttonText = \"Continue\";\n        var dialogDiv = UIObject.continueAfterDialogue(text, buttonText, continueWithScript);\n\n        // we might like to check now and then to see if more memory has been freed up, so that we could start again\n        MiscUtilities.repeatUntil(\n          function() {\n      console.log(\"do we have enough memory?\");\n            splitOnEnoughMemoryToCloneTrace(trace,\n              function() { // enough memory now, so we actually want to continue\n    console.log(\"changed our minds.  decided we do have enough memory.\");\n                dialogDiv.remove(); // get rid of that dialog, so user doesn't see it\n                continueWithScript();\n              },\n              function() {}); // if there's not enough memory, just don't do anything, keep waiting for user\n          }, // repeat this\n          function() {return continueWithScriptExecuted;}, // until this\n          function() {}, // don't have any functions to run after the condition is reached\n          60000, false); // just check every minute\n      });\n      */\n      continueWithScript();\n  }\n\n  public runBasicBlock(runObject: RunObject, bodyStmts: HelenaLangObject[],\n      callback: Function, options: RunOptions = {}) {\n    const self = this;\n    HelenaConsole.namedLog(\"rbb\", bodyStmts.length, bodyStmts);\n\n    // first check if we're supposed to pause, stop execution if yes\n    HelenaConsole.namedLog(\"rbb\", \"runObject.userPaused\",\n      runObject.userPaused);\n    if (runObject.userPaused) {\n      const repWindowId = window.helenaMainpanel.currentReplayWindowId;\n      window.helenaMainpanel.currentReplayWindowId = null;\n      runObject.resumeContinuation = () => {\n        window.helenaMainpanel.currentReplayWindowId = repWindowId;\n        self.runBasicBlock(runObject, bodyStmts, callback, options);\n      };\n      HelenaConsole.log(\"paused\");\n      return;\n    }\n    HelenaConsole.log(\"runObject.userStopped\", runObject.userStopped);\n    if (runObject.userStopped) {\n      HelenaConsole.log(\"run stopped\");\n      \n      // set it back so that if the user goes to run again, everything will work\n      runObject.userStopped = false;\n      return;\n    }\n\n    if (bodyStmts.length < 1) {\n      HelenaConsole.namedLog(\"rbb\", \"rbb: empty loopystatments.\");\n      callback(options);\n      return;\n    } else if (bodyStmts[0] instanceof LoopStatement) {\n      const loopStmt = <LoopStatement> bodyStmts[0];\n      const relation = <Relation> loopStmt.relation;\n\n      // for now LoopStatement gets special processing\n      if (options.skipMode) {\n        // in this case, when we're basically 'continue'ing, it's as if this\n        //   loop is empty, so skip straight to that\n        self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n          callback, options);\n        return;\n      }\n      HelenaConsole.namedLog(\"rbb\", \"rbb: loop.\");\n\n      const cleanupAfterLoopEnd = (continuation: Function) => {\n        loopStmt.rowsSoFar = 0;\n\n        if (loopStmt.pageVar) {\n          const prinfo = relation.getPrinfo(loopStmt.pageVar);\n          HelenaConsole.namedLog(\"prinfo\", \"change prinfo, finding for cleanup\");\n          HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n          HelenaConsole.log(\"prinfo in cleanup\", prinfo);\n          // have to get rid of this prinfo in case (as when a pulldown menu is\n          //   dynamically adjusted by another, and so we want to come back and\n          //   get it again later) we'll want to scrape the same relation fresh\n          //   from the same page later\n          delete loopStmt.pageVar.pageRelations[relation.name+\"_\"+relation.id];\n          HelenaConsole.namedLog(\"prinfo\", \"cleared a page relation entry\"); \n        }\n        \n        // time to run end-of-loop-cleanup on the various bodyStatements\n        loopStmt.traverse((stmt: HelenaLangObject) => {\n          // cjbaik: not sure if SkipBlocks actually pass thru here but safer to\n          //   assume so\n          if (stmt instanceof LoopStatement || stmt instanceof SkipBlock) {\n            stmt.endOfLoopCleanup(continuation);\n          }\n        }, () => {});\n      }\n\n      // are we actually breaking out of the loop?\n      if (options.breakMode) {\n        console.warn(\"breaking out of the loop\");\n        // if we were in break mode, we're done w/loop, so turn off break mode\n        options.breakMode = false;\n        const continuation = () => {\n          // once we're done with the loop, have to replay the remainder of the\n          //   script\n          self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n            callback, options);   \n        }\n        cleanupAfterLoopEnd(continuation);\n        return;\n      }\n\n      // have we hit the maximum number of iterations we want to do?\n      if (loopStmt.maxRows !== null && loopStmt.rowsSoFar >= loopStmt.maxRows) {\n        // hey, we're done!\n        HelenaConsole.namedLog(\"rbb\", \"hit the row limit\");\n        const continuation = () => {\n          // once we're done with the loop, have to replay the remainder of the\n          //   script\n          self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n            callback, options);\n        }\n        cleanupAfterLoopEnd(continuation);\n        return;\n      }\n\n      // if we're going to simulate an error at any point, is this the point?\n      if (options.simulateError) {\n        const targetIterations = options.simulateError;\n        // gets the iterations of this loop and any ancestor loops\n        const currentIterations = loopStmt.getLoopIterationCounters();\n        // first make sure we're actually on the right loop.  no need to check\n        //   if we're still on the outermost loop but breaking in the innermost\n        if (currentIterations.length >= targetIterations.length) {\n          // ok, that last loop is the one we're about to run, including upping\n          //   the rowsSoFar counter, so up that now.  no need to fetch row if\n          //   we're supposed to error now\n          currentIterations[currentIterations.length - 1] =\n            currentIterations[currentIterations.length - 1] + 1;\n          // now that we know we're at the right loop or deeper, let's check...\n          let timeToError = true;\n          for (let i = 0; i < targetIterations.length; i++) {\n            if (currentIterations[i] > targetIterations[i]) {\n              // ok, it's time.  need this case if we never hit the iteration on\n              //   an inner loop, so we do the error at the start of the next\n              //   loop\n              timeToError = true;\n              break;\n            }\n            if (currentIterations[i] < targetIterations[i]) {\n              timeToError = false; // ok, we're not there yet\n              break;\n            }\n            // if it's equal, check the next nested loop\n          }\n          // at this point, only if all loops were greater than or equal to the\n          //   target number of iterations will timeToError be true\n          if (timeToError) {\n            // remember, when we rerun, don't error anymore!  don't want an\n            //   infinite loop.\n            options.simulateError = undefined;\n            // first close the old dataset object in order to flush all its data\n            //   to the server\n            runObject.dataset.closeDataset();\n            // now restart\n            // all other options should be the same, except that we shouldn't\n            //   simulate the error anymore and must make sure to use the same\n            //   dataset\n            options.dataset_id = runObject.dataset.getId();\n            runObject.program.runProgram(options); \n\n            // don't run any of the callbacks for this old run! we're done w/it!\n            return;\n          }\n        }\n      }\n\n      loopStmt.relation.getNextRow(runObject, loopStmt.pageVar,\n          (moreRows: boolean) => {\n        if (!moreRows) {\n          // hey, we're done!\n          HelenaConsole.namedLog(\"rbb\", \"no more rows\");\n          const continuation = () => {\n            // once we're done with the loop, have to replay the remainder of\n            //   the script\n            self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n              callback, options);\n          }\n          cleanupAfterLoopEnd(continuation);\n          return;\n        }\n        HelenaConsole.namedLog(\"rbb\", \"we have a row!  let's run\");\n        // otherwise, should actually run the body\n        loopStmt.rowsSoFar += 1;\n        // block scope.  let's add a new frame\n        runObject.environment = runObject.environment.envExtend();\n        HelenaConsole.namedLog(\"rbb\", \"envExtend done\");\n        // and let's give us access to all the loop variables\n        // note that for now loopVarsMap includes all columns of the relation.\n        //   may some day want to limit it to only the ones used...\n        loopStmt.updateRelationNodeVariables(runObject.environment);\n        HelenaConsole.namedLog(\"rbb\", \"bodyStatements\", bodyStmts);\n\n        // running extra iterations of the for loop is the only time we change\n        //   the callback\n        self.runBasicBlock(runObject, loopStmt.bodyStatements, () => {\n          // and once we've run the body, we should do the next iteration of the\n          //   loop but first let's get rid of that last environment frame\n          HelenaConsole.namedLog(\"rbb\", \"rbb: preparing for next loop \" +\n            \"iteration, popping frame off environment.\");\n          if (runObject.environment.parent) {\n            runObject.environment = runObject.environment.parent;\n          }\n          // for the next iteration, we'll be back out of skipMode if we were in\n          //   skipMode and let's run loop cleanup, since we actually ran the\n          //   body statements\n          // we don't skip things in the cleanup, so time to swap those off\n          options.skipMode = false;\n          options.skipCommitInThisIteration = false;\n\n          // the main way we clean up is by running the cleanupStatements\n          self.runBasicBlock(runObject, loopStmt.cleanupStatements, () => {\n            // and once we've done that loop body cleanup, then let's finally\n            //   go ahead and go back to do the loop again!\n            HelenaConsole.namedLog(\"rbb\", \"Post-cleanupstatements.\")\n            self.runBasicBlock(runObject, bodyStmts, callback, options); \n          }, options);\n        }, options);\n      });\n      return;\n    } else if (!bodyStmts[0].isRingerBased()) {\n      // also need special processing for back statements, if statements,\n      //   continue statements, whatever isn't ringer-based\n      HelenaConsole.namedLog(\"rbb\", \"rbb: non-Ringer-based statement.\");\n\n      if (options.skipMode || options.breakMode) {\n        // in this case, when we're basically 'continue'ing, we should do\n        //   nothing\n        self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n          callback, options);\n        return;\n      }\n\n      // normal execution, either because we're not in skipMode, or because we\n      //   are but it's a back or a close\n      const continuation = (rbboptions: RunOptions) => { \n        // remember that rbbcontinuations passed to run methods must always\n        //   handle rbboptions\n        // rbboptions includes skipMode to indicate whether we're continuing\n        // once we're done with this statement running, have to replay the\n        //   remainder of the script\n        self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n          callback, rbboptions);\n      };\n      bodyStmts[0].run(runObject, continuation, options);\n      return;\n    } else {\n      HelenaConsole.namedLog(\"rbb\", \"rbb: r+r.\");\n      // the fun stuff!  we get to run a basic block with the r+r layer\n\n      if (options.skipMode || options.breakMode) {\n        // in this case, when we're basically 'continue'ing, we should do\n        //   nothing, so just go on to the next statement without doing anything\n        //   else\n        self.runBasicBlock(runObject, bodyStmts.slice(1, bodyStmts.length),\n          callback, options);\n        return;\n      }\n\n      self.runBasicBlockWithRinger(bodyStmts, options, runObject, callback);\n    }\n  }\n\n  public turnOffDescentIntoLockedSkipBlocks() {\n    this.traverse(function(stmt: HelenaLangObject) {\n      if (stmt instanceof SkipBlock) {\n        stmt.descendIntoLocks = false;\n      }\n    }, () => {});\n  }\n\n  /**\n   * \n   * @param options \n   * @param continuation \n   * @param parameters \n   * @param requireDataset should only be false if we're sure users shouldn't be\n   *  putting in output rows...\n   */\n  public runProgram(options: RunOptions = {}, continuation?: Function,\n      parameters: Parameters = {}, requireDataset = true) {\n    const self = this;\n    console.log(\"program run\");\n    console.log(`options: ${JSON.stringify(options)}`);\n    console.log(`continuation: ${continuation}`);\n    console.log(`parameters: ${JSON.stringify(parameters)}`);\n\n    HelenaConsole.log(\"parameters\", parameters);\n    for (const prop in options) {\n      if (!recognizedOptions.includes(prop)) {\n        // woah, bad, someone thinks they're providing an option that will\n        //   affect us, but we don't know what to do with it\n        // don't let them think everything's ok, especially since they probably\n        //   just mispelled\n        console.warn(\"Woah, woah, woah.  Tried to provide option \" +\n          prop + \" to program run, but we don't know what to do with it.\");\n        if (internalOptions.includes(prop)) {\n          // ok, well an internal prop sneaking in is ok, so we'll just provide a warning.  otherwise we're actually going to stop\n          console.warn(\"Ok, we're allowing it because it's an \" +\n            \"internal option, but we're not happy about it and we're setting \" +\n            \"it to false.\");\n          options[prop] = false;\n        } else {\n          return;\n        }\n      }\n    }\n\n    // in case we left the last run in a bad state, let's go ahead and make sure\n    //   we'll parallelize at top level\n    this.turnOffDescentIntoLockedSkipBlocks();\n\n    // before we start running, let's check if we need to update the\n    //   continuation in order to make it loop on this script forever\n    // (if it's one of those programs where we're supposed to go back and run\n    //   again as soon as we finish)\n    let fullContinuation = continuation;\n    if (this.restartOnFinish || options.restartOnFinish === true) {\n      // yep, we want to repeat.  time to make a new continuation that, once it\n      //   finishes the original continuation\n      // will make a new dataset and start over. the loop forever option/start\n      //   again when done option\n      fullContinuation = (dataset: Dataset, timeScraped: number,\n          tabId: number) => {\n        if (continuation) {\n          continuation(dataset, timeScraped, options);\n        }\n        // TODO: cjbaik: not sure what the tabId is doing here, is !! correct?\n        self.runProgram(options, continuation, parameters, !!tabId);\n      }\n    }\n\n    if (options.dataset_id) {\n      // no need to make a new dataset\n      const dataset = new Dataset(self, options.dataset_id);\n      runInternals(this, parameters, dataset, options, fullContinuation);\n    } else {\n      // ok, have to make a new dataset\n      const dataset = new Dataset(self);\n      // it's really annoying to go on without having an id, so let's wait till\n      //   we have one\n      const continueWork = () => {\n        adjustDatasetNameForOptions(dataset, options);\n        runInternals(self, parameters, dataset, options, fullContinuation);       \n      }\n\n      if (requireDataset) {\n        MiscUtilities.repeatUntil(\n          () => {}, \n          () => dataset.isReady(),\n          () => { continueWork(); },\n          1000, true);\n      } else {\n        continueWork();\n      }\n    }\n  }\n\n  public restartFromBeginning(runObjectOld: RunObject, continuation: Function) {\n    // basically same as above, but store to the same dataset (for now, dataset\n    //   id also controls which saved annotations we're looking at)\n    runObjectOld.program.runProgram({\n      dataset_id: runObjectOld.dataset.getId()\n    }, continuation);\n  }\n\n  public stopRunning(runObject: RunObject) {\n    if (!runObject.userPaused) {\n      // don't need to stop continuation chain unless it's currently going; if\n      //   paused, isn't going, stopping flag won't get turned off and will\n      //   prevent us from replaying later\n      runObject.userStopped = true; // this will stop the continuation chain\n    }\n    // should we even bother saving the data?\n    runObject.dataset.closeDataset();\n    this.clearRunningState();\n\n    // todo: is current (new) stopReplay enough to make sure that when we try to\n    //   run the script again, it will start up correctly?\n    window.ringerMainpanel.stopReplay();\n  }\n\n  public clearRunningState() {\n    for (const relation of this.relations) {\n      relation.clearRunningState();\n    }\n    for (const pageVar of this.pageVars) {\n      pageVar.clearRunningState();\n    }\n    this.traverse((stmt: HelenaLangObject) => {\n      stmt.clearRunningState();\n    }, () => {});\n  }\n\n  public setParameterNames(paramNamesLs: string[]) {\n    console.log(\"setParameterNames\", paramNamesLs);\n    this.parameterNames = paramNamesLs;\n    // when you make parameters, they might be referred to by NodeVariableUse\n    //   expressions so you need to make node variables for them (even though of\n    //   course they aren't nodes)\n    // todo: do we want to restructure this in some way?\n    for (const paramName of paramNamesLs) {\n      var nodeVar = window.helenaMainpanel.getNodeVariableByName(paramName);\n      if (!nodeVar) {\n        new NodeVariable(paramName, { text: \"\" }, { text: \"\" }, null,\n          NodeSources.PARAMETER);\n      }\n    }\n  }\n\n  public getParameterNames() {\n    return this.parameterNames;\n  }\n\n  public setParameterDefaultValue(paramName: string, paramVal: any) {\n    this.defaultParamVals[paramName] = paramVal;\n  }\n\n  public getParameterDefaultValues() {\n    return this.defaultParamVals;\n  }\n\n  public getAllVariableNames() {\n    // start with the parameters to the program\n    let variableNames: string[] = [];\n    let paramNames = this.getParameterNames();\n    if (paramNames) {\n      variableNames = paramNames.slice();\n    }\n    this.traverse((stmt: HelenaLangObject) => {\n      if (stmt instanceof LoopStatement) {\n        variableNames = variableNames.concat(stmt.relation.columnNames());\n      } else if (stmt instanceof ScrapeStatement &&\n                 !stmt.scrapingRelationItem()) {\n        variableNames.push(stmt.currentNode.getName());\n      }\n    }, () => {});\n    // cjbaik: could replace this with different function, but need to make sure\n    //   our replacement for _.uniq preserves ordering\n    return _.uniq(variableNames);\n  }\n\n  public makeVariableNamesDropdown() {\n    const varNames = this.getAllVariableNames();\n    const varNamesDropDown = [];\n    for (const varName of varNames) {\n      varNamesDropDown.push([varName, varName]);\n    }\n    return varNamesDropDown;\n  }\n\n  public prepareToRun() {\n    this.traverse((stmt: HelenaLangObject) => {\n      stmt.prepareToRun();\n    }, () => {});\n  }\n\n  public relevantRelations() {\n    const self = this;\n    // ok, at this point we know the urls we've used and the xpaths we've used\n    //   on them. we should ask the server for relations that might help us out\n    // when the server gets back to us, we should try those relations on the\n    //   current page. we'll compare those against the best we can create on the\n    //   page right now, pick the winner\n\n    // get the xpaths used on the urls\n    // todo: right now we're doing this on a page by page basis, splitting into\n    //   assuming it's one first row per page (tab)...\n    // but it should really probably be per-frame, not per tab\n    for (const stmt of this.statements) {\n      if (stmt instanceof ScrapeStatement ||\n          stmt instanceof ClickStatement ||\n          stmt instanceof PulldownInteractionStatement) {\n        // todo: in future, should get the whole node info, not just the xpath,\n        //   but this is sufficient for now\n        const xpath = stmt.node;\n        // pagevar is better than url for helping us figure out what was on a\n        //   given logical page\n        const pageVarName = stmt.pageVar?.name;\n        const url = stmt.pageVar?.recordTimeUrl;\n        const frameUrl = stmt.trace[0].frame.URL;\n        const frameId = stmt.trace[0].frame.iframeIndex;\n\n        if (pageVarName) {\n          if (!(pageVarName in this.pagesToNodes)) {\n            this.pagesToNodes[pageVarName] = [];\n          }\n          if (xpath && !this.pagesToNodes[pageVarName].includes(xpath)) {\n            this.pagesToNodes[pageVarName].push(xpath);\n          }\n\n          if (!(pageVarName in this.pagesToFrameUrls)) {\n            this.pagesToFrameUrls[pageVarName] = [];\n          }\n          this.pagesToFrameUrls[pageVarName].push(frameUrl);\n\n          if (!(pageVarName in this.pagesToFrames)) {\n            this.pagesToFrames[pageVarName] = [];\n          }\n          this.pagesToFrames[pageVarName].push(frameId);\n\n          if (url) {\n            this.pagesToUrls[pageVarName] = url;\n          }\n        } else {\n          console.warn(\"No valid pageVarName set.\");\n        }\n      }\n    }\n    // ask the server for relations\n    // sample: $($.post('http://localhost:3000/retrieverelations', { pages: [{xpaths: [\"a[1]/div[2]\"], url: \"www.test2.com/test-test\"}] }, function(resp) { HelenaConsole.log(resp);} ));\n    const reqList = [];\n    for (const pageVarName in this.pagesToNodes) {\n      reqList.push({\n        url: this.pagesToUrls[pageVarName],\n        xpaths: this.pagesToNodes[pageVarName],\n        page_var_name: pageVarName,\n        frame_ids: this.pagesToFrames[pageVarName]\n      });\n    }\n    HelenaServer.retrieveRelations({ pages: reqList },\n      (resp: RetrieveRelationsResponse) => {\n        self.processServerRelations(resp);\n      }\n    );\n  }\n\n  public processServerRelations(resp: RetrieveRelationsResponse,\n      currentStartIndex = 0, tabsToCloseAfter: number[] = [], tabMapping = {},\n      windowId?: number, pageCount = 0) {\n    const self = this;\n    \n    // we're ready to try these relations on the current pages\n    // to do this, we'll have to actually replay the script\n    const startIndex = currentStartIndex;\n\n    const runRelationFindingInNewWindow = (windowId: number) => {\n      // let's find all the statements that should open new pages (where we'll\n      //   need to try relations)\n      for (let i = currentStartIndex; i < self.statements.length; i++) {\n        const curStmt = self.statements[i];\n        if (curStmt.hasOutputPageVars()) {\n          pageCount += 1;\n          if (window.helenaMainpanel.UIObject.handleRelationFindingPageUpdate) {\n            window.helenaMainpanel.UIObject.handleRelationFindingPageUpdate(\n              pageCount);\n          }\n\n          // todo: for now this code assumes there's exactly one outputPageVar.\n          //   this may not always be true!  but dealing with it now is a bad\n          //   use of time\n          const outputPVStmt = (<OutputPageVarStatement> curStmt);\n          const outputPageVars = <PageVariable[]> outputPVStmt.outputPageVars;\n          const targetPageVar = outputPageVars[0];\n          HelenaConsole.log(\"processServerrelations going for index:\", i,\n            targetPageVar);\n\n          // this is one of the points to which we'll have to replay\n          const statementSlice = self.statements.slice(startIndex, i + 1);\n          let trace: Trace = [];\n          for (const stmt of statementSlice) {\n            trace = trace.concat((<OutputPageVarStatement> stmt).cleanTrace);\n          }\n          // strip the display info back out from the event objects\n          //_.each(trace, function(ev) {Trace.clearDisplayInfo(ev);});\n\n          HelenaConsole.log(\"processServerrelations program: \", self);\n          HelenaConsole.log(\"processServerrelations trace indexes: \",\n            startIndex, i);\n          HelenaConsole.log(\"processServerrelations trace:\", trace.length);\n\n          const nextIndex = i + 1;\n\n          // ok, we have a slice of the statements that should produce one of\n          //   our pages. let's replay\n          // todo, if we fail to find it with this approach, start running\n          //   additional statements (seomtimes the relation is only displayed\n          //   after user clicks on an element, that kind of thing)\n          window.ringerMainpanel.replayScript(trace, {\n            tabMapping: tabMapping,\n            targetWindowId: windowId\n          }, (replayObj: Replay) => {\n            // continuation\n            HelenaConsole.log(\"replayobj\", replayObj);\n\n            // what's the tab that now has the target page?\n            const replayTrace = replayObj.record.events;\n            const lastCompletedEvent = Traces.lastTopLevelCompletedEvent(\n              replayTrace);\n            let lastCompletedEventTabId = Traces.tabId(lastCompletedEvent);\n            // what tabs did we make in the interaction in general?\n            tabsToCloseAfter = tabsToCloseAfter.concat(\n              Traces.tabsInTrace(replayTrace));\n            // also sometimes it's important that we bring this tab (on which\n            //   we're about to do relation finding)\n            // to be focused, so that it will get loaded and we'll be able to\n            //   find the relation\n            chrome.tabs.update(lastCompletedEventTabId, { active: true },\n              (tab) => { });\n            // I know I know, I should really have all the rest of this inside\n            //   the callback for the tab update\n            // but we didn't even do this in the past and it's pretty fast...\n\n            // let's do some trace alignment to figure out a tab mapping\n            const newMapping = tabMappingFromTraces(trace, replayTrace);\n            tabMapping = _.extend(tabMapping, newMapping);\n            HelenaConsole.log(newMapping, tabMapping);\n\n            // and what are the server-suggested relations we want to send?\n            const resps = resp.pages;\n            let suggestedRelations: (RelationSelector | null)[] | null = null;\n            for (const resp of resps) {\n              const pageVarName = resp.page_var_name;\n              if (pageVarName === targetPageVar.name) {\n                suggestedRelations = [];\n\n                const sameDomainRelSel = resp.relations.same_domain_best_relation;\n                if (sameDomainRelSel !== null) {\n                  suggestedRelations.push(\n                    RelationSelector.fromJSON(sameDomainRelSel));\n                } else {\n                  suggestedRelations.push(sameDomainRelSel);\n                }\n\n                const sameUrlRelSel = resp.relations.same_url_best_relation;\n                if (sameUrlRelSel !== null) {\n                  suggestedRelations.push(\n                    RelationSelector.fromJSON(sameUrlRelSel));\n                } else {\n                  suggestedRelations.push(sameUrlRelSel);\n                }\n\n                /*\n                suggestedRelations = [\n                  resp.relations.same_domain_best_relation,\n                  resp.relations.same_url_best_relation\n                ];\n                for (let j = 0; j < suggestedRelations.length; j++) {\n                  if (suggestedRelations[j] === null) {\n                    continue;\n                  }\n                  // is this the best place to deal with going between our\n                  //   object attributes and the server strings?\n                  suggestedRelations[j] = RelationSelector.fromJSON(\n                    suggestedRelations[j]);\n                }*/\n              }\n            }\n\n            if (suggestedRelations === null) {\n              HelenaConsole.log(\"Panic!  We found a page in our \" +\n                \"outputPageVars that wasn't in our request to the server for \" +\n                \"relations that might be relevant on that page.\");\n            }\n\n            let framesHandled: {\n              [key: string]: RelationResponse;\n            } = {};\n\n            // we'll do a bunch of stuff to pick a relation, then we'll call\n            //   this function\n            const handleSelectedRelation = (data: RelationResponse) => {\n              // handle the actual data the page sent us, if we're still\n              //   interested in adding loops\n\n              // if we're in this but the user has told us to stop trying to\n              //   automatically add relations, let's stop\n              if (self.automaticLoopInsertionForbidden) {\n                // don't even go running more ringer stuff if we're not\n                //   interested in seeing more loops inserted\n                return;\n              }\n\n              // ok, normal processing.  we want to add a loop for this relation\n              if (data) {\n                self.processLikelyRelation(data);\n              }\n              // update the control panel display\n              // true because we're still unearthing interesting relations, so\n              //   should indicate we're in progress\n              window.helenaMainpanel.UIObject.updateDisplayedRelations(true);\n              // now let's go through this process all over again for the next\n              //   page, if there is one\n              HelenaConsole.log(\"going to processServerRelations with \" +\n                \"nextIndex: \", nextIndex);\n              self.processServerRelations(resp, nextIndex, tabsToCloseAfter,\n                tabMapping, windowId, pageCount);\n            };\n\n            if (window.helenaMainpanel.UIObject.\n                handleFunctionForSkippingToNextPageOfRelationFinding) {\n              window.helenaMainpanel.UIObject.\n                handleFunctionForSkippingToNextPageOfRelationFinding(\n                  handleSelectedRelation);\n            }\n\n            // this function will select the correct relation from amongst a\n            //   bunch of frames' suggested relatoins\n            let processedTheLikeliestRelation = false;\n            const pickLikelyRelation = () => {\n              if (processedTheLikeliestRelation) {\n                return; // already did this.  don't repeat\n              }\n\n              for (const key in framesHandled) {\n                if (!framesHandled[key]) {\n                  // nope, not ready yet.  wait till all the frames have given\n                  //   answers\n                  return;\n                }\n              }\n              // todo: this is just debugging\n              HelenaConsole.log(\"framesHandled\", framesHandled);\n\n              let dataObjs = Object.keys(framesHandled).map(\n                (key) => framesHandled[key]\n              );\n              HelenaConsole.log(\"dataObjs\", dataObjs);\n              // todo: should probably do a fancy similarity thing here, but for\n              //   now we'll be casual\n              // we'll sort by number of cells, then return the first one that\n              //   shares a url with our spec nodes, or the first one if none\n              //   share that url\n              dataObjs = dataObjs.filter(\n                (obj) => obj !== null && obj !== undefined\n              );\n              let sortedDataObjs = _.sortBy(dataObjs, (data) => {\n                if (!data || !data.first_page_relation ||\n                    !data.first_page_relation[0]) {\n                  return -1;\n                } else {\n                  return data.first_page_relation.length *\n                    data.first_page_relation[0].length;\n                }\n              }); // ascending\n              sortedDataObjs = sortedDataObjs.reverse();\n              HelenaConsole.log(\"sortedDataObjs\", sortedDataObjs);\n              const frameUrls = self.pagesToFrameUrls[targetPageVar.name];\n              HelenaConsole.log(\"frameUrls\", frameUrls,\n                self.pagesToFrameUrls, targetPageVar.name);\n              \n              // a silly one-liner for getting the most freq\n              const mostFrequentFrameUrl = _.first(_.chain(frameUrls).countBy()\n                .pairs().max(_.last).value());\n            \n              for (const data of sortedDataObjs) {\n                if (data.url === mostFrequentFrameUrl) {\n                  // ok, this is the one\n                  // now that we've picked a particular relation, from a\n                  //   particular frame, actually process it\n                  processedTheLikeliestRelation = true;\n                  handleSelectedRelation(data);\n                  return;\n                }\n              }\n              // drat, none of them had the exact same url. ok, let's just pick\n              //   the first\n              if (sortedDataObjs.length < 1) {\n                HelenaConsole.log(\"Aaaaaaaaaaah there aren't any frames \" +\n                  \"that offer good relations!  Why???\");\n                return;\n              }\n              processedTheLikeliestRelation = true;\n              handleSelectedRelation(sortedDataObjs[0]);\n            };\n\n            const sendMessageForFrames = (frames: number[]) => {\n              framesHandled = {};\n              for (const frame of frames) {\n                // keep track of which frames need to respond before we'll be\n                //   read to advance\n                HelenaConsole.log(\"frameId\", frame);\n                delete framesHandled[frame];\n              }\n              for (const frame of frames) {\n                // for each frame in the target tab, we want to see if the frame\n                //   suggests a good relation.  once they've all made their\n                //   suggestions\n                // we'll pick the one we like best\n                // todo: is there a better way? after all, we do know the frame\n                //   in which the user interacted with the first page at\n                //   original record-time\n                \n                // here's the function for sending the message once\n                var getLikelyRelationFunc = () => {\n                  Messages.sendFrameSpecificMessage(\"mainpanel\",\n                    \"content\", \"likelyRelation\", {\n                      xpaths: self.pagesToNodes[targetPageVar.name],\n                      pageVarName: targetPageVar.name,\n                      serverSuggestedRelations: suggestedRelations\n                    }, lastCompletedEventTabId, frame,\n                    (resp: RelationResponse) => {\n                      // question: is it ok to insist that every single frame\n                      //   returns a non-null one?  maybe have a timeout?\n                      //   maybe accept once we have at least one good response\n                      //   from one of the frames?\n                      if (resp) {\n                        resp.frame = frame;\n                        framesHandled[frame] = resp;\n                        \n                        // when get response, call pickLikelyRelation (defined\n                        //   above) to pick from the frames' answers\n                        pickLikelyRelation();\n                      }\n                    }\n                  );\n                };\n\n                // here's the function for sending the message until we get the\n                //   answer\n                const getLikelyRelationFuncUntilAnswer = () => {\n                  // cool, already got the answer, stop asking\n                  if (framesHandled[frame]) { return; }\n                  getLikelyRelationFunc(); // send that message\n\n                  // come back and send again if necessary\n                  setTimeout(getLikelyRelationFuncUntilAnswer, 5000);\n                };\n\n                // actually call it\n                getLikelyRelationFuncUntilAnswer();\n              }\n            }\n\n            let allFrames = self.pagesToFrames[targetPageVar.name];\n            allFrames = [...new Set(allFrames)];\n            if (allFrames.length === 1 && allFrames[0] === -1) {\n              // cool, it's just the top-level frame\n              // just do the top-level iframe, and that will be faster\n              \n              // assumption: 0 is the id for the top-level frame\n              sendMessageForFrames([0]);\n            } else {\n              // ok, we'll have to ask the tab what frames are in it\n              // let's get some info from the pages, and when we get that info\n              //   back we can come back and deal with more script segments\n              const checkFramesFunc = () => {\n                if (!lastCompletedEventTabId) {\n                  return;\n                }\n                chrome.webNavigation.getAllFrames({\n                  tabId: lastCompletedEventTabId\n                }, (details) => {\n                  console.log(\"about to send to frames, tabId\",\n                    lastCompletedEventTabId);\n                  if (details) {\n                    const frames = details.map((d) => d.frameId);\n                    sendMessageForFrames(frames);\n                  }\n                });\n              };\n              // for pages that take a long time to actually load the right page\n              //   (redirects), can increase this; todo: fix it a real way by\n              //   trying over and over until we get a reasonable answer\n              setTimeout(checkFramesFunc, 0);\n            }\n          });\n          // all later indexes will be handled by the recursion instead of the\n          //   rest of the loop\n          return;\n        }\n      }\n      // ok we hit the end of the loop without returning after finding a new\n      //   page to work on.  time to close tabs\n      tabsToCloseAfter = [...new Set(tabsToCloseAfter)]; \n      console.log(\"tabsToCloseAfter\", tabsToCloseAfter);     \n      // commenting out the actual tab closing for debugging purposes\n      /*\n      for (var i = 0; i < tabsToCloseAfter.length; i++) {\n        console.log(\"processServerRelations removing tab\", tabsToCloseAfter[i]);\n        chrome.tabs.remove(tabsToCloseAfter[i], function() {\n          // do we need to do anything?\n        }); \n      }\n      */\n      /*\n      chrome.windows.remove(windowId);\n      */\n      // let's also update the ui to indicate that we're no longer looking\n      window.helenaMainpanel.UIObject.updateDisplayedRelations(false);\n    }\n\n    // if this is our first time calling this function, we'll need to make a new\n    //   window for our exploration of pages so we don't just choose a random\n    //   one but if we've already started, no need, can juse use the windowId we\n    //   already know\n    if (!windowId) {\n      if (self.windowWidth) {\n        var width = self.windowWidth;\n        var height = self.windowHeight;\n        MiscUtilities.makeNewRecordReplayWindow(\n          runRelationFindingInNewWindow, undefined, width, height);\n      } else {\n        MiscUtilities.makeNewRecordReplayWindow(\n          runRelationFindingInNewWindow);\n      }\n    } else {\n      runRelationFindingInNewWindow(windowId);\n    }\n  }\n\n  public forbidAutomaticLoopInsertion() {\n    this.automaticLoopInsertionForbidden = true;\n  }\n\n  public processLikelyRelation(data: RelationResponse) {\n    HelenaConsole.log(data);\n\n    if (this.pagesProcessed[data.page_var_name]) {\n      // we already have an answer for this page.  must have gotten sent\n      //   multiple times even though that shouldn't happen\n      HelenaConsole.log(\"Alarming.  We received another likely relation \" +\n        \"for a given pageVar, even though content script should prevent this.\");\n      return this.relations;\n    }\n\n    this.pagesProcessed[data.page_var_name] = true;\n\n    if (data.num_rows_in_demonstration < 2 &&\n        data.next_type === NextButtonTypes.NONE) {\n      // what's the point of showing a relation with only one row?\n    } else {\n      // if we have a normal selector, let's add that to our set of relations\n      if (data.selector) {\n        const rel = new Relation(data.relation_id, data.name, data.selector,\n          data.selector_version, data.exclude_first, data.columns,\n          data.first_page_relation, data.num_rows_in_demonstration,\n          data.page_var_name, data.url, data.next_type,\n          data.next_button_selector, data.frame);\n        if (!this.relations.includes(rel)) {\n          this.relations.push(rel);\n        }\n      }\n      \n      // if we also have pulldown menu selectors, let's add those too\n      if (data.pulldown_relations) {\n        for (const pulldownRel of data.pulldown_relations) {\n          var rel = new Relation(pulldownRel.relation_id, pulldownRel.name,\n            pulldownRel.selector, pulldownRel.selector_version,\n            pulldownRel.exclude_first, pulldownRel.columns,\n            pulldownRel.first_page_relation,\n            pulldownRel.num_rows_in_demonstration,\n            pulldownRel.page_var_name, pulldownRel.url, pulldownRel.next_type,\n            pulldownRel.next_button_selector, pulldownRel.frame);\n          if (!this.relations.includes(rel)) {\n            this.relations.push(rel);\n          }\n        }\n      }\n    }\n\n    HelenaConsole.log(this.pagesToNodes);\n\n    if (!this.automaticLoopInsertionForbidden) {\n      this.insertLoops(true);\n    }\n\n    // give the text relations back to the UI-handling component so we can display to user\n    return this.relations;\n  }\n\n  public insertLoops(updateProgPreview: boolean) {\n    // indexes into the statements mapped to the relations used by those\n    //   statements\n    const indexesToRelations: {\n      [key: number]: GenericRelation\n    } = {};\n    for (const relation of this.relations) {\n      for (let j = 0; j < this.statements.length; j++) {\n        const statement = this.statements[j];\n        if (statement.usesRelation(relation)) {\n          let loopStartIndex = j;\n          // let's do something a little different in cases where there's a\n          //   keydown right before the loop, since the keyups will definitely\n          //   happen within\n          // todo: may even need to look farther back for keydowns whose keyups\n          //   happen within the loop body\n          const prevStmt = this.statements[j-1];\n          if (prevStmt instanceof TypeStatement && prevStmt.onlyKeydowns) {\n            loopStartIndex = j - 1;\n          }\n          indexesToRelations[loopStartIndex] = relation;\n          break;\n        }\n      }\n    }\n\n    this.updateChildStatements(this.statements);\n\n    // start at end, work towards beginning\n    const indexes = Object.keys(indexesToRelations).map(Number)\n                          .sort((a, b) => b - a);\n    for (const index of indexes) {\n      // let's grab all the statements from the loop's start index to the end,\n      //   put those in the loop body\n      const bodyStatementLs = this.bodyStatements.slice(index,\n        this.bodyStatements.length);\n      // pageVar comes from first item because that's the one using the\n      //   relation, since it's the one that made us decide to insert a new loop\n      //   starting with that \n      const pageVar = (<PageActionStatement> bodyStatementLs[0]).pageVar;\n\n      if (!pageVar) {\n        throw new ReferenceError(\"Page variable not set.\");\n      }\n\n      // let's use bodyStatementLs as our body,\n      //   indexesToRelations[index] as our relation \n      const loopStatement = loopStatementFromBodyAndRelation(bodyStatementLs,\n        indexesToRelations[index], pageVar);\n      \n      const newChildStatements = this.bodyStatements.slice(0, index);\n      newChildStatements.push(loopStatement);\n      this.updateChildStatements(newChildStatements);\n    }\n\n    if (updateProgPreview) {\n      window.helenaMainpanel.UIObject.updateDisplayedScript();\n      // now that we know which columns are being scraped, we may also need to\n      //   update how the relations are displayed\n      window.helenaMainpanel.UIObject.updateDisplayedRelations();\n    }\n  }\n\n  public tryAddingRelation(relation: GenericRelation) {\n    tryAddingRelationHelper(relation, this.bodyStatements, this);\n    // for now we'll add it whether or not it actually get used, but this may\n    //   not be the best way...\n    this.relations.push(relation);\n  }\n\n  public removeRelation(relationObj: GenericRelation) {\n    this.relations = this.relations.filter((rel) => rel !== relationObj);\n\n    // now let's actually remove any loops that were trying to use this relation\n    var newChildStatements = removeLoopsForRelation(this.bodyStatements,\n      relationObj);\n    this.updateChildStatements(newChildStatements);\n    \n    // if the removed relation was using the same cell as another potential\n    //   relation, that one may now be relevant\n    this.insertLoops(false);\n\n    window.helenaMainpanel.UIObject.updateDisplayedScript();\n    window.helenaMainpanel.UIObject.updateDisplayedRelations();\n  };\n\n  // by default, we'll wait up to 15 seconds for the target node to appear\n  //   (see ringer/common/common_params.js)\n  // for static pages, this is silly\n  // user may want to provide a custom timeout\n  // this particular function resets the wait for all events in the program,\n  //   which is easy but not always a good idea\n  public setCustomTargetTimeout(timeoutSeconds: number) {\n    this.traverse((stmt: HelenaLangObject) => {\n      if (stmt.isRingerBased()) {\n        const ringerStmt = <RingerStatement> stmt;\n        for (var i = 0; i < ringerStmt.cleanTrace.length; i++) {\n          ringerStmt.cleanTrace[i].targetTimeout = timeoutSeconds;\n        }\n      }\n    }, () => {});\n  };\n}\n\n// statement traverse because we're not going through expressions, not going\n//   through all nodes, just hitting things in the bodyStatements lists\nfunction firstTrueStatementTraverse(statementLs: HelenaLangObject[],\n    fn: Function): HelenaLangObject | null {\n  for (const stmt of statementLs) {\n    if (fn(stmt)) {\n      return stmt;\n    } else {\n      // ok, this statement didn't do the trick, but maybe the children?\n      if (stmt instanceof StatementContainer) {\n        const ans = firstTrueStatementTraverse(stmt.bodyStatements, fn);\n        if (ans) {\n          return ans;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n\nfunction insertAfterHelper(statements: HelenaLangObject[],\n    stmtToInsert: HelenaLangObject, stmtToInsertAfter: HelenaLangObject) {\n  for (let i = 0; i < statements.length; i++) {\n    const curStmt = statements[i];\n    if (curStmt === stmtToInsertAfter) {\n      // remember, overwrites the original array bc splice\n      statements.splice(i + 1, 0, stmtToInsert);\n      return statements;\n    } else {\n      // ok, haven't found it yet.  mayhaps it belongs in the body statements of\n      //   this very statement?\n      if (curStmt instanceof StatementContainer) {\n        // ok, this one has bodyStatements to check\n        const possibleNewLs = insertAfterHelper(curStmt.bodyStatements,\n          stmtToInsert, stmtToInsertAfter);\n        if (possibleNewLs) {\n          // awesome, we're done\n          curStmt.bodyStatements = possibleNewLs;\n          return statements;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction removeStatementAndFollowing(stmts: HelenaLangObject[],\n    stmt: HelenaLangObject): HelenaLangObject[] | null {\n  for (let i = 0; i < stmts.length; i++) {\n    const curStmt = stmts[i];\n    if (curStmt === stmt) {\n      // remember, overwrites the original array bc splice\n      const removedSeq = stmts.splice(i);\n      return removedSeq;\n    } else {\n      // ok, haven't found it yet.  mayhaps it belongs in the body statements of\n      //   this very statement?\n      if (curStmt instanceof StatementContainer) {\n        // ok, this one has bodyStatements to check\n        const removedSeq = removeStatementAndFollowing(curStmt.bodyStatements,\n          stmt);\n        if (removedSeq) {\n          // awesome, we're done\n          return removedSeq;\n        }\n      }\n    }\n  }\n  return null;\n}\n\nfunction alignCompletedEvents(recordTrace: Trace,\n    replayTrace: Trace) {\n  // we should see corresponding 'completed' events in the traces\n  // todo: should we remove http?\n  // now only doing this for top-level completed events.  will see if this is\n  //   sufficient\n  const recCompleted = recordTrace.filter((ev) =>\n    RingerEvents.isComplete(ev) &&\n    !ev.data.url.includes(HelenaConfig.helenaServerUrl)\n  );\n\n  // have to check for kaofang presence, because otherwise user can screw it up\n  //   by downloading data in the middle or something like that\n  const repCompleted = replayTrace.filter((ev) =>\n    RingerEvents.isComplete(ev) &&\n    !ev.data.url.includes(HelenaConfig.helenaServerUrl)\n  );\n\n  HelenaConsole.log(recCompleted, repCompleted);\n  // should have same number of top-level load events.  if not, might be trouble\n  if (recCompleted.length !== repCompleted.length) {\n    HelenaConsole.log(\"Different numbers of completed events in record \" +\n      \"and replay: \", recCompleted, repCompleted);\n  }\n  // todo: for now aligning solely based on point at which the events appear in\n  //   the trace.  if we get traces with many events, may need to do something\n  //   more intelligent\n  let smallerLength = recCompleted.length;\n  if (repCompleted.length < smallerLength) {\n    smallerLength = repCompleted.length;\n  }\n  return [\n    recCompleted.slice(0, smallerLength),\n    repCompleted.slice(0, smallerLength)\n  ];\n}\n\nfunction updatePageVars(recordTrace: Trace,\n    replayTrace: Trace, continuation: Function) {\n  // console.log(`recordTrace: ${JSON.stringify(recordTrace)}`);\n  // console.log(`replayTrace: ${JSON.stringify(replayTrace)}`);\n  // HelenaConsole.log(\"updatePageVars\", recordTimeTrace, replayTimeTrace);\n  const alignedTraces = alignCompletedEvents(recordTrace, replayTrace);\n  const alignedRecord = alignedTraces[0];\n  const alignedReplay = alignedTraces[1];\n  // console.log(`alignedRecord: ${JSON.stringify(alignedRecord)}`);\n  // console.log(`alignedRecord: ${JSON.stringify(alignedRecord)}`);\n  // HelenaConsole.log(\"recEvents:\", recEvents, \"repEvents\", repEvents);\n  updatePageVarsHelper(alignedRecord, alignedReplay, 0, continuation);\n}\n\nfunction updatePageVarsHelper(recordTrace: Trace,\n    replayTrace: Trace, index: number, continuation: Function) {\n  if (index >= recordTrace.length) {\n    continuation();\n  } else {\n    const pageVar = Traces.getLoadOutputPageVar(\n      <DisplayTraceEvent> recordTrace[index]);\n    if (pageVar === undefined) {\n      updatePageVarsHelper(recordTrace, replayTrace, index + 1, continuation);\n      return;\n    }\n    console.log(`PageVar tabID set with ${JSON.stringify(replayTrace[index])}`);\n    // HelenaConsole.log(\"Setting pagevar current tab id to:\", repEvents[i].data.tabId);\n    pageVar.setCurrentTabId(replayTrace[index].data.tabId, () =>\n      updatePageVarsHelper(recordTrace, replayTrace, index + 1, continuation)\n    );\n  }\n}\n\nfunction tabMappingFromTraces(recordTrace: Trace,\n    replayTrace: Trace) {\n  const alignedTraces = alignCompletedEvents(recordTrace, replayTrace);\n  const alignedRecord = alignedTraces[0];\n  const alignedReplay = alignedTraces[1];\n  const tabIdMapping: {\n    [key: number]: number\n  } = {};\n  for (let i = 0; i < alignedRecord.length; i++) {\n    const recTabId = alignedRecord[i].data.tabId;\n    const repTabId = alignedReplay[i].data.tabId;\n    tabIdMapping[recTabId] = repTabId;\n  }\n  return tabIdMapping;\n}\n\n\nfunction ringerBasedAndNotIgnorable(stmt: HelenaLangObject) {\n  return (\n    // ringer based and not a scrape statement, so we have to replay for sure\n    (stmt.isRingerBased() && !(stmt instanceof ScrapeStatement)) ||\n    \n    // a scrape statement and it's not scraping a relation, so we have to run it\n    //   to find the node\n    (stmt instanceof ScrapeStatement && !stmt.scrapingRelationItem()));\n}\n\nfunction determineNextBlockStartIndex(bodyStmts: HelenaLangObject[]) {\n  let nextBlockStartIndex = bodyStmts.length;\n  for (let i = 0; i < bodyStmts.length; i++) {\n    // todo: is this the right condition?\n    if (!bodyStmts[i].isRingerBased()) {\n      nextBlockStartIndex = i;\n      break;\n    }\n  }\n\n  if (nextBlockStartIndex === 0) {\n    throw new ReferenceError(\"nextBlockStartIndex should not be 0.\");\n  }\n  return nextBlockStartIndex;\n}\n\nfunction selectBasicBlockStatements(bodyStmts: HelenaLangObject[],\n    nextBlockStartIndex: number) {\n  const basicBlockStatements = [];\n  for (let i = 0; i < nextBlockStartIndex; i++) {\n    basicBlockStatements.push(bodyStmts[i]);\n  }\n\n  return <RingerStatement[]> basicBlockStatements;\n}\n\nfunction makeTraceFromStatements(stmts: RingerStatement[]) {\n  let trace: Trace = [];\n  \n  // label each trace item with the basicBlock statement being used\n  let withinScrapeSection = false;\n  for (let i = 0; i < stmts.length; i++) {\n    const curStmt = stmts[i];\n    var cleanTrace = curStmt.cleanTrace;\n\n    // first let's figure out whether we're even doing anything with this\n    //   statement\n    if (curStmt.contributesTrace === TraceContributions.NONE) {\n      continue; // don't need this one.  just skip\n    } else if (curStmt.contributesTrace === TraceContributions.FOCUS) {\n      // let's just change the cleanTrace so that it only grabs the focus events\n      console.warn(\"We're including a focus event, which might cause \" +\n        \"problems. If you see weird behavior, check this first.\");\n      cleanTrace = cleanTrace.filter((ev) => ev.data.type === \"focus\");\n    } else if (curStmt instanceof ScrapeStatement) {\n      // remember, scrape statements shouldn't change stuff!  so it should be\n      //   safe to throw away events\n      // we just need to be sure to have one event that actually finds the node\n      //   and grabs its contets\n      const nodeUsingEvent = Traces.firstScrapedContentEventInTrace(cleanTrace);\n      if (nodeUsingEvent) {\n        cleanTrace = [ nodeUsingEvent ];\n      }\n    }\n\n    for (const ev of cleanTrace) {\n      Traces.setTemporaryStatementIdentifier(ev, i);\n    }\n\n    // ok, now let's deal with speeding up the trace based on knowing that\n    //   scraping shouldn't change stuff, so we don't need to wait after it\n    if (withinScrapeSection) {\n      // don't need to wait after scraping.  scraping doesn't change stuff.\n      if (cleanTrace.length > 0) {\n        cleanTrace[0].timing.ignoreWait = true;\n      }\n    }\n    if (curStmt instanceof ScrapeStatement) {\n      withinScrapeSection = true;\n      // the first event may need to wait after whatever came before\n      for (let j = 1; j < cleanTrace.length; j++) {\n        cleanTrace[j].timing.ignoreWait = true;\n      }\n    } else {\n      withinScrapeSection = false;\n    }\n\n    // let's see if we can adapt mac-recorded traces to linux if necessary...\n    // todo: clean this up, make it work for different transitions...\n    const osString = window.navigator.platform;\n    if (osString.includes(\"Linux\")) {\n      if (curStmt.hasOutputPageVars()) {\n        for (const ev of cleanTrace) {\n          // hey, digging into the ev data here is gross.  todo: fix that\n          if (ev.data.metaKey) {\n            ev.data.ctrlKeyOnLinux = true;\n          }\n          Traces.setTemporaryStatementIdentifier(ev, i);\n        }\n      }\n    } else if (osString.indexOf(\"Mac\") > -1) {\n      // and same deal with mac -> linux?  not sure this is safe in general.\n      //   but it is convenient for the moment...\n      if (curStmt.hasOutputPageVars()) {\n        for (const ev of cleanTrace) {\n          // hey, digging into the ev data here is gross.  todo: fix that\n          if (ev.data.ctrlKey) {\n            ev.data.metaKeyOnMac = true;\n          }\n          Traces.setTemporaryStatementIdentifier(ev, i);\n        }\n      }\n    }\n\n    trace = trace.concat(cleanTrace);\n  }\n  return trace;\n}\n\nfunction shortPrintString(obj: object) {\n  if (!obj) {\n    return JSON.stringify(obj);\n  }\n  else{\n    return JSON.stringify(obj).substring(0,20);\n  }\n}\n\nfunction runInternals(program: HelenaProgram, parameters: Parameters,\n    dataset: Dataset, options: RunOptions, continuation?: Function) {\n  // first let's make the runObject that we'll use for all the rest\n  // for now the below is commented out to save memory, since only running one\n  //   per instance\n\n  // must clone so that run-specific state can be saved with relations and so\n  //   on\n  //var programCopy = Clone.cloneProgram(program);\n\n  const runObject: RunObject = {\n    program: program,\n    dataset: dataset,\n    environment: Environment.envRoot(),\n    tab: \"\"\n  };\n\n  // the mainpanel tab in which we'll preview stuff\n  runObject.tab = window.helenaMainpanel.UIObject.newRunTab(runObject);\n  window.helenaMainpanel.currentRunObjects.push(runObject);\n\n  // let's figure out params first.  parameters may be passed in (e.g., from\n  //   command line or from tool running on top of Helena language)\n  //   but we also have some default vals associated with the program object\n  //   itself.\n  // we want to start with the default vals associated with the program, but\n  //   then we're willing to overwrite them with the user-supplied vals\n  // so first assign default values, then assign from passed-in parameters arg\n  for (const key in program.defaultParamVals) {\n    if (!(key in parameters)) {\n      runObject.environment.envBind(key, program.defaultParamVals[key]);\n    }\n  }\n\n  // let's add the intput parameters to our environment.  todo: in future,\n  //   should probably make sure we only use params that are associated with\n  //   prog (store param names with prog...)\n  for (const key in parameters) {\n    runObject.environment.envBind(key, parameters[key]);\n  }\n\n  runObject.program.clearRunningState();\n  runObject.program.prepareToRun();\n\n  const usesTheWeb = runObject.program.loadsUrl();\n  HelenaConsole.log(\"usesTheWeb\", usesTheWeb);\n\n  const runProgFunc = (windowId?: number) => {\n    // now let's actually run\n    if (windowId) {\n      window.helenaMainpanel.recordingWindowIds.push(windowId);\n      runObject.window = windowId;\n      window.helenaMainpanel.currentReplayWindowId = windowId;\n    }\n    window.datasetsScraped.push(runObject.dataset.getId());\n    runObject.program.runBasicBlock(runObject,\n      runObject.program.bodyStatements, () => {\n\n      // ok, we're done.  unless!  are we in parallel mode?  if we're in\n      //   parallel mode, let's go back and help any workers that are\n      //   stragglers\n\n      // before we start running, let's check if we need to update the\n      //   continuation in order to make it loop on this script forever\n      // (if it's one of those programs where we're supposed to go back and\n      //   run again as soon as we finish)\n      // or if we need to loop again to descend into locked skip blocks\n      if (options.parallel) {\n        // ok, we're ready to do our descent into parallelizing at lower skip\n        //   blocks\n        // todo: this should really grab all the skip blocks at a given level\n        // this code will work as long as all skip blocks are nested one\n        //   inside one, as when our pbd system writes them\n        const normalModeSkipBlock = (stmt: HelenaLangObject) => {\n          return stmt instanceof SkipBlock &&\n                 stmt.descendIntoLocks === false;\n        }\n\n        const nextSkipBlockToSwitch = <SkipBlock> firstTrueStatementTraverse(\n          program.bodyStatements, normalModeSkipBlock);\n        if (nextSkipBlockToSwitch) {\n          nextSkipBlockToSwitch.descendIntoLocks = true;\n        }\n        const nextSkipBlockToSwitchHasParallelizableSubcomponents =\n          firstTrueStatementTraverse(program.bodyStatements,\n            normalModeSkipBlock);\n\n        if (nextSkipBlockToSwitch &&\n          nextSkipBlockToSwitchHasParallelizableSubcomponents) {\n          // we only want to do another run if there are actually\n          //   parallelizable subcomponents of the thing we just switched\n          // otherwise it's useless to send more workers after the skip blocks\n          //   that have already been locked by other workers\n          // but here we have both, so let's actually run again\n          // todo: do we need to do anything to clean up here?\n          //   is program state ok?\n          runInternals(program, parameters, dataset, options, continuation);\n          // now return so we don't do the normal whatToDoWhenWereDone stuff\n          //   that we'll do when we've really finished\n          return;\n        } else {\n          // ok, we wanted to find a next skip block, but we ran out. let's set\n          //   them all back to false\n          program.turnOffDescentIntoLockedSkipBlocks();\n          // next we'll fall through out of this if statement and do the normal\n          //   processing for being done, actually close the dataset and all\n        }\n      }\n\n      const whatToDoWhenWereDone = () => {\n        window.scrapingRunsCompleted += 1;\n        console.log(\"scrapingRunsCompleted\", window.scrapingRunsCompleted);\n        window.helenaMainpanel.currentRunObjects = window.helenaMainpanel.currentRunObjects.filter(\n          (runObj) => runObj !== runObject\n        );\n        HelenaConsole.log(\"Done with script execution.\");\n        const timeScraped = (new Date()).getTime() -\n          parseInt(dataset.pass_start_time.toString());\n        console.log(runObject.dataset.getId(), timeScraped);\n\n        if (windowId) {\n          // take that window back out of the allowable recording set\n          window.helenaMainpanel.recordingWindowIds = window.helenaMainpanel.recordingWindowIds.filter(\n            (window) => window !== windowId);\n        }\n        // go ahead and actually close the window so we don't have chrome memory\n        //   leaking all over the place.\n        // todo: put this back in!\n        //chrome.windows.remove(windowId);\n\n        // if there was a continuation provided for when we're done, do it\n        if (continuation) {\n          continuation(runObject.dataset, timeScraped, runObject.tab);\n        }\n      }\n\n      runObject.dataset.closeDatasetWithCont(whatToDoWhenWereDone);\n\n    }, options);\n  };\n\n  // now actually call the function for running the program\n  // ok let's do this in a fresh window\n  if (usesTheWeb) {\n    if (runObject.program.windowWidth) {\n      const width = runObject.program.windowWidth;\n      const height = runObject.program.windowHeight;\n      MiscUtilities.makeNewRecordReplayWindow(runProgFunc, undefined,\n        width, height);\n    } else {\n      MiscUtilities.makeNewRecordReplayWindow(runProgFunc);\n    }\n  } else {\n    // no need to make a new window (there are no load statements in the\n    //   program), so don't\n    runProgFunc();\n  }\n}\n\nfunction adjustDatasetNameForOptions(dataset: Dataset, options: RunOptions) {\n  if (options.ignoreEntityScope) {\n    dataset.appendToName(\"_ignoreEntityScope\");\n  }\n  if (options.nameAddition) {\n    // just for scripts that want more control of how it's saved\n    dataset.appendToName(options.nameAddition);\n  }\n}\n\nfunction paramName(stmtIndex: number, paramType: string) {\n  // assumes we can't have more than one of a single paramtype from a single\n  //   statement.  should be true\n  return `s${stmtIndex}_${paramType}`;\n}\n\n\n/**\n * Parameterize by value. TODO: what does that mean?\n * @param trace \n * @param stmts \n */\nfunction pbv(trace: Trace, stmts: RingerStatement[]) {\n  const pTrace = new ParameterizedTrace(trace);\n\n  for (let i = 0; i < stmts.length; i++) {\n    const stmt = stmts[i];\n    const pbvs = stmt.pbvs();\n    HelenaConsole.log(\"pbvs\", pbvs);\n    for (const curPbv of pbvs) {\n      var pname = paramName(i, curPbv.type);\n      if (curPbv.type === \"url\") {\n        pTrace.parameterizeUrl(pname, curPbv.value);\n      } else if (curPbv.type === \"node\") {\n        pTrace.parameterizeXpath(pname, curPbv.value);\n      } else if (curPbv.type === \"typedString\") {\n        pTrace.parameterizeTypedString(pname, curPbv.value);\n      } else if (curPbv.type === \"tab\") {\n        pTrace.parameterizeTab(pname, curPbv.value);\n      } else if (curPbv.type === \"frame\") {\n        // pTrace.parameterizeFrame(pname, curPbv.value);\n      } else if (curPbv.type === \"property\") {\n        pTrace.parameterizeProperty(pname, curPbv.value);\n      } else {\n        HelenaConsole.log(\"Tried to do pbv on a type we don't know.\");\n      }\n    }\n  }\n  return pTrace;\n}\n\n\n\nfunction parameterizeWrapperNodes(pTrace: ParameterizedTrace, origXpath: string,\n    newXpath: string) {\n  // todo: should we do something to exempt xpaths that are already being\n  //   parameterized based on other relation elements?\n  // for now this is irrelevant because we'll come to the same conclusion\n  //   because of using fixed suffixes, but could imagine different approach\n  const origSegs = origXpath.split(\"/\");\n  const newSegs = newXpath.split(\"/\");\n  if (origSegs.length !== newSegs.length) {\n    HelenaConsole.log(\"origSegs and newSegs different length!\", origXpath,\n      newXpath);\n  }\n  \n  // assumption: origSegs and newSegs have same length; we'll see\n  for (let i = 0; i < origSegs.length; i++) {\n    if (origSegs[origSegs.length - 1 - i] === newSegs[newSegs.length - 1 - i]) {\n      // still match\n      // we do need the last segment ot match, but the one that goes all the way\n      //   to the last segment is the one that inspired this\n      // so we don't need to param the last one again, but we do need to param\n      //   the one prior, even if it doesn't match\n      // (the first one that doesn't match should still be parameterized)\n      // a1/b1/c1/a1/a1/a1 -> d1/e1/f1/a2/a1/a1 original already done;\n      // should do a1/b1/c1/a1/a1 -> d1/e1/f1/a2/a1, a1/b1/c1/a1 -> d1/e1/f1/a2\n      const origXpathPrefix = origSegs.slice(0,origSegs.length - 1 - i).join(\"/\");\n      const newXpathPrefix = newSegs.slice(0,newSegs.length - 1 - i).join(\"/\");\n      const pname = `wrappernode_${HelenaProgram.wrapperNodeCounter}`;\n      HelenaProgram.wrapperNodeCounter += 1;\n      pTrace.parameterizeXpath(pname, origXpathPrefix);\n      pTrace.useXpath(pname, newXpathPrefix);\n      HelenaConsole.log(\"Wrapper node correction:\");\n      HelenaConsole.log(origXpathPrefix);\n      HelenaConsole.log(newXpathPrefix);\n    } else {\n      // this one is now diff, so shouldn't do replacement for the one further\n      // (shouldn't do a1/b1/c1 -> d1/e1/f1 from example above)\n      // I mean, maybe we actually should do this, but not currently a reason to\n      //   think it will be useful.  worth considering though\n      break;\n    }\n  }\n}\n\n/**\n * TODO\n * @param pTrace \n * @param stmts \n * @param environment \n */\nfunction passArguments(pTrace: ParameterizedTrace, stmts: RingerStatement[],\n    environment: Environment.Frame) {\n  for (let i = 0; i < stmts.length; i++) {\n    const stmt = stmts[i];\n    const args = stmt.args(environment);\n    for (const curArg of args) {\n      const pname = paramName(i, curArg.type);\n      if (curArg.type === \"url\") {\n        pTrace.useUrl(pname, curArg.value);\n      } else if (curArg.type === \"node\") {\n        pTrace.useXpath(pname, curArg.value);\n        // below is kind of gross and I don't know if this is really where it\n        //   should happen, but we definitely want to parameterize wrapper nodes\n        // todo: maybe find a cleaner, nice place to put this or write this.\n        //   for now this should do the trick\n        const node = <string> (<PageActionStatement> stmt).node;\n        parameterizeWrapperNodes(pTrace, node, curArg.value);\n      } else if (curArg.type === \"typedString\") {\n        pTrace.useTypedString(pname, curArg.value);\n      } else if (curArg.type === \"tab\") {\n        pTrace.useTab(pname, curArg.value);\n      } else if (curArg.type === \"frame\") {\n        // pTrace.useFrame(pname, curArg.value);\n      } else if (curArg.type === \"property\") {\n        pTrace.useProperty(pname, curArg.value);\n      } else {\n        HelenaConsole.log(\"Tried to do pbv on type we don't know. \" +\n          \"(Arg provision.)\");\n      }\n    }\n  }\n\n  return pTrace.getStandardTrace();\n}\n\n/*\nfunction longestCommonPrefix(strings) {\n  if (strings.length < 1) {\n    return \"\";\n  }\n  if (strings.length == 1) {\n    return strings[0];\n  }\n\n  var sorted = strings.slice(0).sort(); // copy\n  var string1 = sorted[0];\n  var string2 = sorted[sorted.length - 1];\n  var i = 0;\n  var l = Math.min(string1.length, string2.length);\n\n  while (i < l && string1[i] === string2[i]) {\n    i++;\n  }\n\n  return string1.slice(0, i);\n}*/\n\n\nfunction isScrapingSet(keyCodes: number[]) {\n  const charsDict = {SHIFT: 16, CTRL: 17, ALT: 18, CMD: 91};\n  keyCodes.sort();\n  const acceptableSets = [\n    [charsDict.ALT], // mac scraping\n    [charsDict.CTRL, charsDict.ALT], // unix scraping\n    [charsDict.ALT, charsDict.SHIFT], // mac link scraping\n    [charsDict.CTRL, charsDict.ALT, charsDict.SHIFT] // unix link scraping\n  ];\n  for (const acceptableSet of acceptableSets) {\n    acceptableSet.sort();\n    if (_.isEqual(keyCodes, acceptableSet)) {\n      return true;\n    }\n  }\n  // nope, none of them are the right set\n  return false;\n}\n\nfunction sameNodeIsNextUsed(stmt: PageActionStatement,\n    stmts: PageActionStatement[]) {\n  HelenaConsole.log(\"sameNodeIsNextUsed\", stmt, stmts);\n\n  if (!stmt.origNode) { // there's no node associated with the first arg\n    console.log(\"Warning!  No node associated with the statement, which may \" +\n      \"mean there was an earlier statement that we should have called on.\");\n    return false;\n  }\n  \n  for (const curStmt of stmts) {\n    if (curStmt.origNode === stmt.origNode) {\n      return true;\n    }\n    if (curStmt instanceof ClickStatement) { // || statements[i] instanceof ScrapeStatement) {\n      // ok, we found another statement that focuses a node, but it's a\n      //   different node\n      // todo: is this the right condition?  certainly TypeStatements don't\n      //   always have the same origNode as the focus event that came\n      //   immediately before\n      return false;\n    }\n  }\n  // we've run out\n  return false;\n}\n\nfunction doWeHaveRealRelationNodesWhereNecessary(stmts: HelenaLangObject[],\n    environment: Environment.Frame) {\n  for (const stmt of stmts) {\n    if (stmt.hasOutputPageVars()) {\n      // ok, this is an interaction where we should be opening a new page based on the statement\n      if ((stmt instanceof ClickStatement ||\n          stmt instanceof ScrapeStatement ||\n          stmt instanceof TypeStatement) && stmt.columnObj) {\n        // if the statement is parameterized with the column object of a given\n        //   relation, this will be non-null\n        // also, it means the statement's currentNode will be a NodeVariable,\n        //   so we can call currentXPath\n        // also it means we'll already have assigned to the node variable, so\n        //   currentXPath should actually have a value\n        var currentXpath = stmt.currentNode.currentXPath(environment);\n        if (currentXpath) {\n          continue;\n        }\n\n        // we've found a statement for which we'll want to use a node to produce\n        //   a new page, but we won't have one\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction markNonTraceContributingStatements(stmts: HelenaLangObject[]):\n    RingerStatement[] {\n  // if we ever get a sequence within the statements that's a keydown statement,\n  //   then only scraping statements, then a keyup, assume we can toss the keyup\n  //   and keydown ones\n\n  HelenaConsole.log(\"markNonTraceContributingStatements\", stmts);\n\n  // ok first some special handling for cases where the only statements in the\n  //   block aren't ringer-y at all\n  // it's possible that this will sometimes screw things up.  if you ever get\n  //   annoying weird behavior, \n  // where the page stops reacting correctly, this might be a place to look\n  // but it's just so annoying when the scripts are slow on things that don't\n  //   need to be slow.  so we're gonna do it anyway\n\n  let allNonRinger = true;\n  for (const stmt of stmts) {\n    // console.log(\"ringerBasedButNotScraping\",\n    //   ringerBasedButNotScraping(statements[i]), statements[i]);\n    if (ringerBasedAndNotIgnorable(stmt) && !stmt.nullBlockly) {\n      allNonRinger = false;\n      break;\n    }\n  }\n\n  if (allNonRinger) {\n    //console.log(\"Cool, found a situation where we can ignore all statements\",\n    //  statements);\n    for (const stmt of stmts) {\n      const ringerStmt = <RingerStatement> stmt;\n      ringerStmt.contributesTrace = TraceContributions.NONE;\n    }\n    return <RingerStatement[]> stmts;\n  }\n\n  let keyIndexes: number[] = [];\n  let keysdown: number[] = [];\n  let keysup: number[] = [];\n  const sets: number[][] = [];\n  for (let i = 0; i < stmts.length; i++) {\n    const stmt = stmts[i];\n    if (stmt instanceof TypeStatement && stmt.onlyKeydowns) {\n      // we're seeing typing, but only keydowns, so it might be the start of entering scraping mode\n      keyIndexes.push(i);\n      keysdown = keysdown.concat(stmt.keyCodes);\n    } else if (keyIndexes.length > 0 && stmt instanceof ScrapeStatement &&\n        stmt.scrapingRelationItem()) {\n      // cool, we think we're in scraping mode, and we're scraping a relation-scraped thing, so no need to\n      // actually execute these events with Ringer\n      stmt.contributesTrace = TraceContributions.FOCUS;\n      continue;\n    } else if (keyIndexes.length > 0 && stmt instanceof TypeStatement &&\n        stmt.onlyKeyups) {\n      // ok, looks like we might be about to pop out of scraping mode\n      keyIndexes.push(i);\n      keysup = keysup.concat(stmt.keyCodes);\n\n      // ok, do the keysdown and keysup arrays have the same elements (possibly\n      //   including repeats), just reordered?\n      // todo: is this a strong enough condition?\n      keysdown.sort();\n      keysup.sort();\n\n      // below: are we letting up all the same keys we put down before? and are\n      //   the keys from a set we might use for entering scraping mode?\n      if (_.isEqual(keysdown, keysup) && isScrapingSet(keysdown)) {\n        HelenaConsole.log(\"decided to remove set\", keyIndexes, keysdown);\n        sets.push(keyIndexes);\n        keyIndexes = [];\n        keysdown = [];\n        keysup = [];\n      }\n    } else if (keyIndexes.length > 0 && !(stmt instanceof ScrapeStatement &&\n        stmt.scrapingRelationItem())) {\n      // well drat.  we started doing something that's not scraping a relation\n      //   item\n      // maybe clicked, or did another interaction, maybe just scraping\n      //   something where we'll rely on ringer's node finding abilities\n      //   but in either case, we need to actually run Ringer\n      keyIndexes = [];\n      keysdown = [];\n      keysup = [];\n    }\n  }\n  // ok, for now we're only going to get rid of the keydown and keyup statements\n  // they're in sets because may ultimately want to try manipulating scraping\n  //   statements in the middle if they don't have dom events (as when relation\n  //   parameterized)\n  // but for now we'll stick with this\n\n  // todo: I'd like to get rid of the above and switch to just checking for a\n  //   given event whether all contained events had additional.scrape set\n  // the only complication is the focus thing mentioned below\n\n  for (const set of sets) {\n    // let's ignore the events associated with all of these statements!\n    for (let j = set[0]; j < set[set.length-1] + 1; j++) {\n      const stmt = <RingerStatement> stmts[j];\n      stmt.contributesTrace = TraceContributions.NONE;\n    }\n    // ok, one exception.  sometimes the last relation scraping statement\n    //   interacts with the same node that we'll use immediately after scraping\n    //   stops\n    // in these cases, during record, the focus was shifted to the correct node\n    //   during scraping, but the replay won't shift focus unless we replay that\n    //   focus event so we'd better replay that focus event\n    const keyupIndex = set[set.length - 1];\n    if (sameNodeIsNextUsed(<PageActionStatement> stmts[keyupIndex - 1],\n        <PageActionStatement[]> stmts.slice(keyupIndex + 1, stmts.length))) {\n      // is it ok to restrict it to only statements replayed immediately after? \n      //   rather than in a for loop that's coming up or whatever?\n      // it's definitely ok while we're only using our own inserted for loops,\n      //   since those get inserted where we start using a new node\n      const lastStatementBeforeKeyup = <RingerStatement> stmts[keyupIndex - 1];\n      HelenaConsole.log(\"lastStatementBeforeKeyup\",\n        lastStatementBeforeKeyup);\n      lastStatementBeforeKeyup.contributesTrace = TraceContributions.FOCUS;\n      // let's make sure to make the state match the state it should have, based\n      //   on no longer having these keypresses around\n      const cleanTrace = lastStatementBeforeKeyup.cleanTrace;\n      for (const ev of cleanTrace) {\n        // right now hard coded to get rid of ctrl alt every time.  todo: fix\n        if (ev.data.ctrlKey) {\n          ev.data.ctrlKey = false;\n        }\n        if (ev.data.altKey) {\n          ev.data.altKey = false;\n        }\n      }\n    }\n\n    /* an alternative that removes keyup, keydown events instead of the whole statements\n    for (var j = set.length - 1; j >= 0; j--) {\n      //statements.splice(set[j], 1);\n      var statement = statements[set[j]];\n      console.log(\"statement\", statement);\n      var cleanTrace = statement.cleanTrace;\n      for (var l =  cleanTrace.length - 1; l >= 0; l--) {\n        if (cleanTrace[l].data.type === \"keyup\" || cleanTrace[l].data.type === \"keydown\") {\n          cleanTrace.splice(l, 1);\n        }\n      }\n    }\n    */\n    \n  }\n  \n  HelenaConsole.log(\"markNonTraceContributingStatements\", stmts);\n  return <RingerStatement[]> stmts;\n}\n\n\nfunction parameterizeBodyStatementsForRelation(bodyStmts: HelenaLangObject[],\n  relation: GenericRelation) {\n  let relationColumnsUsed: (IColumnSelector | null)[] = [];\n  for (const bodyStmt of bodyStmts) {\n    relationColumnsUsed = relationColumnsUsed.concat(\n      bodyStmt.parameterizeForRelation(relation)\n    );\n  }\n  relationColumnsUsed = _.uniq(relationColumnsUsed);\n  relationColumnsUsed = _.without(relationColumnsUsed, null);\n  return relationColumnsUsed;\n}\n\nfunction loopStatementFromBodyAndRelation(bodyStmts: HelenaLangObject[],\n    relation: GenericRelation, pageVar: PageVariable) {\n  // we want to parameterize the body for the relation\n  const relationColumnsUsed = parameterizeBodyStatementsForRelation(bodyStmts,\n    relation); \n\n  // ok, and any pages to which we travel within a loop's non-loop body nodes\n  //   must be counteracted with back buttons at the end\n  // todo: come back and make sure we only do this for pages that aren't being\n  //   opened in new tabs already, and maybe ultimately for pages that we can't\n  //   convert to open in new tabs\n  const backStatements = [];\n  for (const stmt of bodyStmts) {\n    if (stmt.hasOutputPageVars()) {\n      // we're making that assumption again about just one outputpagevar.\n      //   also that everything is happening in one tab.  must come back and\n      //   revisit this\n      const ringerStmt = <OutputPageVarStatement & PageActionStatement> stmt;\n      const currPage = (<PageVariable[]> ringerStmt.outputPageVars)[0];\n      const backPage = ringerStmt.pageVar;\n      if (backPage && currPage.originalTabId() === backPage.originalTabId()) {\n        // only need to add back button if they're actually in the same tab (may\n        //   be in diff tabs if CTRL+click, or popup, whatever)\n        backStatements.push(new BackStatement(currPage, backPage));\n      } else {\n        // we're going back to messing with an earlier page, so should close the\n        //   current page. insert a statement that will do that\n        backStatements.push(new ClosePageStatement(currPage));\n      }\n    }\n  }\n  backStatements.reverse(); // must do the back button in reverse order\n\n  const cleanupStatementLs = backStatements;\n  // todo: also, this is only one of the places we introduce loops. should do\n  //   this everywhere we introduce or adjust loops.  really need to deal with\n  //   the fact those aren't aligned right now\n\n  const loopStatement = new LoopStatement(relation, relationColumnsUsed,\n    bodyStmts, cleanupStatementLs, pageVar); \n  return loopStatement;\n}\n\n// parent will be either the full program or a loop statement\nfunction tryAddingRelationHelper(relation: GenericRelation,\n    bodyStmts: HelenaLangObject[], parent: StatementContainer): boolean {\n  for (let i = 0; i < bodyStmts.length; i++) {\n    const stmt = bodyStmts[i];\n    if (stmt instanceof LoopStatement) {\n      const used = tryAddingRelationHelper(relation, stmt.bodyStatements, stmt);\n      if (used) {\n        // if we've already found a use for it, we won't try to use it twice.\n        //   so at least for now, as long as we only want one use, we should\n        //   stop checking here, not continue\n        return used;\n      }\n    }\n    \n    if (stmt.usesRelation(relation)) {\n      // ok, let's assume the rest of this loop's body should be nested\n      const bodyStatementLs = bodyStmts.slice(i, bodyStmts.length);\n      if (!(stmt instanceof PageActionStatement) || !stmt.pageVar) {\n        throw new ReferenceError(\"Have an incorrect statement reference\");\n      }\n\n      // statement uses relation, so pick statement's pageVar\n      const loopStatement = loopStatementFromBodyAndRelation(bodyStatementLs,\n        relation, stmt.pageVar);\n      // awesome, we have our new loop statement, which should now be the final\n      //   statement in the parent\n      const newStatements = bodyStmts.slice(0,i);\n      newStatements.push(loopStatement);\n      parent.updateChildStatements(newStatements);\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction removeLoopsForRelation(bodyStmts: HelenaLangObject[],\n    relation: GenericRelation): HelenaLangObject[] {\n  let outputStatements: HelenaLangObject[] = [];\n  for (const stmt of bodyStmts) {\n    if (stmt instanceof LoopStatement) {\n      if (stmt.relation === relation) {\n        // ok, we want to remove this loop; let's pop the body statements back\n        //   out into our outputStatements\n        const bodyStmts = removeLoopsForRelation(stmt.bodyStatements, relation);\n        outputStatements = outputStatements.concat(bodyStmts);\n      } else {\n        // we want to keep this loop, but we'd better descend and check the loop\n        //   body still\n        const newChildStatements = removeLoopsForRelation(stmt.bodyStatements,\n          relation);\n        stmt.updateChildStatements(newChildStatements);\n        outputStatements.push(stmt);\n      }\n    } else {\n      // not a loop statement\n      stmt.unParameterizeForRelation(relation);\n      outputStatements.push(stmt);\n    }\n  }\n  return outputStatements;\n}\n\n/**\n * Filter out load events that load URLs whose associated DOM trees the user\n *   never actually uses.\n * @param trace\n */\nfunction markUnnecessaryLoads(trace: DisplayTraceEvent[]) {\n  const domEvents =  trace.filter((ev) => ev.type === \"dom\");\n  const domEventURLs = [...new Set(domEvents.map((ev) => Traces.getDOMURL(ev)))];\n\n  // ok, now first let's mark all the loads that are top-level and used, so we\n  //   need them for introducing page variables (even if they'll ultimately be\n  //   invisible/not load events/not forced to replay)\n  //_.each(trace, function(ev){if (ev.type === \"completed\" &&\n  //  ev.data.type === \"main_frame\" &&\n  //  domEventURLs.indexOf(EventM.getLoadURL(ev)) > -1){\n  //    EventM.setVisible(ev, true);}});\n  \n  // all right.  now we want to figure out (based on how the new page was\n  //   reached, based on whether we saw a manualload event) which completed\n  //   events are manual and shouldn't be made invisible/associated with prior\n  //   dom event later\n\n  // ok, manual load events are weird, because they sometimes actually happen\n  //   after the completed events, and what we really want is to just go back\n  //   and make sure we run completed events like normal but mark them visible\n  //   if they include the url we want for the manual load so we'll find the\n  //   nearest completed event with the correct url and we'll mark that one\n  const urlsToCompletedEvents: {\n    [key: string]: any\n  } = {};\n  for (let i = 0; i < trace.length; i++){\n    const ev = trace[i];\n    if (RingerEvents.isComplete(ev)) {\n      const url = trimSlashes(Traces.getLoadURL(ev));\n      if (url in urlsToCompletedEvents){\n        urlsToCompletedEvents[url].push([i, ev]);\n      } else {\n        urlsToCompletedEvents[url] = [[i, ev]];\n      }\n    }\n  }\n  for (let i = 0; i < trace.length; i++){\n    const ev = trace[i];\n    if (ev.type === \"manualload\") {\n      // ok, we found that this was actually a manual load one, so we better\n      //   mark an event as visible\n      const url = trimSlashes(ev.data.url);\n      const completedEvs = urlsToCompletedEvents[url];\n      if (!completedEvs || completedEvs.length < 1) {\n        console.log(\"bad bad bad, we couldn't find a completed event for a \" +\n          \"manual load:\", ev);\n        continue;\n      }\n      let minDistance = Number.MAX_SAFE_INTEGER;\n      let preferredCe = null;\n      for (let j = 0; j < completedEvs.length; j++){\n        const ceIndex = completedEvs[j][0];\n        const ce = completedEvs[j][1];\n        const diff = Math.abs(ceIndex - i);\n        if (diff < minDistance){\n          minDistance = diff;\n          preferredCe = ce;\n        }\n      }\n      // go ahead and mark the closest completed event as the one that's\n      //   visible/must be replayed\n      Traces.setVisible(preferredCe, true);\n\n      // go ahead and mark the closest completed event as the one that's\n      //   visible/must be replayed\n      Traces.setManual(preferredCe, true);\n    }\n  }\n  return trace;\n}\n\nfunction trimSlashes(url: string) {\n  return url.replace(/\\/+$/g, ''); // trim slashes from the end\n}\n\nfunction associateNecessaryLoadsWithIDsAndParameterizePages(trace:\n    DisplayTraceEvent[]) {\n  let idCounter = 1; // blockly says not to count from 0\n\n  // ok, unfortunately urls (our keys for frametopagevarid) aren't sufficient to\n  //   distinguish all the different pagevariables, because sometimes pages load\n  //   a new top-level/main_frame page without actually changing the url\n  // so we'll need to actually keep track of the ports as well. any ports that\n  //   appear with the target url before the creation of the next page var with\n  //   the same url, we'll use those for the first page var, and so on\n\n  const urlsToMostRecentPageVar: {\n    [key: string]: PageVariable;\n  } = {};\n\n  const portsToPageVars: {\n    [key: string]: PageVariable;\n  } = {};\n\n  // people do redirects!  to track it, let's track the url that was actually\n  //   loaded into a given tab last\n  const tabToCanonicalUrl: {\n    [key: number]: string;\n  } = {};\n\n  // people do redirects. let's track which tab each url is in. shame we can't\n  //   just get the tab.  whatever\n  const urlToTab: {\n    [key: string]: number;\n  } = {};\n\n  let lastURL = null;\n  for (let i = 0; i < trace.length; i++){\n    const ev = trace[i];\n    const newPageVar = newTopLevelUrlLoadedEvent(ev, lastURL);\n\n    // any time we complete making a new page in the top level, we want to intro\n    //   a new pagevar\n    if (newPageVar) {\n      const url = Traces.getLoadURL(ev);\n      if (url === lastURL) {\n        // sometimes the same URL appears to load twice in a single logical load\n        //   if we see the same url twice in a row, just ignore the second\n        trace[i].mayBeSkippable = true;\n        continue;\n      }\n      const p = new PageVariable(\"page\" + idCounter, url);\n      Traces.setLoadOutputPageVar(ev, p);\n      urlsToMostRecentPageVar[url] = p;\n      idCounter += 1;\n      const tab = Traces.getTabId(ev);\n\n      // this is the complete-time urls, so go ahead and put it in there\n      tabToCanonicalUrl[tab] = url;\n\n      urlToTab[url] = tab;\n      // for now, anything that loads a new page var should be visible. later\n      //   we'll take away any that shouldn't be\n      // but for now it means just that it's top-level and thus needs to be\n      //   taken care of\n      Traces.setVisible(ev, true);\n      lastURL = url;\n    } else if (ev.type === \"webnavigation\") {\n      // fortunately webnavigation events look at redirects, so we can put in that a redirect happend in a given tab\n      // so that we can use the tab to get the canonical/complete-time url, then use that to get the relevant page var\n      const url = Traces.getLoadURL(ev);\n      if (!(url in urlToTab)){\n        urlToTab[url] = Traces.getTabId(ev);\n      }\n    } else if (ev.type === \"dom\") {\n      const port = Traces.getDOMPort(ev);\n      let pageVar = null;\n      if (port in portsToPageVars) {\n        // we already know the port, and that's a great way to do the mapping\n        pageVar = portsToPageVars[port];\n      } else {\n        // ok, have to look it up by url\n        const url = Traces.getDOMURL(ev);\n        let correctUrl = null;\n        if (url in urlsToMostRecentPageVar) {\n          // great, this dom event already uses the canonical complete-time url\n          //   (no redirects)\n          correctUrl = url;\n        } else {\n          // there was a redirect.  but we tracked it via webnavigation events,\n          //   so let's go find it\n          const tabId = urlToTab[url];\n          correctUrl = tabToCanonicalUrl[tabId];\n        }\n        pageVar = urlsToMostRecentPageVar[correctUrl];\n        if (!pageVar){\n          console.warn(\"Woah woah woah, real bad, why did we try to \" +\n            \"associate a dom event with a page var, but we didn't know a page\" +\n            \" var for the dom it happened on????\");\n        }\n        // from now on we'll associate this port with this pagevar, even if\n        //   another pagevar later becomes associated with the url\n        portsToPageVars[port] = pageVar;\n      }\n      Traces.setDOMInputPageVar(ev, pageVar); \n      pageVar.setRecordTimeFrameData(ev.frame);\n    }\n  }\n  return trace;\n}\n\nfunction newTopLevelUrlLoadedEvent(ev: DisplayTraceEvent,\n    lastURL: string | null) {\n  // any time we complete making a new page in the top level, we want to intro\n  //   a new pagevar\n  return RingerEvents.isComplete(ev);\n}\n\n\nfunction addCausalLinks(trace: DisplayTraceEvent[]) {\n  let lastDOMEvent = null;\n  for (const ev of trace) {\n    if (ev.type === \"dom\"){\n      lastDOMEvent = ev;\n      Traces.setDOMOutputLoadEvents(ev, []);\n    } else if (lastDOMEvent !== null && RingerEvents.isComplete(ev) &&\n      Traces.getVisible(ev) && !Traces.getManual(ev)) {\n      // events should be invisible if they're not top-level or if they're\n      //   caused by prior dom events instead of a url-bar load\n      // if they're visible right now but not manual, that means they're caused\n      //   by a dom event, so let's add the causal link and remove their\n      //   visibility\n      Traces.setLoadCausedBy(ev, lastDOMEvent);\n      Traces.addDOMOutputLoadEvent(lastDOMEvent, ev);\n      // now that we have a cause for the load event, we can make it invisible\n      Traces.setVisible(ev, false);\n    }\n  }\n  return trace;\n}\n\nfunction removeEventsBeforeFirstVisibleLoad(trace: DisplayTraceEvent[]) {\n  for (let i = 0; i < trace.length; i++){\n    const ev = trace[i];\n    if (Traces.getVisible(ev)) {\n      // we've found the first visible event\n      return trace.slice(i, trace.length);\n    }\n  }\n  throw new ReferenceError(\"First visible load not found\");\n}\n\nfunction segment(trace: DisplayTraceEvent[]) {\n  const allSegments = [];\n  let currentSegment: DisplayTraceEvent[] = [];\n  // an event that should be shown to the user and thus determines the type of\n  //   the statement\n  let currentSegmentVisibleEvent = null;\n  for (const ev of trace) {\n    if (allowedInSameSegment(currentSegmentVisibleEvent, ev)) {\n      if (Traces.statementType(ev) !== null) {\n        HelenaConsole.log(\"stype(ev)\", ev, Traces.statementType(ev),\n          currentSegmentVisibleEvent);\n      }\n      currentSegment.push(ev);\n\n      // only relevant to first segment\n      if (currentSegmentVisibleEvent === null &&\n          Traces.statementType(ev) !== null) {\n        currentSegmentVisibleEvent = ev;\n      }\n    } else {\n      // the current event isn't allowed in last segment -- maybe it's on a new\n      //   node or a new type of action.  need a new segment\n      HelenaConsole.log(\"making a new segment\", currentSegmentVisibleEvent, ev,\n        currentSegment, currentSegment.length);\n      allSegments.push(currentSegment);\n      currentSegment = [ev];\n\n      // if this were an invisible event, we wouldn't have needed to start a new\n      //   block, so it's always ok to put this in for the current segment's\n      //   visible event\n      currentSegmentVisibleEvent = ev;\n    }\n  }\n  allSegments.push(currentSegment); // put in that last segment\n\n  // for now rather than this func, we'll try an alternative where we just show\n  //   ctrl, alt, shift keypresses in a simpler way\n  // allSegments = postSegmentationInvisibilityDetectionAndMerging(allSegments);\n\n  HelenaConsole.log(\"allSegments\", allSegments, allSegments.length);\n  return allSegments;\n}\n\n /**\n  * Returns true if two trace events should be allowed in the same statement,\n  *   based on visibility, statement type, statement page, statement target.\n  * @param e1 \n  * @param e2 \n  */\n function allowedInSameSegment(e1: DisplayTraceEvent | null,\n    e2: DisplayTraceEvent | null) {\n  // if either of them is null (as when we do not yet have a current visible\n  //   event), anything goes\n  if (e1 === null || e2 === null) {\n    return true;\n  }\n  const e1type = Traces.statementType(e1);\n  const e2type = Traces.statementType(e2);\n  HelenaConsole.log(\"allowedInSameSegment?\", e1type, e2type, e1, e2);\n  // if either is invisible, can be together, because an invisible event allowed\n  //   anywhere\n  if (e1type === null || e2type === null) {\n    return true;\n  }\n  // now we know they're both visible\n  // visible load events aren't allowed to share with any other visible events\n  if (e1type === StatementTypes.LOAD || e2type === StatementTypes.LOAD){\n    return false;\n  }\n  // now we know they're both visible and both dom events\n  // if they're both visible, but have the same type and called on the same node, they're allowed together\n  if (e1type === e2type) {\n    const e1page = Traces.getDOMInputPageVar(e1);\n    const e2page = Traces.getDOMInputPageVar(e2);\n    if (e1page === e2page) {\n      const e1node = e1.target.xpath;\n      const e2node = e2.target.xpath;\n      if (e1node === e2node) {\n        return true;\n      }\n      // we also have a special case where keyup events allowed in text, but\n      //   text not allowed in keyup\n      // this is because text segments that start with keyups get a special\n      //   treatment, since those are the ctrl, alt, shift type cases\n      // if (e1type === StatementTypes.KEYBOARD &&\n      //     e2type === StatementTypes.KEYUP) {\n      //   return true;\n      // }\n    }\n  }\n  return false;\n}\n\nfunction segmentedTraceToProgram(segmentedTrace: DisplayTraceEvent[][],\n    addOutputStatement?: boolean) {\n  const statements = [];\n  for (const seg of segmentedTrace) {\n    let sType = null;\n    for (let i = 0; i < seg.length; i++){\n      const ev = seg[i];\n      const st = Traces.statementType(ev);\n      if (st !== null){\n        sType = st;\n        if (sType === StatementTypes.LOAD){\n          statements.push(new LoadStatement(seg));\n        } else if (sType === StatementTypes.MOUSE) {\n          statements.push(new ClickStatement(seg));\n        } else if (sType === StatementTypes.SCRAPE ||\n                   sType === StatementTypes.SCRAPELINK) {\n          statements.push(new ScrapeStatement(seg));\n        } else if (sType === StatementTypes.KEYBOARD ||\n                   sType === StatementTypes.KEYUP) {\n          statements.push(new TypeStatement(seg));\n        } else if (sType === StatementTypes.PULLDOWNINTERACTION) {\n          statements.push(new PulldownInteractionStatement(seg));\n        }\n        break;\n      }\n    }\n  }\n  return new HelenaProgram(statements, addOutputStatement);\n}\n\n/*\nfunction postSegmentationInvisibilityDetectionAndMerging(segments){\n  // noticed that we see cases of users doing stray keypresses while over non-targets (as when about to scrape, must hold keys), then get confused when there are screenshots of whole page (or other node) in the control panel\n  // so this merging isn't essential or especially foundational, but this detects the cases that are usually just keypresses that won't be parameterized or changed, and it can make the experience less confusing for users if we don't show them\n  var outputSegments = [];\n  for (var i = 0; i < segments.length; i++){\n    var segment = segments[i];\n    var merge = false;\n    if (HelenaMainpanel.statementType(segment[0]) === StatementTypes.KEYBOARD){\n      // ok, it's keyboard events\n      WALconsole.log(segment[0].target);\n      if (segment[0].target.snapshot.value === undefined && segment.length < 20){\n        // yeah, the user probably doesn't want to see this...\n        merge = true;\n      }\n    }\n    var currentOutputLength = outputSegments.length;\n    if (merge && currentOutputLength > 0){\n      outputSegments[currentOutputLength - 1] = outputSegments[currentOutputLength - 1].concat(segments[i]);\n    }\n    else{\n      outputSegments.push(segments[i]);\n    }\n  }\n  return outputSegments;\n}\n\nfunction insertArrayAt(array, index, arrayToInsert) {\n  Array.prototype.splice.apply(array, [index, 0].concat(arrayToInsert));\n}\nfunction addSeq(listOfStatements, statementSeq, blocklyParentStatement, inputName) {\n  for (var i = 0; i < listOfStatements.length; i++) {\n    if (listOfStatements[i] === blocklyParentStatement) {\n      // awesome, found the new parent.  now the questions is: is this the parent because the new statementSeq\n      // comes immediately after it in the listOfStatements?  or because it's the new first\n      // seq in the body statements?  blockly does it both ways\n      // we'll use inputName to find out\n      var s = listOfStatements[i];\n      if (inputName === \"statements\") {\n        // ok.  the new seq is going in the body statements, right at the head\n        insertArrayAt(s.bodyStatements, 0, statementSeq); // in place, so overwriting the original\n      }\n      else{\n        // ok, not going in the body statements\n        // going after this statement in the current listOfStatements\n        insertArrayAt(listOfStatements, i + 1, statementSeq); // in place, again, so overwriting the original\n      }\n      return true;\n    }\n    else{\n      // ok, haven't found it yet.  mayhaps it belongs in the body statements of this very statement?\n      if (listOfStatements[i].bodyStatements) {\n        // ok, this one has bodyStatements to check\n        var res = addSeq(listOfStatements[i].bodyStatements, statementSeq, blocklyParentStatement, inputName);\n        if (res) {\n          // awesome, we're done\n          return res;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction checkEnoughMemoryToCloneTrace(memoryData, trace) {\n  var approximateMemoryPerEvent = 133333; // bytes\n  //if (data.availableCapacity/data.capacity < 0.1) { // this is for testing\n  return (memoryData.availableCapacity) > approximateMemoryPerEvent * trace.length * 2.5;\n}\nfunction splitOnEnoughMemoryToCloneTrace(trace, ifEnoughMemory, ifNotEnoughMemory) {\n  var check = function() {\n    chrome.system.memory.getInfo(function(data) {\n      if (checkEnoughMemoryToCloneTrace(data, trace)) {\n        ifEnoughMemory();\n      }\n      else{\n        ifNotEnoughMemory();\n      }\n    });\n  };\n  try {\n      check();\n  } catch(err) {\n    // just try again until it works\n    setTimeout(function() {splitOnEnoughMemoryToCloneTrace(trace,\n      ifEnoughMemory, ifNotEnoughMemory);}, 1000);\n  }\n}\n*/","import { HelenaConsole } from \"../../../../common/utils/helena_console\";\nimport { HelenaLangObject } from \"../../helena_lang\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { RunObject, RunOptions } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { Messages } from \"../../../../common/messages\";\n\nexport class BackStatement extends HelenaLangObject {\n  public pageVarBack: PageVariable;\n  public pageVarCurr: PageVariable;\n  constructor(pageVarCurr: PageVariable,\n      pageVarBack: PageVariable) {\n    super();\n    Revival.addRevivalLabel(this);\n    // setBlocklyLabel(this, \"back\");\n    \n    this.pageVarCurr = pageVarCurr;\n    this.pageVarBack = pageVarBack;\n  }\n\n  public static createDummy() {\n    return new BackStatement(new PageVariable(\"\", \"\"),\n      new PageVariable(\"\", \"\"));\n  }\n\n  public toStringLines() {\n    // back statements are now invisible cleanup, not normal statements, so\n    //   don't use the line below for now\n    // return [this.pageVarBack.toString() + \" = \" + this.pageVarCurr.toString()\n    //   + \".back()\" ];\n    return [];\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    fn2(this);\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    const self = this;\n    HelenaConsole.log(\"run back statement\");\n    \n    // if something went wrong, we won't have a pagevar tabid, ugh\n    if (!this.pageVarCurr.currentTabId()) {\n        rbbcontinuation(rbboptions);\n        return;\n    }\n\n    const pageVarTabId = this.pageVarCurr.currentTabId();\n    this.pageVarCurr.clearCurrentTabId();\n\n    // ok, the only thing we're doing right now is trying to run this back\n    //   button, so the next time we see a tab ask for an id\n    // it should be because of this -- yes, theoretically there could be a\n    //   process we started earlier that *just* decided to load a new top-level\n    //   page but that should probably be rare.\n    // todo: is that actually rare?\n    Messages.listenForMessageOnce(\"content\", \"mainpanel\",\n      \"requestTabID\", () => {\n        HelenaConsole.log(\"back completed\");\n        if (pageVarTabId) {\n          self.pageVarBack.setCurrentTabId(pageVarTabId,\n            () => rbbcontinuation(rbboptions));\n        }\n    });\n\n    // send a back message to pageVarCurr\n    Messages.sendMessage(\"mainpanel\", \"content\", \"backButton\", {}, undefined,\n      undefined, [ <number> pageVarTabId ]);\n    // todo: is it enough to just send this message and hope all goes well, or\n    //   do we need some kind of acknowledgement?\n    // update pageVarBack to make sure it has the right tab associated\n\n    // todo: if we've been pressing next or more button within this loop, we\n    //   might have to press back button a bunch of times!  or we might not if\n    //   they chose not to make it a new page!  how to resolve????\n  }\n}","import * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\n\nimport { HelenaLangObject } from \"../../helena_lang\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { RunObject, RunOptions } from \"../../program\";\nimport { Revival } from \"../../../revival\";\n\nexport class ClosePageStatement extends HelenaLangObject {\n  public pageVarCurr: PageVariable;\n  constructor(pageVarCurr: PageVariable) {\n    super();\n    Revival.addRevivalLabel(this);\n    // setBlocklyLabel(this, \"close\");\n    this.pageVarCurr = pageVarCurr;\n  }\n\n  public static createDummy() {\n    return new ClosePageStatement(new PageVariable(\"\", \"\"));\n  }\n\n  public toStringLines() {\n    // close statements are now invisible cleanup, not normal statements, so\n    //   don't use the line below for now\n    // return [this.pageVarCurr.toString() + \".close()\" ];\n    return [];\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    const self = this;\n    console.log(\"run close statement\");\n\n    const tabId = this.pageVarCurr.currentTabId();\n    if (tabId !== undefined && tabId !== null) {\n      console.log(\"ClosePageStatement run removing tab\",\n        this.pageVarCurr.currentTabId());\n\n      // we want to remove the tab, but we should never do that if we actually\n      //   mapped the wrong tab and this tab belongs somewhere else\n      // todo: in future, prevent it from mapping the wrong tab in the first\n      //   place!  might involve messing with ringer layer\n      // but also with setCurrentTabId, but mostly I think with the ringer layer\n      const okToRemoveTab = runObject.program.pageVars.every(\n        (pageVar: PageVariable) =>\n          pageVar.currentTabId() !== self.pageVarCurr.currentTabId() ||\n          pageVar === self.pageVarCurr\n      );\n      if (okToRemoveTab) {\n        const tabId = this.pageVarCurr.currentTabId();\n        if (!tabId) {\n          throw new ReferenceError(\"tabId is undefined.\");\n        }\n        chrome.tabs.remove(tabId, () => {\n          self.pageVarCurr.clearCurrentTabId();\n          const portManager = window.ringerMainpanel.ports;\n          portManager.removeTabInfo(tabId);\n          rbbcontinuation(rbboptions);\n        });\n      } else {\n        // it's still ok to clear current tab, but don't close it\n        self.pageVarCurr.clearCurrentTabId();\n        rbbcontinuation(rbboptions);\n      }\n    } else {\n      HelenaConsole.log(\"Warning: trying to close tab for pageVar that \" +\n        \"didn't have a tab associated at the moment.  Can happen after \" +\n        \"continue statement.\");\n      rbbcontinuation(rbboptions);\n    }\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { NodeVariable } from \"../../../variables/node_variable\";\nimport { NodeVariableUse } from \"../../values/node_variable_use\";\n\nimport { HelenaLangObject } from \"../../helena_lang\";\n\nimport { HelenaString } from \"../../values/string\";\nimport { Concatenate } from \"../../values/concatenate\";\n\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { RunObject, HelenaProgram, RunOptions,\n  TraceContributions } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { Trace, Traces, DisplayTraceEvent } from \"../../../../common/utils/trace\";\nimport { Environment } from \"../../../environment\";\nimport { MiscUtilities } from \"../../../../common/misc_utilities\";\nimport { TextRelation } from \"../../../relation/text_relation\";\nimport { Relation } from \"../../../relation/relation\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\nexport class LoadStatement extends HelenaLangObject {\n  public cleanTrace: Trace;\n  public contributesTrace?: TraceContributions;\n  public currentUrl: string | HelenaString | NodeVariable | NodeVariableUse |\n    Concatenate | null;\n  public outputPageVar?: PageVariable;\n  public outputPageVars: (PageVariable | undefined)[];\n  public relation: GenericRelation | null;\n  public trace: Trace;\n  public url: string;\n\n  constructor(trace?: Trace) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"load\");\n\n    // Prematurely end, for the `createDummy` method\n    if (!trace) {\n      return;\n    }\n\n    // find the record-time constants that we'll turn into parameters\n    this.trace = trace;\n\n    const ev = Traces.firstVisibleEvent(trace);\n    this.url = ev.data.url;\n    this.outputPageVar = Traces.getLoadOutputPageVar(<DisplayTraceEvent> ev);\n\n    // this will make it easier to work with for other parts of the code\n    this.outputPageVars = [ this.outputPageVar ];\n\n    // for now, assume the ones we saw at record time are the ones we'll want at\n    //   replay\n    this.currentUrl = new HelenaString(this.url);\n\n    // usually 'completed' events actually don't affect replayer -- won't load a\n    //   new page in a new tab just because we have one.  want to tell replayer\n    //   to actually do a load\n    ev.forceReplay = true;\n\n    this.cleanTrace = Traces.cleanTrace(trace);\n  }\n\n  public static createDummy() {\n    return new LoadStatement();\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    if (this.currentUrl &&\n        (this.currentUrl instanceof HelenaString ||\n         this.currentUrl instanceof NodeVariableUse ||\n         this.currentUrl instanceof Concatenate)) {\n      this.currentUrl.run(runObject, rbbcontinuation, rbboptions);\n    }\n  }\n\n  public cUrl(environment?: Environment.Frame) {\n    if (this.currentUrl instanceof NodeVariable) {\n      // todo: hmmmm, really should have nodevariableuse, not node variable\n      //   here.  test with text relation uploads\n      if (!environment) {\n        throw new ReferenceError(\"No environment provided.\");\n      }\n      return this.currentUrl.currentText(environment);\n    } else if (this.currentUrl instanceof NodeVariableUse) {\n      // todo: hmmmm, really should have nodevariableuse, not node variable\n      //   here.  test with text relation uploads\n      const val = this.currentUrl.getCurrentVal();\n      if (typeof val !== \"string\") {\n        throw new ReferenceError(\"Current URL value is not a string!\");\n      }\n      return val;\n    } else if (this.currentUrl instanceof HelenaString) {\n      return this.currentUrl.getCurrentVal();\n    } else if (this.currentUrl instanceof Concatenate) {\n      this.currentUrl.updateCurrentVal();\n      return this.currentUrl.getCurrentVal();\n    } else {\n      throw new ReferenceError(\"Invalid currentUrl type in load statement.\");\n    }\n  }\n\n  // deprecated\n  private cUrlString() {\n    if (this.currentUrl instanceof NodeVariable) {\n      return this.currentUrl.toString();\n    } else {\n      // else it's a string\n      return this.currentUrl;\n    }\n  }\n\n  private getUrlObj() {\n    if (typeof this.currentUrl === \"string\") {\n      // sometimes it's a string; this is left over from before, when we used to\n      //   store the string internally rather than as a proper block\n      // let's go ahead and correct it now\n      \n      // we'll make a little string node for it\n      this.currentUrl = new HelenaString(this.currentUrl);\n    }\n\n    if (this.currentUrl instanceof NodeVariable) {\n      // hey, we don't want NodeVariable as the item--we want a NodeVariableUse\n      const nodevaruse = new NodeVariableUse(this.currentUrl);\n      this.currentUrl = nodevaruse;\n    }\n    \n    return this.currentUrl;\n  }\n\n  public toStringLines() {\n    var cUrl = this.cUrlString();\n    const pvStr = this.outputPageVar?\n      this.outputPageVar.toString() : \"undefined\";\n    return [ `${pvStr} = load(${cUrl})` ];\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    if (!program || !pageVars) {\n      return;\n    }\n\n    // addToolboxLabel(this.blocklyLabel, \"web\");\n    var pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendDummyInput()\n            .appendField(\"load\")\n        this.appendValueInput(\"url\");\n        this.appendDummyInput()\n            //.appendField(new Blockly.FieldTextInput(\"URL\", handleNewUrl), \"url\")\n            .appendField(\"into\")\n            .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\");\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(280);\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    const urlObject = this.getUrlObj();\n    if (urlObject) {\n      HelenaBlocks.attachToInput(this.block,\n        urlObject.genBlocklyNode(this.block, workspace), \"url\");\n    }\n    const pvStr = this.outputPageVar? this.outputPageVar.toString() : \"undefined\";\n    this.block.setFieldValue(pvStr, \"page\");\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public getHelena() {\n    // ok, but we also want to update our own url object\n    const url = this.block.getInput('url').connection.targetBlock();\n    if (url) {\n      this.currentUrl = <HelenaString | Concatenate | NodeVariableUse>\n        window.helenaMainpanel.getHelenaStatement(url).getHelena();\n    } else {\n      this.currentUrl = null;\n    }\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    if (this.currentUrl &&\n        (this.currentUrl instanceof HelenaString ||\n         this.currentUrl instanceof NodeVariableUse ||\n         this.currentUrl instanceof Concatenate)) {\n      this.currentUrl.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  public pbvs() {\n    const pbvs = [];\n    if (this.url !== this.currentUrl) {\n      pbvs.push({\n        type: \"url\",\n        value: this.url\n      });\n    }\n    return pbvs;\n  };\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    // ok!  loads can now get changed based on relations!\n    // what we want to do is load a different url if we have a relation that\n    //   includes the url\n    const columns = relation.columns;\n    // var firstRowNodeRepresentations = relation.firstRowNodeRepresentations();\n    // again, must have columns and firstRowNodeRepresentations aligned.  should be a better way\n    // for (var i = 0; i < columns.length; i++) {\n    for (const column of columns) {\n      const text = column.firstRowText;\n      if (text === null || text === undefined) {\n        // can't parameterize for a cell that has null text\n        continue;\n      }\n\n      if (MiscUtilities.urlMatch(text, this.cUrl())) {\n        // ok, we want to parameterize\n        this.relation = relation;\n        const name = column.name;\n\n        if (!name) {\n          throw new ReferenceError(\"Column has no name.\");\n        }\n\n        const nodevar = window.helenaMainpanel.getNodeVariableByName(name);\n        if (!nodevar) {\n          throw new ReferenceError(\"NodeVariable is invalid.\");\n        }\n        const nodevaruse = new NodeVariableUse(nodevar);\n        this.currentUrl = nodevaruse; // new NodeVariable(name, firstRowNodeRepresentations[i], null, null, NodeSources.RELATIONEXTRACTOR);\n        return [ column ];\n      }\n    }\n    throw new ReferenceError(\"No matching column found.\");\n  }\n\n  public hasOutputPageVars() {\n    return this.outputPageVars && this.outputPageVars.length > 0;\n  }\n\n  /**\n   * Returns whether this Helena statement is Ringer based.\n   */\n  public isRingerBased() {\n    return true;\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    if (this.relation === relation) {\n      this.relation = null;\n      this.currentUrl = this.url;\n    }\n    return;\n  }\n\n  public usesRelation(rel: GenericRelation) {\n    if (rel instanceof Relation) {\n      return this.usesRelationText(rel.firstRowTexts);\n    } else if (rel instanceof TextRelation) {\n      return this.usesRelationText(rel.relation[0]);\n    }\n    return false;\n  }\n\n  public usesRelationText(parameterizeableStrings: (string | null)[]) {\n    if (!parameterizeableStrings) {\n      return false;\n    }\n\n    for (const curString of parameterizeableStrings) {\n      if (!curString) continue;\n\n      const lowerString = curString.toLowerCase();\n      const currURL = this.cUrl();\n      if (currURL && MiscUtilities.urlMatch(currURL.toLowerCase(),\n          lowerString)) {\n        // for loadstatement\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public args(environment: Environment.Frame) {\n    const args = [];\n    const currentUrl = this.cUrl(environment);\n    args.push({ type:\"url\", value: currentUrl.trim() });\n    return args;\n  }\n\n  public postReplayProcessing(runObject: RunObject, trace: Trace,\n    temporaryStatementIdentifier: number) {\n      return;\n  };\n}","import { HelenaLangObject } from \"../helena_lang\";\n\n/**\n * A Helena language object that contains a body of statements.\n */\nexport class StatementContainer extends HelenaLangObject {\n  public bodyStatements: HelenaLangObject[];\n\n  public removeChild(stmt: HelenaLangObject) {\n    this.bodyStatements = this.bodyStatements?.filter(\n      (bodyStmt) => bodyStmt !== stmt\n    );\n  }\n\n  public removeChildren(stmts: HelenaLangObject[]) {\n    this.bodyStatements = this.bodyStatements?.filter(\n      (bodyStmt) => !stmts.includes(bodyStmt)\n    );\n  }\n  \n  public appendChild(stmt: HelenaLangObject) {\n    this.bodyStatements.push(stmt);\n    this.updateChildStatements(this.bodyStatements);\n  }\n\n  public insertChild(stmt: HelenaLangObject, index: number) {\n    this.bodyStatements.splice(index, 0, stmt);\n    this.updateChildStatements(this.bodyStatements);\n  }\n\n  public updateChildStatements(stmts: HelenaLangObject[]) {\n    this.bodyStatements = stmts;\n    for (const bodyStmt of this.bodyStatements) {\n      bodyStmt.parent = this;\n    }\n  }\n}","import * as Blockly from \"blockly\";\nimport * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\n\nimport { HelenaLangObject } from \"../../helena_lang\";\n\nimport { SkipBlock, AnnotationItem } from \"./skip_block\";\n\nimport { ScrapeStatement } from \"../page_action/scrape\";\n\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { Relation } from \"../../../relation/relation\";\nimport { TextRelation } from \"../../../relation/text_relation\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { StatementContainer } from \"../container\";\nimport { HelenaProgram } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { Environment } from \"../../../environment\";\nimport { HelenaBlockUIEvent } from \"../page_action/page_action\";\nimport { IColumnSelector } from \"../../../../content/selector/interfaces\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\n/**\n * Loop statements not executed by run method, although may ultimately want to refactor to that\n */\nexport class LoopStatement extends StatementContainer {\n  public static maxRowsFieldName = \"maxRows\";\n\n  public cleanupStatements: HelenaLangObject[];\n  public maxRows: number | null;\n  public pageVar: PageVariable;\n  public relation: GenericRelation;\n  public relationColumnsUsed: (IColumnSelector | null)[];\n  public rowsSoFar: number;\n\n  constructor(relation: GenericRelation,\n      relationColumnsUsed: (IColumnSelector | null)[],\n      bodyStatements: HelenaLangObject[],\n      cleanupStatements: HelenaLangObject[],\n      pageVar: PageVariable) {\n    super();\n\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"loop\");\n\n    this.relation = relation;\n    this.relationColumnsUsed = relationColumnsUsed;\n    this.updateChildStatements(bodyStatements);\n    this.pageVar = pageVar;\n\n    // note: for now, can only be set through js console.\n    //   todo: eventually should have ui interaction for this.\n    this.maxRows = null;\n    this.rowsSoFar = 0;\n    this.cleanupStatements = cleanupStatements;\n  }\n\n  public static createDummy() {\n    return new LoopStatement(new GenericRelation(), [], [], [],\n      new PageVariable(\"\", \"\"));\n  }\n\n  public getChildren() {\n    return this.bodyStatements;\n  }\n\n  public getLoopIterationCounters(acc: number[] = []): number[] {\n    acc.unshift(this.rowsSoFar);\n\n    if (this.parent === null || this.parent === undefined) {\n      return acc;\n    } else {\n      return this.parent.getLoopIterationCounters(acc);\n    }\n  }\n\n  public clearRunningState() {\n    this.rowsSoFar = 0;\n    return;\n  }\n\n  public toStringLines() {\n    let varNames = this.relation.scrapedColumnNames();\n    const addlVarNames = this.relation.columnName(this.relationColumnsUsed);\n    varNames = [...new Set(varNames.concat(addlVarNames))];\n\n    HelenaConsole.log(\"loopstatement\", varNames, addlVarNames);\n    let prefix = \"\";\n    if (this.relation instanceof TextRelation) {\n      prefix = `for (${varNames.join(\", \")} in ${this.relation.name}) {`; \n    } else {\n      prefix = `for (${varNames.join(\", \")} in \" +\n        \"${this.pageVar.toString()}.${this.relation.name}) {`; \n    }\n\n    let statementStrings = this.bodyStatements\n      .reduce((acc: string[], stmt) =>\n        acc.concat(stmt.toStringLines()), [])\n      .map((line) => (`&nbsp;&nbsp;&nbsp;&nbsp; ${line}`));\n    return [prefix].concat(statementStrings).concat([\"}\"]);\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    // uses the program obj, so only makes sense if we have one\n    if (!program) return;\n\n    if (!relations || relations.length < 1) {\n      HelenaConsole.log(\"no relations yet so can't have loops in blockly.\");\n      return;\n    }\n\n    const handleMaxRowsChange = function(newMaxRows: number) {\n      if (this.sourceBlock_ && window.helenaMainpanel.getHelenaStatement(this.sourceBlock_)) {\n        const stmt = <LoopStatement> window.helenaMainpanel.getHelenaStatement(this.sourceBlock_);\n        stmt.maxRows = newMaxRows;\n        // if you changed the maxRows and it's actually defined, should make\n        //   sure the max rows actually used...\n        if (newMaxRows !== null && newMaxRows !== undefined) {\n          this.sourceBlock_.setFieldValue('TRUE', 'limitedRowsCheckbox');\n          // dontUseInfiniteRows();\n        }\n      }\n    };\n  \n    const useInfiniteRows = function(val: string) {\n      if (val === 'FALSE') { return 'FALSE'; }\n\n      const block = this.sourceBlock_;\n      setTimeout(() => {\n        // block.setFieldValue(\"TRUE\", \"infiniteRowsCheckbox\");\n        block.setFieldValue(\"FALSE\", \"limitedRowsCheckbox\");\n      }, 0);\n      const stmt = <LoopStatement> window.helenaMainpanel.getHelenaStatement(block);\n      if (stmt) {\n        stmt.maxRows = null;\n      }\n      return 'TRUE';\n    };\n\n    const dontUseInfiniteRows = function(val: string) {\n      if (val === 'FALSE') { return val; }\n  \n      const block = this.sourceBlock_;\n      setTimeout(() => {\n        block.setFieldValue(\"FALSE\", \"infiniteRowsCheckbox\");\n        // block.setFieldValue(\"TRUE\", \"limitedRowsCheckbox\");\n      }, 0);\n      const stmt = <LoopStatement> window.helenaMainpanel.getHelenaStatement(block);\n      if (stmt) {\n        stmt.maxRows =\n          this.sourceBlock_.getFieldValue(LoopStatement.maxRowsFieldName);\n      }\n      return 'TRUE';\n    }\n\n    const handleNewRelationName = function() {\n      const block = this.sourceBlock_;\n      // getWAL(block).maxRows = this.sourceBlock_.getFieldValue(maxRowsFieldName);\n      const newName = this.sourceBlock_.getFieldValue(\"relationName\");\n      const loopStmt = <LoopStatement> window.helenaMainpanel.getHelenaStatement(block);\n      if (loopStmt) {\n        setTimeout(() => {\n          const relObj = loopStmt.relation;\n          if (relObj) {\n            relObj.name = newName;\n          }\n          //UIObject.updateDisplayedScript();\n\n          // update without updating how blockly appears\n          window.helenaMainpanel.UIObject.updateDisplayedScript(false);\n          window.helenaMainpanel.UIObject.updateDisplayedRelations();\n        }, 0);\n      }\n    }\n\n    // addToolboxLabel(this.blocklyLabel);\n\n    if (!pageVars) {\n      throw new ReferenceError(\"Page vars not set!\");\n    }\n  \n    const pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n    let startName = \"relation_name\";\n    if (this.relation && this.relation.name) {\n      startName = this.relation.name;\n    }\n  \n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        const soFar = this.appendDummyInput()\n            .appendField(\"for each row in\")\n            .appendField(new Blockly.FieldTextInput(startName,\n              handleNewRelationName), \"relationName\")      \n            .appendField(\"in\")\n            .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\");  \n             \n        if (!window.helenaMainpanel.demoMode) {\n          // TODO: cjbaik: 04/04/20 - the useInfiniteRows and dontUseInfiniteRows\n          //   are very strange as validators. They don't actually validate and\n          //   also keep resetting maxRows to invalid values... so why is it\n          //   even here? It also conflicts with the \"setFieldValue\" in `genBlocklyNode`\n          //   below.\n          soFar.appendField(\"(\")\n          .appendField(new Blockly.FieldCheckbox(\"TRUE\", useInfiniteRows),\n            'infiniteRowsCheckbox')\n          .appendField(\"for all rows,\")\n          .appendField(new Blockly.FieldCheckbox(\"TRUE\", dontUseInfiniteRows),\n            'limitedRowsCheckbox')\n          .appendField(\"for the first\")\n          .appendField(new Blockly.FieldNumber(20, 0, undefined, undefined,\n            handleMaxRowsChange), LoopStatement.maxRowsFieldName)      \n          .appendField(\"rows)\");\n        }\n        \n        // important for our processing that we always call this statements\n        this.appendStatementInput(\"statements\")\n            .setCheck(null)\n            .appendField(\"do\");\n        this.setPreviousStatement(true,  null);\n        this.setNextStatement(true, null);\n        this.setColour(44);\n        this.setTooltip('');\n        this.setHelpUrl('');\n      },\n      onchange: function(ev: Blockly.Events.Abstract) {\n        if (ev instanceof Blockly.Events.Ui) {\n          const uiEv = <HelenaBlockUIEvent> ev;\n          \n          // unselected\n          if (uiEv.element === \"selected\" && uiEv.oldValue === this.id) {\n            // remember that if this block was selected, relation names may have\n            //   changed.  so we should re-display everything\n            window.helenaMainpanel.UIObject.updateDisplayedScript(true);\n          }\n        }\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    this.block.setFieldValue(this.relation.name, \"relationName\");\n    if (this.pageVar) {\n      this.block.setFieldValue(this.pageVar.toString(), \"page\");\n    }\n    \n    if (!window.helenaMainpanel.demoMode) {\n      if (this.maxRows) {\n        this.block.setFieldValue(this.maxRows.toString(),\n          LoopStatement.maxRowsFieldName);\n        this.block.setFieldValue(\"TRUE\", \"limitedRowsCheckbox\");\n      } else {\n        // we're using infinite rows\n        this.block.setFieldValue(\"TRUE\", \"infiniteRowsCheckbox\");\n      }\n    }\n    \n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n\n    // handle the body statements\n    const firstNestedBlock = HelenaBlocks.helenaSeqToBlocklySeq(\n      this.bodyStatements, workspace);\n    HelenaBlocks.attachNestedBlocksToWrapper(this.block, firstNestedBlock);\n\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public getHelena() {\n    // all well and good to have the things attached after this block, but also\n    //   need the bodyStatements updated\n    const firstNestedBlock = this.block.getInput('statements').connection\n      .targetBlock();\n    const nested = window.helenaMainpanel.blocklySeqToHelenaSeq(firstNestedBlock);\n    this.bodyStatements = nested;\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    for (const bodyStmt of this.bodyStatements) {\n      bodyStmt.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  private insertAnnotation(annotationItems: AnnotationItem[],\n    availableAnnotationItems: AnnotationItem[], index: number,\n    currProg: HelenaProgram) {\n    const loopBodyStatements = this.bodyStatements;\n    const bodyStatements = loopBodyStatements.slice(index,\n      loopBodyStatements.length);\n    const annotation = new SkipBlock(annotationItems,\n      availableAnnotationItems, bodyStatements);\n    \n    // now that they're the entityScope's children, shouldn't be loop's\n    //   children anymore\n    this.removeChildren(bodyStatements);\n    this.appendChild(annotation);\n    adjustAnnotationParents(currProg);\n    window.helenaMainpanel.UIObject.updateDisplayedScript();\n  }\n\n  public addAnnotation(annotationItems: AnnotationItem[],\n    availableAnnotationItems: AnnotationItem[], currProg: HelenaProgram) {\n    console.log(\"annotationItems\", annotationItems);\n    \n    // if have both text and link, may appear multiple times\n    let notYetDefinedNodeVars = \n      [...new Set(annotationItems.slice().map((obj) => obj.nodeVar))];\n    const definedNodeVars = this.relationNodeVariables();\n    notYetDefinedNodeVars = notYetDefinedNodeVars.filter(\n      (item) => !definedNodeVars.includes(item));\n    if (notYetDefinedNodeVars.length <= 0) {\n      this.insertAnnotation(annotationItems, availableAnnotationItems, 0,\n        currProg);\n      return;\n    }\n\n    for (let i = 0; i < this.bodyStatements.length; i++) {\n      const bodyStmt = this.bodyStatements[i];\n      if (bodyStmt instanceof ScrapeStatement) {\n        notYetDefinedNodeVars = notYetDefinedNodeVars.filter(\n          (nv) => nv !== bodyStmt.currentNode\n        );\n      }\n      if (notYetDefinedNodeVars.length <= 0) {\n        this.insertAnnotation(annotationItems, availableAnnotationItems, i + 1,\n          currProg);\n        return;\n      }\n    }\n  }\n\n  public relationNodeVariables() {\n    return this.relation.nodeVariables();\n  }\n\n  public updateRelationNodeVariables(environment: Environment.Frame) {\n    HelenaConsole.log(\"updateRelationNodeVariables\");\n    this.relation.updateNodeVariables(environment, this.pageVar);\n  }\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    return _.flatten(this.bodyStatements.map(\n      (statement) => statement.parameterizeForRelation(relation)\n    ));\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    for (const bodyStmt of this.bodyStatements) {\n      bodyStmt.unParameterizeForRelation(relation);\n    }\n  }\n\n  public endOfLoopCleanup(continuation: Function) {\n    if (this.relation instanceof Relation) {\n      this.relation.endOfLoopCleanup(this.pageVar, continuation);\n    } else {\n      continuation();\n    }\n  }\n}\n\n/**\n * go through the whole tree and make sure any nested annotations know all\n *   ancestor annotations note that by default we're making all of them required\n *   for matches, not just available for matches\n * in future, if user has edited, we might want to let those edits stand...\n */\nfunction adjustAnnotationParents(currProg: HelenaProgram) {\n  let ancestorAnnotations: SkipBlock[] = [];\n  currProg.traverse(\n    (stmt: HelenaLangObject) => {\n      if (stmt instanceof SkipBlock) {\n        const skipBlock = <SkipBlock> stmt;\n        skipBlock.ancestorAnnotations = ancestorAnnotations.slice();\n        skipBlock.requiredAncestorAnnotations = ancestorAnnotations.slice();\n        ancestorAnnotations.push(skipBlock);\n      }\n    },\n    (stmt: HelenaLangObject) => {\n      if (stmt instanceof SkipBlock) {\n        // back out of this entity scope again, so pop it off\n        ancestorAnnotations = ancestorAnnotations.filter(\n          (annot) => annot !== stmt\n        );\n      }\n    }\n  );\n}\n","import * as Blockly from \"blockly\";\nimport * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\n\nimport { HelenaLangObject } from \"../../helena_lang\";\n\nimport { NodeVariable } from \"../../../variables/node_variable\";\n\nimport { SkipBlockResponse, DatasetSliceRequest } from \"../../../../common/messages\";\n\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { StatementContainer } from \"../container\";\nimport { RunObject, RunOptions } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { HelenaConfig } from \"../../../../common/config/config\";\nimport { HelenaServer } from \"../../../utils/server\";\nimport { Environment } from \"../../../environment\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\nenum SkippingStrategies {\n  ALWAYS = \"always\",\n  NEVER = \"never\",\n  ONERUNLOGICAL = \"onerunlogical\",\n  SOMETIMESPHYSICAL = \"physical\",\n  SOMETIMESLOGICAL = \"logical\"\n}\n\nenum TimeUnits {\n  YEARS = \"years\",\n  MONTHS = \"months\",\n  WEEKS = \"weeks\",\n  DAYS = \"days\",\n  HOURS = \"hours\",\n  MINUTES = \"minutes\"\n}\n\nconst multipliersForSeconds: {\n  [key: string]: number;\n} = {};\n\nmultipliersForSeconds[TimeUnits.MINUTES] = 60;\nmultipliersForSeconds[TimeUnits.HOURS] =\n  multipliersForSeconds[TimeUnits.MINUTES] * 60;\nmultipliersForSeconds[TimeUnits.DAYS] =\n  multipliersForSeconds[TimeUnits.HOURS] * 24;\nmultipliersForSeconds[TimeUnits.WEEKS] =\n  multipliersForSeconds[TimeUnits.DAYS] * 7;\nmultipliersForSeconds[TimeUnits.MONTHS] = 2628000;\nmultipliersForSeconds[TimeUnits.YEARS] =\n  multipliersForSeconds[TimeUnits.DAYS] * 365;\n\nexport interface AnnotationItem {\n  nodeVar: NodeVariable;\n  attr: string;\n}\n\nexport interface HashBasedParallel {\n  on: boolean;\n  numThreads: number;\n  thisThreadIndex: number;\n}\n\ninterface TransactionItem {\n  attr: string;\n  val: string | null;\n}\n\nexport interface ServerTransaction {\n  program_run_id?: number;\n  program_id: string;\n  transaction_attributes: string;\n  annotation_id: number;\n  logical_time_diff?: number;\n  physical_time_diff_seconds?: number;\n  commit_time?: number;\n}\n\nexport class SkipBlock extends StatementContainer {\n  public static counter = 0;\n  public static color = 7;\n\n  public annotationItems: AnnotationItem[];\n  public availableAnnotationItems: AnnotationItem[];\n  public ancestorAnnotations: SkipBlock[];\n  public currentTransaction?: TransactionItem[];\n  public datasetSpecificId: number;\n  public descendIntoLocks?: boolean;\n  public duplicatesInARow: number;\n  public logicalTime?: number;\n  public name: string;\n  public physicalTime?: number;\n  public physicalTimeUnit?: TimeUnits;\n  public requiredAncestorAnnotations: SkipBlock[];\n  public skippingStrategy: SkippingStrategies;\n\n  constructor(annotationItems: AnnotationItem[],\n      availableAnnotationItems: AnnotationItem[],\n      bodyStatements: HelenaLangObject[]) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"skip_block\");\n    \n    this.annotationItems = annotationItems;\n    this.availableAnnotationItems = availableAnnotationItems;\n    this.ancestorAnnotations = [];\n    \n    // we're also allowed to require that prior annotations match, as well as\n    //   our own annotationItems\n    this.requiredAncestorAnnotations = [];\n    \n    SkipBlock.counter += 1;\n    this.name = `Entity${SkipBlock.counter}`;\n    this.datasetSpecificId = SkipBlock.counter;\n    this.updateChildStatements(bodyStatements);\n\n    // by default, we'll skip if there's any duplicate in the history\n    this.skippingStrategy = SkippingStrategies.ALWAYS;\n\n    // make sure to set this to 0 at the beginning of a loop!\n    this.duplicatesInARow = 0;\n  }\n\n  public static createDummy() {\n    return new SkipBlock([], [], []);\n  }\n\n  public clearRunningState() {\n    this.currentTransaction = undefined;\n    this.duplicatesInARow = 0;\n    return;\n  }\n\n  public toStringLines() {\n    let ancestorString = \"\";\n    for (const ancestor of this.ancestorAnnotations) {\n      ancestorString += \", \" + ancestor.name;\n    }\n    const annotationItemsStr = this.annotationItems.map(\n      (item) => annotationItemToString(item)).join(\", \");\n    const prefix =\n      `skipBlock(${this.name}(${annotationItemsStr})${ancestorString}) {`;\n    const statementStrings = this.bodyStatements\n      .reduce((acc: string[], stmt) => acc.concat(stmt.toStringLines()), [])\n      .map((line) => `&nbsp;&nbsp;&nbsp;&nbsp; ${line}`);\n    return [prefix].concat(statementStrings).concat([\"}\"]);\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg) {\n    const self = this;\n\n    // cjbaik: this previously referenced `this.id`, but since it doesn't exist\n    //   I presume datasetSpecificId is correct?\n    const customBlocklyLabel = this.blocklyLabel + this.datasetSpecificId;\n  \n    const name = this.name;\n    const ancestorAnnotations = this.ancestorAnnotations;\n    const requiredAncestorAnnotations = this.requiredAncestorAnnotations;\n    const availableAnnotationItems = this.availableAnnotationItems;\n    const annotationItems = this.annotationItems;\n    \n    console.log(\"in genBlocklyNode\", this, this.name, ancestorAnnotations,\n      requiredAncestorAnnotations);\n\n    Blockly.Blocks[customBlocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        console.log(\"in init\", ancestorAnnotations,\n          requiredAncestorAnnotations);\n        let fieldsSoFar = this.appendDummyInput()\n            .appendField(\"entity name: \")\n            .appendField(new Blockly.FieldTextInput(name), \"name\");\n        if (availableAnnotationItems.length > 0) {\n          fieldsSoFar = this.appendDummyInput().appendField(\"attributes:\");\n        }\n        for (let i = 0; i < availableAnnotationItems.length; i++) {\n          const availItem = availableAnnotationItems[i];\n          const onNow = toBlocklyBoolString(annotationItems.includes(availItem));\n          let extra = \"\";\n          if (i > 0) {\n            extra = \",  \";\n          }\n          const toggleItemUse = function() {\n            var ind = annotationItems.indexOf(availItem);\n            if (ind >= 0) {\n              annotationItems.splice(ind, 1);\n            } else {\n              annotationItems.push(availItem);\n            }\n          };\n          fieldsSoFar = fieldsSoFar\n            .appendField(extra + annotationItemToString(availItem) + \":\")\n            .appendField(new Blockly.FieldCheckbox(onNow, toggleItemUse),\n              annotationItemToString(availableAnnotationItems[i]));\n        }\n        if (ancestorAnnotations.length > 0) {\n          fieldsSoFar = this.appendDummyInput()\n            .appendField(\"other entitites: \");\n        }\n        for (const ancestor of ancestorAnnotations) {\n          const onNow = toBlocklyBoolString(\n            requiredAncestorAnnotations.includes(ancestor));\n          fieldsSoFar = fieldsSoFar\n            .appendField(ancestor.name + \":\")\n            .appendField(new Blockly.FieldCheckbox(onNow),\n              ancestor.name);\n        }\n\n        // ok, time to let the user decide on the skipping strategy\n\n        fieldsSoFar = this.appendDummyInput().appendField(\n          \"When should we skip an item? \");\n        \n        const skippingOptions = [\n          \"Never skip, even if it's a duplicate.\", \n          \"Skip if we've ever scraped a duplicate.\", \n          \"Skip if we scraped a duplicate in the same run.\", \n          \"Skip if we scraped a duplicate in the last\", \n          \"Skip if we scraped a duplicate in the last\"\n        ];\n        const skippingStrategies = [\n          SkippingStrategies.NEVER,\n          SkippingStrategies.ALWAYS,\n          SkippingStrategies.ONERUNLOGICAL,\n          SkippingStrategies.SOMETIMESLOGICAL,\n          SkippingStrategies.SOMETIMESPHYSICAL\n        ];\n        \n        const block = this;\n\n        const allSkippingStrategyCheckboxes: SkippingStrategies[] = [];\n        const skipStratChange = (skippingStrategy: SkippingStrategies) => {\n          console.log(skippingStrategy);\n          if (block.getFieldValue(skippingStrategy) ===\n            toBlocklyBoolString(false)) {\n            // if it's been turned off till now, it's on now, so go ahead and\n            //   set the skipping strategy\n            console.log(\"turned on\", block.getFieldValue(skippingStrategy));\n            self.skippingStrategy = skippingStrategy;\n          }\n          for (const checkboxName of allSkippingStrategyCheckboxes) {\n            if (checkboxName === skippingStrategy) {\n              continue;\n            }\n            block.setFieldValue(toBlocklyBoolString(false),\n              checkboxName);\n          }\n        }\n  \n        for (let i = 0; i < skippingOptions.length; i++) {\n          const skipOption = skippingOptions[i];\n          const skipStrat = skippingStrategies[i];\n\n          let onNow = toBlocklyBoolString(self.skippingStrategy === skipStrat);\n          allSkippingStrategyCheckboxes.push(skipStrat);\n\n          fieldsSoFar = block.appendDummyInput().appendField(\n            new Blockly.FieldCheckbox(onNow, () => skipStratChange(skipStrat)),\n              skipStrat);\n          fieldsSoFar = fieldsSoFar.appendField(skipOption);\n          \n          if (skipStrat === SkippingStrategies.SOMETIMESLOGICAL) {\n            let curLogicalTime = self.logicalTime;\n            if (curLogicalTime === null || curLogicalTime === undefined) {\n              curLogicalTime = 1;\n            }\n            console.log(\"curLogicalTime\", curLogicalTime);\n            \n            const logicalTimeFieldName = \"logicalTime\";\n            const textInput = new Blockly.FieldTextInput(\n              curLogicalTime.toString(), (str: string) => {\n                const ret = Blockly.FieldTextInput.numberValidator(str);\n                if (ret) {\n                  self.logicalTime = parseInt(\n                    block.getFieldValue(logicalTimeFieldName));\n                }\n                return ret;\n              }\n            );\n            fieldsSoFar = fieldsSoFar\n              .appendField(textInput, logicalTimeFieldName)\n              .appendField(\" runs.\");\n            if (self.logicalTime === null || self.logicalTime === undefined) {\n              self.logicalTime = 1;\n            }\n          }\n        \n          if (skipStrat === SkippingStrategies.SOMETIMESPHYSICAL) {\n            let curPhysicalTime = self.physicalTime;\n            if (curPhysicalTime === null || curPhysicalTime === undefined) {\n              curPhysicalTime = 1;\n            }\n            console.log(\"curPhysicalTime\", curPhysicalTime);\n      \n            const physicalTimeFieldName = \"physicalTime\";\n            const textInput = new Blockly.FieldTextInput(\n              curPhysicalTime.toString(), (str: string) => {\n                const ret = Blockly.FieldTextInput.numberValidator(str);\n                if (ret) {\n                  self.physicalTime = parseInt(block.getFieldValue(physicalTimeFieldName));\n                }\n                return ret;\n              }\n            )\n            fieldsSoFar = fieldsSoFar.appendField(textInput,\n              physicalTimeFieldName);\n\n            const options = [];\n            options.push([ TimeUnits.YEARS, TimeUnits.YEARS ]);\n            options.push([ TimeUnits.MONTHS, TimeUnits.MONTHS ]);\n            options.push([ TimeUnits.WEEKS, TimeUnits.WEEKS ]);\n            options.push([ TimeUnits.DAYS, TimeUnits.DAYS ]);\n            options.push([ TimeUnits.HOURS, TimeUnits.HOURS ]);\n            options.push([ TimeUnits.MINUTES, TimeUnits.MINUTES ]);\n\n            // here we actually set the entityScope's time unit, since no\n            //   guarantee the user will interact with that pulldown and trigger\n            //   the setting, but we have to show something, so want what we\n            //   show to match with prog representation\n            if (!self.physicalTimeUnit) {\n              self.physicalTimeUnit = TimeUnits.YEARS;\n            }\n            if (self.physicalTime === null || self.physicalTime === undefined) {\n              self.physicalTime = 1;\n            }\n            const timeUnitsFieldName = \"timeunits\";\n            fieldsSoFar = fieldsSoFar\n              .appendField(new Blockly.FieldDropdown(options,\n                (newVal: TimeUnits) => {\n                  self.physicalTimeUnit = newVal;\n                  console.log(self.physicalTimeUnit);\n              }), timeUnitsFieldName);\n            fieldsSoFar = fieldsSoFar.appendField(\".\");\n\n            // set it to the current time unit\n            block.setFieldValue(self.physicalTimeUnit, timeUnitsFieldName);\n          }\n        }\n\n        this.appendStatementInput(\"statements\") // must be called this\n            .setCheck(null)\n            .appendField(\"do\");\n        \n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(SkipBlock.color);\n      },\n      onchange: function(this: Blockly.Block, ev: Blockly.Events.Abstract) {\n        const newName = this.getFieldValue(\"name\");\n        const skipBlock = <SkipBlock> window.helenaMainpanel.getHelenaStatement(this);\n        if (newName !== skipBlock.name) {\n          skipBlock.name = newName;\n        }\n      }\n    };\n    this.block = workspace.newBlock(customBlocklyLabel);\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n\n    // handle the body statements\n    const firstNestedBlock = HelenaBlocks.helenaSeqToBlocklySeq(\n      this.bodyStatements, workspace);\n    HelenaBlocks.attachNestedBlocksToWrapper(this.block, firstNestedBlock);\n\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public getHelena() {\n    // all well and good to have the things attached after this block, but also\n    //   need the bodyStatements updated\n    const firstNestedBlock = this.block.getInput('statements').connection\n      .targetBlock();\n    const seq = window.helenaMainpanel.blocklySeqToHelenaSeq(firstNestedBlock);\n    this.bodyStatements = seq;\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    for (const bodyStmt of this.bodyStatements) {\n      bodyStmt.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  public endOfLoopCleanup(continuation: Function) {\n    this.currentTransaction = undefined;\n    this.duplicatesInARow = 0;\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    const self = this;\n    \n    if (rbboptions.ignoreEntityScope ||\n        this.skippingStrategy === SkippingStrategies.NEVER) {\n      // this is the case where we just want to assume there's no duplicate\n      //   because we're pretending the annotation isn't there\n      //   or we have the never-skip strategy on\n      //   or we're in hashBasedParallel mode and the hash tells us it's not our\n      //     work\n      runObject.program.runBasicBlock(runObject, self.bodyStatements,\n        rbbcontinuation, rbboptions);\n      return;\n    }\n\n    // if we're not ignoring entityscope, we're in the case where choice depends\n    //   on whether there's a saved duplicate on server\n    this.currentTransaction = this.singleAnnotationItems(runObject.environment);\n\n    let inParallelMode = rbboptions.parallel;\n\n    // let's check if we're divvying work up based on hashes\n    if (rbboptions.hashBasedParallel && rbboptions.hashBasedParallel.on) {\n      if (!isThisMyWorkBasedOnHash(this.currentTransaction,\n        rbboptions.hashBasedParallel)) {\n        // this isn't our responsibility in any case. no need to talk to server.\n        //   just skip\n        rbbcontinuation(rbboptions);\n        return; // very important to return after the skip\n      } else {\n        // ok, let's just fall back into treating it like normal parallel mode\n        inParallelMode = true;\n      }\n    }\n\n    // this is where we should switch to checking if the current task has been\n    //   locked/claimed if we're in parallel mode\n    let targetUrl = HelenaConfig.helenaServerUrl + '/transactionexists';\n    if (inParallelMode) {\n      targetUrl = HelenaConfig.helenaServerUrl + '/locktransaction';\n      if (this.descendIntoLocks) {\n        // this one's a weird case.  in this case, we're actually re-entering a\n        //   skip block already locked by another worker because it has\n        //   descendant work that we can help with and because we want good load\n        //   balancing\n        targetUrl = HelenaConfig.helenaServerUrl + '/takeblockduringdescent';\n      }\n    }\n\n    // you only need to talk to the server if you're actually going to act\n    //   (skip) now on the knowledge of the duplicate\n    const msg = this.serverTransactionRepresentationCheck(runObject);\n\n    HelenaServer.checkSkipBlockTransaction(targetUrl, msg,\n      (resp: SkipBlockResponse) => {\n        if (resp.exists || resp.task_yours === false) {\n          // this is a duplicate, current loop iteration already done, so\n          //   we're ready to skip to the next so actually nothing should happen\n          //   the whole entityscope should be a no-op\n          self.duplicatesInARow += 1;\n          HelenaConsole.namedLog(\"duplicates\", \"new duplicate\",\n            self.duplicatesInARow);\n          if (rbboptions.breakAfterXDuplicatesInARow &&\n              self.duplicatesInARow >= rbboptions.breakAfterXDuplicatesInARow) {\n            // ok, we're actually in a special case, because not only are we not\n            //   doing the body of the entityScope, we're actually breaking out\n            //   of this loop\n            rbboptions.breakMode = true;\n          }\n          rbbcontinuation(rbboptions);\n        } else {\n          self.duplicatesInARow = 0;\n          // no duplicate saved, so just carry on as usual\n          runObject.program.runBasicBlock(runObject, self.bodyStatements, () => {\n            // and when we're done with processing the bodystatements, we'll\n            //   want to commit and then once we've committed, we can go ahead\n            //   and do the original rbbcontinuation\n            self.commit(runObject, rbbcontinuation, rbboptions);\n          }, rbboptions);\n        }\n    });\n  };\n\n  private commit(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    // it could be that something has happened that will cause us to skip any\n    //  commits that happen in a particular loop iteration (no node that has all\n    //  required features, for example)\n    if (!rbboptions.skipCommitInThisIteration) {\n      const transactionMsg = this.serverTransactionRepresentationCommit(\n        runObject, new Date().getTime());\n      const datasetSliceMsg = runObject.dataset.datasetSlice();\n      const fullMsg: ServerTransaction & DatasetSliceRequest =\n        _.extend(transactionMsg, datasetSliceMsg);\n      HelenaServer.newSkipBlockTransaction(fullMsg, () => {});\n    }\n    rbbcontinuation(rbboptions);\n  }\n\n  private singleAnnotationItems(environment: Environment.Frame) {\n    const rep = [];\n    for (const item of this.annotationItems) {\n      const nodeVar = item.nodeVar;\n      let val = null;\n      if (item.attr === \"TEXT\") {\n        val = nodeVar.currentText(environment);\n      } else if (item.attr === \"LINK\") {\n        val = <string> nodeVar.currentLink(environment);\n      } else { \n        console.warn(\"yo, we don't know what kind of attr we're \" +\n          \"looking for: \", item.attr);\n      }\n      rep.push({\n        val: val,\n        attr: item.attr\n      });\n    }\n    return rep;\n  }\n\n  private serverTransactionRepresentation(runObject: RunObject):\n      ServerTransaction {\n    let rep: TransactionItem[] = [];\n    // build up the whole set of attributes that we use to find a duplicate\n    //   some from this annotation, but some from any required ancestor\n    //   annotations\n    for (const ancestor of this.requiredAncestorAnnotations) {\n      if (ancestor.currentTransaction) {\n        rep = rep.concat(ancestor.currentTransaction);\n      }\n    }\n    if (this.currentTransaction) {\n      rep = rep.concat(this.currentTransaction);\n    }\n    return {\n      program_run_id: runObject.dataset.getId(),\n      program_id: runObject.program.id,\n      transaction_attributes: encodeURIComponent(JSON.stringify(rep)),\n      annotation_id: this.datasetSpecificId\n    };\n  };\n\n  private serverTransactionRepresentationCheck(runObject: RunObject,\n      recencyConstraintOptions?: object) {\n    const rep = this.serverTransactionRepresentation(runObject);\n    var strat = this.skippingStrategy;\n    if (strat === SkippingStrategies.ALWAYS) {\n      // actually don't need to do anything.  the default looks through the\n      //   whole log and skips if there's any duplicate match\n    } else if (strat === SkippingStrategies.ONERUNLOGICAL) {\n      rep.logical_time_diff = 0; // we're allowed to go back exactly 0 logical runs, must only reason about this logical run.\n    } else if (strat === SkippingStrategies.SOMETIMESPHYSICAL) {\n      if (!this.physicalTime || !this.physicalTimeUnit) {\n        throw new ReferenceError(\"Physical time or unit not set.\");\n      }\n      rep.physical_time_diff_seconds =\n        this.physicalTime * multipliersForSeconds[this.physicalTimeUnit];\n    }\n    else if (strat === SkippingStrategies.SOMETIMESLOGICAL) {\n      rep.logical_time_diff = this.logicalTime; // the run id is already associated, so we only need to know how many back we're allowed to go\n    } else {\n      console.warn(\"Woah, there was a skipping strategy that we \" +\n        \"actually don't support: \", strat);\n    }\n    return rep;\n  }\n\n  public serverTransactionRepresentationCommit(runObject: RunObject,\n      commitTime: number) {\n    const rep = this.serverTransactionRepresentation(runObject);\n    rep.commit_time = commitTime;\n    return rep;\n  };\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    return [];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    return;\n  }\n}\n\nfunction annotationItemToString(item: AnnotationItem) {\n  return item.nodeVar.toString() + \".\" + item.attr;\n}\n\n\nfunction hash(str: string) {\n  // from https://github.com/darkskyapp/string-hash\n  // The hashing function returns a number between 0 and 4294967295 (inclusive).\n\n  let hash = 5381;\n  let i = str.length;\n\n  while (i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n\n  /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */\n  return hash >>> 0;\n}\n\nfunction transactionToHash(currentTransaction: TransactionItem[]) {\n  let transactionStr = \"\";\n  for (const item of currentTransaction) {\n    transactionStr += \"_\" + item.attr + \"___\" + item.val;\n  }\n  const h = hash(transactionStr);\n  HelenaConsole.log(transactionStr, h);\n  return h;\n}\n\nfunction isThisMyWorkBasedOnHash(currentTransaction: TransactionItem[],\n    hashBasedParallelObject: HashBasedParallel) {\n  const numThreads = hashBasedParallelObject.numThreads;\n  const thisThreadIndex = hashBasedParallelObject.thisThreadIndex;\n  const h = transactionToHash(currentTransaction);\n  // The hashing function returns a number between 0 and 4294967295 (inclusive)\n  const limitLow = (thisThreadIndex / numThreads) * 4294967295;\n  const limitHigh = ((thisThreadIndex + 1) / numThreads) * 4294967295;\n  if (h >= limitLow && h <= limitHigh) {\n    return true;\n  }\n  return false;\n}\n\nexport function toBlocklyBoolString(bool: boolean) {\n  return bool? \"TRUE\": \"FALSE\";\n}\n\n\n// for testing only!  no reason to actually use this!\n/*\nvar bins = {};\nfunction bin(currentTransaction) {\n  var lim = 8;\n  for (var i = 0; i < lim; i++) {\n    var res = isThisMyWorkBasedOnHash(currentTransaction, {numThreads: lim, thisThreadIndex: i});\n    if (res) {\n      if (i in bins) {\n        bins[i] = bins[i] + 1;\n      }\n      else{\n        bins[i] = 1;\n      }\n    }\n  }\n  console.log(\"bins\", bins);\n}*/","import * as Blockly from \"blockly\";\n\nimport { HelenaLangObject } from \"../../helena_lang\";\n\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { HelenaProgram, RunOptions, RunObject } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\n/**\n * No longer executed by Ringer but rather by own run method.\n */\nexport class WaitStatement extends HelenaLangObject {\n  public static waitFieldName = 'waitInSeconds';\n\n  public wait: number;\n\n  constructor() {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"wait\");\n    this.wait = 0;\n  }\n  public static createDummy() {\n    return new WaitStatement();\n  }\n\n  public toStringLines() {\n    return [\"wait \" + this.wait.toString() + \" seconds\"];\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n    pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel);\n\n    const handleWaitChange = function(newWait: number) {\n      if (this.sourceBlock_) {\n        (<WaitStatement> window.helenaMainpanel.getHelenaStatement(this.sourceBlock_)).wait =\n          newWait;\n      }\n    }\n\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendDummyInput()\n            .appendField(\"wait\")\n            .appendField(new Blockly.FieldNumber('0', 0, undefined, undefined,\n              handleWaitChange), WaitStatement.waitFieldName)\n            .appendField(\"seconds\");\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(25);\n        const wal = window.helenaMainpanel.getHelenaStatement(this);\n        if (!wal) {\n          window.helenaMainpanel.setHelenaStatement(this, new WaitStatement());\n        }\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    this.block.setFieldValue(this.wait.toString(), WaitStatement.waitFieldName);\n    return this.block;\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    // just wait a while, then call rbbcontinuation on rbboptions\n    setTimeout(function() {\n      rbbcontinuation(rbboptions);\n    }, this.wait * 1000);\n  }\n};","import * as Blockly from \"blockly\";\nimport * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../../../common/utils/helena_console\";\n\nimport { HelenaLangObject } from \"../helena_lang\";\nimport { NodeVariableUse } from \"../values/node_variable_use\";\nimport { ScrapeStatement } from \"./page_action/scrape\";\nimport { Relation } from \"../../relation/relation\";\nimport { TextRelation } from \"../../relation/text_relation\";\nimport { GenericRelation } from \"../../relation/generic\";\nimport { MainpanelNode } from \"../../../common/mainpanel_node\";\nimport { PageVariable } from \"../../variables/page_variable\";\nimport { RunObject, HelenaProgram, RunOptions } from \"../program\";\nimport { Revival } from \"../../revival\";\nimport { Trace } from \"../../../common/utils/trace\";\nimport { Environment } from \"../../environment\";\nimport { HelenaBlocks } from \"../../ui/blocks\";\n\nexport class OutputRowStatement extends HelenaLangObject {\n  public cleanTrace: Trace;\n  public relations: GenericRelation[];\n  public scrapeStatements: ScrapeStatement[];\n  public trace: Trace;\n  public nodeUseVariables: NodeVariableUse[];\n\n  constructor(scrapeStatements?: ScrapeStatement[]) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"output\");\n    this.trace = []; // no extra work to do in r+r layer for this\n    this.cleanTrace = [];\n    this.scrapeStatements = [];\n    this.nodeUseVariables = [];\n    this.relations = [];\n\n    // Prematurely end, for the `createDummy` method\n    if (!scrapeStatements) {\n      return;\n    }\n  \n    for (const scrapeStmt of scrapeStatements) {\n      this.addAssociatedScrapeStatement(scrapeStmt);\n      this.nodeUseVariables.push(NodeVariableUse.fromScrapeStmt(scrapeStmt));\n    }\n  }\n\n  public setAttributes(attrs: { [key: string]: any } ) {\n    if ('variableUseNodes' in attrs) {\n      this.nodeUseVariables = attrs.variableUseNodes;\n    }\n  }\n\n  public static createDummy() {\n    return new OutputRowStatement();\n  }\n\n  public remove() {\n    this.parent.removeChild(this);\n    for (const scrapeStmt of this.scrapeStatements) {\n      scrapeStmt.removeAssociatedOutputStatement(this);\n    }\n  }\n\n  public addAssociatedScrapeStatement(scrapeStmt: ScrapeStatement) {\n    this.scrapeStatements.push(scrapeStmt);\n    scrapeStmt.addAssociatedOutputStatement(this);\n  }\n\n  public removeAssociatedScrapeStatement(scrapeStmt: ScrapeStatement) {\n    this.scrapeStatements = this.scrapeStatements.filter(\n      (stmt) => stmt !== scrapeStmt\n    );\n  }\n\n  public toStringLines() {\n    const textRelationRepLs = this.relations.reduce(\n      (acc: string[], relation) => acc.concat(relation.scrapedColumnNames()),\n    []);\n    const nodeRepLs = this.scrapeStatements.map(\n      (stmt) => stmt.currentNode.toString(true)\n    );\n    const allNames = textRelationRepLs.concat(nodeRepLs);\n    HelenaConsole.log(\"outputRowStatement\", textRelationRepLs, nodeRepLs);\n    return [ `addOutputRow([ ${allNames.join(\", \")}])` ];\n  };\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: Relation[]) {\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel);\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendValueInput('NodeVariableUse')\n            .appendField(\"add dataset row that includes:\");\n        this.setColour(25);\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    let priorBlock = this.block;\n    for (const vun of this.nodeUseVariables) {\n      const block = vun.genBlocklyNode(this.block, workspace);\n      HelenaBlocks.attachInputToOutput(priorBlock, block);\n      priorBlock = block;\n    }\n    return this.block;\n  }\n\n  public getHelena() {\n    // update our list of variable nodes based on the current blockly situation\n    const firstInput = this.block.getInput('NodeVariableUse');\n    if (firstInput && firstInput.connection.targetBlock()) {\n      const helena = window.helenaMainpanel.getHelenaStatement(firstInput.connection.targetBlock());\n      if (helena instanceof NodeVariableUse) {\n        const inputSeq = helena.getHelenaSeq();\n        this.nodeUseVariables = inputSeq;\n      } else {\n        // right now the only thing we allow to be chained are the node\n        //   variables\n        // todo: make a proper way of making a list in a blockly block. maybe it\n        //   needs to be vertical?\n        // in the meantime, you can make an additional output row that uses\n        //   exactly one cell\n        throw new ReferenceError(\"Could not find NodeVariableUse\");\n\n        // cjbaik: this is what was here before, but the types don't match\n        // this.nodeUseVariables = [ firstInput ];\n      }\n    } else {\n      this.nodeUseVariables = [];\n    }\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    for (const nodeUseVar of this.nodeUseVariables) {\n      nodeUseVar.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  public pbvs() {\n    return [];\n  }\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    if (relation instanceof TextRelation) { // only for text relations!\n      // the textrelation's own function for grabbing current texts will handle\n      //   keeping track of whether a given col should be scraped\n      // note that this currently doesn't handle well cases where multiple\n      //   output statements would be trying to grab the contents of a\n      //   textrelation...\n\n      // add relation if it's not already in there\n      if (!this.relations.includes(relation)) {\n        this.relations.push(relation);\n      }\n      return relation.columns;\n    }\n    return [];\n  };\n  \n  public unParameterizeForRelation(relation: GenericRelation) {\n    this.relations = this.relations.filter((rel) => rel !== relation);\n  }\n\n  public args(environment: Environment.Frame) {\n    return [];\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    // we've 'executed' an output statement. better send a new row to our output\n    const cells = [];\n    const nodeCells = [];\n\n    // let's switch to using the nodeVariableUses that we keep\n    for (const nodeUseVar of this.nodeUseVariables) {\n      nodeUseVar.run(runObject, rbbcontinuation, rbboptions);\n      const v = nodeUseVar.getCurrentVal();\n      let n: MainpanelNode.Interface = _.clone(nodeUseVar.getCurrentNode());\n      if (!n) {\n        // an empty cell for cases where we never found the relevant node, since\n        //   must send a node dict to server to store result\n        n = {\n          text: \"\"\n        };\n      }\n      n.scraped_attribute = nodeUseVar.getAttribute();\n      cells.push(v);\n      nodeCells.push(n);\n    }\n\n    // for now we're assuming we always want to show the number of iterations of\n    //   each loop as the final columns\n    const loopIterationCounterTexts = this.getLoopIterationCounters().map(\n        (i: number) => i.toString()\n    );\n    for (const ic of loopIterationCounterTexts) {\n      cells.push(ic);\n    }\n    \n    /*\n    // todo: why are there undefined things in here!!!!????  get rid of them.\n    //   seriously, fix that\n    cells = _.filter(cells, function(cell) {return cell !== null && cell !== undefined;});\n    */\n\n    runObject.dataset.addRow(nodeCells);\n    runObject.program.mostRecentRow = cells;\n\n    const displayTextCells = cells.map((cell) => cell? cell : \"EMPTY\");\n\n    window.helenaMainpanel.UIObject.addNewRowToOutput(runObject.tab, displayTextCells);\n    window.helenaMainpanel.UIObject.updateRowsSoFar(runObject.tab,\n      runObject.dataset.fullDatasetLength);\n\n    rbbcontinuation(rbboptions); // and carry on when done\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { NodeSources, NodeVariable } from \"../../../variables/node_variable\";\nimport { PageActionStatement, HelenaBlockUIEvent } from \"./page_action\";\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { HelenaProgram } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport {\n  Trace,\n  Traces,\n  DisplayTraceEvent,\n} from \"../../../../common/utils/trace\";\nimport { Environment } from \"../../../environment\";\nimport { IColumnSelector } from \"../../../../content/selector/interfaces\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\nexport class ClickStatement extends PageActionStatement {\n  public static maxDim = 50;\n  public static maxHeight = 20;\n\n  public columnObj: IColumnSelector;\n  public outputPageVars: (PageVariable | undefined)[];\n  public pageUrl: string;\n  public pageVar: PageVariable;\n  public relation: GenericRelation;\n\n  constructor(trace?: Trace) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"click\");\n\n    // Prematurely end, for the `createDummy` method\n    if (!trace) {\n      return;\n    }\n\n    this.trace = trace;\n\n    // find the record-time constants that we'll turn into parameters\n    const ev = Traces.firstVisibleEvent(trace);\n    this.pageVar = Traces.getDOMInputPageVar(ev);\n    this.pageUrl = <string>ev.frame.topURL;\n    this.node = <string>ev.target.xpath;\n\n    // any event in the segment may have triggered a load\n    const domEvents = trace.filter((ev) => ev.type === \"dom\");\n\n    const outputLoads = domEvents.reduce((acc: Trace, ev) => {\n      const loadEvs = Traces.getDOMOutputLoadEvents(<DisplayTraceEvent>ev);\n      if (!loadEvs) {\n        throw new ReferenceError(\"DOM output load events undefined\");\n      }\n      return acc.concat(loadEvs);\n    }, []);\n\n    this.outputPageVars = outputLoads.map((ev) =>\n      Traces.getLoadOutputPageVar(<DisplayTraceEvent>ev)\n    );\n\n    // for now, assume the ones we saw at record time are the ones we'll want at\n    //   replay\n    // this.currentNode = this.node;\n    this.origNode = this.node;\n\n    // we may do clicks that should open pages in new tabs but didn't open new\n    //   tabs during recording\n    // todo: may be worth going back to the ctrl approach, but there are links\n    //   that refuse to open that way, so for now let's try back buttons\n    // proposeCtrlAdditions(this);\n    this.cleanTrace = Traces.cleanTrace(this.trace);\n\n    // actually we want the currentNode to be a nodeVariable so we have a name for the scraped node\n    this.currentNode = NodeVariable.fromTrace(trace);\n  }\n\n  public static createDummy() {\n    return new ClickStatement();\n  }\n\n  public getOutputPagesRepresentation() {\n    let prefix = \"\";\n    if (this.hasOutputPageVars()) {\n      prefix =\n        this.outputPageVars\n          .map((pv) => (pv ? pv.toString() : \"undefined\"))\n          .join(\", \") + \" = \";\n    }\n    return prefix;\n  }\n\n  public prepareToRun() {\n    const feats = this.currentNode.getRequiredFeatures();\n    this.requireFeatures(feats);\n  }\n\n  public toStringLines(): string[] {\n    const nodeRep = this.getNodeRepresentation();\n    return [`${this.getOutputPagesRepresentation()}click(${nodeRep})`];\n  }\n\n  public updateBlocklyBlock(\n    program?: HelenaProgram,\n    pageVars?: PageVariable[],\n    relations?: GenericRelation[]\n  ) {\n    if (!program || !pageVars) {\n      return;\n    }\n    // addToolboxLabel(this.blocklyLabel, \"web\");\n    const pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n    const shapes = [\"\", \"ringer\", \"output\", \"ringeroutput\"];\n    for (const shape of shapes) {\n      const shapeLabel = this.blocklyLabel + \"_\" + shape;\n      Blockly.Blocks[shapeLabel] = {\n        init: function (this: Blockly.Block) {\n          let fieldsSoFar = this.appendDummyInput().appendField(\"click\");\n\n          // let's decide how to display the node\n          if (shapeLabel.indexOf(\"ringer\") > -1) {\n            // it's just a ringer-identified node, use the pic\n            fieldsSoFar = fieldsSoFar.appendField(\n              new Blockly.FieldImage(\n                \"node\",\n                ClickStatement.maxDim,\n                ClickStatement.maxHeight,\n                \"node image\"\n              ),\n              \"node\"\n            );\n          } else {\n            // it has a name so just use the name\n            fieldsSoFar = fieldsSoFar.appendField(\n              new Blockly.FieldTextInput(\"node\"),\n              \"node\"\n            );\n          }\n          fieldsSoFar = fieldsSoFar\n            .appendField(\"in\")\n            .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\");\n\n          // let's decide whether there's an output page\n          if (shapeLabel.indexOf(\"output\") > -1) {\n            fieldsSoFar = fieldsSoFar\n              .appendField(\", load page into\")\n              .appendField(\n                new Blockly.FieldDropdown(pageVarsDropDown),\n                \"outputPage\"\n              );\n          }\n          this.setPreviousStatement(true, null);\n          this.setNextStatement(true, null);\n          this.setColour(280);\n        },\n        onchange: function (ev: Blockly.Events.Abstract) {\n          const newName = this.getFieldValue(\"node\");\n          const clickStmt = <ClickStatement>(\n            window.helenaMainpanel.getHelenaStatement(this)\n          );\n          const currentName = clickStmt.currentNode.getName();\n          if (newName !== currentName) {\n            // new name so update all our program display stuff\n            clickStmt.currentNode.setName(newName);\n\n            // update without updating how blockly appears\n            window.helenaMainpanel.UIObject.updateDisplayedScript(false);\n\n            // now make sure the relation column gets renamed too\n            const colObj = clickStmt.currentColumnObj();\n            if (colObj) {\n              colObj.name = newName;\n              window.helenaMainpanel.UIObject.updateDisplayedRelations();\n            }\n          }\n          if (ev instanceof Blockly.Events.Ui) {\n            const uiEv = <HelenaBlockUIEvent>ev;\n\n            // unselected\n            if (uiEv.element === \"selected\" && uiEv.oldValue === this.id) {\n              window.helenaMainpanel.UIObject.updateDisplayedScript(true);\n            }\n          }\n        },\n      };\n    }\n  }\n\n  public genBlocklyNode(\n    prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg\n  ) {\n    let label = this.blocklyLabel + \"_\";\n\n    if (this.currentNode.getSource() === NodeSources.RINGER) {\n      label += \"ringer\";\n    }\n    if (this.outputPageVars && this.outputPageVars.length > 0) {\n      label += \"output\";\n    }\n\n    this.block = workspace.newBlock(label);\n\n    if (this.currentNode.getSource() === NodeSources.RINGER) {\n      this.block.setFieldValue(this.getNodeRepresentation(), \"node\");\n    } else {\n      this.block.setFieldValue(this.getNodeRepresentation(), \"node\");\n    }\n\n    if (this.outputPageVars && this.outputPageVars.length > 0) {\n      let pvStr = \"undefined\";\n      if (this.outputPageVars[0]) {\n        pvStr = this.outputPageVars[0].toString();\n      }\n      this.block.setFieldValue(pvStr, \"outputPage\");\n    }\n\n    this.block.setFieldValue(this.pageVar.toString(), \"page\");\n\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public pbvs() {\n    const pbvs = [];\n    if (this.currentTab()) {\n      // do we actually know the target tab already?  if yes, go ahead and\n      //   paremterize that\n      pbvs.push({\n        type: \"tab\",\n        value: this.originalTab(),\n      });\n    }\n\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (\n      this.currentNode instanceof NodeVariable &&\n      this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR\n    ) {\n      pbvs.push({\n        type: \"node\",\n        value: this.node,\n      });\n    }\n    return pbvs;\n  }\n\n  public parameterizeForRelation(\n    relation: GenericRelation\n  ): (IColumnSelector | null)[] {\n    return [this.parameterizeNodeWithRelation(relation, this.pageVar)];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    this.unParameterizeNodeWithRelation(relation);\n  }\n\n  public args(environment: Environment.Frame) {\n    const args = [];\n    args.push({\n      type: \"tab\",\n      value: this.currentTab(),\n    });\n\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (\n      this.currentNode instanceof NodeVariable &&\n      this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR\n    ) {\n      args.push({\n        type: \"node\",\n        value: this.currentNodeXpath(environment),\n      });\n    }\n    return args;\n  }\n\n  public currentRelation() {\n    return this.relation;\n  }\n\n  public currentColumnObj() {\n    return this.columnObj;\n  }\n\n  public hasOutputPageVars() {\n    return this.outputPageVars && this.outputPageVars.length > 0;\n  }\n}\n\n/*\nfunction proposeCtrlAdditions(statement) {\n  if (statement.outputPageVars.length > 0) {\n    var counter = 0;\n    var lastIndex = _.reduce(statement.trace, function(acc, ev) {counter += 1; if (Trace.getDOMOutputLoadEvents(ev).length > 0) {return counter;} else {return acc;}}, 0);\n\n    var ctrlKeyDataFeatures = {altKey: false, bubbles: true, cancelable: true, charCode: 0, ctrlKey: true, keyCode: 17, keyIdentifier: \"U+00A2\", keyLocation: 1, metaKey: false, shiftKey: false, timeStamp: 1466118461375, type: \"keydown\"};\n\n    var ctrlDown = cleanEvent(statement.trace[0]); // clones\n    ctrlDown.data = ctrlKeyDataFeatures;\n    ctrlDown.meta.dispatchType = \"KeyboardEvent\";\n\n    var ctrlUp = cleanEvent(statement.trace[0]);\n    ctrlUp.data = clone(ctrlKeyDataFeatures);\n    ctrlUp.data.ctrlKey = false;\n    ctrlUp.data.type = \"keyup\";\n    ctrlUp.meta.dispatchType = \"KeyboardEvent\";\n\n    statement.trace.splice(lastIndex, 0, ctrlUp);\n    statement.trace.splice(0, 0, ctrlDown);\n\n    WALconsole.log(ctrlUp, ctrlDown);\n\n    for (var i = 0; i < lastIndex + 1; i++) { // lastIndex + 1 because we just added two new events!\n      if (statement.trace[i].data) {\n        statement.trace[i].data.ctrlKey = true; // of course may already be true, which is fine\n      }\n    }\n  }\n}*/\n","import * as Blockly from \"blockly\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\nimport { HelenaLangObject, StatementParameter } from \"../../helena_lang\";\nimport { NodeSources, NodeVariable } from \"../../../variables/node_variable\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { TraceContributions, RunObject } from \"../../program\";\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { Trace } from \"../../../../common/utils/trace\";\nimport { Environment } from \"../../../environment\";\nimport { TextRelation } from \"../../../relation/text_relation\";\nimport { Relation } from \"../../../relation/relation\";\nimport { TargetInfo } from \"../../../../ringer-record-replay/content/target\";\nimport { IColumnSelector } from \"../../../../content/selector/interfaces\";\n\nexport interface HelenaBlockUIEvent extends Blockly.Events.Ui {\n  element: string;\n  oldValue: any;\n}\n\nexport class PageActionStatement extends HelenaLangObject {\n  public cleanTrace: Trace;\n  public columnObj?: IColumnSelector;\n  public contributesTrace?: TraceContributions;\n  public currentNode: NodeVariable;\n  public node?: string;\n  public origNode?: string;\n  public pageVar?: PageVariable;\n  public relation?: GenericRelation;\n  public trace: Trace;\n\n  public args(environment: Environment.Frame): StatementParameter[] {\n    return [];\n  }\n\n  public currentNodeXpath(environment: Environment.Frame) {\n    if (this.currentNode instanceof NodeVariable) {\n      return this.currentNode.currentXPath(environment);\n    }\n    // this means currentNode better be an xpath if it's not a variable use!\n    return this.currentNode;\n  }\n\n  public currentTab() {\n    return this.pageVar?.currentTabId();\n  }\n\n  /**\n   * Returns whether this Helena statement is Ringer based.\n   */\n  public isRingerBased() {\n    return true;\n  }\n\n  public getNodeRepresentation(linkScraping = false) {\n    if (this.currentNode instanceof NodeVariable) {\n      // todo: this isn't really correct.  we could reuse a node scraped or\n      //   clicked before, and then it would be bound already.  fix this.\n      const alreadyBound =\n        this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR;\n      let nodeRep = this.currentNode.toString(alreadyBound, this.pageVar);\n      if (linkScraping) {\n        nodeRep += \".link\";\n      }\n      return nodeRep;\n    }\n    if (this.trace[0].additional?.visualization === \"whole page\") {\n      return \"whole page\";\n    }\n    if (linkScraping) {\n      // we don't have a better way to visualize links than just giving text\n      return <string> this.trace[0].additional?.scrape.link;\n    }\n    return `<img src='${this.trace[0].additional?.visualization}'` +\n      \" style='max-height: 150px; max-width: 350px;'>\";\n  }\n\n  public originalTab() {\n    return this.pageVar?.originalTabId();\n  }\n  \n  public parameterizeNodeWithRelation(genericRelation: GenericRelation,\n      pageVar: PageVariable) {\n    // note: may be tempting to use the columns' xpath attributes to decide\n    //   this, but this is not ok!  now that we can have mutliple suffixes\n    //   associated with a column, that xpath is not always correct but we're\n    //   in luck because we know the selector has just been applied to the\n    //   relevant page (to produce relation.demonstrationTimeRelation and from\n    //   that relation.firstRowXpaths) so we can learn from those attributes\n    //   which xpaths are relevant right now, and thus which ones the user would\n    //   have produced in the current demo\n    \n    // if the relation is a text relation, we actually don't want to do the\n    //   below, because it doesn't represent nodes, only texts\n    if (genericRelation instanceof TextRelation) {\n      return null;\n    }\n\n    let relation = <Relation> genericRelation;\n\n    // hey, this better be in the same order as relation.columns and\n    //   relation.firstRowXpaths!\n    // todo: maybe add some helper functions to get rid of this necessity? since\n    //   it may not be clear in there...\n    const nodeRepresentations = relation.firstRowNodeRepresentations();\n\n    for (let i = 0; i < relation.firstRowXPaths.length; i++) {\n      const firstRowXpath = relation.firstRowXPaths[i];\n      if (firstRowXpath === this.origNode) {\n        this.relation = relation;\n        const name = relation.columns[i].name;\n        const nodeRep = nodeRepresentations[i];\n\n        // not ok to just overwrite currentNode, because there may be multiple\n        //   statements using the old currentNode, and becuase we're interested\n        //   in keeping naming consistent, they should keep using it so...just\n        //   overwrite some things\n        if (!this.currentNode) {\n          // have to check if there's a current node because if we're dealing\n          //   with pulldown menu there won't be\n          this.currentNode = new NodeVariable();\n        }\n        if (name) {\n          this.currentNode.setName(name);\n        }\n        this.currentNode.nodeRep = nodeRep;\n        this.currentNode.setSource(NodeSources.RELATIONEXTRACTOR);\n        // statement.currentNode = new NodeVariable(name, nodeRep, null, null,\n        //   NodeSources.RELATIONEXTRACTOR); // note that this means the\n        //   elements in the firstRowXPaths and the elements in columns must be\n        //   aligned!\n        // ps. in theory the above commented out line should have just worked\n        //   because we could search all prior nodes to see if any is the same\n        //   but we just extracted the relation from a fresh run of the script,\n        //   so any of the attributes we use (xpath, text, or even in some cases\n        //   url) could have changed, and we'd try to make a new node, and mess\n        //   it up since we know we want to treat this as the same as a prior\n        //   one, better to just do this\n\n        // the statement should track whether it's currently parameterized for a\n        //   given relation and column obj\n        this.relation = relation;\n        this.columnObj = relation.columns[i];\n\n        return relation.columns[i]; \n      }\n    }\n    return null;\n  }\n  \n  public postReplayProcessing(runObject: RunObject, trace: Trace,\n      temporaryStatementIdentifier: number) {\n    return;\n  }\n\n  /**\n   * Parameterize by value. TODO: What does it mean?\n   */\n  public pbvs(): StatementParameter[] {\n    return [];\n  }\n\n  public requireFeatures(featureNames: string[]) {\n    if (featureNames.length > 0) { \n      if (!this.node) {\n        // sometimes this.node will be empty, as when we add a scrape\n        //   statement for known relation item, with no trace associated \n        throw new ReferenceError(\"Required features with no associated trace.\");\n      }\n      // note that this.node stores the xpath of the original node\n      this.requireFeaturesHelper(this.trace, this.node, featureNames);\n      this.requireFeaturesHelper(this.cleanTrace, this.node, featureNames);\n    }\n  }\n\n  private requireFeaturesHelper(trace: Trace, targetXpath: string,\n      features: string[]) {\n\t\ttargetXpath = targetXpath.toUpperCase();\n\t\t// for (var i = 0; i< trace.length; i++){\n    for (const ev of trace) {\n\t\t\tif (ev.type !== \"dom\"){ continue; }\n      const xpathStr = <string> ev.target.xpath;\n      \n      // sometimes it's a parameterized node, not a normal node\n      if (!xpathStr.toUpperCase){ continue; }\n      \n\t\t\tvar xpath = xpathStr.toUpperCase();\n\t\t\tif (xpath === targetXpath) {\n        HelenaConsole.log(\"requiring stability of features\", features,\n          targetXpath);\n\t\t\t\t(<TargetInfo> ev.target).requiredFeatures = features;\n\t\t\t}\n\t\t}\n  }\n\n  public unParameterizeNodeWithRelation(relation: GenericRelation) {\n    if (this.relation === relation) {\n      this.relation = undefined;\n      const columnObject = this.columnObj;\n      this.columnObj = undefined;\n      this.currentNode = NodeVariable.fromTrace(this.trace);\n      return columnObject;\n    }\n    return null;\n  }\n\n  public usesRelation(rel: GenericRelation) {\n    if (rel instanceof Relation) {\n      if (this.pageVar?.name === rel.pageVarName &&\n          this.node && rel.firstRowXPaths.includes(this.node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\n\nimport { NodeSources, NodeVariable } from \"../../../variables/node_variable\";\nimport { PageActionStatement } from \"./page_action\";\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { HelenaProgram } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { Trace, Traces } from \"../../../../common/utils/trace\";\nimport { MiscUtilities } from \"../../../../common/misc_utilities\";\nimport { Environment } from \"../../../environment\";\nimport { TextRelation } from \"../../../relation/text_relation\";\nimport { Relation } from \"../../../relation/relation\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\nfunction deleteAPropDelta(trace: Trace, propertyName: string) {\n  for (const event of trace) {\n    if (event.type !== \"dom\") { continue; }\n    const deltas = event.meta.deltas;\n    if (deltas) {\n      for (let j = 0; j < deltas.length; j++) {\n        const delta = deltas[j];\n        if (delta.divergingProp === propertyName) {\n          deltas.splice(j, 1); // throw out the relevant delta\n        }\n      }\n    }\n  }\n}\n\nfunction firstUpdateToProp(trace: Trace, propertyName: string) {\n  for (const event of trace) {\n    if (event.type !== \"dom\") { continue; }\n    const deltas = event.meta.deltas;\n    if (deltas) {\n      for (let j = 0; j < deltas.length; j++) {\n        const delta = deltas[j];\n        if (delta.divergingProp === propertyName && delta.changed) {\n          for (const key in delta.changed.prop) {\n            if (key === propertyName) {\n              // phew, finally found it.  grab it from the changed, not the\n              //   original snapshot (want what it changed to)\n              return delta.changed.prop[key];\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class PulldownInteractionStatement extends PageActionStatement {\n  public node: string;\n  public origTrace?: Trace;\n  public origCleanTrace?: Trace;\n  public pageVar: PageVariable;\n\n  constructor(trace?: Trace) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"pulldownInteraction\");\n\n    // Prematurely end, for the `createDummy` method\n    if (!trace) {\n      return;\n    }\n\n    this.trace = trace;\n    \n    // find the record-time constants that we'll turn into parameters\n    this.cleanTrace = Traces.cleanTrace(trace);\n    const ev = Traces.firstVisibleEvent(trace);\n    this.pageVar = Traces.getDOMInputPageVar(ev);\n    this.node = <string> ev.target.xpath;\n    this.origNode = this.node;\n    // we want the currentNode to be a nodeVariable so we have a name for the\n    //   scraped node\n    this.currentNode = NodeVariable.fromTrace(trace);\n  }\n  \n  public static createDummy() {\n    return new PulldownInteractionStatement();\n  }\n\n  public toStringLines() {\n    return [\"pulldown interaction\"];\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    if (!program) {\n      return;\n    }\n    // addToolboxLabel(this.blocklyLabel, \"web\");\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendDummyInput()\n            .appendField(\"pulldown interaction\");\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(280);\n      }\n    };\n  }\n\n  public parameterizeNodeWithRelation(genericRelation: GenericRelation,\n      pageVar: PageVariable) {\n    // note: may be tempting to use the columns' xpath attributes to decide\n    //   this, but this is not ok!  now that we can have mutliple suffixes\n    //   associated with a column, that xpath is not always correct but we're\n    //   in luck because we know the selector has just been applied to the\n    //   relevant page (to produce relation.demonstrationTimeRelation and from\n    //   that relation.firstRowXpaths) so we can learn from those attributes\n    //   which xpaths are relevant right now, and thus which ones the user would\n    //   have produced in the current demo\n    \n    // if the relation is a text relation, we actually don't want to do the\n    //   below, because it doesn't represent nodes, only texts\n    if (genericRelation instanceof TextRelation) {\n      return null;\n    }\n\n    let relation = <Relation> genericRelation;\n\n    // hey, this better be in the same order as relation.columns and\n    //   relation.firstRowXpaths!\n    // todo: maybe add some helper functions to get rid of this necessity? since\n    //   it may not be clear in there...\n    const nodeRepresentations = relation.firstRowNodeRepresentations();\n\n    for (let i = 0; i < relation.firstRowXPaths.length; i++) {\n      const firstRowXpath = relation.firstRowXPaths[i];\n      if (firstRowXpath === this.origNode || \n          (this instanceof PulldownInteractionStatement &&\n            this.origNode && firstRowXpath.includes(this.origNode))) {\n        this.relation = relation;\n        const name = relation.columns[i].name;\n        const nodeRep = nodeRepresentations[i];\n\n        // not ok to just overwrite currentNode, because there may be multiple\n        //   statements using the old currentNode, and becuase we're interested\n        //   in keeping naming consistent, they should keep using it so...just\n        //   overwrite some things\n        if (!this.currentNode) {\n          // have to check if there's a current node because if we're dealing\n          //   with pulldown menu there won't be\n          this.currentNode = new NodeVariable();\n        }\n        if (name) {\n          this.currentNode.setName(name);\n        }\n        this.currentNode.nodeRep = nodeRep;\n        this.currentNode.setSource(NodeSources.RELATIONEXTRACTOR);\n        // statement.currentNode = new NodeVariable(name, nodeRep, null, null,\n        //   NodeSources.RELATIONEXTRACTOR); // note that this means the\n        //   elements in the firstRowXPaths and the elements in columns must be\n        //   aligned!\n        // ps. in theory the above commented out line should have just worked\n        //   because we could search all prior nodes to see if any is the same\n        //   but we just extracted the relation from a fresh run of the script,\n        //   so any of the attributes we use (xpath, text, or even in some cases\n        //   url) could have changed, and we'd try to make a new node, and mess\n        //   it up since we know we want to treat this as the same as a prior\n        //   one, better to just do this\n\n        // the statement should track whether it's currently parameterized for a\n        //   given relation and column obj\n        this.relation = relation;\n        this.columnObj = relation.columns[i];\n\n        return relation.columns[i]; \n      }\n    }\n    return null;\n  }\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    const col = this.parameterizeNodeWithRelation(relation, this.pageVar);\n\n    // if we did actually parameterize, we need to do something kind of weird.\n    //   need to replace the trace with something that just sets 'selected' to\n    //   true for the target node\n    if (col) {\n      this.origTrace = this.trace;\n      this.origCleanTrace = this.cleanTrace;\n\n      // clone it.  update it.  put the xpath in the right places. put a delta\n      //   for 'selected' being true\n      const trace = MiscUtilities.dirtyDeepcopy(this.trace);\n      for (const event of trace) {\n        if (event.meta) {\n          event.meta.forceProp = ({ selected: true });\n        }\n      }\n      // don't try to update the value of select node just update the\n      //   selectindex\n      deleteAPropDelta(trace, \"value\");\n      this.trace = trace;\n      this.cleanTrace = Traces.cleanTrace(this.trace);\n    }\n    return [col];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    const col = this.unParameterizeNodeWithRelation(relation);\n    // if we did find a col, need to undo the thing where we replaced the trace\n    //   with the 'selected' update, put the old trace back in\n    if (col) {\n      if (!this.origTrace || !this.origCleanTrace) {\n        throw new ReferenceError(\"origTrace or origCleanTrace not set.\");\n      }\n      this.trace = this.origTrace;\n      this.cleanTrace = this.origCleanTrace;\n\n      this.origTrace = undefined; // just to be clean\n      this.origCleanTrace = undefined;\n    }\n  }\n\n  public pbvs() {\n    var pbvs = [];\n    if (this.currentTab()) {\n      // do we actually know the target tab already?  if yes, go ahead and\n      //   paremterize that\n      pbvs.push({\n        type: \"tab\",\n        value: this.originalTab()\n      });\n    }\n\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (this.currentNode instanceof NodeVariable &&\n        this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR) {\n      //pbvs.push({type:\"node\", value: this.node});\n      // crucial to make sure that selectedIndex for the select node gets\n      //   updated\n      // otherwise things don't change and it doesn't matter if change event is\n      //   raised\n      // what index was selected in the recording?\n      const origVal = firstUpdateToProp(this.trace, \"selectedIndex\");\n      const originalValDict = {\n        property: \"selectedIndex\",\n        value: origVal\n      };\n      pbvs.push({\n        type: \"property\",\n        value: originalValDict\n      });\n    }\n    return pbvs;\n  }\n\n  public args(environment: Environment.Frame) {\n    const args = [];\n    args.push({\n      type: \"tab\",\n      value: this.currentTab()\n    });\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (this.currentNode instanceof NodeVariable &&\n        this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR) {\n      //args.push({type:\"node\", value: currentNodeXpath(this, environment)});\n      // crucial to make sure that selectedIndex for the select node gets\n      //   updated. otherwise things don't change and it doesn't matter if\n      //   change event is raised\n\n      // extract the correct selectedIndex from the xpath of the current option\n      //   node\n      const xpath = <string> this.currentNodeXpath(environment);\n      HelenaConsole.log(\"currentNodeXpath\", xpath);\n      const segments = xpath.split(\"[\")\n      let indexStr = segments[segments.length - 1].split(\"]\")[0]; \n      let indexOfNextOption = parseInt(indexStr);\n      // our node-to-xpath converter starts counting at 1, but selectedIndex\n      //   property starts counting at 0, so subtract one\n      indexOfNextOption = indexOfNextOption - 1;\n      const valDict = {\n        property: \"selectedIndex\",\n        value: indexOfNextOption\n      };\n\n      args.push({\n        type: \"property\",\n        value: valDict\n      });\n    }\n    return args;\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public usesRelation(rel: GenericRelation) {\n    if (rel instanceof Relation) {\n      if (this.pageVar?.name === rel.pageVarName &&\n          this.node && rel.firstRowXPaths.includes(this.node)) {\n        return true;\n      }\n      const xpath = this.node;\n      for (const cXpath of rel.firstRowXPaths) {\n        // so if the xpath of the pulldown menu appears in the xpath of the\n        //   first row cell\n        if (cXpath.includes(xpath)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { HelenaConsole } from \"../../../../common/utils/helena_console\";\n\nimport { NodeSources, NodeVariable } from \"../../../variables/node_variable\";\n\nimport { OutputRowStatement } from \"../output_row\";\n\nimport { MainpanelNode } from \"../../../../common/mainpanel_node\";\n\nimport { PageActionStatement, HelenaBlockUIEvent } from \"./page_action\";\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { HelenaProgram, RunObject } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport { Trace, Traces } from \"../../../../common/utils/trace\";\nimport { Environment } from \"../../../environment\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\nexport class ScrapeStatement extends PageActionStatement {\n  public static maxDim = 50;\n  public static maxHeight = 20;\n\n  public alternativeBlocklyLabel: string;\n  public associatedOutputStatements: OutputRowStatement[];\n  public currentNodeCurrentValue?: MainpanelNode.Interface;\n  public pageUrl?: string;\n  public preferredXpath?: string;\n  public scrapeLink?: boolean;    // true if scraping link, not just text\n  public xpaths: string[];\n\n  constructor(trace?: Trace) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"scrape\");\n\n    this.alternativeBlocklyLabel = \"scrape_ringer\";\n    this.associatedOutputStatements = [];\n    this.scrapeLink = false;\n    this.xpaths = [];\n\n    // Prematurely end, for the `createDummy` method\n    if (!trace) {\n      return;\n    }\n\n    this.trace = trace;\n    this.cleanTrace = Traces.cleanTrace(this.trace);\n\n    // may get 0-length trace if we're just adding a scrape statement by editing\n    //   (as for a known column in a relation)\n    if (trace.length > 0) {\n      // find the record-time constants that we'll turn into parameters\n      const ev = Traces.firstVisibleEvent(trace);\n      this.pageVar = Traces.getDOMInputPageVar(ev);\n      this.node = <string> ev.target.xpath;\n      this.pageUrl = <string> ev.frame.topURL;\n      // for now, assume the ones we saw at record time are the ones we'll want\n      //   at replay\n      // this.currentNode = this.node;\n      this.origNode = this.node;\n\n      for (const event of trace) {\n        if (event.additional && event.additional.scrape) {\n          if (event.additional.scrape.linkScraping) {\n            this.scrapeLink = true;\n            break;\n          }\n        }\n      }\n\n      // actually we want the currentNode to be a nodeVariable so we have a name\n      //   for the scraped node\n      this.currentNode = NodeVariable.fromTrace(trace);\n    }\n  }\n\n  public static createDummy() {\n    return new ScrapeStatement();\n  }\n\n  public remove() {\n    this.parent.removeChild(this);\n    for (const stmt of this.associatedOutputStatements) {\n      stmt.removeAssociatedScrapeStatement(this);\n    }\n  }\n\n  public prepareToRun() {\n    if (this.currentNode instanceof NodeVariable) {\n      var feats = this.currentNode.getRequiredFeatures();\n      this.requireFeatures(feats);\n    }\n  }\n\n  public clearRunningState() {\n    this.xpaths = [];\n    this.preferredXpath = undefined;\n  }\n\n  public toStringLines() {\n    // todo: could be it's already bound even without being relation extracted,\n    //   so should really handle that\n    const alreadyBound = this.currentNode instanceof NodeVariable &&\n      this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR;\n    if (alreadyBound) {\n      return [ `scrape(${this.currentNode.getName()})` ];\n    }\n    const nodeRep = this.getNodeRepresentation(this.scrapeLink);\n    return [ `scrape(${nodeRep}, ${this.currentNode.getName()})` ];\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    if (!program || !pageVars) {\n      return;\n    }\n    // addToolboxLabel(this.blocklyLabel, \"web\");\n    const pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendDummyInput()\n            .appendField(\"scrape\")\n\n            // switch to pulldown\n            .appendField(new Blockly.FieldTextInput(\"node\"), \"node\")\n\n            .appendField(\"in\")\n            .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\");\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(280);\n      },\n      onchange: function(ev: Blockly.Events.Abstract) {\n        const newName = this.getFieldValue(\"node\");\n        const scrapeStmt = <ScrapeStatement> window.helenaMainpanel.getHelenaStatement(this);\n        const currentName = scrapeStmt.currentNode.getName();\n        if (newName !== currentName) {\n          // new name so update all our program display stuff\n          scrapeStmt.currentNode.setName(newName);\n\n          // update without updating how blockly appears\n          window.helenaMainpanel.UIObject.updateDisplayedScript(false);\n\n          // now make sure the relation column gets renamed too\n          const colObj = scrapeStmt.currentColumnObj();\n          if (colObj) {\n            colObj.name = newName;\n            window.helenaMainpanel.UIObject.updateDisplayedRelations();\n          }\n        }\n\n        if (ev instanceof Blockly.Events.Ui) {\n          const uiEv = <HelenaBlockUIEvent> ev;\n          \n          // unselected\n          if (uiEv.element === \"selected\" && uiEv.oldValue === this.id) {\n            window.helenaMainpanel.UIObject.updateDisplayedScript(true);\n          }\n        }\n      }\n    }\n\n    // now any blockly blocks we'll need but don't want to have in the toolbox\n    //   for whatever reason (usually because we can only get the statement from\n    //   ringer)\n    this.updateAlternativeBlocklyBlock(program, pageVars, relations);\n  }\n\n  public updateAlternativeBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    if (!program || !pageVars) {\n      return;\n    }\n\n    const pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n    const defaultName = \"name\";\n    Blockly.Blocks[this.alternativeBlocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendDummyInput()\n            .appendField(\"scrape\")\n            .appendField(new Blockly.FieldImage(\"node\", ScrapeStatement.maxDim,\n              ScrapeStatement.maxHeight, \"node image\"), \"node\")\n            .appendField(\"in\")\n            .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\")\n            .appendField(\"and call it\")\n            .appendField(new Blockly.FieldTextInput(defaultName), \"name\");\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(280);\n      },\n      onchange: function(ev: Blockly.Events.Abstract) {\n        const newName = this.getFieldValue(\"name\");\n        const scrapeStmt = <ScrapeStatement> window.helenaMainpanel.getHelenaStatement(this);\n        const currentName = scrapeStmt.currentNode.getName();\n        if (newName !== defaultName && (newName !== currentName)) {\n          // new name so update all our program display stuff\n          scrapeStmt.currentNode.setName(newName);\n          // update without updating how blockly appears\n          window.helenaMainpanel.UIObject.updateDisplayedScript(false);\n        }\n        if (ev instanceof Blockly.Events.Ui) {\n          const uiEv = <HelenaBlockUIEvent> ev;\n          \n          // unselected\n          if (uiEv.element === \"selected\" && uiEv.oldValue === this.id) {\n            window.helenaMainpanel.UIObject.updateDisplayedScript(true);\n          }\n        }\n      }\n    };\n  };\n\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg) {\n    if (this.relation) {\n      // scrapes a relation node\n      this.block = workspace.newBlock(this.blocklyLabel);\n      this.block.setFieldValue(this.getNodeRepresentation(), \"node\");\n    } else {\n      // ah, a ringer-scraped node\n      this.block = workspace.newBlock(this.alternativeBlocklyLabel);\n      this.block.setFieldValue(this.currentNode.getName(), \"name\");\n      this.block.setFieldValue(this.getNodeRepresentation(), \"node\");\n    }\n    if (!this.pageVar) {\n      throw new ReferenceError(\"Page variable not set.\");\n    }\n    this.block.setFieldValue(this.pageVar.toString(), \"page\");\n    HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    return this.block;\n  }\n\n  public scrapingRelationItem() {\n    return this.relation !== null && this.relation !== undefined;\n  }\n\n  public pbvs() {\n    const pbvs = [];\n    // no need to make pbvs based on this statement's parameterization if it\n    //   doesn't have any events to parameterize anyway...\n    if (this.trace.length > 0) {\n      if (this.currentTab()) {\n        // do we actually know the target tab already?  if yes, go ahead and\n        //   parameterize that\n        pbvs.push({\n          type: \"tab\",\n          value: this.originalTab()\n        });\n      }\n      if (this.scrapingRelationItem()) {\n        pbvs.push({\n          type: \"node\",\n          value: this.node\n        });\n      }\n      if (this.preferredXpath) {\n        // using the usual pbv process happens to be a convenient way to enforce\n        //   a preferred xpath, since it sets it to prefer a given xpath and\n        //   replaces all uses in the trace of a given xpath with a preferred\n        //   xpath but may prefer to extract this non-relation based pbv process\n        //   from the normal relation pbv.  we'll see\n        // side note: the node pbv above will only appear if it's a use of a\n        //   relation cell, and this one will only appear if it's not\n        pbvs.push({\n          type: \"node\",\n          value: this.node\n        });\n      }\n    }\n\n    return pbvs;\n  }\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    HelenaConsole.log(\"scraping cleantrace\", this.cleanTrace);\n\n    if (!this.pageVar) {\n      throw new ReferenceError(\"Page var not set.\");\n    }\n\n    // this sets the currentNode\n    const relationColumnUsed = this.parameterizeNodeWithRelation(relation,\n      this.pageVar);\n    \n    return [relationColumnUsed];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    const columnObject = this.unParameterizeNodeWithRelation(relation);\n    // todo: right now we're assuming we only scrape a given column once in a\n    //   given script, so if we unparameterize here we assume no where else is\n    //   scraping this column, and we reset the column object's scraped value\n    //   but there's no reason for this assumption to be true.  it doesn't\n    //   matter much, so not fixing it now.  but fix in future\n      \n    // will be null if we're not actually unparameterizing anything\n    if (columnObject) {\n      columnObject.scraped = false; // should really do reference counting\n    }\n\n    // have to go back to actually running the scraping interactions...\n    //   note! right now unparameterizing a scrape statement adds back in all\n    //   the removed scraping events, which won't always be necessary\n    // should really do it on a relation by relation basis, only remove the ones\n    //   related to the current relation\n    this.cleanTrace = Traces.cleanTrace(this.trace);\n  }\n\n  public args(environment: Environment.Frame) {\n    const args = [];\n    // no need to make pbvs based on this statement's parameterization if it\n    //   doesn't have any events to parameterize anyway...\n    if (this.trace.length > 0) {\n      if (this.scrapingRelationItem()) {\n        args.push({\n          type: \"node\",\n          value: this.currentNodeXpath(environment)\n        });\n      }\n\n      args.push({\n        type: \"tab\",\n        value: this.currentTab()\n      });\n\n      if (this.preferredXpath) {\n        args.push({\n          type: \"node\",\n          value: this.preferredXpath\n        });\n      }\n    }\n    return args;\n  }\n\n  public postReplayProcessing(runObject: RunObject, trace: Trace,\n      temporaryStatementIdentifier: number) {\n    if (!this.scrapingRelationItem()) {\n      // ok, this was a ringer-run scrape statement, so we have to grab the\n      //   right node out of the trace\n\n      // it's not just a relation item, so relation extraction hasn't extracted\n      //   it, so we have to actually look at the trace\n      // find the scrape that corresponds to this scrape statement based on\n      //   temporarystatementidentifier\n      const stmtTraceSegment = trace.filter(\n        (ev) => Traces.getTemporaryStatementIdentifier(ev) ===\n          temporaryStatementIdentifier);\n      const scrapedContentEvent =\n        Traces.firstScrapedContentEventInTrace(stmtTraceSegment);\n      if (scrapedContentEvent) {\n        // for now, all scrape statements have a NodeVariable as currentNode, so\n        //   can call setCurrentNodeRep to bind name in current environment\n        let node: MainpanelNode.Interface | null | undefined =\n          scrapedContentEvent.additional?.scrape;\n        if (!node) {\n          node = null\n        }\n        this.currentNode.setCurrentNodeRep(runObject.environment, node);  \n      } else {\n        this.currentNode.setCurrentNodeRep(runObject.environment, null);\n      }\n\n      // it's not a relation item, so let's start keeping track of the xpaths of\n      //   the nodes we actually find, so we can figure out if we want to stop\n      //   running full similarity\n      // note, we could factor this out and let this apply to other statement\n      //   types --- clicks, typing but empirically, have mostly had this issue\n      //   slowing down scraping, not clicks and the like, since there are\n      //   usually few of those\n\n      // if we haven't yet picked a preferredXpath...\n      if (!this.preferredXpath) {\n        if (scrapedContentEvent) {\n          const firstNodeUse = scrapedContentEvent;\n          const xpath = firstNodeUse.target.xpath;\n          this.xpaths.push(<string> xpath);\n          if (this.xpaths.length === 5) {\n            // ok, we have enough data now that we might be able to decide to do\n            //   something smarter\n            const uniqueXpaths = [...new Set(this.xpaths)];\n            if (uniqueXpaths.length === 1) {\n              // we've used the exact same one this whole time... let's try\n              //   using that as our preferred xpath\n              this.preferredXpath = uniqueXpaths[0];\n            }\n          }\n        }\n      } else {\n        // we've already decided we have a preferred xpath. we should check and\n        //   make sure we're still using it.  if we had to revert to using\n        //   similarity we should stop trying to use the current preferred\n        //   xpath, start tracking again.  maybe the page has been redesigned\n        //   and we can discover a new preferred xpath so we'll enter that phase\n        //   again\n\n        // only make this call if we actually have an event that aligns...\n        if (scrapedContentEvent) {\n          const firstNodeUse = scrapedContentEvent; \n          const xpath = firstNodeUse.target.xpath;\n          if (xpath !== this.preferredXpath) {\n            this.preferredXpath = undefined;\n            this.xpaths = [];\n          }\n        }\n      }\n    }\n\n    // and now get the answer in a way that works both for relation-scraped and\n    //   ringer-scraped, because of using NodeVariable\n    this.currentNodeCurrentValue = this.currentNode.currentNodeRep(\n      runObject.environment);\n    if (!this.currentNodeCurrentValue) {\n      // TODO: cjbaik: naively initialized this. is that okay?\n      this.currentNodeCurrentValue = { text: \"\" };\n    }\n\n    if (this.scrapeLink) {\n      this.currentNodeCurrentValue.scraped_attribute = \"LINK\";\n    } else {\n      this.currentNodeCurrentValue.scraped_attribute = \"TEXT\";\n    }\n  }\n\n  public addAssociatedOutputStatement(outputStatement: OutputRowStatement) {\n    this.associatedOutputStatements.push(outputStatement);\n    this.associatedOutputStatements =\n      [...new Set(this.associatedOutputStatements)];\n  }\n\n  public removeAssociatedOutputStatement(outputStatement: OutputRowStatement) {\n    this.associatedOutputStatements = this.associatedOutputStatements.filter(\n      (stmt) => stmt !== outputStatement\n    );\n  }\n\n  public currentRelation() {\n    return this.relation;\n  }\n\n  public currentColumnObj() {\n    return this.columnObj;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { StatementTypes } from \"../statement_types\";\n\nimport { NodeSources, NodeVariable } from \"../../../variables/node_variable\";\nimport { NodeVariableUse } from \"../../values/node_variable_use\";\n\nimport { Concatenate } from \"../../values/concatenate\";\nimport { HelenaString } from \"../../values/string\";\nimport { PageActionStatement } from \"./page_action\";\nimport { MainpanelNode } from \"../../../../common/mainpanel_node\";\nimport { GenericRelation } from \"../../../relation/generic\";\nimport { PageVariable } from \"../../../variables/page_variable\";\nimport { RunObject, RunOptions, HelenaProgram } from \"../../program\";\nimport { Revival } from \"../../../revival\";\nimport {\n  Trace,\n  Traces,\n  DisplayTraceEvent,\n} from \"../../../../common/utils/trace\";\nimport { Environment } from \"../../../environment\";\nimport { TargetInfo } from \"../../../../ringer-record-replay/content/target\";\nimport { IColumnSelector } from \"../../../../content/selector/interfaces\";\nimport { Relation } from \"../../../relation/relation\";\nimport { TextRelation } from \"../../../relation/text_relation\";\nimport { HelenaBlocks } from \"../../../ui/blocks\";\n\n/**\n * Statement representing a user taking the action of typing something.\n */\nexport class TypeStatement extends PageActionStatement {\n  public currentTypedString:\n    | HelenaString\n    | Concatenate\n    | NodeVariableUse\n    | null;\n  public keyCodes: number[];\n  public keyEvents: Trace;\n  public onlyKeydowns: boolean;\n  public onlyKeyups: boolean;\n  public outputPageVars?: (PageVariable | undefined)[];\n  public pageUrl?: string;\n  public typedString?: string;\n  public typedStringLower?: string;\n  public typedStringParameterizationRelation?: GenericRelation;\n\n  constructor(trace?: Trace) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"type\");\n\n    // Prematurely end, for the `createDummy` method\n    if (!trace) {\n      return;\n    }\n\n    this.trace = trace;\n    this.cleanTrace = Traces.cleanTrace(trace);\n\n    // find the record-time constants that we'll turn into parameters\n    const ev = Traces.firstVisibleEvent(trace);\n    this.pageVar = Traces.getDOMInputPageVar(ev);\n    this.node = <string>ev.target.xpath;\n    this.pageUrl = <string>ev.frame.topURL;\n    // var acceptableEventTypes = HelenaMainpanel.statementToEventMapping.keyboard;\n    const textEntryEvents = trace.filter((ev) => {\n      const sType = Traces.statementType(ev);\n      return sType === StatementTypes.KEYBOARD;\n      // || sType === StatementTypes.KEYUP);\n    });\n\n    if (textEntryEvents.length > 0) {\n      const lastTextEntryEvent = textEntryEvents[textEntryEvents.length - 1];\n      this.typedString = (<TargetInfo>lastTextEntryEvent.target).snapshot.value;\n      if (!this.typedString) {\n        this.typedString = \"\";\n      }\n      this.typedStringLower = this.typedString.toLowerCase();\n    }\n\n    // any event in the segment may have triggered a load\n    const domEvents = trace.filter((ev) => ev.type === \"dom\");\n\n    const outputLoads = domEvents.reduce((acc: Trace, ev) => {\n      const loadEvs = Traces.getDOMOutputLoadEvents(<DisplayTraceEvent>ev);\n      if (!loadEvs) {\n        throw new ReferenceError(\"DOM output load events undefined\");\n      }\n      return acc.concat(loadEvs);\n    }, []);\n\n    this.outputPageVars = outputLoads.map((ev) =>\n      Traces.getLoadOutputPageVar(<DisplayTraceEvent>ev)\n    );\n\n    // for now, assume the ones we saw at record time are the ones we'll want at\n    //   replay\n    this.currentNode = NodeVariable.fromTrace(trace);\n    this.origNode = this.node;\n    this.currentTypedString = new HelenaString(this.typedString);\n\n    // we want to do slightly different things for cases where the typestatement only has keydowns or only has keyups (as when ctrl, shift, alt used)\n    const onlyKeydowns = textEntryEvents.every(\n      (event) => event.data.type === \"keydown\"\n    );\n    if (onlyKeydowns) {\n      this.onlyKeydowns = true;\n    }\n    const onlyKeyups = textEntryEvents.every(\n      (event) => event.data.type === \"keyup\"\n    );\n    if (onlyKeyups) {\n      this.onlyKeyups = true;\n    }\n\n    if (onlyKeydowns || onlyKeyups) {\n      this.keyEvents = textEntryEvents;\n      this.keyCodes = this.keyEvents.map((ev) => <number>ev.data.keyCode);\n    }\n  }\n\n  public static createDummy() {\n    return new TypeStatement();\n  }\n\n  public getOutputPagesRepresentation() {\n    let prefix = \"\";\n    if (this.hasOutputPageVars()) {\n      prefix =\n        this.outputPageVars\n          ?.map((pv) => (pv ? pv.toString() : \"undefined\"))\n          .join(\", \") + \" = \";\n    }\n    return prefix;\n  }\n\n  public prepareToRun() {\n    const feats = this.currentNode.getRequiredFeatures();\n    this.requireFeatures(feats);\n  }\n\n  public stringRep() {\n    let stringRep = \"\";\n    if (this.currentTypedString instanceof Concatenate) {\n      stringRep = this.currentTypedString.toString();\n    } else if (this.currentTypedString instanceof HelenaString) {\n      stringRep = <string>this.currentTypedString.getCurrentVal();\n    }\n    return stringRep;\n  }\n\n  public toStringLines(): string[] {\n    if (!this.onlyKeyups && !this.onlyKeydowns) {\n      // normal processing, for when there's actually a typed string\n      const stringRep = this.stringRep();\n      const pageVarStr = this.pageVar ? this.pageVar.toString() : \"undefined\";\n      return [\n        `${this.getOutputPagesRepresentation()}type(${pageVarStr}, ${stringRep})`,\n      ];\n    } else {\n      return [];\n      /*\n      var charsDict = {16: \"SHIFT\", 17: \"CTRL\", 18: \"ALT\", 91: \"CMD\"}; // note that 91 is the command key in Mac; on Windows, I think it's the Windows key; probably ok to use cmd for both\n      var chars = [];\n      _.each(this.keyEvents, function(ev) {\n        if (ev.data.keyCode in charsDict) {\n          chars.push(charsDict[ev.data.keyCode]);\n        }\n      });\n      var charsString = chars.join(\", \");\n      var act = \"press\"\n      if (this.onlyKeyups) {\n        act = \"let up\"\n      }\n      return [act + \" \" + charsString + \" on \" + this.pageVar.toString()];\n      */\n    }\n  }\n\n  public updateBlocklyBlock(\n    program?: HelenaProgram,\n    pageVars?: PageVariable[],\n    relations?: GenericRelation[]\n  ) {\n    if (!program || !pageVars) {\n      return;\n    }\n    // addToolboxLabel(this.blocklyLabel, \"web\");\n    const pageVarsDropDown = PageVariable.makePageVarsDropdown(pageVars);\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function (this: Blockly.Block) {\n        this.appendDummyInput().appendField(\"type\");\n        this.appendValueInput(\"currentTypedString\");\n        this.appendDummyInput()\n          .appendField(\"in\")\n          .appendField(new Blockly.FieldDropdown(pageVarsDropDown), \"page\");\n        this.setInputsInline(true);\n        this.setPreviousStatement(true, null);\n        this.setNextStatement(true, null);\n        this.setColour(280);\n      },\n    };\n  }\n\n  public genBlocklyNode(\n    prevBlock: Blockly.Block,\n    workspace: Blockly.WorkspaceSvg\n  ) {\n    if (\n      this.onlyKeyups ||\n      this.onlyKeydowns ||\n      (this.currentTypedString &&\n        (this.currentTypedString instanceof HelenaString ||\n          this.currentTypedString instanceof Concatenate) &&\n        !this.currentTypedString.hasText())\n    ) {\n      return null;\n    } else {\n      this.block = workspace.newBlock(this.blocklyLabel);\n\n      const pageVarStr = this.pageVar ? this.pageVar.toString() : \"undefined\";\n      this.block.setFieldValue(pageVarStr, \"page\");\n      HelenaBlocks.attachToPrevBlock(this.block, prevBlock);\n      window.helenaMainpanel.setHelenaStatement(this.block, this);\n\n      if (this.currentTypedString) {\n        HelenaBlocks.attachToInput(\n          this.block,\n          this.currentTypedString.genBlocklyNode(this.block, workspace),\n          \"currentTypedString\"\n        );\n      }\n\n      return this.block;\n    }\n  }\n\n  public getHelena() {\n    const currentTypedString = this.block\n      .getInput(\"currentTypedString\")\n      .connection.targetBlock();\n    if (currentTypedString) {\n      this.currentTypedString = <HelenaString | Concatenate>(\n        window.helenaMainpanel\n          .getHelenaStatement(currentTypedString)\n          .getHelena()\n      );\n    } else {\n      this.currentTypedString = null;\n    }\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    if (this.currentTypedString) {\n      this.currentTypedString.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  public pbvs() {\n    const pbvs = [];\n    if (this.currentTab()) {\n      // do we actually know the target tab already?  if yes, go ahead and\n      //   paremterize that\n      pbvs.push({\n        type: \"tab\",\n        value: this.originalTab(),\n      });\n    }\n\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (\n      this.currentNode instanceof NodeVariable &&\n      this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR\n    ) {\n      pbvs.push({\n        type: \"node\",\n        value: this.node,\n      });\n    }\n\n    if (this.typedString !== this.stringRep()) {\n      if (this.typedString && this.typedString.length > 0) {\n        pbvs.push({\n          type: \"typedString\",\n          value: this.typedString,\n        });\n      }\n    }\n    return pbvs;\n  }\n\n  public parameterizeForString(\n    relation: GenericRelation,\n    column: IColumnSelector,\n    nodeRep: MainpanelNode.Interface,\n    string?: string\n  ) {\n    if (string === null || string === undefined) {\n      // can't parameterize for a cell that has null text\n      return;\n    }\n    const textLower = string.toLowerCase();\n    const startIndex = this.typedStringLower?.indexOf(textLower);\n    if (startIndex && startIndex > -1) {\n      // cool, this is the column for us then\n      this.relation = relation;\n      this.columnObj = column;\n      const name = column.name;\n\n      if (!name) {\n        throw new ReferenceError(\"Column has no name.\");\n      }\n\n      const components = [];\n      const left = string.slice(0, startIndex);\n      if (left.length > 0) {\n        components.push(new HelenaString(left));\n      }\n\n      const nodevar = window.helenaMainpanel.getNodeVariableByName(name);\n      if (!nodevar) {\n        throw new ReferenceError(\"NodeVariable is invalid.\");\n      }\n      const nodevaruse = new NodeVariableUse(nodevar);\n      components.push(nodevaruse);\n\n      const right = string.slice(\n        startIndex + (<string>this.typedString).length,\n        string.length\n      );\n      if (right.length > 0) {\n        components.push(new HelenaString(right));\n      }\n\n      let finalNode = null;\n      if (components.length == 1) {\n        finalNode = components[0];\n      } else if (components.length == 2) {\n        finalNode = new Concatenate(components[0], components[1]);\n      } else if (components.length === 3) {\n        finalNode = new Concatenate(\n          components[0],\n          new Concatenate(components[1], components[2])\n        );\n      }\n      this.currentTypedString = finalNode;\n      this.typedStringParameterizationRelation = relation;\n      return true;\n    }\n    return false;\n  }\n\n  public parameterizeForRelation(relation: GenericRelation) {\n    if (!this.pageVar) {\n      throw new ReferenceError(\"Page variable not set.\");\n    }\n\n    const relationColumnUsed = this.parameterizeNodeWithRelation(\n      relation,\n      this.pageVar\n    );\n\n    if (!this.onlyKeydowns && !this.onlyKeyups) {\n      // now let's also parameterize the text\n      const columns = relation.columns;\n      const firstRowNodeReprs = relation.firstRowNodeRepresentations();\n      for (let i = 0; i < columns.length; i++) {\n        const text = columns[i].firstRowText;\n        const paramed = this.parameterizeForString(\n          relation,\n          columns[i],\n          firstRowNodeReprs[i],\n          text\n        );\n        if (paramed) {\n          return [relationColumnUsed, columns[i]];\n        }\n      }\n    }\n\n    return [relationColumnUsed];\n  }\n\n  public unParameterizeForRelation(relation: GenericRelation) {\n    this.unParameterizeNodeWithRelation(relation);\n    if (this.typedStringParameterizationRelation === relation) {\n      this.currentTypedString = new HelenaString(this.typedString);\n    }\n  }\n\n  public usesRelation(rel: GenericRelation) {\n    if (rel instanceof Relation) {\n      if (\n        this.pageVar?.name === rel.pageVarName &&\n        this.node &&\n        rel.firstRowXPaths.includes(this.node)\n      ) {\n        return true;\n      }\n      return this.usesRelationText(rel.firstRowTexts);\n    } else if (rel instanceof TextRelation) {\n      return this.usesRelationText(rel.relation[0]);\n    }\n    return false;\n  }\n\n  public usesRelationText(parameterizeableStrings: (string | null)[]) {\n    if (!parameterizeableStrings) {\n      return false;\n    }\n\n    for (const curString of parameterizeableStrings) {\n      if (!curString) continue;\n\n      const lowerString = curString.toLowerCase();\n      if (this.typedStringLower?.includes(lowerString)) {\n        // for typestatement\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public run(\n    runObject: RunObject,\n    rbbcontinuation: Function,\n    rbboptions: RunOptions\n  ) {\n    if (this.currentTypedString) {\n      this.currentTypedString.run(runObject, rbbcontinuation, rbboptions);\n    }\n  }\n\n  public args(environment: Environment.Frame) {\n    const args = [];\n\n    // we only want to pbv for things that must already have been extracted by\n    //   relation extractor\n    if (\n      this.currentNode instanceof NodeVariable &&\n      this.currentNode.getSource() === NodeSources.RELATIONEXTRACTOR\n    ) {\n      args.push({\n        type: \"node\",\n        value: this.currentNodeXpath(environment),\n      });\n    }\n    args.push({\n      type: \"typedString\",\n      value: this.stringRep(),\n    });\n    args.push({\n      type: \"tab\",\n      value: this.currentTab(),\n    });\n    return args;\n  }\n\n  public currentRelation() {\n    return this.relation;\n  }\n\n  public currentColumnObj() {\n    return this.columnObj;\n  }\n\n  public hasOutputPageVars() {\n    return !!(this.outputPageVars && this.outputPageVars.length > 0);\n  }\n}\n","export enum StatementTypes {\n  MOUSE = 1,\n  KEYBOARD,\n  LOAD,\n  SCRAPE,\n  SCRAPELINK,\n  KEYUP,\n  PULLDOWNINTERACTION\n};","import * as Blockly from \"blockly\";\n\nimport { HelenaString } from \"./string\";\nimport { Value } from \"./value\";\n\nimport { NodeVariableUse } from \"./node_variable_use\";\nimport { GenericRelation } from \"../../relation/generic\";\nimport { PageVariable } from \"../../variables/page_variable\";\nimport { RunObject, HelenaProgram, RunOptions } from \"../program\";\nimport { Revival } from \"../../revival\";\nimport { HelenaBlocks } from \"../../ui/blocks\";\n\nexport class Concatenate extends Value {\n  public currentVal: string;\n  public left?: HelenaString | NodeVariableUse | Concatenate;\n  public right?: HelenaString | NodeVariableUse | Concatenate;\n\n  constructor(left?: HelenaString | NodeVariableUse | Concatenate,\n              right?: HelenaString | NodeVariableUse | Concatenate) {\n    super();\n\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"concatenate\");\n  \n    this.left = left;\n    this.right = right;\n  }\n\n  public static createDummy() {\n    return new Concatenate();\n  }\n\n  public toStringLines() {\n    return [\"concatenate\"];\n  }\n\n  /**\n   * @returns true because a Concatenate always involves text\n   */\n  public hasText() {\n    return true;\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel, \"text\");\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        this.appendValueInput(\"left\");\n        this.appendDummyInput().appendField(\"+\");\n        this.appendValueInput(\"right\");\n        this.setInputsInline(true);\n        this.setOutput(true, 'Bool');\n        this.setColour(25);\n\n        const helena = window.helenaMainpanel.getHelenaStatement(this);\n        if (!helena) {\n          window.helenaMainpanel.setHelenaStatement(this, new Concatenate());\n        }\n      }\n    };\n  };\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n\n    if (this.left) {\n      const leftBlock = this.left.genBlocklyNode(this.block, workspace);\n      if (!leftBlock) {\n        throw new ReferenceError(\"Could not create left block.\");\n      }\n      HelenaBlocks.attachToInput(this.block, leftBlock, \"left\");\n    }\n    if (this.right) {\n      const rightBlock = this.right.genBlocklyNode(this.block, workspace);\n      if (!rightBlock) {\n        throw new ReferenceError(\"Could not create right block.\");\n      }\n      HelenaBlocks.attachToInput(this.block, rightBlock, \"right\");\n    }\n    return this.block;\n  }\n\n  public getHelena() {\n    // ok, but we also want to update our own condition object\n    const leftBlock = this.block.getInput('left').connection.targetBlock();\n    const rightBlock = this.block.getInput('right').connection.targetBlock();\n    if (leftBlock) {\n      this.left = <HelenaString> window.helenaMainpanel.getHelenaStatement(leftBlock).getHelena();\n    } else {\n      this.left = undefined;\n    }\n\n    if (rightBlock) {\n      this.right = <HelenaString> window.helenaMainpanel.getHelenaStatement(rightBlock).getHelena();\n    } else {\n      this.right = undefined;\n    }\n    return this;\n  }\n\n  public traverse(fn: Function, fn2: Function) {\n    fn(this);\n    if (this.left) {\n      this.left.traverse(fn, fn2);\n    }\n    if (this.right) {\n      this.right.traverse(fn, fn2);\n    }\n    fn2(this);\n  }\n\n  public updateCurrentVal() {\n    if (!this.left || !this.right) {\n      throw new ReferenceError(\"Concatenate improperly initialized.\");\n    }\n    const leftVal = this.left.getCurrentVal();\n    const rightVal = this.right.getCurrentVal();\n\n    if (typeof leftVal !== \"string\" || typeof rightVal !== \"string\") {\n      throw new ReferenceError(\"Concatenate value is not a string!\");\n    }\n    this.currentVal = leftVal + rightVal;\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    if (!this.left || !this.right) {\n      throw new ReferenceError(\"Concatenate improperly initialized.\");\n    }\n    // now run the things on which we depend\n    this.left.run(runObject, rbbcontinuation, rbboptions);\n    this.right.run(runObject, rbbcontinuation, rbboptions);\n\n    this.updateCurrentVal();\n  }\n\n  public getCurrentVal() {\n    return this.currentVal;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { ScrapeStatement } from \"../statements/page_action/scrape\";\n\nimport { Value } from \"./value\";\n\nimport { NodeSources, NodeVariable } from \"../../variables/node_variable\";\n\nimport { MainpanelNode } from \"../../../common/mainpanel_node\";\nimport { GenericRelation } from \"../../relation/generic\";\nimport { PageVariable } from \"../../variables/page_variable\";\nimport { RunObject, HelenaProgram, RunOptions } from \"../program\";\nimport { Revival } from \"../../revival\";\nimport { HelenaConsole } from \"../../../common/utils/helena_console\";\n\n// silly to use strings, I know, but it makes it easier to do the blockly\n//   dropdown\nexport enum AttributeOptions { \n  TEXT = \"1\",\n  LINK = \"2\"\n}\n\nexport class NodeVariableUse extends Value {\n  public static attributeFieldName = 'attributeFieldName';\n  public static varNameFieldName = 'varNameFieldName';\n\n  public attributeOption: AttributeOptions;\n  public currentVal: MainpanelNode.Interface | string;\n  public nodeVar?: NodeVariable;\n\n  constructor(nodeVar?: NodeVariable, attributeOption = AttributeOptions.TEXT) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"variableUse\");\n    \n    this.attributeOption = attributeOption;\n\n    if (nodeVar) {\n      this.nodeVar = nodeVar;\n    }\n  }\n\n  public static createDummy() {\n    return new NodeVariableUse();\n  }\n\n  public static fromScrapeStmt(scrapeStmt: ScrapeStatement) {\n    let attrOption = AttributeOptions.TEXT;\n    if (scrapeStmt.scrapeLink) {\n      attrOption = AttributeOptions.LINK;\n    }\n    return new NodeVariableUse(scrapeStmt.currentNode, attrOption);\n  }\n\n  public toStringLines() {\n    if (this.nodeVar) {\n      const name = this.nodeVar.getName();\n      if (name) {\n        return [ name ];\n      } else {\n        return [ \"\" ];\n      }\n    } else {\n      return [ \"\" ];\n    }\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    if (!program) {\n      return;\n    }\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel);\n    const handleVarChange = function(newVarName: string) {\n      if (this.sourceBlock_) {\n        console.log(\"updating node to \", newVarName);\n        const nodeVarUse =\n          <NodeVariableUse> window.helenaMainpanel.getHelenaStatement(this.sourceBlock_);\n        nodeVarUse.nodeVar =\n          <NodeVariable> window.helenaMainpanel.getNodeVariableByName(newVarName);\n      }\n    };\n    const handleAttributeChange = function(newAttribute: AttributeOptions) {\n      if (this.sourceBlock_) {\n        const nodeVarUse =\n          <NodeVariableUse> window.helenaMainpanel.getHelenaStatement(this.sourceBlock_);\n        nodeVarUse.attributeOption = newAttribute;\n      }\n    };\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        if (program) {\n          const varNamesDropDown = program.makeVariableNamesDropdown();\n          const attributesDropDown = [\n            [\"TEXT\", AttributeOptions.TEXT],\n            [\"LINK\", AttributeOptions.LINK]\n          ];\n          if (varNamesDropDown.length > 0) {\n            this.appendValueInput('NodeVariableUse')\n                .appendField(new Blockly.FieldDropdown(varNamesDropDown,\n                  handleVarChange), NodeVariableUse.varNameFieldName)\n                .appendField(new Blockly.FieldDropdown(attributesDropDown,\n                  handleAttributeChange), NodeVariableUse.attributeFieldName);\n            \n            this.setOutput(true, 'NodeVariableUse');\n            //this.setColour(25);\n            this.setColour(298);\n            // the following is an important pattern\n            // this might be a new block, in which case searching for existing\n            //   Helena statement for the block with this block's id will be\n            //   pointless; but if init is being called because a block is being\n            //   restored from the trashcan, then we have to do this check or\n            //   we'll overwrite the existing Helena stuff, which would lose\n            //   important state (in this case, the information about the node\n            //   variable/what node it actually represents)\n            const helena = window.helenaMainpanel.getHelenaStatement(this);\n            if (!helena) {\n              const name = varNamesDropDown[0][0];\n              window.helenaMainpanel.setHelenaStatement(this,\n                new NodeVariableUse(\n                  <NodeVariable> window.helenaMainpanel.getNodeVariableByName(name)\n              ));\n              /*\n              const nodeVarUse = <NodeVariableUse> window.helenaMainpanel.\n                getHelenaStatement(this);\n              if (!nodeVarUse.nodeVar) {\n                console.warn(\"NodeVariableUse has no node var!\");\n              }*/\n            }\n          }\n        }\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    // nope!  this one doesn't attach to prev! attachToPrevBlock(this.block, prevBlock);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    \n    let varName = this.nodeVar?.getName();\n    if (!varName) {\n      varName = \"Unknown\";\n    }\n    this.block.setFieldValue(varName,\n      NodeVariableUse.varNameFieldName);\n    this.block.setFieldValue(this.attributeOption,\n      NodeVariableUse.attributeFieldName);\n    \n    return this.block;\n  }\n\n  public getHelenaSeq(): NodeVariableUse[] {\n    const inputSeq = window.helenaMainpanel.getInputSeq(this.block,\n      \"NodeVariableUse\");\n    let fullSeq: NodeVariableUse[] = [this];\n    fullSeq = fullSeq.concat(inputSeq);\n    return fullSeq;\n  }\n\n  public run(runObject: RunObject, rbbcontinuation: Function,\n      rbboptions: RunOptions) {\n    // just retrieve the val\n    if (!this.nodeVar) {\n      throw new ReferenceError(\"Node var required!\");\n    }\n    this.currentVal = runObject.environment.envLookup(this.nodeVar.getName());\n  }\n\n  public getCurrentVal() {\n    // remember!  currentval is an object with text, link, source url, xpath,\n    //   that stuff so if the val is being used, we have fto pull out just the\n    //   text\n    if (!this.currentVal) {\n      return \"\";\n    } else if (this.nodeVar?.nodeSource === NodeSources.PARAMETER) {\n      // special case.  just return the val\n      return <string> this.currentVal;\n    } else if (this.attributeOption === AttributeOptions.TEXT) {\n      // ok, it's a normal nodevar, an actual dom node representation\n      const text = (<MainpanelNode.Interface> this.currentVal).text;\n      return text? text : \"undefined\";\n    } else if (this.attributeOption === AttributeOptions.LINK &&\n               this.currentVal.link) {\n      return <string> this.currentVal.link;\n    }\n    return \"\";\n  }\n\n  public getAttribute() {\n    if (this.attributeOption === AttributeOptions.TEXT) {\n      return 'TEXT';\n    } else if (this.attributeOption === AttributeOptions.LINK) {\n      return 'LINK'\n    } else {\n      return '';\n    }\n  }\n\n  public getCurrentNode(): MainpanelNode.Interface {\n    if (this.nodeVar?.nodeSource === NodeSources.PARAMETER) {\n      // special case. we need a dictionary, but we only have text because we\n      //   got this as a param\n      return { text: <string> this.currentVal };\n    }\n    return <MainpanelNode.Interface> this.currentVal;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { HelenaMainpanel } from \"../../helena_mainpanel\";\n\nimport { Value } from \"./value\";\n\nimport { GenericRelation } from \"../../relation/generic\";\nimport { PageVariable } from \"../../variables/page_variable\";\nimport { HelenaProgram } from \"../program\";\nimport { Revival } from \"../../revival\";\n\nexport class HelenaNumber extends Value {\n  public static fieldName = 'numberFieldName';\n\n  constructor() {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"num\");\n    this.currentVal = null;\n  }\n  \n  public static createDummy() {\n    return new HelenaNumber();\n  }\n\n  public toStringLines() {\n    if (this.currentVal) {\n      return [ this.currentVal.toString() ];\n    } else {\n      return [ \"\" ];\n    }\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel, \"numbers\");\n    const defaultNum = 100;\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        const helena = window.helenaMainpanel.getHelenaStatement(this);\n        if (!helena) {\n          window.helenaMainpanel.setHelenaStatement(this, new HelenaNumber());\n        }\n\n        const block = this;\n        this.appendDummyInput()\n            .appendField(new Blockly.FieldNumber(defaultNum, undefined,\n              undefined, undefined, (newNum: number) => {\n                (<HelenaNumber> window.helenaMainpanel.getHelenaStatement(block)).currentVal = newNum;\n              }), HelenaNumber.fieldName);\n\n        this.setOutput(true, 'number');\n        this.setColour(25);\n        (<HelenaNumber> window.helenaMainpanel.getHelenaStatement(this)).currentVal = defaultNum;\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    if (this.currentVal) {\n      this.block.setFieldValue(this.currentVal.toString(), HelenaNumber.fieldName);\n    }\n    return this.block;\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { HelenaMainpanel } from \"../../helena_mainpanel\";\n\nimport { Value } from \"./value\";\n\nimport { GenericRelation } from \"../../relation/generic\";\nimport { PageVariable } from \"../../variables/page_variable\";\nimport { HelenaProgram } from \"../program\";\nimport { Revival } from \"../../revival\";\n\nexport class HelenaString extends Value {\n  public static fieldName = 'stringFieldName';\n\n  public currentVal: string;\n\n  constructor(currString?: string) {\n    super();\n    Revival.addRevivalLabel(this);\n    this.setBlocklyLabel(\"string\");\n\n    if (currString || currString === \"\") {\n      this.currentVal = currString;\n    } else {\n      this.currentVal = \"your text here\";\n    }\n  }\n\n  public setAttributes(attrs: { [key: string] : any }) {\n    if ('currentValue' in attrs) {\n      this.currentVal = attrs.currentValue;\n    }\n  }\n\n  public static createDummy() {\n    return new HelenaString();\n  }\n\n  public toStringLines() {\n    return [ this.currentVal ];\n  }\n\n  public hasText() {\n    if (this.currentVal.length < 1) {\n      return false;\n    }\n    return true;\n  }\n\n  public updateBlocklyBlock(program?: HelenaProgram,\n      pageVars?: PageVariable[], relations?: GenericRelation[]) {\n    window.helenaMainpanel.addToolboxLabel(this.blocklyLabel, \"text\");\n    const text = this.currentVal;\n    Blockly.Blocks[this.blocklyLabel] = {\n      init: function(this: Blockly.Block) {\n        const helena = window.helenaMainpanel.getHelenaStatement(this);\n        if (!helena) {\n          window.helenaMainpanel.setHelenaStatement(this, new HelenaString());\n        }\n\n        this.appendDummyInput()\n            .appendField(new Blockly.FieldTextInput(text,\n              function (newStr: string) {\n                const helenaStr =\n                  <HelenaString> window.helenaMainpanel.getHelenaStatement(this.sourceBlock_);\n                helenaStr.currentVal = newStr;\n              }), HelenaString.fieldName);\n\n        this.setOutput(true, 'string');\n        this.setColour(25);\n        const helenaStr = <HelenaString> window.helenaMainpanel.getHelenaStatement(this);\n        helenaStr.currentVal = text;\n      }\n    };\n  }\n\n  public genBlocklyNode(prevBlock: Blockly.Block,\n      workspace: Blockly.WorkspaceSvg) {\n    this.block = workspace.newBlock(this.blocklyLabel);\n    window.helenaMainpanel.setHelenaStatement(this.block, this);\n    if (this.currentVal) {\n      this.block.setFieldValue(this.currentVal, HelenaString.fieldName);\n    }\n    return this.block;\n  }\n\n  public getCurrentVal() {\n    return this.currentVal;\n  }\n}","import { HelenaLangObject } from \"../helena_lang\";\n\nimport { MainpanelNode } from \"../../../common/mainpanel_node\";\n\nexport class Value extends HelenaLangObject {\n  public currentVal: MainpanelNode.Interface | boolean | string | number | null;\n\n  public getCurrentVal() {\n    return this.currentVal;\n  }\n}","import { Utilities } from \"../ringer-record-replay/common/utils\";\nimport { HelenaConsole } from \"../common/utils/helena_console\";\nimport { ParameterizedXPath, StringParameterizeEvent, RecordedRingerEvent,\n\tParameterizedTopURL } from \"../ringer-record-replay/common/event\";\nimport { Trace } from \"../common/utils/trace\";\nimport { Delta } from \"../ringer-record-replay/content/snapshot\";\n\nexport interface ParameterizedTraceConfig {\n\t// frameMapping: any;\n\ttabMapping: {\n\t\t[key: number]: number\n\t};\n\ttargetWindowId?: number;\n}\n\ninterface Property {\n  property: string;\n  value: string;\n}\n\ninterface ParameterizedTab {\n\toriginal_value: number,\n\tvalue?: number\n}\n\nexport class ParameterizedTrace {\n\t// private frames: object;\n\tprivate tabs: {\n\t\t[key: string]: ParameterizedTab\n\t};\n\tprivate trace: (RecordedRingerEvent | StringParameterizeEvent)[];\n\n\tconstructor(trace: Trace) {\n\t\t// this.frames = {};\n\t\tthis.tabs = {}\n\t\tthis.trace = trace;\n\t}\n\n\t/**\n\t * Get parameterized trace config.\n\t */\n\tpublic getConfig() {\n\t\t// WALconsole.log(\"frames\", frames);\n\t\tconst config: ParameterizedTraceConfig = {\n\t\t\t// frameMapping: {},\n\t\t\ttabMapping: {}\n\t\t};\n\t\t/*for (const param in frames) {\n\t\t\tconfig.frameMapping[frames[param].original_value] = frames[param].value;\n\t\t}*/\n\t\tfor (const param in this.tabs) {\n\t\t\tconst tabValue = this.tabs[param].value;\n\t\t\tif (!tabValue) {\n\t\t\t\tthrow new ReferenceError(\"tabValue should be set!\");\n\t\t\t}\n\t\t\tconfig.tabMapping[this.tabs[param].original_value] = tabValue;\n\t\t}\n\t\tHelenaConsole.log(\"config\", config);\n\t\treturn config;\n\t};\n\t\n\t/**\n\t * TODO\n\t */\n\tpublic getStandardTrace() {\n\t\tHelenaConsole.log(\"about to clone trace \", this.trace);\n\t\tlet clonedTrace = Utilities.clone(this.trace);\n\t\tHelenaConsole.log(\"successfully cloned trace\");\n\t\tconst prop_corrections: {\n\t\t\t[key: string]: {\n\t\t\t\tprop: string;\n\t\t\t\tvalue: string;\n\t\t\t\torig_value: string;\n\t\t\t}\n\t\t} = {};\n\t\tfor (let i = 0; i < clonedTrace.length; i++){\n\t\t\tconst event = clonedTrace[i];\n\t\t\tif (event.type === \"completed\" || event.type === \"webnavigation\") {\n\t\t\t\t// correct url if it's a parameterized url\n\t\t\t\tconst url = event.data.url;\n\t\t\t\tif (url.name) {\n\t\t\t\t\tHelenaConsole.log(\"Correcting url to \", url.value);\n\t\t\t\t\tevent.data.url = url.value;\n\t\t\t\t}\n\t\t\t} else if (event.type === \"dom\") {\n\t\t\t\t// do any prop corrections we might need, as when we've recorded a value\n\t\t\t\t//   but want to enforce a diff\n\t\t\t\tif (event.meta.nodeSnapshot && event.meta.nodeSnapshot.prop) {\n\t\t\t\t\tconst xpath = event.meta.nodeSnapshot.prop.xpath;\n\t\t\t\t\tfor (const correction_xpath in prop_corrections){\n\t\t\t\t\t\tif (xpath === correction_xpath) {\n\t\t\t\t\t\t\tconst d = prop_corrections[correction_xpath];\n\t\t\t\t\t\t\tdeltaReplace(event.meta.deltas, d.prop, d.orig_value, d.value);\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// do explicit pbv prop corrections (for deltas that we need to cause)\n\t\t\t\tconst deltas = event.meta.deltas;\n\t\t\t\tif (deltas) {\n\t\t\t\t\tfor (let j = 0; j < deltas.length; j++) {\n\t\t\t\t\t\tconst delta = deltas[j];\n\t\t\t\t\t\tconst props = delta.changed.prop;\n\t\t\t\t\t\tfor (const key in props){\n\t\t\t\t\t\t\tif (props[key] && props[key].value) {\n\t\t\t\t\t\t\t\t// phew, finally found it.  put in the placeholder\n\t\t\t\t\t\t\t\tHelenaConsole.log(\"Correcting prop to\", props[key].value);\n\t\t\t\t\t\t\t\tevent.meta.deltas[j].changed.prop[key] = props[key].value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// correct xpath if it's a parameterized xpath\n\t\t\t\tconst xpath = event.target.xpath;\n\t\t\t\tif (xpath.name) {\n\t\t\t\t\tHelenaConsole.log(\"Correcting xpath to \", xpath.value);\n\t\t\t\t\tevent.target.xpath = xpath.value;\n\t\t\t\t\tevent.target.useXpathOnly = true;\n\t\t\t\t}\n\t\t\t\t// correct url if it's a parameterized url\n\t\t\t\tconst url = event.frame.topURL;\n\t\t\t\tif (url.name) {\n\t\t\t\t\tHelenaConsole.log(\"Correcting url to \", url.value);\n\t\t\t\t\tevent.frame.topURL = url.value;\n\t\t\t\t}\n\t\t\t\t// correct tab if it's a parameterized tab\n\t\t\t\tconst tab = event.frame.tab;\n\t\t\t\tif (tab.name) {\n\t\t\t\t\tHelenaConsole.log(\"Correcting url to \", tab.value);\n\t\t\t\t\tevent.frame.tab = tab.value;\n\t\t\t\t}\n\t\t\t} else if (event.type === \"string_parameterize\") {\n\t\t\t\tHelenaConsole.log(\"Correcting string to \", event.value);\n\t\t\t\tHelenaConsole.log(event);\n\t\t\t\tconst new_event = event.text_input_event;\n\t\t\t\tnew_event.data.data = event.value;\n\t\t\t\tdeltaReplace(new_event.meta.deltas, \"value\", event.orig_value,\n\t\t\t\t\tevent.value);\n\t\t\t\tprop_corrections[new_event.meta.nodeSnapshot.prop.xpath] = {\n\t\t\t\t\tprop: \"value\", \n\t\t\t\t\torig_value: event.orig_value, \n\t\t\t\t\tvalue: event.value\n\t\t\t\t};\n\t\t\t\tclonedTrace = clonedTrace.slice(0, i)\n\t\t\t\t\t.concat([ new_event ])\n\t\t\t\t\t.concat(clonedTrace.slice(i+1, clonedTrace.length));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\treturn clonedTrace;\n\t}\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param origValue \n\t */\n\t/*\n\tpublic parameterizeFrame(paramName: string, origValue) {\n\t\tHelenaConsole.log(\"parameterizing frame \", paramName, origValue);\n\t\tframes[paramName] = {\n\t\t\toriginal_value: origValue\n\t\t};\n\t};*/\n\n\t/**\n\t * Property parameterization\n\t * @param paramName\n\t * @param origValue\n\t */\n\tpublic parameterizeProperty(paramName: string, origValue: Property) {\n\t\tconst propertyName = origValue.property;\n\t\tconst propertyOriginalValue = origValue.value;\n\t\tfor (const ev of this.trace) {\n\t\t\tif (ev.type !== \"dom\") { continue; }\n\t\t\tconst deltas = ev.meta.deltas;\n\t\t\tif (deltas) {\n\t\t\t\tfor (const delta of deltas) {\n\t\t\t\t\tif (delta.divergingProp === propertyName) {\n\t\t\t\t\t\tconst props = delta.changed?.prop;\n\t\t\t\t\t\tif (props) {\n\t\t\t\t\t\t\tfor (const key in props) {\n\t\t\t\t\t\t\t\tif (key === propertyName &&\n\t\t\t\t\t\t\t\t\t  props[key] === propertyOriginalValue) {\n\t\t\t\t\t\t\t\t\t// finally found it.  put in the placeholder\n\t\t\t\t\t\t\t\t\tHelenaConsole.log(\"putting a hole in for a prop\", origValue);\n\t\t\t\t\t\t\t\t\tprops[key] = {\n\t\t\t\t\t\t\t\t\t\tname: paramName,\n\t\t\t\t\t\t\t\t\t\tvalue: null,\n\t\t\t\t\t\t\t\t\t\torig_value: propertyOriginalValue\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Tab parameterization if we want to say which page to go to but leave fram\n\t *   mapping to lower level r+r code\n\t * @param paramName \n\t * @param origValue \n\t */\n\tpublic parameterizeTab(paramName: string, origValue: number) {\n\t\tHelenaConsole.log(\"parameterizing tab \", paramName, origValue);\n\t\tthis.tabs[paramName] = {\n\t\t\toriginal_value: origValue\n\t\t};\n\t}\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param origString \n\t */\n\tpublic parameterizeTypedString(paramName: string, origString: string) {\n\t\tHelenaConsole.log(\"parameterizing string \", paramName, origString);\n\t\tlet curr_node_xpath = null;\n\t\tlet curr_string = \"\";\n\t\tlet char_indexes = [];\n\t\tlet started_char = false;\n\n\t\t// let's see if there's just a textinput event that adds the whole thing\n\t\tfor (let i = 0; i < this.trace.length; i++) {\n\t\t\tconst event = this.trace[i];\n\t\t\tif (event.type === \"dom\" &&\n\t\t\t    event.data.type === \"textInput\") {\n\t\t\t\tconst typed = event.data.data;\n\t\t\t\tif (typed.toLowerCase() === origString.toLowerCase()) {\n\t\t\t\t\t// great, this is the one\n\t\t\t\t\tthis.trace = replaceSliceWithParamEvent(this.trace, paramName,\n\t\t\t\t\t\tevent, origString, i, i)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet i;\n\t\tfor (i = 0; i < this.trace.length; i++){\n\t\t\tconst event = this.trace[i];\n\t\t\t// ok to drop these from script, so ok to skip\n\t\t\tif (event.type !== \"dom\") { continue; }\n\t\t\n\t\t\tconst event_data = event.data;\n\t\t\tif (!([\"keydown\", \"keypress\", \"keyup\", \"input\",\t// not a key event\n\t\t\t\t\t\t \"textInput\"].includes(event_data.type)) ||\n\t\t\t\t\t \n\t\t\t\t\t // event now targeting a different node (and not just bc it's the\n\t\t\t\t\t //   first node we've seen)\n\t\t\t\t   (event.target.xpath !== curr_node_xpath &&\n\t\t\t\t\t    curr_node_xpath !== null)){\n\t\t\t\t// if the next thing isn't a key event or if we've switched nodes, we're\n\t\t\t\t//   done with the current string! (assuming we have a current string\n\t\t\t\t//   right now)\n\t\t\t\tif (curr_string.length > 0) {\n\t\t\t\t\tHelenaConsole.log(\"processString\", curr_string);\n\t\t\t\t\tconst currIndex = processString(paramName, origString, curr_string,\n\t\t\t\t\t\tchar_indexes, i - 1);\n\t\t\t\t\tcurr_string = \"\";\n\t\t\t\t\tchar_indexes = [];\n\t\t\t\t\tif (currIndex !== null) {\n\t\t\t\t\t\t// have to update this, because processString might have shortened\n\t\t\t\t\t\t//   the trace\n\t\t\t\t\t\ti = currIndex;\n\n\t\t\t\t\t\t// have to continue so the if statement below doesn't fire until we\n\t\t\t\t\t\t//   do i++\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ([\"keydown\", \"keypress\", \"keyup\", \"input\",\n\t\t\t\t\t \"textInput\"].includes(event_data.type)) {\n\t\t\t\t// ok, we're doing key stuff\n\t\t\t\tcurr_node_xpath = event.target.xpath;\n\t\t\t\tif (event_data.type === \"keydown\" && !started_char) {\n\t\t\t\t\t// starting a new char\n\t\t\t\t\tchar_indexes.push(i);\n\t\t\t\t\tstarted_char = true;\n\t\t\t\t} else if (event_data.type === \"textInput\") {\n\t\t\t\t\tcurr_string += event_data.data;\n\t\t\t\t} else if (event_data.type === \"keyup\") {\n\t\t\t\t\tstarted_char = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// and let's check whatever we had at the end if it hadn't been checked yet\n\t\tif (curr_string.length > 0) {\n\t\t\tconst currIndex = processString(paramName, origString, curr_string,\n\t\t\t\tchar_indexes, this.trace.length - 1);\n\t\t\tif (currIndex !== null) {\n\t\t\t\t// have to update this, because processString might have shortened the\n\t\t\t\t//   trace\n\t\t\t\ti = currIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * URL load parameterization\n\t *   TODO: also change the completed event now that we allow that to cause\n\t *   loads if forceReplay is set\n\t * @param paramName \n\t * @param origValue \n\t */\n\tpublic parameterizeUrl(paramName: string, origValue: string) {\n\t\t// so that dom events (when they open new tabs) open correct tab\n\t\t// see record-replay/mainpanel_main for the func (getMatchingPort) where we\n\t\t//   actually open a new tab if we're trying to run an event that needs it,\n\t\t//   which explains why we do url parameterization the way we do\n\t\torigValue = origValue.toUpperCase();\n\t\tfor (const event of this.trace) {\n\t\t\tif (event.type !== \"dom\"){ continue; }\n\t\t\tif (typeof event.frame.topURL !== 'string') {\n\t\t\t\t//this one has already been converted to an object, parameterized\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst url = event.frame.topURL.toUpperCase();\n\t\t\tif (url === origValue) {\n\t\t\t\tHelenaConsole.log(\"putting a hole in for a URL\", origValue);\n\t\t\t\tevent.frame.topURL = {\n\t\t\t\t\t\"name\": paramName,\n\t\t\t\t\t\"value\": null\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t// so that 'completed' events open correct tab\n\t\tfor (const event of this.trace) {\n\t\t\tif (event.type !== \"completed\" && event.type !== \"webnavigation\") {\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (event.data.url.name){\n\t\t\t\t//this one has already been converted to an object, parameterized\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvar url = event.data.url.toUpperCase();\n\t\t\tif (url === origValue){\n\t\t\t\tHelenaConsole.log(\"putting a hole in for a URL\", origValue);\n\t\t\t\tevent.data.url = {\"name\": paramName, \"value\": null};\n\t\t\t}\n\t\t}\n\t};\n\n\n\t/**\n\t * Parameterize XPath\n\t * @param paramName \n\t * @param origValue \n\t */\n\tpublic parameterizeXpath(paramName: string, origValue: string) {\n\t\torigValue = origValue.toUpperCase();\n\t\tfor (const ev of this.trace) {\n\t\t\tif (ev.type !== \"dom\") { continue; }\n\t\t\tlet xpath = null;\n\t\t\tif (typeof ev.target.xpath === 'string') {\n\t\t\t\tHelenaConsole.log(ev.target.xpath);\n\t\t\t\txpath = ev.target.xpath.toUpperCase();\n\t\t\t} else {\n\t\t\t\t// this one has already been converted to an object, parameterized\n\t\t\t\t// ok! this used to say we were going to continue, since we've already\n\t\t\t\t//   parameterized.  now we allow us to re-parameterize\n\t\t\t\t// so this is now out of sync with the way the other parameterize\n\t\t\t\t//   functions work.  todo: fix the others to match!\n\t\t\t\t// note: added the original_value field, since need that now\n\t\t\t\txpath = ev.target.xpath.orig_value;\n\t\t\t}\n\n\t\t\tif (xpath === origValue) {\n\t\t\t\tHelenaConsole.log(\"putting a hole in for an xpath\", origValue);\n\t\t\t\tev.target.xpath = {\n\t\t\t\t\tname: paramName,\n\t\t\t\t\tvalue: null,\n\t\t\t\t\torig_value: origValue\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n /**\n  * TODO\n  * @param parameter_name \n  * @param value \n  */\n\t/*public useFrame(parameter_name, value) {\n\t\tif(value === null){\n\t\t\tWALconsole.log(\"Freak out.\");\n\t\t}\n\t\tif (!frames[parameter_name]){\n\t\t\tWALconsole.log(\"warning, may be trying to give argument for something that hasn't been parameterized: !frames[parameter_name]\");\n\t\t\tWALconsole.log(parameter_name, value);\n\t\t\tWALconsole.log(this);\n\t\t\treturn;\n\t\t}\n\t\tframes[parameter_name].value = value;\n\t}*/\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param value \n\t */\n\tpublic useProperty(paramName: string, value: Property) {\n\t\tconst propertyName = value.property;\n\t\tconst propertyValue = value.value;\n\t\tfor (const ev of this.trace) {\n\t\t\tif (ev.type !== \"dom\") { continue; }\n\t\t\tconst deltas = ev.meta.deltas;\n\t\t\tif (deltas) {\n\t\t\t\t// for (var j = 0; j < deltas.length; j++) {\n\t\t\t\tfor (const delta of deltas) {\n\t\t\t\t\tif (delta.divergingProp === propertyName) {\n\t\t\t\t\t\tconst props = delta.changed?.prop;\n\t\t\t\t\t\tif (props) {\n\t\t\t\t\t\t\tfor (const key in props) {\n\t\t\t\t\t\t\t\tif (key === propertyName &&\n\t\t\t\t\t\t\t\t\t  props[key].name === paramName) {\n\t\t\t\t\t\t\t\t\t// phew, finally found it.\n\t\t\t\t\t\t\t\t\tHelenaConsole.log(\"use prop\", value);\n\t\t\t\t\t\t\t\t\tprops[key].value = propertyValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param value \n\t */\n\tpublic useTab(paramName: string, value: number) {\n\t\tif (value === null) {\n\t\t\tHelenaConsole.log(\"Freak out: tabs.\");\n\t\t}\n\t\tif (!this.tabs[paramName]) {\n\t\t\tHelenaConsole.log(\"warning, may be trying to give argument for \" +\n\t\t\t\t\"something that hasn't been parameterized: !tabs[parameter_name]\");\n\t\t\tHelenaConsole.log(paramName, value);\n\t\t\tHelenaConsole.log(this);\n\t\t\treturn;\n\t\t}\n\t\tthis.tabs[paramName].value = value;\n\t}\n\n\n\t/**\n\t * \n\t * @param paramName \n\t * @param str \n\t */\n\tpublic useTypedString(paramName: string, str: string){\n\t\tfor (const event of this.trace) {\n\t\t\tif (event.type === \"string_parameterize\") {\n\t\t\t\tconst strParamEv = <StringParameterizeEvent> event;\n\t\t\t  if (strParamEv.parameter_name === paramName) {\n\t\t\t\t\tHelenaConsole.log(\"use string\", str);\n\t\t\t\t\tstrParamEv.value = str;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param value \n\t */\n\tpublic useUrl(paramName: string, value: string) {\n\t\t// dom events\n\t\t// for (var i = 0; i< trace.length; i++){\n\t\tfor (const event of this.trace) {\n\t\t\tif (event.type !== \"dom\"){ continue; }\n\t\t\tconst url = <ParameterizedTopURL> event.frame.topURL;\n\t\t\tif (url.name === paramName) {\n\t\t\t\tHelenaConsole.log(\"use url\", url);\n\t\t\t\tevent.frame.topURL = {\n\t\t\t\t\tname: paramName,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\t// completed events\n\t\tfor (const event of this.trace) {\n\t\t\tif (event.type !== \"completed\" && event.type !== \"webnavigation\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst url = event.data.url;\n\t\t\tif (url.name === paramName){\n\t\t\t\tHelenaConsole.log(\"use url\", url);\n\t\t\t\tevent.data.url = {\n\t\t\t\t\tname: paramName,\n\t\t\t\t\tvalue: value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * TODO\n\t * @param paramName \n\t * @param value \n\t */\n\tpublic useXpath(paramName: string, value: any) {\n\t\tfor (const ev of this.trace) {\n\t\t\tif (ev.type !== \"dom\") { continue; }\n\t\t\tconst xpath = <ParameterizedXPath> ev.target.xpath;\n\t\t\tif (xpath.name === paramName) {\n\t\t\t\tHelenaConsole.log(\"use xpath\", value);\n\t\t\t\tev.target.xpath = {\n\t\t\t\t\tname: paramName,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\torig_value: xpath.orig_value\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * TODO\n * @param trace \n * @param paramName \n * @param textInputEvent \n * @param origStringInitialCase \n * @param startTargetTypingIndex \n * @param stopTargetTypingIndex \n */\nfunction replaceSliceWithParamEvent(\n\t\ttrace: (RecordedRingerEvent | StringParameterizeEvent)[], paramName: string,\n\t\ttextInputEvent: RecordedRingerEvent, origStringInitialCase: string,\n\t\tstartTargetTypingIndex: number, stopTargetTypingIndex: number) {\n\t// now make our param event\n\tconst param_event: StringParameterizeEvent = {\n\t\ttype: \"string_parameterize\", \n\t\tparameter_name: paramName, \n\t\ttext_input_event: textInputEvent, \n\t\torig_value: origStringInitialCase,\n\t\tvalue: \"\"\n\t};\n\t// now remove the unnecessary events, replace with param event\n\t// todo: note that this is a bad bad approach!  learn from CoScripter!\n\t//   replay all low-level events!  (also see verion in structured codebase)\n\t// but it's in here now becuase recreating each keypress is a pain that I want\n\t//   to put off until later, and this works for current apps\n\ttrace = trace.slice(0, startTargetTypingIndex)\n\t\t\t\t\t\t\t .concat([ param_event ])\n\t\t\t\t\t\t\t .concat(trace.slice(stopTargetTypingIndex, trace.length));\n\tHelenaConsole.log(\"putting a hole in for a string\", origStringInitialCase);\n\treturn trace;\n}\n\n\n/**\n * Figure out if the keyevents issued on the node associated with the event at\n *   last_key_index should be parameterized for original_string (a cell in a\n *   relation); put in holes if yes.\n * @param paramName \n * @param origStr \n * @param str \n * @param charIndexes \n * @param lastKeyIndex \n */\nfunction processString(paramName: string, origStr: string, str: string,\n\t\tcharIndexes: number[], lastKeyIndex: number) {\n\t// the string we got as an argument was based on the keypresses, but\n\t//   recreating all the logic around that is a terrible pain\n\t// let's try using the value of the node\n\t// using value is nice because it allows us to figure out if the target string\n\t//   is present even if it was typed in some weird way,\n\t// with the user jumping all around, or doing deletion, whatever\n\n\tlet lastDomEventIndex = null;\n\tlet targetNode = null;\n\t// let's find the most recent dom event, working backwards from last_key_index\n\tfor (let i = lastKeyIndex; i >= 0; i--){\n\t\tif (this.trace[i].type === \"dom\") {\n\t\t\tlastDomEventIndex = i;\n\t\t\ttargetNode = this.trace[lastDomEventIndex].target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!targetNode.snapshot || !targetNode.snapshot.value) {\n\t\t// can currently only parameterize actions on nodes that have value\n\t\t//   attributes (so text input nodes); should potentially expand to others\n\t\t//   eventually; todo: why do some not have snapshot?\n\t\treturn null;\n\t}\n\n\t// obviously this approach is limited to nodes with value attributes, as is\n\t//   current top-level tool\n\tconst typed_value = targetNode.snapshot.value;\n\n\tconst original_string_initial_case = origStr;\n\torigStr = origStr.toLowerCase();\n\n\tconst typed_value_lower = typed_value.toLowerCase();\n\n\tconst target_string_index = typed_value_lower.indexOf(origStr);\n\tif (target_string_index > -1) {\n\t\t// oh cool, that substring appears in this node by the end of the typing.\n\t\t//   let's try to find where we start and finish typing it\n\t\t// assumption is that we're typing from begining of string to end.\n\t\t//   below won't work well if we're hopping all around \n\n\t\t// what's the last place where we see everything that appears left of our\n\t\t//   target string, but none of the target string?\n\t\tconst left = typed_value_lower.slice(0, target_string_index);\n\t\tHelenaConsole.log(\"left\", left);\n\t\tconst first_key_event_index = charIndexes[0];\n\n\t\tlet start_target_typing_index = first_key_event_index;\n\t\tfor (let i = first_key_event_index; i < lastKeyIndex; i++) {\n\t\t\tconst event = this.trace[i];\n\t\t\tif (event.type === \"dom\" && event.data.type === \"keyup\" &&\n\t\t\t    event.target.snapshot.value) {\n\t\t\t\t// cool, we're on the last event in a particular key sequence. does it\n\t\t\t\t//   have the whole left in the value yet?\n\t\t\t\tconst lowerCurrString = event.target.snapshot.value.toLowerCase();\n\t\t\t\tif (lowerCurrString.includes(left + origStr[0])) {\n\t\t\t\t\t// oops, gone too far!  we've started the target string\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (lowerCurrString.includes(left)){\n\t\t\t\t\tstart_target_typing_index = i + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHelenaConsole.log(\"start_typing_index\", start_target_typing_index);\n\t\t// what's the first place where we see the whole target string?\n\t\t// we know it's there by the last key, so that's a safe bet\n\t\tlet stop_target_typing_index = lastKeyIndex;\n\t\tfor (let i = start_target_typing_index; i < lastKeyIndex; i++) {\n\t\t\tconst event = this.trace[i];\n\t\t\tif (event.type === \"dom\" && event.data.type === \"keyup\" &&\n\t\t\t    event.target.snapshot.value){\n\t\t\t\t// cool, we're on the last event in a particular key sequence. does it\n\t\t\t\t//   have the whole left in the value yet?\n\t\t\t\tif (event.target.snapshot.value.toLowerCase().includes(origStr)) {\n\t\t\t\t\tstop_target_typing_index = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tHelenaConsole.log(\"stop_target_typing_index\", stop_target_typing_index);\n\n\t\tlet text_input_event = null;\n\t\t// ok, so we type our target from start_target_typing_index to\n\t\t//   stop_target_typing_index\n\t\tfor (let i = stop_target_typing_index; i > start_target_typing_index; i--) {\n\t\t\tconst event = this.trace[i];\n\t\t\tif (event.type === \"dom\" && event.data.type === \"textInput\") {\n\t\t\t\ttext_input_event = event;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (text_input_event === null) {\n\t\t\tHelenaConsole.log(\"one of our assumptions broken. no textinput event.\");\n\t\t}\n\t\tthis.trace = replaceSliceWithParamEvent(this.trace, paramName,\n\t\t\ttext_input_event, original_string_initial_case, start_target_typing_index,\n\t\t\tstop_target_typing_index);\n\t\treturn start_target_typing_index + 1;\n\t}\n\n\treturn null;\n}\n\n/**\n * Using current arguments, create a standard, replayable trace\n * @param deltas \n * @param propToChange \n * @param origValue \n * @param replaceValue \n */\nfunction deltaReplace(deltas: Delta[], propToChange: string, origValue: string,\n\t\treplaceValue: string){\n\tfor (const delta of deltas) {\n\t\tif (delta.changed?.prop) {\n\t\t\tdelta.changed.prop[propToChange] =\n\t\t\t\tdelta.changed.prop[propToChange].replace(origValue, replaceValue);\n\t\t}\n\t}\n}","import { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport { NodeVariable } from \"../variables/node_variable\";\nimport { PageVariable } from \"../variables/page_variable\";\nimport { RunObject } from \"../lang/program\";\nimport { Revival } from \"../revival\";\nimport { RelationMessage } from \"../../common/messages\";\nimport { Environment } from \"../environment\";\nimport { IColumnSelector } from \"../../content/selector/interfaces\";\n\nexport class GenericRelation implements Revival.Revivable {\n  public ___revivalLabel___: string;\n  public name: string;\n  public columns: IColumnSelector[];\n  public firstRowTexts: string[];\n  public nodeVars: NodeVariable[];\n\n  public clearRunningState() {\n    return;\n  }\n\n  public columnName(colObj: (IColumnSelector | null) []) {\n    return colObj.map((colObj) => {\n      if (colObj && colObj.name) {\n        return colObj.name;\n      } else {\n        return \"undefined\";\n      }\n    });\n  }\n\n  public columnNames() {\n    return this.columns.map((colObj) => colObj.name? colObj.name : \"undefined\");\n  }\n\n  public demonstrationTimeRelationText(): string[][] {\n    return [];\n  }\n\n  public firstRowNodeRepresentation(colObj: IColumnSelector) {\n    if (!colObj.index) {\n      throw new ReferenceError(\"ColumnSelector has no index.\");\n    }\n    const firstRow = this.firstRowNodeRepresentations();\n    return firstRow[parseInt(colObj.index)];\n  }\n\n  public firstRowNodeRepresentations(): MainpanelNode.Interface[] {\n    return [];\n  }\n\n  public getColumnObjectFromXpath(xpath: string) {\n    for (const column of this.columns) {\n      if (column.xpath === xpath) {\n        return column;\n      }\n    }\n    HelenaConsole.log(\"Ack!  No column object for that xpath: \",\n      this.columns, xpath);\n    return null;\n  }\n\n  public getNextRow(runObject: RunObject, pageVar: PageVariable,\n    callback: Function) {\n      return;\n  }\n\n  public nodeVariables(): NodeVariable[] {\n    return [];\n  }\n\n  public processColumns() {\n    return;\n  }\n\n  public scrapedColumnNames() {\n    return this.columns.filter((colObj) => colObj.scraped)\n                       .map((colObj) => colObj.name? colObj.name : \"undefined\");\n  }\n\n  public setColumnName(columnObj: IColumnSelector, v: string) {\n    columnObj.name = v;\n\n    if (!columnObj.index) {\n      throw new ReferenceError(\"Column selector index not provided.\");\n    }\n    \n    const nodeVariables = this.nodeVariables();\n    nodeVariables[parseInt(columnObj.index)].setName(v);\n    window.helenaMainpanel.UIObject.updateDisplayedScript();\n  }\n\n  /**\n   * Could not name this `toJSON` because JSOG treats objects with `toJSON`\n   *   methods in a special way.\n   */\n  public convertToJSON: () => RelationMessage | string;\n\n  public updateNodeVariables(environment: Environment.Frame,\n    pageVar: PageVariable) {\n      return;\n  }\n}","import * as _ from \"underscore\";\nimport * as stringify from \"json-stable-stringify\";\n\nimport { HelenaConfig } from \"../../common/config/config\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport { FreshRelationItemsMessage, NextButtonTextMessage, RelationMessage,\n  Messages } from \"../../common/messages\";\nimport { MiscUtilities } from \"../../common/misc_utilities\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\n\nimport { INextButtonSelector, NextButtonTypes,\n  IColumnSelector } from \"../../content/selector/interfaces\";\nimport { Features } from \"../../content/utils/features\";\nimport GenericFeatureSet = Features.GenericFeatureSet;\n\nimport { Environment } from \"../environment\";\nimport { RunObject } from \"../lang/program\";\nimport { Revival } from \"../revival\";\nimport { NodeSources, NodeVariable } from \"../variables/node_variable\";\nimport { PageRelation, PageVariable } from \"../variables/page_variable\";\nimport { HelenaServer } from \"../utils/server\";\nimport { GenericRelation } from \"./generic\";\n\n/**\n * State of the current scraped relation items.\n */\nexport enum ScrapedRelationState {\n  NO_MORE_ITEMS = 1,\n  NO_NEW_ITEMS_YET,\n  NEW_ITEMS\n}\n\nexport class Relation extends GenericRelation {\n  public static counter = 0;\n  \n  public id: string;\n  public selector: GenericFeatureSet | GenericFeatureSet[];\n  public selectorVersion: number;\n  public excludeFirst: number;\n  public demonstrationTimeRelation: MainpanelNode.Interface[][];\n  public numRowsInDemo: number;\n  public pageVarName: string;\n  public url: string;\n  public nextType: number;\n  public nextButtonSelector: INextButtonSelector | null;\n  public frame: number;\n  \n  public firstRowXPaths: string[];\n  public firstRowTexts: string[];\n  public firstRowValues: string[];\n\n  public relationScrapeWait: number;\n\n  public getRowsCounter: number;\n  public doneArray: boolean[];\n  public relationItemsRetrieved: {\n    [key: string]: FreshRelationItemsMessage;\n  };\n  // may still be interesting to track misses. may choose to send an extra next\n  //   button press, something like that\n  public missesSoFar: {\n    [key: string]: number;\n  };\n\n  public getNextRowCounter: number;\n  \n  // for next buttons that are actually counting (page 1, 2, 3...), it's useful\n  //   to keep track of this\n  public currNextButtonText?: string;\n\n  constructor(relationId: string, name: string,\n      selector: GenericFeatureSet | GenericFeatureSet[],\n      selectorVersion: number, excludeFirst: number,\n      columns: IColumnSelector[],\n      demonstrationTimeRelation: MainpanelNode.Interface[][],\n      numRowsInDemo: number, pageVarName: string, url: string,\n      nextType: number, nextButtonSelector: INextButtonSelector | null,\n      frame: number) {\n    super();\n    \n    Revival.addRevivalLabel(this);\n\n    this.id = relationId;\n    this.selector = selector;\n    this.selectorVersion = selectorVersion;\n    this.excludeFirst = excludeFirst;\n    this.columns = columns;\n    this.demonstrationTimeRelation = demonstrationTimeRelation;\n    this.numRowsInDemo = numRowsInDemo;\n    this.pageVarName = pageVarName;\n    this.url = url;\n    this.nextType = nextType;\n    this.nextButtonSelector = nextButtonSelector;\n\n    // note that right now this frame comes from our relation-finding stage.\n    //   might want it to come from record\n    this.frame = frame;\n\n    if (!name) {\n      Relation.counter += 1;\n      this.name = \"list_\" + Relation.counter;\n    } else {\n      this.name = name;\n    }\n\n    HelenaConsole.log(this);\n    this.processColumns();\n    this.updateFirstRowInfo();\n\n    this.getRowsCounter = 0;\n    this.doneArray = [];\n    this.relationItemsRetrieved = {};\n    this.missesSoFar = {};\n\n    this.getNextRowCounter = 0;\n  }\n\n  public static createDummy() {\n    return new Relation(\"\", \"\", {}, 1, 0, [], [], 0, \"\", \"\", 1, null, 0);\n  }\n\n  public demonstrationTimeRelationText() {\n    return this.demonstrationTimeRelation.map(\n      (row: MainpanelNode.Interface[]) => {\n        return row.map(\n          (cell: MainpanelNode.Interface) => cell.text? cell.text : \"undefined\");\n      }\n    );\n  }\n\n  public firstRowNodeRepresentations() {\n    return this.demonstrationTimeRelation[0];\n  }\n\n  public nodeVariables() {\n    if (!this.nodeVars || this.nodeVars.length < 1) {\n      this.nodeVars = [];\n      const nodeReps = this.firstRowNodeRepresentations();\n      for (let i = 0; i < nodeReps.length; i++) {\n        const name = this.columns[i].name;\n        if (!name) {\n          throw ReferenceError(\"Column has no name.\");\n        }\n        this.nodeVars.push(new NodeVariable(name, nodeReps[i], null, null,\n          NodeSources.RELATIONEXTRACTOR));\n      }\n    }\n    return this.nodeVars;\n  }\n\n  public updateNodeVariables(environment: Environment.Frame,\n      pageVar: PageVariable) {\n    HelenaConsole.log(\"updateNodeVariables Relation\");\n    const nodeVariables = this.nodeVariables();\n    const columns = this.columns; // again, nodeVariables and columns must be aligned\n    for (let i = 0; i < columns.length; i++) {\n      let currNodeRep = this.getCurrentNodeRep(pageVar, columns[i]);\n      nodeVariables[i].setCurrentNodeRep(environment, currNodeRep);\n    }\n    HelenaConsole.log(\"updateNodeVariables Relation completed\");\n  }\n\n  public processColumns(oldColumns?: IColumnSelector[]) {\n    for (let i = 0; i < this.columns.length; i++) {\n      // should later look at whether this index is good enough\n      this.processColumn(this.columns[i], i, oldColumns);\n    }\n  };\n\n  private processColumn(colObject: IColumnSelector, index: number,\n    oldColObjects?: IColumnSelector[]) {\n    let oldColObject;\n    if (colObject.name === null || colObject.name === undefined) {\n      // a filler name that we'll use for now\n      colObject.name = `${this.name}_item_${(index+1)}`;\n      if (oldColObjects) {\n        if (!colObject.xpath) {\n          throw new ReferenceError(\"Column object has no XPath.\");\n        }\n\n        // let's search the old col objects, see if any share an xpath and have\n        //   a name for us\n        oldColObject = <IColumnSelector> findByXpath(oldColObjects,\n          colObject.xpath);\n        if (oldColObject) {\n          colObject.name = oldColObject.name;\n        }\n      }\n    }\n\n    // let's keep track of whether it's scraped by the current program\n    if (colObject.scraped === undefined) {\n      if (oldColObject) {\n        colObject.scraped = oldColObject.scraped;\n      } else {\n        colObject.scraped = false;\n      }\n    }\n    \n    if (this.demonstrationTimeRelation[0]) {\n      if (!colObject.xpath) {\n        throw new ReferenceError(\"Column object has no XPath.\");\n      }\n      // for now we're aligning the demonstration items with everything else via\n      //   xpath.  may not always be best\n      let firstRowCell = <MainpanelNode.Interface> findByXpath(\n        this.demonstrationTimeRelation[0], colObject.xpath);\n      if (!firstRowCell && colObject.xpath.toLowerCase().includes(\"/option[\")) {\n        // we're in the weird case where we interacted with a pulldown.  assume\n        //   the options remain the same even though we never recorded the\n        //   option during record-time\n        // only one column for pulldown menus\n        firstRowCell = this.demonstrationTimeRelation[0][0];\n      }\n      if (firstRowCell) {\n        colObject.firstRowXpath = firstRowCell.xpath;\n        colObject.firstRowText = firstRowCell.text;\n        colObject.firstRowValue = firstRowCell.value;\n      }\n    }\n    colObject.index = index.toString();\n  }\n\n  private updateFirstRowInfo() {\n    if (this.demonstrationTimeRelation.length === 0) {\n      return;\n    }\n\n    this.firstRowXPaths = this.demonstrationTimeRelation[0].map(\n      (cell) => cell.xpath? cell.xpath : \"undefined\"\n    );\n    this.firstRowTexts = this.demonstrationTimeRelation[0].map(\n      (cell) => cell.text? cell.text : \"undefined\"\n    );\n    this.firstRowValues = this.demonstrationTimeRelation[0].map(\n      (cell) => <string> cell.value\n    );\n  }\n\n  public setNewAttributes(selector: GenericFeatureSet | GenericFeatureSet[],\n    selectorVersion: number, excludeFirst: number,\n    columns: IColumnSelector[],\n    demonstrationTimeRelation: MainpanelNode.Interface[][],\n    numRowsInDemo: number, nextType: number,\n    nextButtonSelector: INextButtonSelector | null) {\n      this.selector = selector;\n      this.selectorVersion = selectorVersion;\n      this.excludeFirst = excludeFirst;\n      this.demonstrationTimeRelation = demonstrationTimeRelation;\n      this.numRowsInDemo = numRowsInDemo;\n      this.nextType = nextType;\n      this.nextButtonSelector = nextButtonSelector;\n\n      this.updateFirstRowInfo();\n\n      // now let's deal with columns.  recall we need the old ones, since they\n      //   might have names we need\n      const oldColumns = this.columns;\n      this.columns = columns;\n      this.processColumns(oldColumns);\n  }\n\n  public messageRelationRepresentation(): RelationMessage {\n    return {\n      id: this.id, \n      name: this.name, \n      selector: this.selector, \n      selector_version: this.selectorVersion, \n      exclude_first: this.excludeFirst, \n      columns: this.columns, \n      next_type: this.nextType, \n      next_button_selector: this.nextButtonSelector, \n      url: this.url, \n      num_rows_in_demonstration: this.numRowsInDemo,\n      relation_scrape_wait: this.relationScrapeWait\n    };\n  }\n\n  public getPrinfo(pageVar: PageVariable) {\n    return pageVar.pageRelations[this.name + \"_\" + this.id];\n  }\n  \n  public setPrinfo(pageVar: PageVariable, val: PageRelation) {\n    pageVar.pageRelations[this.name + \"_\" + this.id] = val;\n  }\n\n  public noMoreRows(runObject: RunObject, pageVar: PageVariable,\n    callback: Function, allowMoreNextInteractions: boolean) {\n    // first let's see if we can try running the next interaction again to get\n    //   some fresh stuff.  maybe that just didn't go through?\n    let maxNextButtonAttempts = runObject.program.nextButtonAttemptsThreshold;\n    if (maxNextButtonAttempts === undefined) {\n      maxNextButtonAttempts = HelenaConfig.nextButtonAttemptsThreshold;\n    }\n    const prinfo = this.getPrinfo(pageVar);\n    if (allowMoreNextInteractions &&\n      prinfo.currentNextInteractionAttempts < maxNextButtonAttempts) {\n      HelenaConsole.log(\"ok, we're going to try calling getNextRow again,\" +\n        \" running the next interaction again. currentNextInteractionAttempts: \"+\n        prinfo.currentNextInteractionAttempts);\n      // so that we don't fall back into trying to grab rows from current page\n      //   when what we really want is to run the next interaction again.\n      prinfo.runNextInteraction = true;\n      this.getNextRow(runObject, pageVar, callback);\n    } else {\n      // no more rows -- let the callback know we're done\n      // clear the stored relation data also\n      prinfo.currentRows = null;\n      HelenaConsole.namedLog(\"prinfo\", \"changing prinfo.currentrows, setting to null bc no more rows\");\n      HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n      prinfo.currentRowsCounter = 0;\n      prinfo.currentNextInteractionAttempts = 0;\n      callback(false); \n    }\n  }\n\n  public gotMoreRows(pageVar: PageVariable, callback: Function,\n    rel: MainpanelNode.Interface[][]) {\n    const prinfo = this.getPrinfo(pageVar);\n    // so that we don't fall back into this same case even though we now have\n    //   the items we want\n    prinfo.needNewRows = false;\n    prinfo.currentRows = rel;\n    HelenaConsole.namedLog(\"prinfo\", \"changing prinfo.currentrows, \" +\n      \"setting to rel bc found more rows\", rel);\n    HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n    prinfo.currentRowsCounter = 0;\n    prinfo.currentNextInteractionAttempts = 0;\n    callback(true);\n  }\n\n  // the function that we'll call when we actually have to go back to a page for freshRelationItems\n  private getRowsFromPageVar(runObject: RunObject, pageVar: PageVariable,\n    callback: Function) {\n    \n    const self = this;\n    if (!pageVar.currentTabId()) {\n      console.warn(\"Hey!  How'd you end up trying to find a \" +\n       \"relation on a page for which you don't have a current tab id?? \" +\n       \"That doesn't make sense.\", pageVar);\n    }\n\n    this.getRowsCounter += 1;\n    this.doneArray.push(false);\n    \n    // once we've gotten data from any frame, this is the function we'll call to\n    //   process all the results\n    const handleNewRelationItemsFromFrame = (data: FreshRelationItemsMessage,\n        frameId: number) => {\n      const currentGetRowsCounter = self.getRowsCounter;\n      if (self.doneArray[currentGetRowsCounter]) {\n        return;\n      }\n\n      if (self.relationItemsRetrieved[frameId]) {\n        // we actually already have data from this frame.  this can happen\n        //   because pages are still updating what they're showing but it's a\n        //   bit of a concern.  let's see what the data actually is, \n        // todo: we should make sure we're not totally losing data because of\n        //   overwriting old data with new data, then only processing the new\n        //   data...\n        HelenaConsole.namedLog(\"getRelationItems\", \"Got data from a frame\" +\n          \" for which we already have data\", self.getRowsCounter);\n        HelenaConsole.namedLog(\"getRelationItems\", _.isEqual(data,\n          self.relationItemsRetrieved[frameId]), data,\n          self.relationItemsRetrieved[frameId]);\n        // we definitely don't want to clobber real new items with anything\n        //   that's not new items, so let's make sure we don't\n        if (self.relationItemsRetrieved[frameId].type ===\n              ScrapedRelationState.NEW_ITEMS &&\n            data.type !== ScrapedRelationState.NEW_ITEMS) {\n          return;\n        }\n        // we also don't want to clobber if the old data is actually longer than\n        //   the new data...\n        // if we have long data, it's a little weird that we wouldn't just have\n        //   accepted it and moved on, but it does happen...\n        if (self.relationItemsRetrieved[frameId].type ===\n              ScrapedRelationState.NEW_ITEMS &&\n            data.type === ScrapedRelationState.NEW_ITEMS &&\n            self.relationItemsRetrieved[frameId].relation.length >\n              data.relation.length) {\n          HelenaConsole.namedLog(\"getRelationItems\", \"The new data is \" +\n            \"also new items, but it's shorter than the others, so we're \" +\n            \"actually going to throw it away for now.  May be something to \" +\n            \"change later.\");\n          return;\n        }\n      }\n\n      HelenaConsole.log(\"data\", data);\n      if (data.type === ScrapedRelationState.NO_MORE_ITEMS) {\n        // NOMOREITEMS -> definitively out of items.\n        //   this frame says this relation is done\n        // to stop us from continuing to ask for freshitems\n        self.relationItemsRetrieved[frameId] = data;\n        HelenaConsole.namedLog(\"getRelationItems\", \"We're giving up on \" +\n          \"asking for new items for one of \",\n          Object.keys(self.relationItemsRetrieved).length, \" frames. frameId: \",\n          frameId, self.relationItemsRetrieved, self.missesSoFar);\n      } else if (data.type === ScrapedRelationState.NO_NEW_ITEMS_YET ||\n        (data.type === ScrapedRelationState.NEW_ITEMS &&\n          data.relation.length === 0)) {\n        // todo: currently if we get data but it's only 0 rows, it goes here.  is that just an unnecessary delay?  should we just believe that that's the final answer?\n        self.missesSoFar[frameId] += 1;\n        HelenaConsole.namedLog(\"getRelationItems\",\n          \"adding a miss to our count\", frameId, self.missesSoFar[frameId]);\n      } else if (data.type === ScrapedRelationState.NEW_ITEMS) {\n        // yay, we have real data!\n\n        // ok, the content script is supposed to prevent us from getting the\n        //   same thing that it already sent before but to be on the safe side,\n        //   let's put in some extra protections so we don't try to advance too\n        //   early and also so we don't get into a case where we keep getting\n        //   the same thing over and over and should decide we're done but\n        //   instead loop forever\n        \n        function extractUserVisibleAttributesFromRelation(\n          rel: MainpanelNode.Interface[][]) {\n            return rel.map((row) => row.map((d) => [d.text, d.link]));\n        }\n\n        const prinfo = self.getPrinfo(pageVar);\n\n        if (prinfo.currentRows &&\n            _.isEqual(\n              extractUserVisibleAttributesFromRelation(prinfo.currentRows), \n              extractUserVisibleAttributesFromRelation(data.relation))) {\n          HelenaConsole.namedLog(\"getRelationItems\", \"This really \" +\n            \"shouldn't happen.  We got the same relation back from the \" +\n            \"content script that we'd already gotten.\");\n          HelenaConsole.namedLog(\"getRelationItems\", prinfo.currentRows);\n          self.missesSoFar[frameId] += 1;\n        } else {\n          HelenaConsole.log(\"The relations are different.\");\n          HelenaConsole.log(prinfo.currentRows, data.relation);\n          HelenaConsole.namedLog(\"getRelationItems\", currentGetRowsCounter,\n            data.relation.length);\n\n          // to stop us from continuing to ask for freshitems\n          self.relationItemsRetrieved[frameId] = data;\n\n          // let's see if this one has xpaths for all of a row in the first few\n          const aRowWithAllXpaths =\n            highestPercentOfHasXpathPerRow(data.relation, 20) === 1;\n          \n          // and then see if the difference between the num rows and the\n          //   target num rows is less than 90% of the target num rows \n          const targetNumRows = self.demonstrationTimeRelation.length;\n          const diffPercent =\n            Math.abs(data.relation.length - targetNumRows) / targetNumRows;\n          \n          // only want to do the below if we've decided this is the actual data\n          //   if this is the only frame, then it's definitely the data\n          if (Object.keys(self.relationItemsRetrieved).length == 1 ||\n              (aRowWithAllXpaths && diffPercent < .9)) {\n            self.doneArray[self.getRowsCounter] = true;\n            self.gotMoreRows(pageVar, callback, data.relation);\n            return;\n          }\n        }\n      } else {\n        HelenaConsole.log(\"There's freshRelationItems with unknown type.\");\n      }\n\n      // so?  are we done?  if all frames indicated that there are no more, then\n      //   we just need to stop because the page tried using a next button,\n      //   couldn't find one, and just won't be getting us more data\n\n      // false should be the value if all frames said NOMOREITEMS\n      let stillPossibleMoreItems = false;\n      for (const key in self.relationItemsRetrieved) {\n        const obj = self.relationItemsRetrieved[key];\n        if (!obj || obj.type !== ScrapedRelationState.NO_MORE_ITEMS) {\n          // ok, there's some reason to think it might be ok, so let's actually\n          //   go ahead and try again\n          stillPossibleMoreItems = true;\n        }\n      }\n      if (!stillPossibleMoreItems) {\n        HelenaConsole.namedLog(\"getRelationItems\",\n          \"all frames say we're done\", self.getRowsCounter);\n        self.doneArray[self.getRowsCounter] = true;\n        \n        // false because shouldn't try pressing the next button\n        self.noMoreRows(runObject, pageVar, callback, false);\n      } else {\n        HelenaConsole.namedLog(\"getRelationItems\", \"we think we might \" +\n          \"still get rows based on some frames not responding yet\");\n      }\n    }\n\n    function processEndOfCurrentGetRows(pageVar: PageVariable,\n      callback: Function) {\n      HelenaConsole.namedLog(\"getRelationItems\",\n        \"processEndOfCurrentGetRows\", self.getRowsCounter);\n      \n      // ok, we have 'real' (NEWITEMS or decided we're done) data for all of\n      //   them, we won't be getting anything new, better just pick the best one\n      self.doneArray[self.getRowsCounter] = true;\n      const dataObjs = Object.keys(self.relationItemsRetrieved).map(\n        (key) => self.relationItemsRetrieved[key]\n      );\n      const dataObjsFiltered = dataObjs.filter(\n        (data) => data.type === ScrapedRelationState.NEW_ITEMS\n      );\n      \n      // ok, let's see whether any is close in length to our original one.\n      //   otherwise have to give up. how should we decide whether to accept\n      //   something close or to believe it's just done???\n\n      for (const data of dataObjsFiltered) {\n        // let's see if this one has xpaths for all of a row in the first few\n        const percentColumns = highestPercentOfHasXpathPerRow(data.relation, 20);\n        \n        // and then see if the difference between the num rows and the target\n        //   num rows is less than 20% of the target num rows \n        const targetNumRows = self.demonstrationTimeRelation.length;\n        const diffPercent =\n          Math.abs(data.relation.length - targetNumRows) / targetNumRows;\n        if (percentColumns > .5 && diffPercent < .3) {\n          HelenaConsole.namedLog(\"getRelationItems\",\n            \"all defined and found new items\", self.getRowsCounter);\n          self.doneArray[self.getRowsCounter] = true;\n          self.gotMoreRows(pageVar, callback, data.relation);\n          return;\n        }\n      }\n\n      // drat, even with our more flexible requirements, still didn't find one\n      //   that works.  guess we're done?\n\n      HelenaConsole.namedLog(\"getRelationItems\",\n        \"all defined and couldn't find any relation items from any frames\",\n        self.getRowsCounter);\n      self.doneArray[self.getRowsCounter] = true;\n\n      // true because should allow trying the next button\n      self.noMoreRows(runObject, pageVar, callback, true);\n    }\n\n    // let's go ask all the frames to give us relation items for the relation\n    const tabId = pageVar.currentTabId();\n\n    function requestFreshRelationItems(frames: number[]) {\n      const currentGetRowsCounter = self.getRowsCounter;\n      self.relationItemsRetrieved = {};\n      self.missesSoFar = {};\n      for (const frame of frames) {\n        // keep track of which frames need to respond before we'll be ready to\n        //   advance\n        delete self.relationItemsRetrieved[frame];\n        self.missesSoFar[frame] = 0;\n      }\n      for (const frame of frames) {\n        // for each frame in the target tab, we want to see if the frame\n        //   retrieves good relation items. we'll pick the one we like best\n        // todo: is there a better way?  after all, we do know the frame in\n        //   which the user interacted with the first page at original\n        //   record-time.  if we have next stuff happening, we might even know\n        //   the exact frameId on this exact page\n        \n        // here's the function for sending the message once\n        const sendGetRelationItems = () => {\n          HelenaConsole.namedLog(\"getRelationItems\",\n            \"requesting relation items\", currentGetRowsCounter);\n          Messages.sendFrameSpecificMessage(\"mainpanel\", \"content\",\n            \"getFreshRelationItems\", self.messageRelationRepresentation(), \n            <number> tabId, frame, (msg: FreshRelationItemsMessage) => {\n              // question: is it ok to insist that every single frame returns a\n              //   non-null one?  maybe have a timeout?  maybe accept once we\n              //   have at least one good response from one of the frames?\n              HelenaConsole.namedLog(\"getRelationItems\",\n                \"Receiving response: \", frame, msg); \n              HelenaConsole.namedLog(\"getRelationItems\",\n                \"getFreshRelationItems answer\", msg);\n              \n              // when get response, call handleNewRelationItemsFromFrame\n              //   (defined above) to pick from the frames' answers\n              if (msg !== null && msg !== undefined) {\n                handleNewRelationItemsFromFrame(msg, frame);\n              }\n            }\n          );\n        }\n        // here's the function for sending the message until we decide we're\n        //   done with the current attempt to get new rows, or until actually\n        //   get the answer\n        MiscUtilities.repeatUntil(sendGetRelationItems, () => {\n          return self.doneArray[currentGetRowsCounter] ||\n                 self.relationItemsRetrieved[frame];\n        }, () => {}, 1000, true);\n      }\n\n      // and let's make sure that after our chosen timeout, we'll stop and just\n      //   process whatever we have\n      let desiredTimeout = runObject.program.relationFindingTimeoutThreshold;\n      if (!desiredTimeout) {\n        desiredTimeout = HelenaConfig.relationFindingTimeoutThreshold;\n      }\n      // todo: this timeout should be configurable by the user, relation seconds\n      //   timeout\n      \n      setTimeout(() => {\n        HelenaConsole.namedLog(\"getRelationItems\",\n          \"TIMEOUT, giving up on currentGetRows\", currentGetRowsCounter);\n        if (!self.doneArray[currentGetRowsCounter]) {\n          self.doneArray[currentGetRowsCounter] = false;\n          processEndOfCurrentGetRows(pageVar, callback);\n        }\n      }, desiredTimeout);\n    }\n\n    // if we're trying to get relation items from a page, we should have it\n    //   visible\n    if (!tabId) {\n      throw new ReferenceError(\"Tab ID is undefined.\");\n    }\n    chrome.tabs.update(tabId, { selected: true });\n\n    // ok, let's figure out whether to send the message to all frames in the tab\n    //   or only the top frame\n    if (self.frame === 0) {\n      // for now, it's only when the frame index is 0, meaning it's the\n      //   top-level frame, that we decide on using a single frame ahead of time\n      requestFreshRelationItems([0]);\n    } else {\n      chrome.webNavigation.getAllFrames({ tabId: tabId }, (details) => {\n        const frames = details?.map((d) => d.frameId);\n        if (frames) {\n          requestFreshRelationItems(frames);\n        }\n      });\n    }\n  }\n\n  public endOfLoopCleanup(pageVar: PageVariable, continuation: Function) {\n    const self = this;\n\n    // if we're not closing this page and we want to iterate through this\n    //   relation again, it's critical that we clear out all the stuff that's\n    //   stored about the relation now\n    let gotAck = false;\n    Messages.listenForMessageOnce(\"content\", \"mainpanel\",\n      \"clearedRelationInfo\", () => {\n        gotAck = true;\n        continuation();\n    });\n\n    const currentTabId = pageVar.currentTabId();\n    if (currentTabId) {\n      MiscUtilities.repeatUntil(() => {\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"clearRelationInfo\", self.messageRelationRepresentation(), undefined,\n          undefined, [currentTabId]);\n      }, () => gotAck, () => {}, 1000, false);\n    } else {\n      continuation();\n    }\n  }\n\n  // has to be called on a page, since a relation selector can be applied to\n  //   many pages. higher-level tool must control where to apply\n  public getNextRow(runObject: RunObject, pageVar: PageVariable,\n      callback: Function) {\n    const self = this;\n\n    // ok, what's the page info on which we're manipulating this relation?\n    HelenaConsole.log(pageVar.pageRelations);\n\n    // separate relations can have same name (no rule against that) and same id\n    //   (undefined if not yet saved to server), but since we assign unique\n    //   names when not saved to server and unique ides when saved to server,\n    //   should be rare to have same both.  todo: be more secure in future\n    let prinfo = this.getPrinfo(pageVar);\n    HelenaConsole.namedLog(\"prinfo\",\n      \"change prinfo, finding it for getnextrow\", this.name, this.id);\n    HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n\n    // if we haven't seen the frame currently associated with this pagevar, need\n    //   to clear our state and start fresh\n    if (prinfo === undefined) {\n      // TODO: prinfo type sep\n      prinfo = {\n        currentRows: null,\n        currentRowsCounter: 0,\n        currentTabId: pageVar.currentTabId(),\n        currentNextInteractionAttempts: 0\n      };\n      this.setPrinfo(pageVar, prinfo);\n      HelenaConsole.namedLog(\"prinfo\",\n        \"change prinfo, prinfo was undefined\", this.name, this.id);\n      HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n    }\n\n    // now that we have the page info to manipulate, what do we need to do to get the next row?\n    HelenaConsole.log(\"getnextrow\", this, prinfo.currentRowsCounter);\n    if ((prinfo.currentRows === null || prinfo.needNewRows) &&\n        !prinfo.runNextInteraction) {\n      // cool!  no data right now, so we have to go to the page and ask for some\n      this.getRowsFromPageVar(runObject, pageVar, callback);\n    } else if ((prinfo.currentRows &&\n                prinfo.currentRowsCounter + 1 >= prinfo.currentRows.length) ||\n              prinfo.runNextInteraction) {\n      // have to turn that flag back off so we don't fall back into here after\n      //   running the next interaction\n      prinfo.runNextInteraction = false;\n      self.getNextRowCounter += 1;\n      // ok, we had some data but we've run out.  time to try running the next\n      //   button interaction and see if we can retrieve some more\n\n      // the one exception, the case where we don't even want to bother asking\n      //   the page is if we already know. there's no next button, no way to get\n      //   additional pages.  in that case, just know the loop is done and call\n      //   the callback with false as the moreRows argument\n      if (!this.nextButtonSelector &&\n           this.nextType !== NextButtonTypes.SCROLLFORMORE) {\n        callback(false);\n        return;\n      }\n\n      // the function for continuing once we've done a next interaction\n      const continueWithANewPage = () => {\n        // cool, and now let's start the process of retrieving fresh items by\n        //   calling this function again\n        prinfo.needNewRows = true;\n        self.getNextRow(runObject, pageVar, callback);\n      }\n\n      // here's what we want to do once we've actually clicked on the next\n      //   button, more button, etc\n      // essentially, we want to run getNextRow again, ready to grab new data\n      //   from the page that's now been loaded or updated\n      let stopRequestingNext = false;\n      Messages.listenForMessageOnce(\"content\", \"mainpanel\",\n        \"runningNextInteraction\", () => {\n        const currentGetNextRowCounter = self.getNextRowCounter;\n        HelenaConsole.namedLog(\"getRelationItems\", currentGetNextRowCounter,\n          \"got nextinteraction ack\");\n        prinfo.currentNextInteractionAttempts += 1;\n        HelenaConsole.log(\"we've tried to run the get next interaction \" +\n          \"again, got an acknowledgment, so now we'll stop requesting next\");\n        stopRequestingNext = true;\n        continueWithANewPage();\n      });\n\n      Messages.listenForMessageOnce(\"content\", \"mainpanel\",\n        \"nextButtonText\", (data: NextButtonTextMessage) => {\n          self.currNextButtonText = data.text;\n      });\n\n\n      // here's us telling the content script to take care of clicking on the\n      //   next button, more button, etc\n      if (!pageVar.currentTabId()) {\n        HelenaConsole.log(\"Hey!  How'd you end up trying to click next \" +\n        \"button on a page for which you don't have a current tab id?? \" +\n        \"That doesn't make sense.\", pageVar);\n      }\n      const startRequestNextInteraction = (new Date()).getTime();\n\n      // 2 minutes timeout for when we just try reloading the page;\n      //   todo: is this something we even hit?\n      const relationFindingTimeout = 120000;\n      const sendRunNextInteraction = () => {\n        HelenaConsole.log(\"we're trying to send a next interaction again\");\n        const currTime = (new Date()).getTime();\n        // let's check if we've hit our timeout\n        if ((currTime - startRequestNextInteraction) > relationFindingTimeout) {\n          // ok, we've crossed the threshold time and the next button still\n          //   didn't work.  let's try refreshing the tab\n          HelenaConsole.log(\"we crossed the time out between when we \" +\n            \"started requesting the next interaction and now. \" +\n            \"we're going to try refreshing\");\n          stopRequestingNext = true;\n\n          const tabId = pageVar.currentTabId();\n          if (!tabId) {\n            throw new ReferenceError(\"tabId is undefined.\");\n          }\n          chrome.tabs.get(tabId, () => {\n            if (chrome.runtime.lastError) {\n              // tab doesn't actually even exist. the only way we could continue\n              //   is just restart from the beginning because this is a list\n              //   page.  so we just don't know what else to do\n              console.log(chrome.runtime.lastError.message);\n              console.warn(\"No idea what to do, so we're breaking\" +\n                \" -- a list page just wasn't present, so didn't know what to\" +\n                \" do next.\");\n              return;\n            } else {\n                HelenaConsole.log(\"refreshing the page now.\");\n                // Tab exists.  so we can try reloading it, see how it goes\n                chrome.tabs.reload(tabId, {}, () => {\n                  // ok, good, it's reloaded.  ready to go on with normal\n                  //   processing as though this reloaded page is our new page\n                  continueWithANewPage();\n                });\n            }\n          });\n        }\n        // ok, haven't hit the timeout so just keep trying the next interaction\n        const currentGetNextRowCounter = self.getNextRowCounter;\n        HelenaConsole.namedLog(\"getRelationItems\", currentGetNextRowCounter,\n          \"requestNext\");\n        const msg = self.messageRelationRepresentation();\n        msg.prior_next_button_text = self.currNextButtonText;\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"runNextInteraction\", msg, undefined, undefined,\n          [ <number> pageVar.currentTabId() ]);};\n      MiscUtilities.repeatUntil(sendRunNextInteraction,\n        () => stopRequestingNext, () => {}, 17000, false);\n    } else {\n      // we still have local rows that we haven't used yet. just advance the\n      //   counter to change which is our current row\n      // the easy case :)\n      prinfo.currentRowsCounter += 1;\n      callback(true);\n    }\n  }\n\n  public getCurrentNodeRep(pageVar: PageVariable,\n    columnObject: IColumnSelector) {\n    const prinfo = pageVar.pageRelations[this.name + \"_\" + this.id]\n    HelenaConsole.namedLog(\"prinfo\",\n      \"change prinfo, finding it for getCurrentNodeRep\", this.name, this.id);\n    HelenaConsole.namedLog(\"prinfo\", shortPrintString(prinfo));\n\n    if (prinfo === undefined) {\n      HelenaConsole.log(\"Bad!  Shouldn't be calling getCurrentLink on a \" +\n        \"pageVar for which we haven't yet called getNextRow.\");\n      return null;\n    }\n    if (prinfo.currentRows === undefined) {\n      HelenaConsole.log(\"Bad!  Shouldn't be calling getCurrentLink on a \" +\n        \"prinfo with no currentRows.\", prinfo);\n        return null;\n    }\n    if (prinfo.currentRows === null) {\n      HelenaConsole.namedLog(\"prinfo\", \"the bad state\");\n      return null;\n    }\n    if (prinfo.currentRows[prinfo.currentRowsCounter] === undefined) {\n      HelenaConsole.log(\"Bad!  Shouldn't be calling getCurrentLink on a \" +\n        \"prinfo with a currentRowsCounter that doesn't correspond to a row \" +\n        \"in currentRows.\", prinfo);\n      return null;\n    }\n    if (columnObject.index === undefined) {\n      throw new ReferenceError(\"No column index set.\");\n    }\n    // in the current row, value at the index associated with nodeName\n    return prinfo.currentRows[prinfo.currentRowsCounter][parseInt(columnObject.index)];\n  }\n\n  public saveToServer() {\n    HelenaServer.saveRelation({ relation: this.convertToJSON() }, () => {});\n  }\n\n  /**\n   * Could not name this `toJSON` because JSOG treats objects with `toJSON`\n   *   methods in a special way.\n   */\n  public convertToJSON: () => RelationMessage = () => {\n    // ok, first let's get the nice dictionary-looking version that we use for\n    //   passing relations around, instead of our internal object representation\n    //   that we use in the mainpanel/program\n    const relationDict = this.messageRelationRepresentation();\n    // let's start by deep copying so that we can JSONify the selector,\n    //   next_button_selector, and column suffixes without messing up the real\n    //   object\n    const relation = JSON.parse(JSON.stringify(relationDict)); // deepcopy\n  \n    // now that it's deep copied, we can safely strip out jsog stuff that we\n    //   don't want in there, since it will interfere with our canonicalization\n    //   process\n    MiscUtilities.removeAttributeRecursive(relation, \"__jsogObjectId\");\n    relation.selector = stringify(relation.selector);\n    relation.next_button_selector = stringify(relation.next_button_selector);\n    for (const column of relation.columns) {\n      // is this the best place to deal with going between our object attributes\n      //   and the server strings?\n      column.suffix = stringify(column.suffix);\n    }\n    HelenaConsole.log(\"relation after jsonification\", relation);\n    return relation;\n  }\n}\n\n\nfunction shortPrintString(obj: object) {\n  if (!obj) {\n    return JSON.stringify(obj);\n  }\n  else{\n    return JSON.stringify(obj).substring(0,20);\n  }\n}\n\nfunction domain(url: string) {\n  let domain = \"\";\n  // don't need http and so on\n  if (url.indexOf(\"://\") > -1) {\n    domain = url.split('/')[2];\n  }\n  else {\n    domain = url.split('/')[0];\n  }\n  // there can be site.com:1234 and we don't want that\n  domain = domain.split(':')[0];\n  return domain;\n}\n\nfunction findByXpath(\n  objectList: (IColumnSelector | MainpanelNode.Interface)[],\n  xpath: string) {\n    const objs = objectList.filter((obj) => obj.xpath === xpath);\n    if (objs.length === 0) { return null; }\n    return objs[0];\n}\n\nfunction highestPercentOfHasXpathPerRow(relation: MainpanelNode.Interface[][],\n  limitToSearch: number) {\n  if (relation.length < limitToSearch) {\n    limitToSearch = relation.length;\n  }\n  let maxWithXpathsPercent = 0;\n  for (let i = 0; i < limitToSearch; i++) {\n    let numWithXpaths = relation[i].reduce((acc, cell) => {\n      if (cell.xpath) {\n        return acc + 1;\n      } else {\n        return acc\n      }\n    }, 0);\n    let percentWithXpaths = numWithXpaths / relation[i].length;\n    if (percentWithXpaths > maxWithXpathsPercent) {\n      maxWithXpathsPercent = percentWithXpaths;\n    }\n  }\n  return maxWithXpathsPercent;\n}\n","import { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { NodeSources, NodeVariable } from \"../variables/node_variable\";\nimport { GenericRelation } from \"./generic\";\nimport { PageVariable } from \"../variables/page_variable\";\nimport { RunObject } from \"../lang/program\";\nimport { Revival } from \"../revival\";\nimport { Environment } from \"../environment\";\nimport { IColumnSelector } from \"../../content/selector/interfaces\";\n\n// used for relations that only have text in cells, as when user uploads the relation\nexport class TextRelation extends GenericRelation {\n  private currentRowsCounter: number;\n  public relation: string[][];\n\n  constructor(csvFileContents?: string, name?: string) {\n    super();\n    Revival.addRevivalLabel(this);\n    \n    this.columns = [];\n\n    // we will sometimes initialize with undefined, as when reviving a saved\n    //   program\n    if (csvFileContents) {\n      this.relation = $.csv.toArrays(csvFileContents);\n      this.firstRowTexts = this.relation[0];\n      if (name) {\n        this.name = name;\n      }\n\n      this.processColumns();\n\n      // call this so that we make all of the node variables we'll need\n      this.nodeVariables();\n    }\n    this.currentRowsCounter = -1;\n  }\n\n  public static createDummy() {\n    return new TextRelation();\n  }\n\n  public demonstrationTimeRelationText() {\n    return this.relation;\n  }\n\n  public firstRowNodeRepresentations() {\n    return this.relation[0].map((text) => {\n      return { text: text };\n    });\n  }\n\n  public nodeVariables() {\n    const firstRowNodeReps = this.firstRowNodeRepresentations();\n    if (!this.nodeVars || this.nodeVars.length < 1) {\n      this.nodeVars = [];\n      for (let i = 0; i < this.columns.length; i++) {\n        const column = this.columns[i];\n        if (!column.name) {\n          throw new ReferenceError(\"Column has no name.\");\n        }\n        this.nodeVars.push(new NodeVariable(column.name, firstRowNodeReps[i],\n          null, null, NodeSources.TEXTRELATION));\n      }\n    }\n    return this.nodeVars;\n  }\n\n  public updateNodeVariables(environment: Environment.Frame,\n      pageVar: PageVariable) {\n    HelenaConsole.log(\"updateNodeVariables TextRelation\");\n    var nodeVariables = this.nodeVariables();\n    var columns = this.columns; // again, nodeVariables and columns must be aligned\n    for (let i = 0; i < columns.length; i++) {\n      const column = columns[i];\n      if (!column.index) {\n        throw new ReferenceError(\"Column index is undefined.\");\n      }\n      const text = this.relation[this.currentRowsCounter][parseInt(column.index)];\n      const currNodeRep = {text: text};\n      nodeVariables[i].setCurrentNodeRep(environment, currNodeRep);\n    }\n  }\n\n  public processColumns() {\n    for (let i = 0; i < this.relation[0].length; i++) {\n      this.columns.push({\n        index: i.toString(),\n        name: `column_${i}`,\n        firstRowText: this.firstRowTexts[i], // todo: don't want filler here\n        \n        // by default, assume we want to scrape all of a text relation's cols\n        //   (or else, why are they even here?)\n        scraped: true\n      });\n    }\n  }\n\n  public toJSON: () => string = () => {\n    const stringifiedTextRelation = JSON.stringify(this.relation);\n    return stringifiedTextRelation;\n  }\n\n  // has to be called on a page, to match the signature for the non-text\n  //   relations, but we'll ignore the pagevar\n  public getNextRow(runObject: RunObject, pageVar: PageVariable,\n      callback: Function) {\n    if (this.currentRowsCounter + 1 >= this.relation.length) {\n      callback(false); // no more rows -- let the callback know we're done\n    } else {\n      this.currentRowsCounter += 1;\n      callback(true);\n    }\n  }\n\n  public getCurrentCellsText() {\n    const cells = [];\n    for (let i = 0; i < this.columns.length; i++) {\n      if (this.columns[i].scraped) {\n        const cellText = this.getCurrentText(this.columns[i]);\n        cells.push(cellText);\n      }\n    }\n    return cells;\n  }\n\n  public getCurrentText(columnObject: IColumnSelector) {\n    if (!columnObject.index) {\n      throw new ReferenceError(\"Column object contains no index.\");\n    }\n\n    HelenaConsole.log(this.currentRowsCounter, \"currentRowsCounter\");\n    return this.relation[this.currentRowsCounter][parseInt(columnObject.index)];\n  };\n\n  public getCurrentLink(pageVar: PageVariable,\n    columnObject: IColumnSelector) {\n    HelenaConsole.log(\"yo, why are you trying to get a link from a text \" +\n      \"relation???\");\n    return \"\";\n  }\n\n  public clearRunningState() {\n    this.currentRowsCounter = -1;\n  }\n\n  public setRelationContents(relationContents: string[][]) {\n    this.relation = relationContents;\n  }\n\n  public getRelationContents() {\n    return this.relation;\n  }\n}","import * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../common/utils/helena_console\";\n\n/**\n * A very important set of utilities for reviving objects that have been\n *   stringified (as for sending to the server) but have returned to us, and\n *   need to be used as proper objects again.\n * We always store all the fields; it's the methods we lose. So we basically,\n *   when it comes time to revive it, want to union the attributes of the now\n *   unstringified dict and the prototype, grabbing the methods back from the\n *   prototype.\n */\nexport namespace Revival {\n  export interface Revivable {\n    ___revivalLabel___: string;\n    setAttributes?: (attrs: object) => void;\n  }\n  export type Prototype = {\n    new(...args: any[]): Revivable;\n    createDummy: () => Revivable;\n  };\n\n  export const revivalLabels: {\n    [key: string]: Prototype\n  } = {};\n\n  export function introduceRevivalLabel(label: string,\n      prototype: Prototype) {\n    revivalLabels[label] = prototype;\n  }\n\n  export function addRevivalLabel(object: Revivable) {\n    for (const prop in revivalLabels) {\n      if (object instanceof revivalLabels[prop]){\n        object.___revivalLabel___ = prop;\n        return;\n      }\n    }\n    HelenaConsole.log(\"No known revival label for the type of \" +\n      \"object:\", object);\n  }\n\n  export function revive(attrs: { [key: string]: any }){\n    // we're going to be handling circular objects, so have to keep track of\n    //   what we've already handled\n    const seen: { [key: string]: any }[] = [];\n    const fullSeen: { [key: string]: any }[] = [];\n\n    const reviveHelper = (attrs: { [key: string]: any }) => {\n      // ok, now let's figure out what kind of case we're dealing with\n      \n      // why is null even an object?\n      if (typeof attrs !== \"object\" || attrs === null) {\n        return attrs; // nothing to do here\n      } else if (seen.includes(attrs)){\n        // already seen it\n        const i = seen.indexOf(attrs);\n        return fullSeen[i]; // get the corresponding revived object\n      } else {\n        // ok, it's an object and we haven't processed it before\n        let fullObj = attrs;\n        if (attrs.___revivalLabel___) {\n          // ok, we actually want to revive this very object\n          const prototype = revivalLabels[attrs.___revivalLabel___];\n          fullObj = prototype.createDummy();\n          if (fullObj.setAttributes) {\n            fullObj.setAttributes(attrs);\n          } else {\n            _.extend(fullObj, attrs);\n          }\n          // now the fullObj is restored to having methods and such\n        }\n        seen.push(attrs);\n        fullSeen.push(fullObj);\n        // ok, whether we revived this obj or not, we definitely have to descend\n        for (const prop in attrs) {\n          const val = attrs[prop];\n          const fullVal = reviveHelper(val);\n\n          // must replace the old fields-only val with the proper object val\n          fullObj[prop] = fullVal;\n        }\n        return fullObj;\n      }\n    };\n    const obj = reviveHelper(attrs);\n    return obj;\n  };\n}","import * as Blockly from \"blockly\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { HelenaLangObject } from \"../lang/helena_lang\";\n\nexport namespace HelenaBlocks {\n  export function attachInputToOutput(left: Blockly.Block,\n      right: Blockly.Block) {\n    if (!left || !right) {\n      console.warn(\"Woah, tried attachInputToOutput with\", left,\n        right);\n      return;\n    }\n    const outputBlockConnection = right.outputConnection;\n    const inputBlockConnection = left.inputList[0].connection;\n    outputBlockConnection.connect(inputBlockConnection);\n  }\n\n  /**\n   * For things like loops that have bodies, attach the nested blocks\n   * @param wrapper \n   * @param firstBlock \n   */\n  export function attachNestedBlocksToWrapper(\n      wrapper: Blockly.Block | null,\n      firstBlock: Blockly.Block | null) {\n    if (!wrapper || !firstBlock) {\n      console.warn(\"Woah, tried attachNestedBlocksToWrapper with\",\n        wrapper, firstBlock);\n      return;\n    }\n    const parentConnection = wrapper.getInput('statements').connection;\n    const childConnection = firstBlock.previousConnection;\n    parentConnection.connect(childConnection);\n  }\n\n  export function attachToInput(left: Blockly.Block, right: Blockly.Block,\n      name: string) {\n    if (!left || !right || !name) {\n      console.warn(\"Woah, tried attachToInput with\", left,\n        right, name);\n      return;\n    }\n    const parentConnection = left.getInput(name).connection;\n    const childConnection = right.outputConnection;\n    parentConnection.connect(childConnection);\n  }\n\n  /**\n   * Attach the current block to the previous block.\n   * @param cur the current block\n   * @param prev the previous block.\n   */\n  export function attachToPrevBlock(cur: Blockly.Block, prev: Blockly.Block) {\n    if (cur && prev) {\n      const prevBlockConnection = prev.nextConnection;\n      const thisBlockConnection = cur.previousConnection;\n      prevBlockConnection.connect(thisBlockConnection);\n    } else {\n      console.warn(\"Woah, tried to attach to a null prevBlock!\");\n    }\n  }\n\n  export function helenaSeqToBlocklySeq(stmts: HelenaLangObject[],\n    workspace: Blockly.WorkspaceSvg) {\n    // get the individual statements to produce their corresponding blockly\n    //   blocks\n\n    // the one we'll ultimately return, in case it needs to be attached to\n    //   something outside\n    let firstNonNull = null;\n\n    let lastBlock = null;\n    let lastStatement = null;\n\n    let invisibleHead = [];\n\n    // for (var i = 0; i < statementsLs.length; i++) {\n    for (const stmt of stmts) {\n      const newBlock = stmt.genBlocklyNode(lastBlock, workspace);\n      // within each statement, there can be other program components that will\n      //   need blockly representations but the individual statements are\n      //   responsible for traversing those\n      if (newBlock !== null) {\n        // handle the fact that there could be null-producing nodes in the\n        //   middle, and need to connect around those\n        lastBlock = newBlock;\n        lastStatement = stmt;\n        lastStatement.invisibleHead = [];\n        lastStatement.invisibleTail = [];\n        // also, if this is our first non-null block it's the one we'll want to\n        //   return\n        if (!firstNonNull) {\n          firstNonNull = newBlock;\n          // oh, and let's go ahead and set that invisible head now\n          stmt.invisibleHead = invisibleHead;\n        }\n      } else {\n        // ok, a little bit of special stuff when we do have null nodes\n        // we want to still save them, even though we'll be using the blockly\n        //   code to generate future versions of the program so we'll need to\n        //   associate these invibislbe statements with others and then the only\n        //   thing we'll need to do is when we go the other direction\n        //   (blockly->helena)\n        // we'll have to do some special processing to put them back in the\n        //   normal structure\n        stmt.nullBlockly = true;\n\n        // one special case.  if we don't have a non-null lastblock, we'll have\n        //   to keep this for later\n        // we prefer to make things tails of earlier statements, but we can make\n        //   some heads if necessary\n        if (!lastBlock || !lastStatement) {\n          invisibleHead.push(stmt);\n        } else {\n          lastStatement.invisibleTail?.push(stmt);\n        }\n      }\n    }\n\n    if (!firstNonNull) {\n      throw new ReferenceError(\"Did not find any non-null blocks.\");\n    }\n\n    return firstNonNull;\n    // todo: the whole invisible head, invisible tail thing isn't going to be\n    //   any good if we have no visible statements in this segment.  So rare\n    //   that spending time on it now is probably bad, but should be considered\n    //   eventually\n  }\n}","import * as Blockly from \"blockly\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { HelenaMainpanel } from \"../helena_mainpanel\";\nimport { HelenaProgram } from \"../lang/program\";\n\nexport class HelenaUIBase {\n  private workspace?: Blockly.WorkspaceSvg;\n\n  private toolboxId?: string;\n  private blocklyAreaId?: string;\n  private blocklyDivId?: string;\n  private containerId?: string;\n  private helenaProg: HelenaProgram | null;\n\n  private maxWaitsForDivAppearance = 10;\n  private currWaitsForDivAppearance = 0;\n  \n  constructor() {\n    // TODO: cjbaik: cannot change this because it is imported. Is there a way\n    //   to change it globally other than forking the entire Blockly library??\n    // control blockly look and feel\n    // Blockly.HSV_SATURATION = 0.7;\n    // Blockly.HSV_VALUE = 0.97;\n  }\n\n  public setBlocklyDivIds(containerIdA: string, toolboxIdA: string,\n    blocklyAreaIdA: string, blocklyDivIdA: string) {\n    this.containerId = containerIdA;\n    this.toolboxId = toolboxIdA;\n    this.blocklyAreaId = blocklyAreaIdA;\n    this.blocklyDivId = blocklyDivIdA;\n  }\n\n  public setBlocklyProgram(helenaProgObj: HelenaProgram | null) {\n    this.helenaProg = helenaProgObj;\n    this.blocklyReadjustFunc();\n  }\n\n  private retrieveBlocklyComponent(componentId?: string) {\n    if (!componentId) {\n      return null;\n    }\n    let containerDiv = $($(\"#\" + this.containerId)[0]);\n    let componentDiv = containerDiv.find(\"#\" + componentId)[0];\n    return componentDiv;\n  }\n\n  public updateBlocklyToolbox() {\n    HelenaConsole.log(\"updateBlocklyToolbox\");\n    let toolboxDiv = this.retrieveBlocklyComponent(this.toolboxId);\n\n    if (!toolboxDiv) {\n      throw new ReferenceError(\"Could not get toolboxDiv.\");\n    }\n    let $toolboxDiv = $(toolboxDiv);\n\n    // before we can use the toolbox, we have to actually have all the relevant\n    //   blocks\n    window.helenaMainpanel.updateToolboxBlocks(this.helenaProg);\n    \n    $toolboxDiv.html(\"\");\n    for (const key in window.helenaMainpanel.blocklyLabels){\n      let bls = window.helenaMainpanel.blocklyLabels[key];\n      let $categoryDiv = $(\"<category name=\" + key + \">\");\n      for (let i = 0; i < bls.length; i++){\n        $categoryDiv.append($(\"<block type=\\\"\" + bls[i] + \"\\\"></block>\"));\n      }\n      $toolboxDiv.append($categoryDiv);\n    }\n    \n    if (this.workspace) {\n      this.workspace.updateToolbox($toolboxDiv[0]);\n    } else {\n      console.warn(\"Tried to update toolbox before the workspace \" +\n        \"was initialized (should be done with setUpBlocklyEditor).\");\n    }\n  }\n\n  private handleNewWorkspace() {\n    // let's handle a little bit of blockly workspace stuff\n    // specifically, we want to listen for any move events so that we can add new WAL statements to the loopy prog\n    // when they're dragged in from the toolbox\n    // todo: right now this only handles the case where a new block is dragged in from the toolbox\n    // eventually should handle the case where existing blocks are being rearranged\n    // and should keep in mind that the blocks mostly move in groupings, not just singly.  will have to test that\n\n    // todo: reminder that the below (for now) still doesn't handle adding a new statement to the beginning of a program\n    // because we focus on the block that moved rather than on the block towards which it moved...\n    // todo: also, what will happen when someone moves out a big slice, then tries to move out a smaller slice and add\n    // it to the already-taken-out slice?  it won't be in the root Helena program, so...we'll look for it and not find it\n    // probably should have a list of other segments?  yeah, let's do that?\n\n    const self = this;\n\n    function onBlockMove(event: Event) {\n      if (event.type === Blockly.Events.MOVE){\n        // this might have changed our program.  let's go ahead and update it\n        self.blocklyToHelena(self.helenaProg);\n      }\n      /* cjbaik: to the best of my knowledge, \"newblocklyblockdraggedin\"\n               doens't exist in the codebase\n      if (self.newBlocklyBlockDraggedIn && event.type === window.Blockly.Events.CREATE){\n        let createdBlock = self.workspace.getBlockById(event.blockId);\n        self.newBlocklyBlockDraggedIn(createdBlock);\n      }*/\n    }\n\n    this.workspace?.addChangeListener(onBlockMove);\n  }\n\n  public blocklyReadjustFunc() {\n    let blocklyArea = this.retrieveBlocklyComponent(this.blocklyAreaId);\n    let blocklyDiv = this.retrieveBlocklyComponent(this.blocklyDivId);\n    if (!blocklyArea || !blocklyDiv) {\n      return;\n    }\n    // compute the absolute coordinates and dimensions of blocklyArea.\n    let element = blocklyArea;\n    let x = 0;\n    let y = 0;\n    do {\n      x += element.offsetLeft;\n      y += element.offsetTop;\n      element = <HTMLElement> element.offsetParent;\n    } while (element);\n  \n    // Position blocklyDiv over blocklyArea.\n    blocklyDiv.style.left = x + 'px';\n    blocklyDiv.style.top = y + 'px';\n    blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';\n    blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';\n  };\n\n  public setUpBlocklyEditor(updateToolbox = true) {\n    HelenaConsole.log(\"handleBlocklyEditorResizing\");\n    let toolboxDiv = this.retrieveBlocklyComponent(this.toolboxId);\n    let blocklyArea = this.retrieveBlocklyComponent(this.blocklyAreaId);\n    let blocklyDiv = this.retrieveBlocklyComponent(this.blocklyDivId);\n    if (!blocklyArea || !blocklyDiv){\n      console.warn(\"Tried to set up the blockly editor display, but the blockly area or div not present now.\");\n      console.log(blocklyArea, blocklyDiv);\n      if (this.currWaitsForDivAppearance < this.maxWaitsForDivAppearance) {\n        setTimeout(this.setUpBlocklyEditor, 100);\n        this.currWaitsForDivAppearance += 1;\n      }\n      return;\n    }\n\n    this.workspace = Blockly.inject(blocklyDiv, {\n      toolbox: toolboxDiv? toolboxDiv : undefined\n    });\n    console.log(\"Updated workspace to:\", this.workspace);\n    this.handleNewWorkspace();\n\n    const self = this;\n    window.addEventListener('resize', () => self.blocklyReadjustFunc(), false);\n    this.blocklyReadjustFunc();\n    // the blockly thing hovers over a node, so it's important that we call its update function whenever that node may have moved\n    let observer = new MutationObserver((mutations, observer) =>\n      self.blocklyReadjustFunc()\n    );\n    // Register the element root you want to look for changes\n    observer.observe(document, {\n      subtree: true,\n      attributes: true\n    });\n\n    Blockly.svgResize(this.workspace);\n\n    if (updateToolbox) {\n      this.updateBlocklyToolbox();\n    }\n  }\n\n  public displayBlockly(program: HelenaProgram) {\n    this.updateBlocklyToolbox();\n    if (program && this.workspace) {\n      program.displayBlockly(this.workspace);\n    } else {\n      console.warn(\"Called displayBlockly, but no program to \" +\n        \"display yet.  Should be set with setBlocklyProgram.\");\n    }\n  }\n\n  /* cjbaik: seems not to be used\n  private quickSizeEstimate(ls) {\n    let acc = 0;\n    acc += ls.length;\n    for (let i = 0; i < ls.length; i++){\n      if (ls[i].bodyStatements){\n        acc += this.quickSizeEstimate(ls[i].bodyStatements);\n      }\n    }\n    return acc;\n  }*/\n\n  public blocklyToHelena(program: HelenaProgram | null) {\n    if (!this.workspace) {\n      throw new ReferenceError(\"Workspace is not set.\");\n    }\n\n    let roots = this.workspace.getTopBlocks(false);\n\n    if (!program) {\n      throw new ReferenceError(\"Program is not provided.\");\n    }\n    let statementLs = program.currentStatementLs();\n    for (const r of roots) {\n      if (r === statementLs[0].block){\n        // found the program root\n        let helenaStatements = HelenaMainpanel.getHelenaFromBlocklyRoot(r);\n        program.bodyStatements = helenaStatements;\n      }\n    }\n  }\n}\n\n","import * as _ from \"underscore\";\nimport * as later from \"later\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { DOMCreation } from \"../../common/utils/dom_creation\";\nimport { HelenaUIBase } from \"./helena_ui_base\";\n\nimport { EditRelationMessage, NextButtonSelectorMessage, RelationResponse,\n  Messages,\n  ScheduledScriptMessage,\n  SavedProgramMessage} from \"../../common/messages\";\n\nimport { Relation } from \"../relation/relation\";\nimport { TextRelation } from \"../relation/text_relation\";\n\nimport { AnnotationItem } from \"../lang/statements/control_flow/skip_block\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport { HelenaProgram, RunObject } from \"../lang/program\";\nimport { LoadStatement } from \"../lang/statements/browser/load\";\nimport { ScheduledRun } from \"../../common/scheduled_run\";\nimport { HelenaConfig } from \"../../common/config/config\";\nimport { MiscUtilities } from \"../../common/misc_utilities\";\nimport { Dataset } from \"../dataset\";\nimport { HelenaServer } from \"../utils/server\";\nimport { Indexable } from \"../../ringer-record-replay/common/utils\";\nimport { Trace } from \"../../common/utils/trace\";\nimport { NextButtonTypes, IColumnSelector } from \"../../content/selector/interfaces\";\n\nfunction activateButton(div: JQuery<HTMLElement>, selector: string,\n  handler: JQuery.EventHandlerBase<HTMLElement,\n    JQuery.ClickEvent<HTMLElement, null, HTMLElement, HTMLElement>>) {\n  let button = div.find(selector);\n  button.button();\n  button.click(handler);\n}\n\n/**\n * Guide the user through making a demonstration recording.\n */\nexport class RecorderUI extends HelenaUIBase {\n  public static ifttturl =\n    \"https://maker.ifttt.com/trigger/scheduled_scrape_completed/with/key/cBhUYy-EzpfmsfrJ9Bzs2p\";\n\n  public tabs?: JQuery<HTMLElement>;\n\n  public ringerUseXpathFastMode: boolean;\n  \n  // I'm going to make these accessible from the outside for debuggning purposes\n  public currentRingerTrace?: Trace;\n  public currentHelenaProgram?: HelenaProgram | null;\n\n  private currentRecordingWindow?: number;\n  private scriptRunCounter: number;\n\n  // during recording, when user scrapes, show the text so user gets feedback on\n  //   what's happening\n  // dictionary based on xpath since we can get multiple DOM events that scrape\n  //   same data from same node\n  private scraped: Indexable; \n  // todo: note that since we're indexing on xpath, if had same xpath on\n  //   multiple different pages, this would fail to show us some data.  bad!\n  //   actually, I think this whole thing may be unnecessary.  we've just been\n  //   adding in the same xpath to the xpaths list to control how we display it\n  //   anyway, so the indexing isn't really getting us anything, isn't\n  //   eliminating anything, and we haven't had any trouble. looks like an\n  //   artifact of an old style.  todo: get rid of it when have a chance.\n  private keys: string[]; // want to show texts in the right order\n\n  private currentSkipper?: Function;\n\n  private highlyHumanReadable: {\n    [key: string]: number\n  };\n\n  private currentUploadRelation?: TextRelation | null;\n\n  constructor() {\n    super();\n\n    this.ringerUseXpathFastMode = true;\n\n    this.scriptRunCounter = 0;\n    this.scraped = {};\n    this.keys = [];\n\n    this.highlyHumanReadable = {\n      \"textContent\": 12,\n      \"preceding-text\": 10,\n      \"previousElementSiblingText\": 10,\n      \"firstWord\": 10,\n      \"firstTwoWords\": 10,\n      \"firstThreeWords\": 10,\n      \"preColonText\": 11,\n      \"lastWord\": 10,\n      \"possibleHeading\": 10,\n      \"id\": 9,\n      \"tagName\": 9,\n      \"className\": 9,\n      \"xpath\": 8,\n      \"background-color\": 7,\n      \"background-image\": 7\n    };\n\n    $(this.init.bind(this));\n  }\n\n  public init() {\n    const self = this;\n    // messages received by this component\n    // Messages.listenForMessage(\"content\", \"mainpanel\", \"selectorAndListData\",\n    //   processSelectorAndListData);\n    // Messages.listenForMessage(\"content\", \"mainpanel\", \"nextButtonData\",\n    //   processNextButtonData);\n    // Messages.listenForMessage(\"content\", \"mainpanel\", \"moreItems\",\n    //   moreItems);\n    Messages.listenForMessage(\"content\", \"mainpanel\", \"scrapedData\",\n      this.processScrapedData.bind(this));\n    Messages.listenForMessage(\"content\", \"mainpanel\",\n      \"requestCurrentRecordingWindows\",\n      this.sendCurrentRecordingWindows.bind(this));\n    Messages.listenForMessage(\"background\", \"mainpanel\",\n      \"runScheduledScript\", this.runScheduledScript.bind(this));\n    Messages.listenForMessage(\"background\", \"mainpanel\",\n      \"pleasePrepareForRefresh\", this.prepareForPageRefresh.bind(this));\n    Messages.listenForMessage(\"content\", \"mainpanel\",\n      \"requestRingerUseXpathFastMode\", () =>\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"ringerUseXpathFastMode\", {use: self.ringerUseXpathFastMode})\n    );\n\n    // handle user interactions with the mainpanel\n    this.setUpRecordingUI();\n\n    $(document).tooltip();\n\n    // communicate to the HelenaBaseUI what we've called the elements we're using for blockly stuff\n    this.setBlocklyDivIds(\"new_script_content\", \"toolbox\", \"blockly_area\", \"blockly_div\");\n\n    // it's possible that we want to start right off by doing a recording, in which case let's start that here\n    let urlString = window.location.href;\n    let url = new URL(urlString);\n    let startUrl = url.searchParams.get(\"starturl\");\n    this.startRecording(startUrl? startUrl : undefined);\n    this.setScrapingInstructions(\"#scraping_instructions\");\n\n  }\n\n  public setScrapingInstructions(instructionsDivSelector: string) {\n    let scrapeCond = \"<kbd>ALT</kbd> + click\";\n    let linkScrapeCond = \"<kbd>ALT</kbd> + <kbd>SHIFT</kbd> + click\";\n\n    if (window.navigator.platform.includes(\"Linux\")) {\n      scrapeCond = \"<kbd>ALT</kbd> + <kbd>CTRL</kbd> + click\";\n      linkScrapeCond = \"<kbd>ALT</kbd> + <kbd>CTRL</kbd> + <kbd>SHIFT</kbd>\" +\n        \" + click\";\n    }\n\n    let innerHTML = $(instructionsDivSelector).html();\n    innerHTML = innerHTML.replace(\n      new RegExp(\"___SCRAPINGCONDITIONSTRING___\", \"g\"),\n      scrapeCond\n    );\n    innerHTML = innerHTML.replace(\n      new RegExp(\"___LINKSCRAPINGCONDITIONSTRING___\", \"g\"),\n      linkScrapeCond\n    );\n\n    $(instructionsDivSelector).html(innerHTML);\n  }\n\n  public setUpRecordingUI() {\n    const self = this;\n\n    // we'll start on the first tab, our default, which gives user change to\n    //   start a new recording\n    const tabsDivs = $(\"#tabs\");\n    this.tabs = tabsDivs.tabs();\n\n    // if we switch to the second tab, we'll need to load in all the saved scripts\n    tabsDivs.on(\"tabsbeforeactivate\", (event, ui) => {\n      if (ui.newPanel.attr('id') === \"tabs-2\") {\n        self.loadSavedScripts();\n      }\n      if (ui.newPanel.attr('id') === \"tabs-3\") {\n        self.loadScheduledScripts();\n      }\n    });\n\n    this.showStartRecording();\n  }\n\n  public showStartRecording() {\n    const self = this;\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#about_to_record\"));\n    div.find(\"#start_recording\").click(() => self.startRecording());\n  }\n\n  public startRecording(specifiedUrl?: string) {\n    const self = this;\n\n    console.log(\"startRecording\", specifiedUrl);\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#recording\"));\n    div.find(\"#stop_recording\").click(this.stopRecording.bind(this));\n    div.find(\"#cancel_recording\").click(this.cancelRecording.bind(this));\n\n    // if we already recorded one, there could be old stuff in here, so clear it\n    //   out\n    const $div = $(\"#scraped_items_preview\");\n    $div.html(\"<div class='scraped_items_preview_start'>\" +\n      \"Collect the FIRST ROW of your target dataset.</div>\");\n\n    MiscUtilities.makeNewRecordReplayWindow((windowId: number) => {\n      window.helenaMainpanel.recordingWindowIds.push(windowId);\n      self.currentRecordingWindow = windowId;\n      window.ringerMainpanel.reset();\n      window.ringerMainpanel.start();\n    }, specifiedUrl);\n  }\n\n  public sendCurrentRecordingWindows() {\n    // the tabs will check whether they're in the window that's actually\n    //   recording to figure out what UI stuff to show\n    Messages.sendMessage(\"mainpanel\", \"content\",\n      \"currentRecordingWindows\", {\n        window_ids: window.helenaMainpanel.recordingWindowIds\n      }); \n  }\n\n  private setCurrentProgram(program: HelenaProgram | null, trace?: Trace) {\n    this.currentHelenaProgram = program;\n    this.currentRingerTrace = trace;\n    this.setBlocklyProgram(program);\n  }\n\n  private setWindowSize(program: HelenaProgram, trace: Trace) {\n    // the last dom event is the one we want to use to figure out the window size\n    // because user might have changed the window size to make it work\n    let ev;\n    for (let i = trace.length - 1; i--; i >= 0) {\n      let evCand = trace[i];\n      if (evCand.frame) {\n        ev = evCand;\n        break;\n      }\n    }\n    if (ev) {\n      program.windowWidth = ev.frame.outerWidth;\n      program.windowHeight = ev.frame.outerHeight;\n    }\n  }\n\n  /**\n   * Sets global configuration variables. Used for test scripts, not in live\n   *   execution.\n   * @param kvArgs \n   */\n  public setGlobalConfig(kvArgs: Indexable) {\n    if (\"helenaServerUrl\" in kvArgs) {\n      HelenaConfig.helenaServerUrl = kvArgs.helenaServerUrl;\n    }\n    if (\"numRowsToSendInOneSlice\" in kvArgs) {\n      HelenaConfig.numRowsToSendInOneSlice = kvArgs.numRowsToSendInOneSlice;\n    }\n  }\n\n  public stopRecording() {\n    window.ringerMainpanel.stop();\n    const trace = window.ringerMainpanel.record.getEvents();\n    const program = HelenaProgram.fromRingerTrace(trace,\n      this.currentRecordingWindow);\n    if (program.statements.length < 1) {\n      // if we didn't actually see any statements worth replaying, let's assume\n      //   they pressed stop before actually doing anything\n      this.cancelRecording();\n      return;\n    }\n    this.setCurrentProgram(program, trace);\n    this.setWindowSize(program, trace);\n\n    // once we're done, remove the window id from the list of windows where\n    //   we're allowed to record\n    if (this.currentRecordingWindow) {\n      window.helenaMainpanel.recordingWindowIds = window.helenaMainpanel.recordingWindowIds.filter(\n        (window) => window !== this.currentRecordingWindow\n      );\n    }\n\n    // now that we have a script, let's set some processing in motion that will\n    //   figure out likely relations\n    program.relevantRelations();\n    \n    // true because we're currently processing the script, stuff is in progress\n    this.showProgramPreview(true);\n  }\n\n  public cancelRecording() {\n    window.ringerMainpanel.stop();\n    // once we're done, remove the window id from the list of windows where\n    //   we're allowed to record\n    if (this.currentRecordingWindow) {\n      window.helenaMainpanel.recordingWindowIds = window.helenaMainpanel.recordingWindowIds.filter(\n        (window) => window !== this.currentRecordingWindow\n      );\n    }\n    this.showStartRecording();\n  }\n\n  public showProgramPreview(inProgress = false) {\n    HelenaConsole.log(\"showProgramPreview\");\n    const div = $(\"#new_script_content\");\n    // let's put in the script_preview node\n    DOMCreation.replaceContent(div, $(\"#script_preview\"));\n\n    // I like it when the run button just says \"Run Script\" for demos\n    //   nice to have a reminder that it saves stuff if we're not in demo mode,\n    //   but it's prettier with just run\n    if (window.helenaMainpanel.demoMode) {\n      div.find(\"#run\").html(\"Run Script\");\n    }\n\n    activateButton(div, \"#run\", this.run.bind(this));\n    activateButton(div, \"#run_fast_mode\", this.runWithFastMode.bind(this));\n    activateButton(div, \"#download_script\", this.downloadScript.bind(this));\n    activateButton(div, \"#load_downloaded_script\", () => {\n      div.find(\"#load_downloaded_script_helper\").click()\n    });\n    $('#load_downloaded_script_helper').on(\"change\",\n      this.handleNewUploadedHelenaProgram.bind(this)\n    );\n    activateButton(div, \"#save\", this.save.bind(this));\n    activateButton(div, \"#replay\", this.replayOriginal.bind(this));\n    activateButton(div, \"#schedule_later\", this.scheduleLater.bind(this));\n    activateButton(div, \"#start_new\", this.startNewScript.bind(this));\n    activateButton(div, '#relation_upload', this.uploadRelation.bind(this));\n    activateButton(div, '#relation_demonstration',\n      this.demonstrateRelation.bind(this));\n\n    // let's handle the collapsibles\n    const tablesDiv = div.find(\"#relevant_tables_accordion\");\n    const additionalRunOptionsDiv = div.find(\"#extra_run_options_accordion\");\n    const troubleshootingDiv = div.find(\"#troubleshooting_accordion\");\n    const options = {\n      collapsible: true,\n      heightStyle: \"content\",\n      active: false\n    };\n    tablesDiv.accordion(options);\n    additionalRunOptionsDiv.accordion(options);\n    troubleshootingDiv.accordion({\n      collapsible: true,\n      active: false,\n      heightStyle: \"content\"\n    }); // always want all of these to start closed\n\n    /*\n    var troubleshootingDivs = $(\".troubleshooting_option\");\n    for (var i = 0; i < troubleshootingDivs.length; i++) {\n      (function() {\n        var d = $(troubleshootingDivs[i]);\n        var controllingDiv = d.find(\".troubleshooting_description\");\n        var childDiv = d.find(\".troubleshooting_option_expansion\");\n        controllingDiv.click(()=> DOMCreation.toggleDisplay(childDiv));  \n      })();\n    }\n    */\n\n    // when the user updates parameter names, we'll need to do some special\n    //   processing\n    // div.find(\"#param_name\").get(0).onchange = pub.processNewParameterName;\n    activateButton(div, '#add_param', this.processNewParameterName.bind(this));\n\n    // false bc no need to update the toolbox for our setup --\n    //   updateDisplayedScript below will do that anyway\n    this.setUpBlocklyEditor(false);\n\n    this.updateDisplayedScript();\n    this.updateDisplayedRelations(inProgress);\n    this.showParamVals();\n  }\n\n  private updateUIForRunFinished(dataset: Dataset, timeScraped: number,\n      runTabId: string) {\n    const div = $(\"#\" + runTabId).find(\"#running_script_content\");\n    const done_note = div.find(\".done_note\");\n    done_note.css(\"display\", \"inline-block\");\n    // if we still show the little thing that says we're waiting for output,\n    //   hide it now\n    div.find(\"#output_explanation\").hide();\n    const still_saving_note = div.find(\".still_saving_note\");\n    still_saving_note.css(\"display\", \"none\");\n    div.find(\"#pause\").button(\"option\", \"disabled\", true);\n    div.find(\"#resume\").button(\"option\", \"disabled\", true);\n    div.find(\"#cancelRun\").button(\"option\", \"disabled\", true);\n  }\n\n  public run(fastMode = false, params?: object) {\n    const self = this;\n    HelenaConsole.log(\"Params: \" + params);\n    // first set the correct fast mode, which means setting it to false if we\n    //   haven't gotten true passed in might still be on from last time\n\n    // trying something new.  have running just always save the thing.\n    //   otherwise, it's so unpredictable\n    this.save(() => {\n      // now we have a program id (already set in currentHelenaProgram.id)\n      self.ringerUseXpathFastMode = fastMode;\n\n      if (!self.currentHelenaProgram) {\n        throw new ReferenceError(\"No currentHelenaProgram.\");\n      }\n      // run whichever program is currently being displayed\n      self.currentHelenaProgram.runProgram({},\n        self.updateUIForRunFinished.bind(self), params);\n    });\n  }\n\n  public runWithFastMode() {\n    // first turn on fast mode, run\n    this.run(true);\n  }\n\n  public runWithAndWithoutEntityScopes() {\n    this.run();\n    this.run(false, { ignoreEntityScope: true });\n  }\n\n  public newRunTab(runObject: RunObject) {\n    const self = this;\n\n    // first let's make the new tab\n    this.scriptRunCounter += 1;\n    const tabDivId = 'runTab' + this.scriptRunCounter;\n\n    if (!this.tabs) {\n      throw new ReferenceError(\"Tabs not set.\");\n    }\n\n    const ul = this.tabs.find(\"ul\");\n    $( \"<li><a href='#\" + tabDivId + \"'>Script Run \"+ this.scriptRunCounter +\n      \"</a></li>\" ).appendTo(ul);\n    $( \"<div id='\" + tabDivId +\n      \"'><div id='running_script_content'></div></div>\").appendTo(this.tabs);\n    this.tabs.tabs(\"refresh\");\n    this.tabs.tabs(\"option\", \"active\", this.scriptRunCounter + 2);\n\n    // update the panel to show pause, resume buttons\n    HelenaConsole.log(\"UI newRunTab\");\n    const div = $(\"#\" + tabDivId).find(\"#running_script_content\");\n    DOMCreation.replaceContent(div, $(\"#script_running\"));\n\n    activateButton(div, \"#pause\", () => self.pauseRun(runObject));\n    activateButton(div, \"#resume\", () => self.resumeRun(runObject));\n    activateButton(div, \"#restart\", () => self.restartRun(runObject));\n\n    // shouldn't be able to resume before we even pause\n    div.find(\"#resume\").button(\"option\", \"disabled\", true); \n\n    activateButton(div, \"#download\", () => runObject.dataset.downloadDataset());\n    activateButton(div, \"#download_all\", () =>\n      runObject.dataset.downloadFullDataset());\n\n    activateButton(div, \"#cancelRun\", () => {\n      runObject.program.stopRunning(runObject);\n      // todo: maybe have this close the tab or swap us back to the program\n      //   preview\n    });\n\n    return tabDivId;\n  }\n\n  // todo: changing the values in these input boxes should actually prompt call\n  //   to update program's default parameter values!!\n\n  public showParamVals() {\n    const div = $(\"#param_wrapper\");\n    const prog = this.currentHelenaProgram;\n\n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n\n    let paramNames = prog.getParameterNames();\n    let params = prog.getParameterDefaultValues();\n    let targetDiv = div.find(\"#current_param_vals\");\n    targetDiv.empty(); // first clear it out\n    \n    if (paramNames) {\n      for (const name of paramNames) {\n        let val = params[name];\n        if (!val) {\n          val = \"no default value set\"\n        }\n        const newDiv = $(\"<div><span class='paramname'>\" + name +\n          \"</span><input type='text' name='paramval' value='\" + val +\n          \"'></input></div>\");\n        targetDiv.append(newDiv);\n      }\n    }\n  }\n\n  public processNewParameterName() {\n    const div = $(\"#param_wrapper\");\n    const prog = this.currentHelenaProgram;\n\n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n\n    const paramInputNode = <HTMLInputElement> div.find(\"#param_name\").get(0);\n    const paramName = paramInputNode.value;\n    const paramValInputNode = <HTMLInputElement> div.find(\"#param_val\").get(0);\n    const paramVal = paramValInputNode.value;\n    // prog.setAssociatedString(paramName);\n    console.log(\"Current parameter name\", paramName);\n    const priorParameterNames = prog.getParameterNames();\n    if (priorParameterNames && !priorParameterNames.includes(paramName)) {\n      priorParameterNames.push(paramName);\n      prog.setParameterNames(priorParameterNames);\n      prog.setParameterDefaultValue(paramName, paramVal);\n      // now that we've set new variable names, the blockly blocks should be\n      //   updated to reflect that\n      this.updateDisplayedScript();\n      this.showParamVals();\n      paramInputNode.value = \"Enter parameter name here\";\n      paramValInputNode.value = \"Enter default parameter value here\";\n    }\n  }\n\n  // for saving a program to the server\n  public save(postIdRetrievalContinuation: Function) {\n    const prog = this.currentHelenaProgram;\n\n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n\n    const div = $(\"#new_script_content\");\n    prog.name = (<HTMLInputElement> div.find(\"#program_name\").get(0)).value;\n\n    // ok, time to call the func that actually interacts with the server\n    // saveToServer(progName, postIdRetrievalContinuation, saveStartedHandler,\n    //   saveCompletedHandler)\n    const saveStartedHandler = () => {\n      // we've sent the save thing, so tell the user\n      const status = div.find(\"#program_save_status\");\n      status.html(\"Saving...\");\n      status.css(\"display\", \"inline\");\n    }\n    const saveCompletedHandler = () => {\n      // we've finished the save thing, so tell the user\n      const status = div.find(\"#program_save_status\");\n      status.html(\"Saved\");\n    }\n\n    prog.saveToServer(postIdRetrievalContinuation, saveStartedHandler,\n      saveCompletedHandler);\n  }\n\n  // for saving a program locally\n  public downloadScript() {\n    const prog = this.currentHelenaProgram;\n    \n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n\n    const div = $(\"#new_script_content\");\n    prog.name = (<HTMLInputElement> div.find(\"#program_name\").get(0)).value;\n\n    const serializedProg = prog.convertToJSON();\n    downloadObject(prog.name + \".hln\", serializedProg);\n  }\n\n  // for loading a program stored locally\n  public handleNewUploadedHelenaProgram(event: Event) {\n    const self = this;\n\n    HelenaConsole.log(\"New program uploaded.\");\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      const str = fileReader.result;\n\n      if (!str) {\n        throw new ReferenceError(\"File reader has no result.\");\n      }\n      // ok, we have the file contents\n      self.loadDownloadedScriptHelper(<string> str);\n    }\n\n    // now that we know how to handle reading data, let's actually read some\n    const target = <HTMLInputElement> event.target;\n    const file = (<FileList> target.files)[0];\n    fileReader.readAsText(file);\n  }\n\n  private loadDownloadedScriptHelper(serialized_program: string,\n    continuation?: Function) {\n    const revivedProgram = HelenaProgram.fromJSON(serialized_program);\n    this.setCurrentProgram(revivedProgram, undefined);\n\n    // make that first tab (the program running tab) active again\n    $(\"#tabs\").tabs(\"option\", \"active\", 0);\n\n    // false because we're not currently processing the program (as in, finding\n    //   relations, something like that)\n    this.showProgramPreview(false);\n    if (continuation) {\n      continuation();\n    } \n  }\n\n  public replayOriginal() {\n    this.currentHelenaProgram?.replayOriginal();\n  }\n\n  public startNewScript() {\n    this.setCurrentProgram(null, []);\n    // clearing out a couple vars that have state from old prog or recording\n    //   process\n    this.resetForNewScript();\n    this.showStartRecording();\n  }\n\n  public pauseRun(runObject: RunObject) {\n    HelenaConsole.log(\"Setting pause flag.\");\n    \n    // next runbasicblock call will handle saving a continuation\n    runObject.userPaused = true;\n\n    const div = $(\"#\" + runObject.tab).find(\"#running_script_content\");\n\n    // can't pause while we're paused\n    div.find(\"#pause\").button(\"option\", \"disabled\", true);\n\n    div.find(\"#resume\").button(\"option\", \"disabled\", false); // can now resume\n  }\n\n  public resumeRun(runObject: RunObject) {\n    runObject.userPaused = false;\n    const div = $(\"#\" + runObject.tab).find(\"#running_script_content\");\n    div.find(\"#pause\").button(\"option\", \"disabled\", false);\n    div.find(\"#resume\").button(\"option\", \"disabled\", true);\n    if (runObject.resumeContinuation) {\n      runObject.resumeContinuation();\n    }\n  }\n\n  public restartRun(runObject: RunObject) {\n    HelenaConsole.log(\"Restarting.\");\n    const div = $(\"#\" + runObject.tab).find(\"#running_script_content\");\n    //div.find(\"#pause\").button(\"option\", \"disabled\", false);\n    div.find(\"#resume\").button(\"option\", \"disabled\", true);\n    runObject.program.restartFromBeginning(runObject,\n      this.updateUIForRunFinished.bind(this));\n  }\n\n  public scheduleLater() {\n    const self = this;\n\n    HelenaConsole.log(\"going to schedule later runs.\");\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#schedule_a_run\"));\n    activateButton(div, \"#schedule_a_run_done\", () => {\n      const scheduleText = <string> div.find(\"#schedule\").val();\n      const schedule = later.parse.text(scheduleText);\n      if (schedule.error !== -1) {\n        // drat, we couldn't parse it.  tell user\n        div.find(\"#schedule_parse_failed\").css(\"display\", \"inline-block\");\n        console.log(scheduleText, schedule);\n      } else {\n        // ok, everything is fine.  just save the thing\n        const scheduledRecord: ScheduledRun = {\n          schedule: scheduleText,\n          progId: <string> self.currentHelenaProgram?.id\n        };\n        window.chrome.storage.sync.get(\"scheduledRuns\", (obj) => {\n          if (!obj.scheduledRuns) {\n            obj.scheduledRuns = [];\n          }\n          obj.scheduledRuns.push(scheduledRecord);\n          chrome.storage.sync.set(obj, () => {\n            console.log(\"Saved the new scheduled run.\");\n            // and let's go back to our normal view of the program\n            self.showProgramPreview(false);\n            // and let's tell the background script to retrieve all the\n            //   schedules so it will actually run them\n            Messages.sendMessage(\"mainpanel\", \"background\",\n              \"scheduleScrapes\", {});\n          })\n        });\n      }\n    });\n  }\n\n  public resetForNewScript() {\n    this.scraped = {};\n    this.keys = [];\n    window.helenaMainpanel.resetForNewScript();\n  }\n\n  public processScrapedData(data: MainpanelNode.Interface) {\n    const xpath = data.xpath;\n    let id = xpath + \"_\" + data.source_url;\n    if (data.linkScraping) {\n      id += data.link;\n      this.scraped[id] = data.link;\n    } else {\n      // just wanted to scrape text\n      id += data.text;\n      this.scraped[id] = data.text;\n    }\n    this.keys.push(id);\n    const $div = $(\"#scraped_items_preview\");\n    $div.html(\"\");\n    for (const key of this.keys) {\n      $div.append($(`<div class=\"first_row_elem\">${this.scraped[key]}</div>`));\n    }\n  }\n\n  public runScheduledScript(data: ScheduledScriptMessage) {\n    const self = this;\n    console.log(\"Running scheduled script\", data);\n    // let's let the background script know that we got its message\n    Messages.sendMessage(\"mainpanel\", \"background\",\n      \"runningScheduledScript\", {});\n    const progId = data.progId;\n    this.loadSavedProgram(progId, () => {\n      const curProg = <HelenaProgram> self.currentHelenaProgram;\n      // once it's loaded, go ahead and actually run it.\n      curProg.runProgram({}, (datasetObj: Dataset, timeToScrape: number,\n          tabId: string) => {\n        const curProg = <HelenaProgram> self.currentHelenaProgram;\n        // and for scheduled runs we're doing something that's currently a\n        //   little wacky, where we trigger an IFTTT action when the scrape has\n        //   run\n        // todo: come up with a cleaner set up for this\n        // this is the part that will send the email\n        const subject = \"Scheduled Scrape Completed: \" + curProg.name;\n        const url = datasetObj.downloadUrl();\n        const fullurl = datasetObj.downloadFullDatasetUrl();\n        const body = \"dataset: \" + datasetObj.getId() + \"<br>dataset download\" +\n          \" url (most recent scrape output): <a href=\" + url + \">\" + url +\n          \"</a>\" + \"<br>full dataset download url (all scrape outputs): \" +\n          \"<a href=\" + fullurl + \">\" + fullurl + \"</a><br>num rows:\" +\n          datasetObj.fullDatasetLength + \"<br>time to scrape (milliseconds): \"\n          + timeToScrape;\n        $.post(RecorderUI.ifttturl, {\n          value1: subject,\n          value2: body\n        });\n        self.updateUIForRunFinished(datasetObj, timeToScrape, tabId);\n      });\n    });\n  }\n\n  public prepareForPageRefresh() {\n    // first we want to wrap up anything we might have been doing.  in\n    //   particular, if we're scraping and we have some outstanding data, not\n    //   yet backed up to the server, better send it to the server.\n    //   should we stop scraping also?\n\n    for (const runObject of window.helenaMainpanel.currentRunObjects) {\n      this.pauseRun(runObject); // we'll let that do its thing in the background\n    }\n\n    let i = 0;\n    const processARunObject = function() {\n      if (i >= window.helenaMainpanel.currentRunObjects.length) {\n        // ok, we're done.  we've closed the datasets for all the current run\n        //   objects. we want to let the background page know that we refreshed,\n        //   in case it was the one that requested it\n        Messages.sendMessage(\"mainpanel\", \"background\",\n          \"readyToRefresh\", {});\n      } else {\n        // still more run objects to process\n        const runObject = window.helenaMainpanel.currentRunObjects[i];\n        i += 1;\n        runObject.dataset.closeDatasetWithCont(processARunObject);\n      }\n    }\n\n    processARunObject();\n  }\n\n  private editSelector(relation: Relation) {\n    const self = this;\n    // show the UI for editing the selector\n    // we need to open up the new tab that we'll use for showing and editing the\n    //   relation, and we need to set up a listener to update the selector\n    //   associated with this relation, based on changes the user makes over at\n    //   the content script\n    let bestLengthSoFar = 0;\n    let heardAnswer = false;\n    chrome.tabs.create({ url: relation.url, active: true }, (tab) => {\n      const tabId = tab.id;\n      if (tabId === undefined) {\n        throw new ReferenceError(\"Tab has no ID set.\");\n      }\n      self.showRelationEditor(relation, tabId);\n      const sendSelectorInfo = () => {\n        Messages.sendMessage(\"mainpanel\", \"content\", \"editRelation\",\n          relation.messageRelationRepresentation(), undefined, undefined,\n          [ tabId ]);\n        };\n      const sendSelectorInfoUntilAnswer = () => {\n        $(\"#instructions_part_1\").css(\"display\", \"none\");\n        $(\"#instructions_part_2\").css(\"display\", \"block\");\n        if (heardAnswer) { return; }\n        sendSelectorInfo(); \n        setTimeout(sendSelectorInfoUntilAnswer, 1000);\n      }\n      // var div = $(\"#new_script_content\");\n      const button = $(\"#page_looks_right\");\n      button.button();\n      button.click(sendSelectorInfoUntilAnswer);\n    });\n    // now we've sent over the current selector info.  let's set up the listener\n    //   that will update the preview (and the object)\n    Messages.listenForMessageWithKey(\"content\", \"mainpanel\",\n      \"editRelation\", \"editRelation\",\n      (msg: RelationResponse & EditRelationMessage &\n          Messages.MessageContentWithTab) => {\n        heardAnswer = true;\n        if (msg.demonstration_time_relation.length >= bestLengthSoFar) {\n          bestLengthSoFar = msg.demonstration_time_relation.length;\n          if (bestLengthSoFar > 0) {\n            relation.setNewAttributes(msg.selector, msg.selector_version,\n              msg.exclude_first, msg.columns, msg.demonstration_time_relation,\n              msg.num_rows_in_demonstration, msg.next_type,\n              msg.next_button_selector);\n            self.updateDisplayedRelation(relation, msg.colors);\n            self.setColumnColors(msg.colors, msg.columns, msg.tab_id);\n          } else {\n            // still need to give the user the option to add a new column, even\n            //   if we have no selector so far\n            self.setColumnColors([], [], msg.tab_id);\n          }\n        }\n      }\n    );\n    // remember this will overwrite previous editRelation listeners, since\n    //   we're providing a key\n  }\n\n  private replaceRelation(relation: TextRelation) {\n    const self = this;\n    // show the UI for replacing the selector, which will basically be the same\n    //   as the one we use for uploading a text relation in the first place\n    HelenaConsole.log(\"going to upload a replacement relation.\");\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#upload_relation\"));\n    \n    // and let's actually process changes\n    $('#upload_data').on(\"change\", this.handleNewUploadedRelation.bind(this));\n\n    activateButton(div, \"#upload_done\", () => {\n      if (self.currentUploadRelation) {\n        relation.setRelationContents(\n          self.currentUploadRelation.getRelationContents()\n        );\n      }\n      self.showProgramPreview();\n      self.currentUploadRelation = null;\n    }); // ok, we're actually using this relation\n    \n    activateButton(div, \"#upload_cancel\", () => {\n      self.showProgramPreview();\n      self.currentUploadRelation = null;\n    }); // don't really need to do anything here\n  }\n\n  public handleFunctionForSkippingToNextPageOfRelationFinding(\n    skipToNextPageFunc: Function) {\n      this.currentSkipper = skipToNextPageFunc;\n  };\n\n  public handleRelationFindingPageUpdate(pageCurrentlyBeingSearched: number) {\n    const $overlaytext = $(\"#overlay\").find(\"#overlay_text\");\n    const $currentPage = $overlaytext.find(\"#overlay_text_current_page\");\n    if ($currentPage.length > 0) {\n      $currentPage.html(pageCurrentlyBeingSearched.toString());\n    } else {\n      $overlaytext.append(\n        $(\"<div>Currently looking for relations on page \" + \n          \"<span id='overlay_text_current_page'>\" + pageCurrentlyBeingSearched +\n          \"</span>.</div>\"));\n    }\n  }\n\n  public updateDisplayedRelations(currentlyUpdating = false) {\n    const self = this;\n    HelenaConsole.log(\"updateDisplayedRelation\");\n\n    if (!self.currentHelenaProgram) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n\n    const relations = self.currentHelenaProgram.relations;\n    let $div = $(\"#new_script_content\").find(\"#status_message\");\n    $div.html(\"\");\n    const $overlay = $(\"#overlay\");\n    const $overlaytext = $overlay.find(\"#overlay_text\");\n    if (currentlyUpdating) {\n      $overlaytext.html(\"<center><img src='../icons/ajax-loader2.gif' \" + \n        \"height='20px'><br>Looking at webpages to find relevant tables. \" +\n        \"Give us a moment.<br></center>\");\n      \n      if (!window.helenaMainpanel.demoMode) {\n        const giveUpButton =\n          $(\"<button>Give up looking for relevant tables.</button>\");\n        giveUpButton.button();\n        giveUpButton.click(() => {\n          // if user thinks we won't have relations, go ahead and do prog\n          //   processing (making loopyStatements) without them\n          self.currentHelenaProgram?.insertLoops(true);\n          // and let's prevent future guessed relations from messing us up\n          self.currentHelenaProgram?.forbidAutomaticLoopInsertion();\n        });\n        $overlaytext.append(giveUpButton);\n\n        const giveUpButton2 = $(\"<button>Give up ON THIS CURRENT PAGE \" +\n          \"(and continue to next page).</button>\");\n        giveUpButton2.button();\n      \n        // this gets updated by\n        //   handleFunctionForSkippingToNextPageOfRelationFinding above\n        giveUpButton2.click(() => {\n          if (self.currentSkipper) {\n            self.currentSkipper();\n          }\n        });\n        $overlaytext.append(giveUpButton2);\n      }\n\n      $overlay.css(\"display\", \"inline\");\n    } else {\n      $overlay.css(\"display\", \"none\");\n    }\n\n    $div = $(\"#new_script_content\").find(\"#relations\");\n    $div.html(\"\");\n    if (relations.length === 0 && !currentlyUpdating) {\n      $div.html(\"No relevant tables found. Sorry!\");  \n      return;\n    }\n    for (const relation of relations) {\n      HelenaConsole.log(\"updateDisplayedRelations table\");\n      const $relDiv = $(\"<div class=relation_preview></div>\");\n      $div.append($relDiv);\n      let textRelation = relation.demonstrationTimeRelationText();\n      if (textRelation.length > 2) {\n        textRelation = textRelation.slice(0,3);\n        textRelation.push(\n          Array.apply(null, Array(textRelation[0].length)).map(() => \"...\"));\n      }\n      const table = DOMCreation.arrayOfArraysToTable(\n        textRelation);\n\n      const columns = relation.columns;\n      const tr = $(\"<tr></tr>\");\n      for (const column of columns) {\n        const columnTitle = $(\"<input></input>\");\n        columnTitle.val(<string> column.name);\n        columnTitle.change(() => {\n          relation.setColumnName(column, <string> columnTitle.val());\n          self.updateDisplayedScript();\n        });\n\n        const td = $(\"<td></td>\");\n        td.append(columnTitle);\n        tr.append(td);\n      }\n      table.prepend(tr);\n      const relationTitle = $(\"<input></input>\");\n      relationTitle.val(relation.name);\n      relationTitle.change(() => {\n        relation.name = <string> relationTitle.val();\n        self.updateDisplayedScript();\n      });\n      $relDiv.append(relationTitle);\n      $relDiv.append(table);\n\n      const saveRelationButton =\n        $(\"<button>Save These Table and Column Names</button>\");\n      saveRelationButton.button();\n      saveRelationButton.click(() => (<Relation> relation).saveToServer());\n      $relDiv.append(saveRelationButton);\n\n      const editRelationButton = $(\"<button>Edit This Table</button>\");\n      editRelationButton.button();\n      editRelationButton.click(() => self.editSelector(<Relation> relation));\n      $relDiv.append(editRelationButton);\n\n      const removeRelationButton =\n        $(\"<button>This Table Is Not Relevant</button>\");\n      removeRelationButton.button();\n      removeRelationButton.click(() => {\n        self.currentHelenaProgram?.removeRelation(relation);\n      });\n      $relDiv.append(removeRelationButton);\n      HelenaConsole.log(\"Done with updateDisplayedRelations table\");\n\n      if (relation instanceof TextRelation) {\n        const replaceRelationButton =\n          $(\"<button>Replace This Uploaded Table</button>\");\n        replaceRelationButton.button();\n        replaceRelationButton.click(() => self.replaceRelation(relation));\n        $relDiv.append(replaceRelationButton);\n      }\n    }\n\n    // if the relation gets updated, the preview for the duplicate detection\n    //   should change\n    self.updateDuplicateDetection();\n  }\n\n  public showRelationEditor(relation: Relation, tabId: number) {\n    const self = this;\n\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#relation_editing\"));\n\n    // let's highlight the appropriate next_type\n    const currNextType = relation.nextType;\n\n    // remember we have to keep the NextButtonTypes in line with the\n    //   ids in the mainpanel html\n    const checkedNode = div.find(\"#next_type_\" + currNextType);\n    checkedNode.prop(\"checked\", true);\n    const radioButtons = <JQuery<HTMLInputElement>>\n      div.find('#next_type input[type=radio]');\n\n    for (const radioButton of radioButtons) {\n      // name must be different from the name of other buttonsets, and since\n      //   we've copied from elsewhere on the page, we need to change this\n      radioButton.name = radioButton.name + \"_current\";\n    }\n\n    // var nextTypeButtonset = div.find(\"#next_type\").buttonset();\n    radioButtons.change((event: JQuery.ChangeEvent) => {\n      const target = <HTMLInputElement> event.currentTarget;\n      relation.nextType = parseInt(target.value);\n      if (relation.nextType === NextButtonTypes.NEXTBUTTON ||\n          relation.nextType === NextButtonTypes.MOREBUTTON) {\n        // ok, we need the user to actually show us the button\n        let buttonType = \"next\";\n        if (relation.nextType === NextButtonTypes.MOREBUTTON) {\n          buttonType = \"more\";\n        }\n        const expl = div.find(\"#next_type_explanation\");\n        expl.html(\"Please click on the '\" + buttonType + \"' button now.\");\n\n        Messages.listenForMessageOnce(\"content\", \"mainpanel\",\n        \"nextButtonSelector\", (data: NextButtonSelectorMessage) => {\n          relation.nextButtonSelector = data.selector;\n          expl.html(\"\");\n        });\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"nextButtonSelector\", {}, undefined, undefined, [tabId]);\n      } else {\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"clearNextButtonSelector\", {}, undefined, undefined, [tabId]);\n      }\n    });\n\n    // ready button\n    const readyButton = div.find(\"#relation_editing_ready\");\n    readyButton.button();\n\n    readyButton.click(() => {\n      // once ready button clicked, we'll already have updated the relation\n      //   selector info based on messages the content panel has been sending,\n      //   so we can just go back to looking at the program preview\n\n      // one exception -- if this was a whole new relation, it won't be in there\n      //   so then we'll need to add it\n      console.log(\"relation\", relation);\n      const rels = self.currentHelenaProgram?.relations;\n      if (rels && !rels.includes(relation)) {\n        self.currentHelenaProgram?.relations.push(relation);\n      }\n      \n      // one thing we do need to change is there may now be nodes included in\n      //   the relation (or excluded) that weren't before, so we should redo\n      //   loop insertion\n      self.currentHelenaProgram?.insertLoops(false);\n\n      self.showProgramPreview();\n      // we also want to close the tab...\n      console.log(\"showRelationEditor removing tab\", tabId);\n      chrome.tabs.remove(tabId);\n      // todo: maybe we also want to automatically save changes to server?\n      //   something to consider.  not yet sure\n    });\n  }\n\n  public updateDisplayedRelation(relation: Relation, colors: string[]) {\n    const self = this;\n    HelenaConsole.log(\"updateDisplayedRelation\");\n    const $relDiv = $(\"#new_script_content\").find(\"#output_preview\");\n    $relDiv.html(\"\");\n\n    const textRelation = relation.demonstrationTimeRelationText();\n    const table = DOMCreation.arrayOfArraysToTable(\n      textRelation);\n\n    const columns = relation.columns;\n    const tr = $(\"<tr></tr>\");\n    let colIndex = 0;\n    for (const column of columns) {\n      const xpath = column.xpath;\n      const colorStyle = \"style='background-color:\" + colors[colIndex] + \";'\";\n      const columnTitle = $(\"<input class='edit-relation-table-header-cell' \" +\n        colorStyle + \" ></input>\");\n      columnTitle.val(<string> column.name);\n      columnTitle.change(() => {\n        HelenaConsole.log(columnTitle.val(), xpath);\n        relation.setColumnName(column, <string> columnTitle.val());\n        self.updateDisplayedScript();\n      });\n      const td = $(\"<td></td>\");\n      td.append(columnTitle);\n      tr.append(td);\n      colIndex++;\n    }\n    table.prepend(tr);\n\n    const relationTitle = $(\"<input></input>\");\n    relationTitle.val(relation.name);\n    relationTitle.change(() => {\n      relation.name = <string> relationTitle.val();\n      self.updateDisplayedScript();\n    });\n    $relDiv.append(relationTitle);\n    $relDiv.append(table);\n  };\n\n  public setColumnColors(colors: string[], columnLs: IColumnSelector[],\n    tabid: number) {\n    const $div = $(\"#new_script_content\").find(\"#color_selector\");\n    $div.html(\"Select the right color for the cell you want to add:   \");\n    for (let i = 0; i < columnLs.length; i++) {\n      const colorDiv = $(\"<div class='edit-relation-color-block' \" +\n        \"style='background-color:\" + colors[i] + \"'></div>\");\n      const col = columnLs[i].index;\n      colorDiv.click(() => {\n        Messages.sendMessage(\"mainpanel\", \"content\",\n          \"currentColumnIndex\", { index: col }, undefined, undefined, [tabid]);\n      });\n      $div.append(colorDiv);\n    }\n\n    // todo: now going to allow folks to make a new column, but also need to\n    //   communicate with content script about color to show\n    const separatorDiv = $(\"<div class='edit-relation-color-block'>or</div>\");\n    const colorDiv = $(\"<div class='edit-relation-color-block' \" + \n      \"id='edit-relation-new-col-button'>New Col</div>\");\n    colorDiv.click(() => {\n      Messages.sendMessage(\"mainpanel\", \"content\", \"currentColumnIndex\",\n        {index: \"newCol\"}, undefined, undefined, [tabid]);\n      }\n    );\n    $div.append(separatorDiv);\n    $div.append(colorDiv);\n  }\n\n  public updateDisplayedScript(updateBlockly = true) {\n    HelenaConsole.log(\"updateDisplayedScript\");\n    const program = this.currentHelenaProgram;\n    const scriptPreviewDiv =\n      $(\"#new_script_content\").find(\"#program_representation\");\n\n    scriptPreviewDiv.remove();\n    if (updateBlockly && program) {\n      this.displayBlockly(program);\n    }\n\n    if (program) {\n      this.updateDisplayedDownloadURLs(program);\n    }\n\n    // we also want to update the section that lets the user say what loop\n    // iterations are duplicates\n    // used for data in relations get shuffled during scraping and for\n    //   recovering from failures. also incremental scraping.\n    this.updateDuplicateDetection();\n    \n    // we also want to make sure the user can tell us which features are\n    //   required for each node that we find using similarity approach\n    this.updateNodeRequiredFeaturesUI();\n\n    // same deal with custom thresholds\n    this.updateCustomThresholds();\n    this.updateCustomWaits();\n\n    if (program && program.name) {\n      const progNameEl = <HTMLInputElement> $(\"#new_script_content\")\n        .find(\"#program_name\").get(0);\n      progNameEl.value = program.name;\n    }\n  }\n\n  public programIdUpdated(prog: HelenaProgram) {\n    // a special handler that the helena library will call when a program's id\n    //   is updated. we'll use it to update the download urls we're showing\n    if (prog === this.currentHelenaProgram) {\n      this.updateDisplayedDownloadURLs(this.currentHelenaProgram);\n    }\n  }\n\n  public updateDisplayedDownloadURLs(prog: HelenaProgram) {\n    if (prog.id) {\n      const $div = $(\"#new_script_content\").find(\"#advanced_options\");\n      $div.find(\"#download_urls_placeholder\").remove();\n\n      function makeOrUpdateDownloadUrl($div: JQuery<HTMLElement>, id: string,\n        url: string, instructions: string) {\n          let $url = $div.find(\"#\" + id);\n          if ($url.length < 1) {\n            $url = $(\"<div id='\" + id + \"'></div>\");\n            $div.append($url);\n          }\n          $url.html(instructions + \": <a href=\" + url + \" target='_blank'>\" +\n            url + \"</a>\");\n      }\n\n      const baseUrl = Dataset.downloadFullDatasetUrl(prog);\n      makeOrUpdateDownloadUrl($div, \"download_url_1\", baseUrl,\n        \"Download all data ever scraped by this program at\");\n      makeOrUpdateDownloadUrl($div, \"download_url_2\", baseUrl + \"/24\",\n        \"Download all data scraped by this program in the last 24 hours (and \" +\n          \"feel free to change the 24 at the end of the URL to your own \" +\n          \"preferred number)\");\n    }\n  }\n\n  public updateDuplicateDetection() {\n    const self = this;\n    HelenaConsole.log(\"updateDuplicateDetection\");\n    const duplicateDetectionData =\n      this.currentHelenaProgram?.getDuplicateDetectionData();\n\n    const $div = $(\"#new_script_content\").find(\"#duplicates_container_content\");\n    $div.html(\"\");\n\n    if (!duplicateDetectionData) {\n      return;\n    }\n\n    for (const oneLoopData of duplicateDetectionData) {\n      const loopStatement = oneLoopData.loopStatement;\n      const table = DOMCreation.arrayOfArraysToTable(oneLoopData.displayData);\n      const nodeVariables = oneLoopData.nodeVariables;\n      const tr = $(\"<tr></tr>\");\n      let annotationItems: AnnotationItem[] = [];\n      let availableAnnotationItems: AnnotationItem[] = [];\n      let colCount = 0;\n      for (const nodeVariable of nodeVariables) {\n        const attributes = [\"TEXT\", \"LINK\"];\n        for (const attr of attributes) {\n          let element = { nodeVar: nodeVariable, attr: attr };\n          const iColCount = colCount;\n          colCount += 1;\n          availableAnnotationItems.push(element);\n          const attrRequired = $(\"<input type='checkbox'>\");\n          attrRequired.change(() => {\n            console.log(\"toggling attribute required for\", nodeVariable, attr);\n            if (attrRequired.prop(\"checked\")) {\n              annotationItems.push(element);\n              // now update how we show the table, add green col\n              table.find(\"tr\").each((i, row) => {\n                const cells = $(row).find(\"td\");\n                const targetCell = $(cells[iColCount]);\n                targetCell.addClass(\"greentable\");\n              });\n            } else {\n              // can't just use without bc element won't be exactly the same as\n              //   the other object, so use findWhere to find the first element\n              //   with the same properties\n              const matchEl = _.findWhere(annotationItems, element);\n              if (matchEl) {\n                annotationItems = annotationItems.filter(\n                  (item) => item !== matchEl\n                );\n              }\n              // now update how we show the table, remove green col\n              table.find(\"tr\").each((i, row) => {\n                const cells = $(row).find(\"td\");\n                const targetCell = $(cells[iColCount]);\n                targetCell.removeClass(\"greentable\");\n              });\n            }\n            console.log(\"annotationItems\", annotationItems)});\n\n          const td = $(\"<td></td>\");\n          td.append(attrRequired);\n          tr.append(td);\n        }\n      }\n      table.prepend(tr);\n      table.find(\"td\").each((i, td) => {\n        $(td).css(\"max-width\", \"200px\");\n        $(td).css(\"word-wrap\", \"break-word\");\n      });\n      $div.append(table);\n\n      const addAnnotationButton = $(\"<div>Add Skip Block</div>\");\n      addAnnotationButton.button();\n      addAnnotationButton.click(() => {\n        if (self.currentHelenaProgram) {\n          loopStatement.addAnnotation(annotationItems, availableAnnotationItems,\n            self.currentHelenaProgram);\n        }\n      });\n      $div.append(addAnnotationButton);\n    }\n  };\n\n  private sortProps(props: { [key: string]: any }, alreadyChosen: string[]) {\n    const rankedProps: {\n      [key: string]: number;\n    } = {}\n    for (const prop in props) {\n      if (alreadyChosen.indexOf(prop) > -1) {\n        rankedProps[prop] = 20;\n      } else if (prop in this.highlyHumanReadable) {\n        rankedProps[prop] = this.highlyHumanReadable[prop];\n      } else if (prop.startsWith(\"child\")) {\n        rankedProps[prop] = 6;\n      } else if (prop.startsWith(\"lastChild\")) {\n        rankedProps[prop] = 5;\n      } else {\n        rankedProps[prop] = 0;\n      }\n    }\n    return Object.keys(rankedProps).sort(\n      (a,b) => rankedProps[b] - rankedProps[a]\n    );\n  }\n\n  public updateCustomThresholds() {\n    HelenaConsole.namedLog(\"tooCommon\", \"updateCustomThresholds\");\n    // program.relationFindingTimeoutThreshold and\n    //   program.nextButtonAttemptsThreshold\n    const prog = this.currentHelenaProgram;\n\n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set\");\n    }\n\n    const defaultSeconds = HelenaConfig.relationFindingTimeoutThreshold / 1000;\n    const defaultTries = HelenaConfig.nextButtonAttemptsThreshold;\n    console.log(defaultSeconds, defaultTries);\n\n    // first let's update the description text to include the correct defaults\n    const $div = $(\"#new_script_content\").find(\"#thresholds_container\");\n    $div.find(\".defaultRelationTimeout\").html(defaultSeconds.toString());\n    $div.find(\".defaultRetriesTotal\").html(defaultTries.toString());\n    $div.find(\".defaultRetries\").html((defaultTries - 1).toString());\n\n    // now let's update the text boxes to refelct the current program's custom\n    //   thresholds, if they have any and put the correct defaults in the input\n    //   boxes otherwise\n    const secondsInput =\n      <HTMLInputElement> $div.find(\"#relationGiveUpThreshold\")[0];\n    const triesInput = <HTMLInputElement> $div.find(\"#nextButtonRetries\")[0];\n\n    function setWithSavedValueIfAvailable(inputNode: HTMLInputElement,\n      savedValue: number | undefined, defaultValue: number) {\n      if (savedValue) { \n        inputNode.value = savedValue.toString();\n      } else {\n        inputNode.value = defaultValue.toString();\n      }\n    }\n\n    let progRelationFindingTimeoutThreshold = undefined;\n    if (prog.relationFindingTimeoutThreshold) {\n      progRelationFindingTimeoutThreshold =\n        prog.relationFindingTimeoutThreshold / 1000;\n    }\n\n    let progNextButtonAttemptsThreshold = undefined;\n    if (prog.nextButtonAttemptsThreshold) {\n      progNextButtonAttemptsThreshold =\n        prog.nextButtonAttemptsThreshold - 1;\n    }\n\n    setWithSavedValueIfAvailable(secondsInput,\n      progRelationFindingTimeoutThreshold, defaultSeconds);\n    setWithSavedValueIfAvailable(triesInput,\n      progNextButtonAttemptsThreshold, defaultTries - 1);\n\n    // ok, now what if the user changes the text in the text box?\n    function attachHandlerToUpdateProgValBasedOnNewInput(isint: boolean,\n      element: HTMLInputElement, prog: HelenaProgram, progAttribute:\n        \"relationFindingTimeoutThreshold\" | \"nextButtonAttemptsThreshold\",\n      defaultVal: number, transformInputToSaved: Function,\n      transformSavedToInput: Function) {\n      if (!element.dataset.hasHandler) {\n        $(element).change(() => {\n          let newVal;\n          if (isint) {\n            newVal = parseInt(element.value);\n          } else {\n            newVal = parseFloat(element.value);\n          }\n          if (newVal !== NaN) {\n            prog[progAttribute] = transformInputToSaved(newVal);\n            // in case we rounded, update what the input shows\n            element.value = newVal.toString();\n          } else {\n            // ugh, why'd you put in something we can't parse. set it back to\n            //   something reasonable\n            setWithSavedValueIfAvailable(element,\n              transformSavedToInput(prog[progAttribute]), defaultVal);\n          }\n        });\n        element.dataset.hasHandler = \"true\";\n      }\n    }\n\n    attachHandlerToUpdateProgValBasedOnNewInput(false, secondsInput, prog,\n      \"relationFindingTimeoutThreshold\", defaultSeconds,\n      (a: number) => a * 1000, (a: number) => a / 1000);\n\n    attachHandlerToUpdateProgValBasedOnNewInput(true, triesInput, prog,\n      \"nextButtonAttemptsThreshold\", defaultTries - 1, (a: number) => a + 1,\n      (a: number) => a - 1);\n  }\n\n  public updateCustomWaits() {\n    HelenaConsole.namedLog(\"tooCommon\", \"updateCustomWaits\");\n\n    // program.relationFindingTimeoutThreshold and\n    //   program.nextButtonAttemptsThreshold\n    const prog = this.currentHelenaProgram; \n\n    if (!prog) {\n      throw new ReferenceError(\"currentHelenaProgram not set.\");\n    }\n    const relations = <Relation[]> prog.relations;\n\n    const defaultSeconds = HelenaConfig.relationScrapeWait / 1000;\n\n    const $div = $(\"#new_script_content\").find(\"#thresholds_container2\");\n\n    for (const rel of relations) {\n      // first let's add a text box for the current relation\n      const $secondsInput = <JQuery<HTMLInputElement>>\n        $('<input type=\"text\" class=\"relationScrapeWait\">');\n      const newRel = $(\"<div><div>How long should we wait before extracting \" +\n        `content from newly-found table cells in table ${rel.name}?` +\n        \"</div></div>\");\n      newRel.append($secondsInput);\n      newRel.append(\"seconds\");\n      const wrapper = $div.find(\"#thresholds_container2_relations\");\n      wrapper.append(newRel);\n      const secondsInput = $secondsInput[0];\n\n      // let's update the text box to reflect the current program's custom\n      //   thresholds, if they have any and put the correct defaults in the\n      //   input boxes otherwise\n\n      if (rel.relationScrapeWait) {\n        secondsInput.value = (rel.relationScrapeWait / 1000).toString();\n      } else {\n        secondsInput.value = defaultSeconds.toString();\n      }\n\n      // ok, now what if the user changes the text in the text box?\n      if (!secondsInput.dataset.hasHandler) {\n        $(secondsInput).change(() => {\n          let newVal = parseFloat(secondsInput.value);\n          if (newVal !== NaN) {\n            if (newVal > 5) {\n              newVal = 5;\n            }\n            rel.relationScrapeWait = newVal * 1000;\n\n            // in case we rounded, update what the input shows\n            secondsInput.value = newVal.toString();\n          }\n          else{\n            secondsInput.value = defaultSeconds.toString();\n          }\n        });\n        secondsInput.dataset.hasHandler = \"true\";\n      }\n    }\n  }\n\n  public updateNodeRequiredFeaturesUI() {\n    const self = this;\n    HelenaConsole.log(\"updateNodeRequiredFeaturesUI\");\n    const similarityNodes =\n      this.currentHelenaProgram?.getNodesFoundWithSimilarity();\n\n    const $div =\n      $(\"#new_script_content\").find(\"#require_features_container_content\");\n\n    if (similarityNodes && similarityNodes.length > 0) {\n      $div.html(\"\");\n      for (const nodeVar of similarityNodes) {\n        const nodeDiv = $(\"<div class='require_features_node_item'>\" + \n          `<div class='node_name'>${nodeVar.toString()}</div></div>`);\n        const showNodeFeatures = () => {\n          const priorFeaturesDiv = nodeDiv.find(\".node_features_container\");\n          if (priorFeaturesDiv.length > 0) {\n            priorFeaturesDiv.remove();\n          }\n          const featuresDiv = $(\"<div class='node_features_container'></div>\");\n          const snapshot = nodeVar.recordTimeSnapshot();\n          const requiredFeatures = nodeVar.getRequiredFeatures();\n          if (snapshot) {\n            const sortedProps = self.sortProps(snapshot, requiredFeatures);\n            for (const p of sortedProps) {\n              const prop = p;\n              let val = (<Indexable> snapshot)[prop];\n              if (val && val.length && val.length > 200) {\n                val = val.slice(0,50) + \"...\" +\n                  val.slice(val.length - 50, val.length);\n              } else if (val === \"\") {\n                val = \"EMPTY\";\n              } else if (!val) {\n                val = String(val);\n              }\n              \n              const featureDiv = $(\"<div class='node_feature'>\" +\n                `<span class='node_prop'>${prop}</span> must be` +\n                `<span class='node_prop_val'>${val}</span></div>`);\n              if (requiredFeatures.includes(prop)) {\n                featureDiv.addClass('node_feature_selected');\n              } else {\n                featureDiv.addClass('node_feature_unselected');\n              }\n              featureDiv.click(() => {\n                if (requiredFeatures.includes(prop)) {\n                  // if it's currently required, stop requiring it\n                  nodeVar.unrequireFeature(prop);\n                } else {\n                  // if it's currently not required, start requiring it\n                  nodeVar.requireFeature(prop);\n                }\n                // in either case, once the feature node is clicked, have to\n                //   re-display the feature data for the whole node\n                showNodeFeatures();\n              });\n              featuresDiv.append(featureDiv);\n            }\n          }\n          nodeDiv.append(featuresDiv);\n        }\n\n        $(nodeDiv.find(\".node_name\")[0]).click(() => {\n          // toggle whether we're showing\n          const priorFeaturesDiv = nodeDiv.find(\".node_features_container\");\n          if (priorFeaturesDiv.length > 0) {\n            priorFeaturesDiv.remove();\n          } else {\n            showNodeFeatures();\n          }\n        });\n\n        $div.append(nodeDiv);\n      }\n    } else {\n      $div.html(\"All of this script's cells come from tables. \" + \n        \"If you're not happy with the table cells, you might try using the \" +\n        \"`Edit This Table' buttons above.\");\n    }\n  }\n\n  public addNewRowToOutput(runTabId: string, listOfCellTexts: string[],\n    limit = 100) {\n    const div = $(\"#\" + runTabId).find(\"#running_script_content\")\n      .find(\"#output_preview\").find(\"table\").find(\"tbody\");\n    const l = div.children().length;\n    if (l === limit) {\n      if ($(\"#\" + runTabId).find(\"#running_script_content\")\n        .find(\"#output_preview\").find(\"#data_too_big\").length === 0) {\n          $(\"#\" + runTabId).find(\"#running_script_content\")\n            .find(\"#output_preview\")\n            .append($(\"<div id='data_too_big'>This dataset is too big for us \" +\n              `to display.  The preview here shows the first ${limit} rows. ` +\n              \"To see the whole dataset, click the download button above.\" +\n              \"</div>\"));  \n      }\n    } else if (l < limit) {\n      HelenaConsole.log(\"adding output row: \", l);\n      div.append(DOMCreation.arrayOfTextsToTableRow(\n        listOfCellTexts));\n    }\n    $(\"#\" + runTabId).find(\"#running_script_content\")\n      .find(\"#output_explanation\").hide();\n  }\n\n  public uploadRelation() {\n    const self = this;\n    HelenaConsole.log(\"going to upload a relation.\");\n    const div = $(\"#new_script_content\");\n    DOMCreation.replaceContent(div, $(\"#upload_relation\"));\n    // and let's actually process changes\n    $('#upload_data').on(\"change\", this.handleNewUploadedRelation.bind(this));\n    \n    // we're actually using this relation. the program better get parameterized\n    activateButton(div, \"#upload_done\", () => {\n      if (self.currentUploadRelation) {\n        self.currentHelenaProgram?.tryAddingRelation(\n          self.currentUploadRelation);\n      }\n      self.showProgramPreview();\n    });\n    \n    // don't really need to do anything here\n    activateButton(div, \"#upload_cancel\", () => self.showProgramPreview());\n  }\n\n  public demonstrateRelation() {\n    // for now we'll just assume we want to introduce a new relation on first\n    //   page.  in future fix.  todo: fix\n    HelenaConsole.log(\"going to demo a relation.\");\n    const loadStmt = <LoadStatement> this.currentHelenaProgram?.statements[0];\n    let pageVarName = loadStmt.outputPageVar?.name;\n    if (!pageVarName) {\n      pageVarName = \"\";\n    }\n    let url = loadStmt.url;\n    if (!url) {\n      url = \"\";\n    }\n    // TODO: cjbaik: is this how you produce a dummy relation with these vars?\n    const newRelation = new Relation(\"\", \"\", {}, 1, 0, [], [], 0, pageVarName,\n      url, 1, null, 0);\n    this.editSelector(newRelation);\n  }\n\n  public handleNewUploadedRelation(event: JQuery.ChangeEvent) {\n    const self = this;\n    HelenaConsole.log(\"New list uploaded.\");\n    const fileName = event.target.files[0].name;\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      let str = <string> fileReader.result;\n      if (!str.endsWith(\"\\n\")) {\n        // sometimes last row gets dropped because no newline at the end of it\n        str = str + \"\\n\";\n      }\n      // ok, we have the file contents.  let's display them\n      self.currentUploadRelation = new TextRelation(str, fileName);\n      const csvData = self.currentUploadRelation?.relation;\n      let sampleData;\n      if (csvData && csvData.length > 100) {\n        // only going to show a sample\n        sampleData = csvData.slice(0,100);\n\n        // to indicate to user that it's a sample\n        sampleData.push(new Array(csvData[0].length).fill(\"...\"));\n      } else {\n        sampleData = csvData;\n      }\n      const tableElement = DOMCreation.arrayOfArraysToTable(\n        sampleData);\n      $(\"#upload_data_table\").append(tableElement);\n    }\n    // now that we know how to handle reading data, let's actually read some\n    fileReader.readAsText(event.target.files[0]);\n  }\n\n  public addDialog(title: string, dialogText: string,\n    buttonTextToHandlers: { [key: string]: Function}) {\n    const dialogDiv = $(\"#dialog\");\n    const dialogDiv2 = dialogDiv.clone();\n    dialogDiv2.attr(\"title\", title);\n    dialogDiv2.html(dialogText);\n    $(\"#new_script_content\").append(dialogDiv2);\n    const buttons = [];\n    for (const bt in buttonTextToHandlers) {\n      buttons.push({\n        text: bt,\n        click: () => {\n          dialogDiv2.remove();\n          buttonTextToHandlers[bt]();\n        }\n      });\n    }\n    dialogDiv2.dialog({\n      dialogClass: \"no-close\",\n      buttons: buttons,\n\n      // user shouldn't be able to close except by using one of our handlers\n      closeOnEscape: false\n    }).prev(\".ui-dialog-titlebar\").css(\"background\",\"#F9A7AE\");;\n    return dialogDiv2;\n  }\n\n  public continueAfterDialogue(text: string, continueButtonText: string,\n    continueButtonContinuation: Function) {\n    const handlers: { [key: string]: Function } = {};\n    handlers[continueButtonText] = continueButtonContinuation;\n    const dialog = this.addDialog(\"Continue?\", text, handlers);\n    // todo: also add the option to pause?  which would do the normal user pause\n    //   interaction?\n    return dialog;\n  };\n\n  public loadSavedScripts() {\n    const self = this;\n    HelenaConsole.log(\"going to load saved scripts.\");\n    const savedScriptsDiv = $(\"#saved_script_list\");\n    const handler = (response: SavedProgramMessage[]) => {\n      HelenaConsole.log(response);\n      const arrayOfArrays = response.map((prog) => {\n        const date = $.format.date(prog.date * 1000, \"dd/MM/yyyy HH:mm\")\n        return [prog.name, date];\n      });\n      const html = DOMCreation.arrayOfArraysToTable(arrayOfArrays);\n      const trs = html.find(\"tr\");\n      for (let i = 0; i < trs.length; i++) {\n        const cI = i;\n        HelenaConsole.log(\"adding handler\", trs[i], response[i].id);\n        $(trs[i]).click(() => {\n          HelenaConsole.log(cI);\n          const id = response[cI].id;\n          self.loadSavedProgram(id);\n        });\n        $(trs[i]).addClass(\"hoverable\");\n      }\n      savedScriptsDiv.html(\"\");\n      savedScriptsDiv.append(html);\n    }\n    HelenaServer.loadSavedPrograms(handler);\n  }\n\n  public loadScheduledScripts() {\n    const self = this;\n    chrome.storage.sync.get(\"scheduledRuns\", (obj) => {\n      const scriptsDiv = $(\"#scheduled_runs_list\");\n      if (!obj.scheduledRuns) {\n        // none to show\n        scriptsDiv.html(\"No runs scheduled now.\");\n        return;\n      }\n\n      // ok, looks like we have a few to show\n      scriptsDiv.html(\"\");\n      for (const run of obj.scheduledRuns) {\n        const newNode = $(`<div class='scheduled_script_run'>${run.progId}` +\n          `<br />${run.schedule}</div>`);\n        const removeButton =\n          $(\"<span class='ui-icon ui-icon-closethick'></span>\")\n        removeButton.click(() => {\n          // if we click, want to remove it from the saved chrome.storage, then\n          //   reshow the scheduled scripts\n          obj.scheduledRuns = obj.scheduledRuns.filter(\n            (schRun: object) => schRun !== run\n          );\n          chrome.storage.sync.set(obj, () => {\n            console.log(\"Saved the new unscheduled run.\");\n            // and let's tell the background script to retrieve all the\n            //   schedules so it will update the ones it's keeping track of\n            Messages.sendMessage(\"mainpanel\", \"background\",\n              \"scheduleScrapes\", {});\n          })\n          self.loadScheduledScripts();\n        });\n        newNode.append(removeButton);\n        scriptsDiv.append(newNode);\n      }\n      /*\n      chrome.storage.sync.set(obj, function() {\n        console.log(\"Saved the new scheduled run.\");\n        // and let's go back to our normal view of the program\n        pub.showProgramPreview(false);\n        // and let's tell the background script to retrieve all the schedules so\n        //   it will actually run them\n        Messages.sendMessage(\"mainpanel\", \"background\", \"scheduleScrapes\", {});\n      })\n      */\n    });\n  }\n\n  public loadSavedDataset(datasetId: number) {\n    const self = this;\n    HelenaConsole.log(\"loading dataset: \", datasetId);\n    HelenaServer.loadSavedDataset(datasetId, (progId: string) => {\n      self.loadSavedProgram(progId);\n    });\n  }\n\n  public loadSavedProgram(progId: string, continuation?: Function) {\n    const self = this;\n    console.log(\"loading program: \", progId);\n    HelenaServer.loadSavedProgram(progId,\n      (resp: { program: SavedProgramMessage }) => {\n        console.log(`[RecorderUI] received program: ${resp}`);\n        const revivedProgram = HelenaProgram.fromJSON(\n          resp.program.serialized_program);\n        \n        // if id was only assigned when it was saved, serialized_prog might not\n        //   have that info yet\n        revivedProgram.setId(resp.program.id);\n\n        revivedProgram.name = resp.program.name;\n\n        this.setCurrentProgram(revivedProgram, undefined);\n\n        // make that first tab (the program running tab) active again\n        $(\"#tabs\").tabs(\"option\", \"active\", 0);\n\n        // false because we're not currently processing the program (as in,\n        //   finding relations, something like that)\n        self.showProgramPreview(false);\n\n        if (continuation) {\n          continuation();\n        }\n      }\n    );\n  }\n\n  public updateRowsSoFar(runTabId: string, num: number) {\n    const div = $(\"#\" + runTabId).find(\"#running_script_content\");\n    div.find(\"#rows_so_far\").html(num.toString());\n  }\n}\n\nfunction downloadObject(filename: string, text: string) {\n  const element = document.createElement('a');\n  // element.setAttribute('href', 'data:text/plain;charset=utf-8,' +\n  //   encodeURIComponent(text));\n  element.setAttribute('href', URL.createObjectURL(new Blob([text], {\n                type: \"application/octet-stream\"})));\n  element.setAttribute('download', filename);\n\n  element.style.display = 'none';\n  document.body.appendChild(element);\n\n  element.click();\n\n  document.body.removeChild(element);\n}","import { HelenaConfig } from \"../../common/config/config\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Dataset } from \"../dataset\";\nimport { DatasetSliceRequest, RelationMessage,\n  Messages } from \"../../common/messages\";\nimport { ServerTransaction } from \"../lang/statements/control_flow/skip_block\";\n\nexport interface KnownRelationRequest {\n  url: string;\n}\n\nexport interface KnownRelationResponse {\n  relations: ServerRelationMessage[];\n}\n\ninterface ProgramIdResponse {\n  program_id: string;\n}\n\ninterface RetrieveRelationsRequest {\n  pages: {\n    frame_ids: number[];\n    page_var_name: string;\n    url: string;\n    xpaths: string[];\n  }[];\n}\n\nexport interface ServerRelationMessage {\n  selector_version: number;\n  selector: string;\n  name: string;\n  exclude_first: number;\n  id: number;\n  columns: {\n    xpath: string;\n    suffix: string;\n    name: string;\n    id: number\n  }[];\n  num_rows_in_demonstration: number;\n  next_type: number;\n  next_button_selector?: string;\n}\n\nexport interface RetrieveRelationsResponse {\n  pages: {\n    page_var_name: string;\n    relations: {\n      same_domain_best_relation: ServerRelationMessage | null;\n      same_url_best_relation: ServerRelationMessage | null;\n    }\n  }[];\n}\n\nexport interface RunNewProgramResponse {\n  run_id?: number;\n  sub_run_id: number;\n}\n\ninterface SaveProgramRequest {\n  associated_string?: string;\n  id: string;\n  name: string;\n  relation_objects?: (string | RelationMessage)[];\n  tool_id?: null;\n}\n\ninterface SaveRelationRequest {\n  relation: RelationMessage;\n}\n\nfunction keepSendingRequest(jQueryMethod: Function, url: string, msg: object,\n    successHandler?: Function, showWaitingMsg = true, extraText = \"\") {\n  let currentWait = 5000;\n  console.log(\"waiting for request\", url);\n\n  let successHandlerWrapped = successHandler;\n  let waitingForServerAlert: JQuery<HTMLElement>;\n  if (showWaitingMsg) {\n    waitingForServerAlert =\n      $(\"<div class='waiting_for_server'>\" +\n          \"<img style='margin-right:7px' src='../icons/ajax-loader2.gif' \" +\n            \"height='10px'><span id='extra'></span>Waiting for the server\" +\n              extraText+\"...</div>\");\n    $(\"body\").append(waitingForServerAlert);\n    successHandlerWrapped = (data: object) => {\n      waitingForServerAlert.remove();\n      if (successHandler) {\n        successHandler(data);\n      }\n    }\n  }\n  const sendHelper = (msg: object) => {\n    jQueryMethod(url, msg, successHandlerWrapped).fail((jqxhr: JQuery.jqXHR,\n          status: string) => {\n        console.log(jqxhr, status);\n        // if we failed, need to be sure to send again...\n        setTimeout(() => { sendHelper(msg); }, currentWait);\n        // doing a little bit of backoff, but should probably do this in a\n        //   cleaner way\n        currentWait = currentWait * 2;\n        if (showWaitingMsg) {\n          // this was a failure, so say we're trying again\n          waitingForServerAlert.find(\"#extra\").html(\"Trying again. \" + \n            \"Is the server down?  Is your Internet connection slow?  \");\n          var additional = $(\"<div>\"+status+\"</div>\");\n          waitingForServerAlert.append(additional);\n          setTimeout(() => { additional.remove() }, 10000);\n        }\n      });\n  };\n  sendHelper(msg);\n}\n\n/**\n * Repeatedly issues a GET request to the Helena server.\n * @param url request URL\n * @param msg request data\n * @param successHandler callback for success\n * @param showWaitingMsg show/hide waiting status message div\n * @param extraText extra text to include in waiting message div\n */\nfunction keepGetting(url: string, msg: object, successHandler?: Function,\n  showWaitingMsg = true, extraText = \"\") {\n    keepSendingRequest($.get, url, msg, successHandler, showWaitingMsg,\n      extraText);\n}\n\n/**\n * Repeatedly issues a POST request to the Helena server.\n * @param url request URL\n * @param msg request data\n * @param successHandler callback for success\n * @param showWaitingMsg show/hide waiting status message div\n * @param extraText extra text to include in waiting message div\n */\nfunction keepPosting(url: string, msg: object, successHandler?: Function,\n    showWaitingMsg = true, extraText = \"\") {\n  keepSendingRequest($.post, url, msg, successHandler, showWaitingMsg,\n    extraText);\n}\n\n\nexport namespace HelenaServer {\n  export function checkSkipBlockTransaction(url: string, tx: ServerTransaction,\n      handler: Function) {\n    keepPosting(url, tx, handler, true,\n      \" to tell us if we should do this subtask\");\n  }\n\n  export function getKnownRelations(\n      req: KnownRelationRequest & Messages.MessageContentWithTab,\n      handler: any) {\n    $.post(HelenaConfig.helenaServerUrl + '/allpagerelations', req, handler);\n  }\n\n  export function loadSavedPrograms(handler: Function) {\n    HelenaConsole.log(\"loading programs\");\n    const toolId = window.helenaMainpanel.toolId;\n    console.log(\"toolId\", toolId);\n    keepGetting(HelenaConfig.helenaServerUrl + '/programs/',\n      {\n        tool_id: toolId\n      }, (resp: object) => {\n        handler(resp);\n    }, true, \" to retrieve saved programs\");\n  }\n\n  export function loadSavedDataset(datasetId: number, handler: Function) {\n    HelenaConsole.log(\"loading dataset: \", datasetId);\n    keepGetting(`${HelenaConfig.helenaServerUrl}/programfordataset/${datasetId}`,\n      {}, (resp: ProgramIdResponse) => {\n        const progId = resp.program_id;\n        handler(progId);\n    }, true, \" to load the saved dataset\");\n  }\n\n  export function loadSavedProgram(progId: string, handler: Function) {\n    console.log(`[HelenaServer] loading program: ${progId}`);\n    console.log(`[HelenaServer] url: ${HelenaConfig.helenaServerUrl + '/programs/' + progId}`);\n    keepGetting(HelenaConfig.helenaServerUrl + '/programs/' + progId, {},\n      (resp: object) => {\n        console.log(`[HelenaServer] received program: ${resp}`);\n        handler(resp);\n    }, true, \" to load the saved program\");\n  }\n\n  export function newSkipBlockTransaction(\n      req: ServerTransaction & DatasetSliceRequest, handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/newtransactionwithdata', req,\n      handler, false);\n  }\n\n  export function retrieveRelations(req: RetrieveRelationsRequest,\n      handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/retrieverelations', req,\n      handler, true, \" to tell us about any relevant tables\");\n  }\n  \n  export function runNewProgram(dataset: Dataset, handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/newprogramrun',\n      {\n        name: dataset.name,\n        program_id: dataset.programId\n      }, (resp: RunNewProgramResponse) => {\n        handler(resp);\n      }, true, \" to tell us it's ready to save scraped data\");\n  }\n\n  export function saveRelation(req: SaveRelationRequest, handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/saverelation', req, handler,\n      false);\n  }\n\n  export function saveProgram(req: SaveProgramRequest, handler: Function,\n      showWaitingStatus = true, extraText = \"\") {\n    keepPosting(HelenaConfig.helenaServerUrl + '/saveprogram', req, handler,\n      showWaitingStatus, extraText);\n  }\n\n  export function sendDatasetSlice(slice: DatasetSliceRequest,\n      handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/datasetslice', slice, handler,\n      false);\n  }\n\n  export function subRunNewProgram(programRunId: number | undefined,\n      handler: Function) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/newprogramsubrun',\n      {\n        program_run_id: programRunId\n      }, (resp: RunNewProgramResponse) => {\n        handler(resp);\n      }, true, \" to tell us it's ready to save scraped data\");\n  }\n\n  export function updateDatasetRunName(dataset: Dataset) {\n    keepPosting(HelenaConfig.helenaServerUrl + '/updaterunname',\n      {\n        id: dataset.programRunId,\n        name: dataset.name,\n        program_id: dataset.programId\n      }\n    );\n  }\n}\n\n\n","import * as _ from \"underscore\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport { PageVariable } from \"./page_variable\";\nimport { Revival } from \"../revival\";\nimport { Environment } from \"../environment\";\nimport { Trace } from \"../../common/utils/trace\";\nimport { DOMRingerEvent } from \"../../ringer-record-replay/common/event\";\n\nexport enum NodeSources {\n  RELATIONEXTRACTOR = 1,\n  RINGER,\n  PARAMETER,\n  TEXTRELATION,\n};\n\nexport class NodeVariable implements Revival.Revivable {\n  public static counter = 0;\n\n  public ___revivalLabel___: string;\n  public name: string | null;\n  public nodeSource?: number;\n  private ___privateName___: string;\n  public recordedNodeSnapshot?: MainpanelNode.Interface | null;\n  public nodeRep: MainpanelNode.Interface;\n  // public mainpanelRep: MainpanelNode.Interface | null;\n  public imgData?: string | null;\n  public requiredFeatures: string[];\n\n  constructor(name?: string | null,\n      mainpanelRep?: MainpanelNode.Interface | null,\n      recordedNodeSnapshot?: MainpanelNode.Interface | null,\n      imgData?: string | null, source?: number) {\n    Revival.addRevivalLabel(this);\n\n    if (name) {\n      this.setName(name);\n    } else {\n      NodeVariable.counter += 1;\n      this.name = \"thing_\" + NodeVariable.counter;\n    }\n\n    if (source === NodeSources.PARAMETER) {\n      this.nodeSource = source;\n      // let's put this in our allNodeVariablesSeenSoFar record of all our nvs\n      window.helenaMainpanel.allNodeVariablesSeenSoFar.push(this);\n    }\n  \n    // ok, node variables are a little weird, because we have a special interest\n    //   in making sure that every place where the same node is used in the\n    //   script is also represented by the same object in the prog (so that we\n    //   can rename in one place and have it propogate all over the program, not\n    //   confuse the user into thinking a single node could be multiple)\n    this.recordedNodeSnapshot = recordedNodeSnapshot;\n    if (!recordedNodeSnapshot && mainpanelRep) {\n      // when we make a node variable based on a cell of a relation, we may not\n      //   have access to the full node snapshot\n      this.recordedNodeSnapshot = mainpanelRep;\n    }\n    // ok, but also sometimes we get the recorded snapshot, which records text\n    //   in the textcontent field but we'll want to reason about the text field\n    // nope, the textContent can totally be different from text have to just\n    //   start recording textContent of all the relation-scraped nodes\n    /*\n    if (this.recordedNodeSnapshot && this.recordedNodeSnapshot.textContent) {\n      this.recordedNodeSnapshot.text = this.recordedNodeSnapshot.textContent;\n    }\n    */\n\n    // go through here if they provided either a snapshot or a mainpanel rep\n    if (this.recordedNodeSnapshot) {\n      // actually go through and compare to all prior nodes\n      for (const node of window.helenaMainpanel.allNodeVariablesSeenSoFar) {\n        if (source !== NodeSources.TEXTRELATION &&\n            this.sameNode(node)) {\n          // ok, we already have a node variable for representing this. just\n          //   return that. first update all the attributes based on how we now\n          //   want to use the node\n          if (name) { node.setName(name); }\n          // if (mainpanelRep) { node.mainpanelRep = mainpanelRep; }\n          if (source) { node.nodeSource = source; }\n          if (recordedNodeSnapshot) {\n            node.recordedNodeSnapshot = recordedNodeSnapshot;\n          }\n          if (imgData) { node.imgData = imgData; }\n          return node;\n        }\n      }\n      // ok, this is our first time seeing the node.  go ahead and build it in\n      //   the normal way\n      this.imgData = imgData;\n      this.nodeSource = source;\n \n      // and let's put this in our allNodeVariablesSeenSoFar record of all our nvs\n      window.helenaMainpanel.allNodeVariablesSeenSoFar.push(this);\n    }\n \n   if (!window.helenaMainpanel.allNodeVariablesSeenSoFar.includes(this)) {\n     // ok, we're reconstructing a program, so we don't yet have this node\n     //   variable in our tracker of all node variables.  go ahead and add it\n     window.helenaMainpanel.allNodeVariablesSeenSoFar.push(this);\n   }\n   \n   this.requiredFeatures = [];\n  }\n\n  public static createDummy() {\n    return new NodeVariable();\n  }\n\n  /**\n   * Create a node variable from a trace.\n   * @param trace \n   */\n  public static fromTrace(trace: Trace) {\n    let recordTimeNodeSnapshot = null;\n    let imgData = null;\n    // may get 0-length trace if we're just adding a scrape statement by editing\n    //   (as for a known column in a relation)\n    if (trace.length > 0) {\n      // 0 bc this is the first ev that prompted us to turn it into the given\n      //   statement, so must use the right node\n      const ev = <DOMRingerEvent> trace[0];\n      recordTimeNodeSnapshot = ev.target.snapshot;\n      imgData = ev.additional.visualization;\n    }\n    return new NodeVariable(null, null, recordTimeNodeSnapshot, imgData,\n      NodeSources.RINGER); // null bc no preferred name\n  }\n\n  // we need these defined right here because we're about to use them in initialization\n  public getName() {\n    if (this.___privateName___) {\n      return this.___privateName___;\n    }\n    if (this.name) {\n      return this.name; // this is here for backwards compatibility.\n    }\n    return this.___privateName___;\n  }\n\n  public setName(name: string) {\n    // don't set it to the original name unless nothing else has that name yet\n    const otherNode = window.helenaMainpanel.getNodeVariableByName(name);\n    if (!otherNode) {\n      this.___privateName___ = name;\n    } else {\n      if (otherNode === this) {\n        // we're renaming it to the same thing.  no need to do anything\n        return;\n      }\n      this.setName(\"alt_\" + name);\n    }\n  }\n\n  public sameNode(otherNodeVariable: NodeVariable) {\n    const nr1 = this.recordedNodeSnapshot;\n    const nr2 = otherNodeVariable.recordedNodeSnapshot;\n    if (!nr1 || !nr2 || nr1.xpath === \"\" || nr2.xpath === \"\") {\n      // don't return that things line up just because we failed to find a node.\n      // it will make us try to redefine the same thing over and over, and we'll\n      //   get errors from that\n      return false;\n    }\n\n    // baseURI is the url on which the ndoe was found\n    const ans = nr1.xpath === nr2.xpath && nr1.source_url === nr2.source_url;\n    return ans;\n  }\n\n  public toString(alreadyBound = true, pageVar?: PageVariable) {\n    if (alreadyBound) {\n      return this.getName();\n    }\n    return this.imgData? this.imgData : \"undefined\";\n  }\n\n  public recordTimeText() {\n    return this.recordedNodeSnapshot?.text;\n  }\n\n  public recordTimeLink() {\n    return this.recordedNodeSnapshot?.link;\n  }\n\n  public recordTimeXPath() {\n    return this.recordedNodeSnapshot?.xpath;\n  }\n\n  public recordTimeSnapshot() {\n    return this.recordedNodeSnapshot;\n  }\n\n  public setCurrentNodeRep(environment: Environment.Frame,\n    nodeRep: MainpanelNode.Interface | null) {\n    // todo: should be a better way to get env\n    HelenaConsole.log(\"setCurrentNodeRep\", this.getName(), nodeRep);\n    environment.envBind(this.getName(), nodeRep);\n  }\n\n  public currentNodeRep(environment: Environment.Frame):\n    MainpanelNode.Interface {\n    // don't want to let someone call this and start messing with the\n    //   enviornment representation, so clone\n    return _.clone(environment.envLookup(this.getName()));\n  }\n\n  public currentText(environment: Environment.Frame) {\n    const text = this.currentNodeRep(environment).text;\n    return text? text : \"undefined\";\n  }\n\n  public currentLink(environment: Environment.Frame) {\n    return this.currentNodeRep(environment).link;\n  }\n\n  public currentXPath(environment: Environment.Frame) {\n    return this.currentNodeRep(environment).xpath;\n  }\n\n  public setSource(src: number) {\n    this.nodeSource = src;\n  }\n\n  public getSource() {\n    return this.nodeSource;\n  }\n\n  public getRequiredFeatures() {\n    return this.requiredFeatures;\n  }\n\n  public setRequiredFeatures(featureSet: string[]) {\n    this.requiredFeatures = featureSet;\n  }\n\n  public requireFeature(feature: string) {\n    this.requiredFeatures.push(feature);\n  }\n\n  public unrequireFeature(feature: string) {\n    this.requiredFeatures = this.requiredFeatures.filter(\n      (reqFeat) => reqFeat !== feature\n    );\n  }\n}","// import { SortedArray } from \"../../common/utils/sorted_array\";\n\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { MainpanelNode } from \"../../common/mainpanel_node\";\nimport { Revival } from \"../revival\";\nimport { RingerFrameInfo } from \"../../ringer-record-replay/common/event\";\n\n// note that first arg should be SortedArray not just sorted array\n/*function outlier(sortedList, potentialItem) {\n  // for now, difficult to deal with...\n  return false;\n  if (sortedList.length <= 10) {\n    // it's just too soon to know if this is an outlier...\n    return false;\n  }\n  // generous q1, q3\n  var q1 = sortedList.get(Math.floor((sortedList.length() / 4)));\n  var q3 = sortedList.get(Math.ceil((sortedList.length() * (3 / 4))));\n  var iqr = q3 - q1;\n\n  //var minValue = q1 - iqr * 1.5;\n  //var maxValue = q3 + iqr * 1.5;\n  var minValue = q1 - iqr * 3;\n  var maxValue = q3 + iqr * 3;\n  WALconsole.log(\"**************\");\n  WALconsole.log(sortedList.array);\n  WALconsole.log(q1, q3, iqr);\n  WALconsole.log(minValue, maxValue);\n  WALconsole.log(\"**************\");\n  if (potentialItem < minValue || potentialItem > maxValue) {\n    return true;\n  }\n  return false;\n}*/\n/*\ninterface PageStats {\n  numNodes: SortedArray;\n}\n\nfunction freshPageStats(): PageStats {\n  return { numNodes: new SortedArray([]) };\n}*/\n\nexport interface PageRelation {\n  currentRows: MainpanelNode.Interface[][] | null;\n  currentRowsCounter: number;\n  currentTabId?: number;\n  currentNextInteractionAttempts: number;\n  runNextInteraction?: boolean;\n  needNewRows?: boolean;\n}\n\nexport class PageVariable implements Revival.Revivable {\n  public ___revivalLabel___: string;\n  public name: string;\n  public recordTimeUrl: string;\n  public pageRelations: {\n    [key: string]: PageRelation\n  };\n  // public pageStats: PageStats;\n\n  public tabId?: number;\n\n  public recordTimeFrameData: RingerFrameInfo;\n\n  constructor(name: string, recordTimeUrl: string) {\n    Revival.addRevivalLabel(this);\n\n    this.name = name;\n    this.recordTimeUrl = recordTimeUrl;\n    this.pageRelations = {};\n    HelenaConsole.namedLog(\"prinfo\", \"fresh empty pageRelations\");\n    // this.pageStats = freshPageStats();\n  }\n\n  public static createDummy() {\n    return new PageVariable(\"\", \"\");\n  }\n\n  public static makePageVarsDropdown(pageVars: PageVariable[]) {\n    let pageVarsDropDown = [];\n    for (const pageVar of pageVars) {\n      const pageVarStr = pageVar.toString();\n      pageVarsDropDown.push([pageVarStr, pageVarStr]);\n    }\n    return pageVarsDropDown;\n  }\n  \n  public setRecordTimeFrameData(frameData: RingerFrameInfo) {\n    this.recordTimeFrameData = frameData;\n  }\n\n  public setCurrentTabId(tabId: number, continuation: Function) {\n    HelenaConsole.log(\"setCurrentTabId\", tabId);\n    this.tabId = tabId;\n    continuation();\n    return;\n    // we used to try outlier checking.  might be something to consider in\n    //   future, but didn't seem all the helpful so far\n    /*\n    this.currentTabIdPageStatsRetrieved = false;\n    that.nonOutlierProcessing(data, continuation);\n    if (tabId !== undefined) {\n      Messages.listenForMessageOnce(\"content\", \"mainpanel\", \"pageStats\", function(data) {\n        that.currentTabIdPageStatsRetrieved = true;\n        if (that.pageOutlier(data)) {\n          WALconsole.log(\"This was an outlier page!\");\n          var dialogText = \"Woah, this page looks very different from what we expected.  We thought we'd get a page that looked like this:\";\n          if (ReplayScript.prog.mostRecentRow) {\n            dialogText += \"<br>If it's helpful, the last row we scraped looked like this:<br>\";\n            dialogText += DOMCreation.arrayOfArraysToTable([ReplayScript.prog.mostRecentRow]).html(); // todo: is this really the best way to acess the most recent row?\n          }\n          UIObject.addDialog(\"Weird Page\", dialogText, \n            {\"I've fixed it\": function _fixedHandler() {WALconsole.log(\"I've fixed it.\"); that.setCurrentTabId(tabId, continuation);}, \n            \"That's the right page\": function _rightPageHandler() {WALconsole.log(\"That's the right page.\"); that.nonOutlierProcessing(data, continuation);}});\n        }\n        else{\n          that.nonOutlierProcessing(data, continuation);\n        }\n      });\n      MiscUtilities.repeatUntil(\n        function() {Messages.sendMessage(\"mainpanel\", \"content\", \"pageStats\", {}, null, null, [tabId], null);}, \n        function() {return that.currentTabIdPageStatsRetrieved;},\n  function() {},\n        1000, true);\n    }\n    else{\n      continuation();\n    }\n    */\n  }\n\n  public setAttributes(attrs: { [key: string]: any }) {\n    if ('tab' in attrs) {\n      this.tabId = attrs.tab;\n    }\n  }\n\n  public clearCurrentTabId() {\n    this.tabId = undefined;\n  }\n\n  /*\n  public nonOutlierProcessing(pageData, continuation) {\n    // wasn't an outlier, so let's actually update the pageStats\n    this.updatePageStats(pageData);\n    continuation();\n  }\n\n  public pageOutlier(pageData) {\n    return outlier(this.pageStats.numNodes, pageData.numNodes); // in future, maybe just iterate through whatever attributes we have, but not sure yet\n  }*/\n\n  /*\n  public updatePageStats(stats: PageStats) {\n    this.pageStats.numNodes.insert(stats.numNodes); // it's sorted\n  }*/\n  \n  public clearRelationData() {\n    this.pageRelations = {};\n    HelenaConsole.namedLog(\"prinfo\", \"clear relation data\");\n  }\n\n  public originalTabId() {\n    HelenaConsole.log(this.recordTimeFrameData);\n    if (this.recordTimeFrameData) {\n      return this.recordTimeFrameData.tab;\n    }\n    return null;\n  }\n\n  public currentTabId() {\n    return this.tabId;\n  }\n\n  public toString() {\n    return this.name;\n  }\n\n  public clearRunningState() {\n    this.tabId = undefined;\n    // this.pageStats = freshPageStats();\n    this.clearRelationData();\n  }\n}","import { TargetInfo } from \"../content/target\";\nimport { Delta } from \"../content/snapshot\";\nimport { RecordState } from \"./messages\";\n\nexport interface RingerFrameInfo {\n  iframeIndex?: number;\n  innerHeight: number;\n  innerWidth: number;\n  outerHeight: number;\n  outerWidth: number;\n  port?: string;\n  tab?: number;\n  topFrame?: boolean;\n  topURL?: string | ParameterizedTopURL;\n  URL: string;\n  windowId?: number;\n}\n\nexport interface RecordedRingerFrameInfo extends RingerFrameInfo {\n  iframeIndex: number;\n  innerHeight: number;\n  innerWidth: number;\n  outerHeight: number;\n  outerWidth: number;\n  port: string;\n  tab: number;\n  topFrame: boolean;\n  topURL: string | ParameterizedTopURL;\n  URL: string;\n  windowId: number;\n}\n\nexport interface RingerEventMeta {\n  deltas?: Delta[];\n  dispatchType?: string;\n  forceProp?: { [key: string]: any };\n  id?: string;\n  nodeName?: string;\n  pageEventId?: number;\n  recordId?: string;\n  recordState?: RecordState;\n}\n\nexport interface RecordedRingerEventMeta extends RingerEventMeta {\n  endEventId?: number;\n  id: string;\n  pageEventId?: number;\n}\n\nexport interface RingerTiming {\n  ignoreWait?: boolean;\n  triggerEvent?: string;\n  waitTime?: number;\n}\n\nexport interface RecordedRingerTiming extends RingerTiming {\n  waitTime: number;\n}\n\nexport interface RingerEvent {\n  additionalDataTmp?: {\n    display?: {\n      visible?: boolean;\n    };\n  };\n  additional?: {\n    [key: string]: any;\n  };\n  data: {\n    [key: string]: any;\n\n    timeStamp: number;\n    type: string;\n  };\n  deltas?: Delta[];\n  frame?: RingerFrameInfo | ParameterizedFrame;\n  pageEventId?: number;\n  meta?: RingerEventMeta;\n  relatedTarget?: TargetInfo;\n  replayed?: boolean;\n  target?: TargetInfo | ParameterizedTarget;\n  targetTimeout?: number;\n  timing?: RingerTiming;\n  type: string;\n}\n\nexport interface DOMRingerEvent extends RingerEvent {\n  additional: {\n    [key: string]: any;\n  };\n  frame: RingerFrameInfo;\n  meta: RingerEventMeta;\n  target: TargetInfo;\n  timing: RingerTiming;\n  type: \"dom\";\n}\n\nexport interface RecordedRingerEvent extends RingerEvent {\n  forceReplay?: boolean;\n  frame: RecordedRingerFrameInfo;\n  mayBeSkippable?: boolean;\n  meta: RecordedRingerEventMeta;\n  reset?: {\n    alreadyForced?: boolean;\n  };\n  target: TargetInfo | ParameterizedTarget;\n  timing: RecordedRingerTiming;\n}\n\nexport interface ParameterizedXPath {\n\tname: string;\n\tvalue: null;\n\torig_value: string;\n}\n\nexport interface ParameterizedTopURL {\n  name: string;\n  value: string | null;\n}\n\ninterface ParameterizedFrame extends RecordedRingerFrameInfo {\n  topURL: ParameterizedTopURL;\n}\n\ninterface ParameterizedTarget {\n  xpath: ParameterizedXPath;\n}\n\nexport interface ParameterizedRingerEvent extends RecordedRingerEvent {\n  frame: ParameterizedFrame;\n\ttarget: ParameterizedTarget;\n}\n\nexport interface StringParameterizeEvent {\n  orig_value: string;\n  parameter_name: string;\n  text_input_event: RecordedRingerEvent;\n  type: \"string_parameterize\";\n  value: string;\n}\n\nexport namespace RingerEvents {\n  export function isComplete(ev: RingerEvent) {\n    return (ev.type === \"completed\" && ev.data.type === \"main_frame\") ||\n           (ev.type === \"webnavigation\" && ev.data.type === \"onCompleted\" &&\n              ev.data.parentFrameId === -1);\n  }\n}","import { Indexable } from \"./utils\";\nimport { RingerParams } from \"./params\";\n\nexport enum LogLevel {\n  LOG = 1,\n  INFO,\n  DEBUG,\n  WARN,\n  ERROR,\n}\n\n/*\n * Logging utility. Allows logs to be disabled based upon name and level.\n */\nexport namespace Logs {\n  export let logRecord: string[] = [];\n\n  /**\n   * Check to see if the log is enabled and return a Logger.\n   */\n  export function getLog(...names: string[]) {\n    const enabledLogs = RingerParams.params.logging.enabled;\n    if (enabledLogs == 'all') {\n      return new Logger(names);\n    }\n\n    for (const name of names) {\n      if (enabledLogs.includes(name)) {\n        return new Logger(names);\n      }\n    }\n\n    return new NoopLogger();\n  };\n\n  export class Logger {\n    private level = RingerParams.params.logging.level;\n    private tag: string;\n\n    constructor(tags: string[]) {\n      let tagString = '';\n      for (let i = 0; i < tags.length; ++i) {\n        tagString += tags[i];\n        if (i !== tags.length - 1) {\n          tagString += ',';\n        }\n      }\n      this.tag = `[${tagString}]`;\n    }\n    \n    public debug(...args: any[]) {\n      if (this.level <= LogLevel.DEBUG) {\n        this.print('debug', args);\n      }\n    }\n\n    public error(...args: any[]) {\n      if (this.level <= LogLevel.ERROR) {\n        this.print('error', args);\n      }\n    }\n    \n    public info(...args: any[]) {\n      if (this.level <= LogLevel.INFO) {\n        this.print('info', args);\n      }\n    }\n\n    public log(...args: any[]) {\n      if (this.level <= LogLevel.LOG) {\n        this.print('log', args);\n      }\n    }\n\n    public warn(...args: any[]) {\n      if (this.level <= LogLevel.WARN) {\n        this.print('warn', args);\n      }\n    }\n\n    public print(f: string, origArgs: any[]) {\n      const args = [this.tag];\n      for (const origArg of origArgs) {\n        args.push(origArg.toString());\n      }\n\n      if (RingerParams.params.logging.saved) {\n        logRecord.push(args.toString());\n      }\n      if (RingerParams.params.logging.print) {\n        (<Indexable> console)[f].apply(console, args);\n      }\n    }\n  }\n\n  export class NoopLogger {\n    public debug() {}\n    public error() {}\n    public info() {}\n    public log() {}\n    public warn() {}\n  }\n}","export interface RingerMessage {\n  state?: string;\n  type: string;\n  value: any;\n}\n\nexport interface PortInfo {\n  portId?: string;\n  top: boolean;\n  URL: string;\n}\n\nexport interface UpdateEventMessage {\n  pageEventId: number;\n  updates: {\n    field: string;\n    value: any;\n  }[];\n}\n\nexport interface GetIdMessage extends RingerMessage {\n  type: \"id\";\n  value: string;\n}\n\nexport enum ReplayAckStatus {\n  SUCCESS = 'success',\n  PARTIAL ='partial' // only some of the commands replayed were successful\n}\n\nexport enum RecordState {\n  STOPPED = 'stopped',\n  RECORDING = 'recording',\n  REPLAYING = 'replaying' // the recorder is recording replayed actions\n}","import { LogLevel } from \"./logs\";\n\n/**\n * Compensation actions scheme, should be used when element properties differ\n *   between record and replay executions.\n */\nexport enum CompensationAction {\n  NONE = 'none',\n  FORCED = 'forced'\n}\n\n/**\n * Strategy to apply when an exception is thrown because of a disconnected\n *   port.\n */ \nexport enum BrokenPortStrategy {\n  RETRY = 'retry',\n  SKIP = 'skip'\n}\n\n/**\n * Strategy for how much time should be spent between events\n */\nexport enum TimingStrategy {\n  MIMIC = 'mimic',\n  SPEED = 'speed',\n  SLOWER = 'slower',\n  SLOWEST = 'slowest',\n  FIXED_1 = 'fixed_1',\n  RANDOM_0_3 = 'random_0_3',\n  PERTURB_0_3 = 'perturb_0_3',\n  PERTURB = 'purterb'\n}\n\n/**\n * Strategy for action to take after a timeout\n */\nexport enum TimeoutStrategy {\n  ERROR = 'error',\n  SKIP = 'skip'\n}\n\n\nexport interface IRingerParams {\n  capture: {\n    saveCaptureLocal: boolean;\n  };\n  compensation: {\n    enabled: boolean;\n    omittedProps: string[];\n  };\n  ctrlOnlyEvents: string[];\n  defaultProps: { [key: string]: any };\n  events: {\n    [key: string]: {\n      [key: string]: boolean\n    }\n  };\n  logging: {\n    level: LogLevel;\n    enabled: string;\n    print: boolean;\n    saved: boolean;\n  };\n  record: {\n    allEventProps?: boolean;\n    cancelUnrecordedEvents: boolean;\n    listenToAllEvents: boolean;\n    recordAllEventProps: boolean;\n  };\n  replay: {\n    atomic: boolean;\n    cascadeCheck: boolean;\n    brokenPortStrategy: BrokenPortStrategy;\n    cancelUnknownEvents: boolean;\n    captureWait: number;\n    compensation: CompensationAction;\n    defaultUser: boolean;\n    defaultWait: number;\n    defaultWaitNewTab: number;\n    defaultWaitNextEvent: number;\n    eventTimeout: null;\n    highlightTarget: boolean;\n    openNewTab: boolean;\n    saveReplay: boolean;\n    skipCascadingEvents: boolean;\n    targetTimeout: number;\n    timingStrategy: TimingStrategy;\n    urlSimilarity: number;\n  };\n}\n\nexport namespace RingerParams {\n  /**\n   * List of all events and whether or not we should capture them\n   */\n  let events = {\n    'Event': {\n      // 'abort': true,\n      'change': true,  // change event occurs before focus is lost (blur)\n      'copy': true,\n      'cut': true,\n      'error': false,\n      'input': true,  // input event occurs on each keystroke (or cut/paste)\n      'load': false,\n      'paste': true,\n      'reset': true,\n      'resize': false,\n      'scroll': false,\n      'select': true,\n      'submit': true,\n      'unload': false\n    },\n    'FocusEvent': {\n      'focus': true,\n      'blur': true\n    },\n    'MouseEvent': {\n      'click': true,\n      'dblclick': true,\n      'mousedown': true,\n      'mousemove': false,\n      'mouseout': false,\n      'mouseover': false,\n      'mouseup': true,\n      'mousewheel': false\n      // 'dragenter': false,\n      // 'dragleave': false,\n    },\n    'KeyboardEvent': {\n      'keydown': true,\n      'keyup': true,\n      'keypress': true\n    },\n    'TextEvent': {\n      'textInput': true  // similar to input event, doesn trigger with cp/pst\n    }\n  };\n\n  let defaultProps = {\n    'Event': {\n      'type': true,\n      'bubbles': true,\n      'cancelable': true,\n      'timeStamp': 0\n    },\n    'FocusEvent': {\n      'type': true,\n      'bubbles': true,\n      'cancelable': true,\n      'detail': 0,\n      'timeStamp': 0\n    },\n    'MouseEvent': {\n      'type': true,\n      'bubbles': true,\n      'cancelable': true,\n      'detail': 0,\n      'screenX': 0,\n      'screenY': 0,\n      'clientX': 0,\n      'clientY': 0,\n      'ctrlKey': false,\n      'altKey': false,\n      'shiftKey': false,\n      'metaKey': false,\n      'button': 0,\n      'timeStamp': 0,\n      'selectionStart': 0,\n      'selectionEnd': 0\n    },\n    'KeyboardEvent': {\n      'type': true,\n      'bubbles': true,\n      'cancelable': true,\n      'ctrlKey': false,\n      'altKey': false,\n      'shiftKey': false,\n      'metaKey': false,\n      'keyCode': 0,\n      'charCode': 0,\n      'timeStamp': 0,\n      'keyIdentifier': '',  // nonstandard to Chrome\n      'keyLocation': 0      // nonstandard to Chrome\n    },\n    'TextEvent': {\n      'type': true,\n      'bubbles': true,\n      'cancelable': true,\n      'data': '',\n      'inputMethod': 0,\n      'locale': '',\n      'timeStamp': 0\n    }\n  };\n\n  export let params: IRingerParams = {\n    events: events,\n    ctrlOnlyEvents: [\"mouseover\"],\n    defaultProps: defaultProps,\n    /*\n    panel: {\n      enableEdit: true,\n      enableRequest: true\n    },*/\n    logging: {\n      level: 4,\n      enabled: 'all',\n      print: true,\n      saved: true\n    },\n    compensation: {\n      enabled: true,\n      omittedProps: ['innerHTML', 'outerHTML', 'innerText', 'outerText',\n          'textContent', 'className', 'childElementCount', 'clientHeight',\n          'clientWidth', 'clientTop', 'clientLeft', 'offsetHeight',\n          'offsetWidth', 'offsetTop', 'offsetLeft', 'text', 'valueAsNumber',\n          'id', 'class', 'xpath', 'baseURI'],\n    },\n    record: {\n      recordAllEventProps: true,\n      cancelUnrecordedEvents: false,\n      listenToAllEvents: false\n    },\n    replay: {\n      openNewTab: true,\n      saveReplay: false,\n      cancelUnknownEvents: false,\n      skipCascadingEvents: true,\n      eventTimeout: null,\n      targetTimeout: 15,\n      compensation: CompensationAction.FORCED,\n      timingStrategy: TimingStrategy.MIMIC,\n      defaultWait: 1000,\n      defaultWaitNewTab: 5000,\n      defaultWaitNextEvent: 5000,\n      captureWait: 0,\n      highlightTarget: true,\n      brokenPortStrategy: BrokenPortStrategy.RETRY,\n      atomic: true,\n      cascadeCheck: true,\n      urlSimilarity: 0.2,\n      defaultUser: false\n    },\n    capture: {\n      saveCaptureLocal: true,\n    },\n    /*\n    server: {\n      // url: 'http://sbarman.webfactional.com/api/',\n      url: 'http://127.0.0.1:8000/api/',\n      user: 'sbarman',\n    },*/\n  };\n}\n","import { RingerParams } from \"./params\";\n\nexport interface Indexable {\n  [key: string]: any;\n}\n\nexport namespace Utilities {\n  /**\n   * Clone an object.\n   * @param obj \n   */\n  export function clone(obj: object) {\n    return JSON.parse(JSON.stringify(obj));\n  }\n\n  /**\n   * Get the longest common sub-expression of two URLs.\n   * @param x \n   * @param y \n   */\n  function lcs(x: string, y: string) {\n    let s, i, j, m, n,\n      lcs = [], row = [], c = [],\n      left, diag, latch;\n    //make sure shorter string is the column string\n    if (x.length < y.length) {s = x;x = y;y = s;}\n    m = x.length;\n    n = y.length;\n    //build the c-table\n    for (j = 0; j < n; row[j++] = 0);\n    for (i = 0; i < m; i++) {\n      c[i] = row = row.slice();\n      for (diag = 0, j = 0; j < n; j++, diag = latch) {\n        latch = row[j];\n        if (x[i] == y[j]) {row[j] = diag + 1;}\n        else {\n          left = row[j - 1] || 0;\n          if (left > row[j]) {row[j] = left;}\n        }\n      }\n    }\n    i--, j--;\n    //row[j] now contains the length of the lcs\n    //recover the lcs from the table\n    while (i > -1 && j > -1) {\n      if (i && c[i - 1][j]) {\n        i--;\n        continue;\n      } else if (j && c[i][j - 1]) {\n        j--;\n      } else {\n        j--;\n        lcs.unshift(x[i]);\n      }\n    }\n    return lcs.join('');\n  }\n\n  /**\n   * Get the Levenshtein distance of two strings.\n   * @param a \n   * @param b \n   */\n  export function levenshteinDistance(a: string, b: string) {\n    if (a.length === 0) return b.length; \n    if (b.length === 0) return a.length; \n\n    const matrix = [];\n\n    // increment along the first column of each row\n    for (let i = 0; i <= b.length; i++) {\n      matrix[i] = [i];\n    }\n\n    // increment each column in the first row\n    for (let j = 0; j <= a.length; j++) {\n      matrix[0][j] = j;\n    }\n\n    // Fill in the rest of the matrix\n    for(let i = 1; i <= b.length; i++) {\n      for(let j = 1; j <= a.length; j++) {\n        if (b.charAt(i-1) === a.charAt(j-1)) {\n          matrix[i][j] = matrix[i-1][j-1];\n        } else {\n          matrix[i][j] = Math.min(matrix[i-1][j-1] + 1, // substitution\n                                  Math.min(matrix[i][j-1] + 1, // insertion\n                                           matrix[i-1][j] + 1)); // deletion\n        }\n      }\n    }\n\n    return matrix[b.length][a.length];\n  }\n\n  /**\n   * Decide whether two urls are the same.\n   * @param similarity Threshold between 0 and 1 (most similar) which needs to\n   *   be met.\n   * @returns true if two urls match\n   */\n  export function matchUrls(origUrl: string, matchedUrl: string,\n      similarity: number) {\n    if (!similarity) {\n      similarity = RingerParams.params.replay.urlSimilarity;\n    }\n\n    const commonUrl = lcs(origUrl, matchedUrl);\n    const commonRatio = commonUrl.length /\n                        Math.max(origUrl.length, matchedUrl.length);\n\n    if (commonRatio > similarity) {\n      return true;\n    }\n\n    const origURLObj = new URL(origUrl);\n    const matchedURLObj = new URL(matchedUrl);\n\n    return origURLObj.hostname === matchedURLObj.hostname &&\n      origURLObj.pathname === matchedURLObj.pathname;\n  }\n\n  export function truncateDictionaryStrings(dict: Indexable,\n     stringLengthLimit: number, keysToSkip: string[]) {\n    for (const key in dict){\n      const val = dict[key];\n      if (!keysToSkip.includes(key) && typeof val === 'string' &&\n          val.length > stringLengthLimit){\n        dict[key] = val.slice(0, stringLengthLimit);\n      }\n    }\n  }\n}","import { Logs } from \"../common/logs\";\n\nexport namespace DOMUtils {\n  /**\n   * Convert a DOM node to a xpath expression representing the path from the\n   * document element.\n   * @param node\n   */\n  export function nodeToXPath(node: Node): string {\n    // a special case for events that happen on document\n    if (node === document) {\n      return \"document\";\n    }\n\n    const el = <Element> node;\n    if (el.tagName.toLowerCase() === 'html')\n      return el.tagName;\n\n    // if there is no parent node then this element has been disconnected\n    // from the root of the DOM tree\n    if (!el.parentNode) {\n      return '';\n    }\n\n    let ix = 0;\n    const siblings = el.parentNode.childNodes;\n    for (let i = 0; i < siblings.length; i++) {\n      const sibling = siblings[i];\n      if (sibling === el) {\n        return `${nodeToXPath(el.parentNode)}/${el.tagName}[${ix + 1}]`;\n      }\n      if (sibling.nodeType === Node.ELEMENT_NODE &&\n          (<Element> sibling).tagName === el.tagName) {\n        ix++;\n      }\n    }\n    throw new ReferenceError(\"Could not convert to XPath.\");\n  }\n\n  /**\n   * Convert a xpath expression to a set of matching nodes.\n   * @param xpath\n   */\n  export function xPathToNodes(xpath: string): Node[] {\n    // a special case for events that happen on document\n    if (xpath === \"document\") {\n      return [document];\n    }\n\n    try {\n      var lowerCaseXpath = xpath.toLowerCase();\n      if (lowerCaseXpath.includes(\"/svg\")) {\n        // ok, have to mess around with the prefixes for the svg components\n        const components = lowerCaseXpath.split(\"/\");\n        let foundSvg = false;\n        for (let i = 0; i < components.length; i++) {\n          const c = components[i];\n          if (c.startsWith(\"svg\")) {\n            foundSvg = true;\n          }\n          if (foundSvg) {\n            components[i] = \"svg:\" + c;\n          }\n        }\n        xpath = components.join(\"/\");\n      }\n\n      const q = document.evaluate(xpath, document, (prefix) => { \n        if (prefix === 'svg') {\n          return 'http://www.w3.org/2000/svg';\n        }\n        else {\n          return null;  // the default namespace\n        }\n      }, XPathResult.ANY_TYPE, null);\n      \n      const results = [];\n\n      let next = q.iterateNext();\n      while (next) {\n        results.push(next);\n        next = q.iterateNext();\n      }\n      return results;\n    } catch (e) {\n      Logs.getLog('misc').error('xPath throws error when evaluated:', xpath);\n    }\n    return [];\n  }\n\n  /**\n   * Convert a xpath expression representing the path from root to a node.\n   * @param xpath\n   */\n  export function simpleXPathToNode(xpath: string) {\n    // error was thrown, attempt to just walk down the dom tree\n    let currentNode = <Element> document.documentElement;\n    const paths = xpath.split('/');\n  \n    // assume first path is \"HTML\"\n    paths: for (let i = 1; i < paths.length; ++i) {\n      const children = currentNode.children;\n      const path = paths[i];\n      const splits = path.split(/\\[|\\]/);\n\n      const tag = splits[0];\n      let index = 1;\n      if (splits.length > 1) {\n        index = parseInt(splits[1]);\n      }\n\n      let seen = 0;\n      children: for (var j = 0; j < children.length; ++j) {\n        const c = children[j];\n        if (c.tagName === tag) {\n          seen++;\n          if (seen === index) {\n            currentNode = c;\n            continue paths;\n          }\n        }\n      }\n      Logs.getLog('misc').error('xpath child cannot be found', xpath);\n      return null;\n    }\n    return [currentNode];\n  }\n\n  /* Convert xpath to a single node */\n  /*\n  export function xPathToNode(xpath) {\n    var nodes = xPathToNodes(xpath);\n    //if we don't successfully find nodes, let's alert\n    if (nodes.length != 1)\n      Logs.getLog('misc').error(\"xpath doesn't return strictly one node\", xpath);\n\n    if (nodes.length >= 1)\n      return nodes[0];\n    else\n      return null;\n  }\n\n  export function isElement(obj) {\n    try {\n      //Using W3 DOM2 (works for FF, Opera and Chrom)\n      return obj instanceof HTMLElement;\n    }\n    catch (e) {\n      //Browsers not supporting W3 DOM2 don't have HTMLElement and\n      //an exception is thrown and we end up here. Testing some\n      //properties that all elements have. (works on IE7)\n      return (typeof obj === 'object') &&\n        (obj.nodeType === 1) && (typeof obj.style === 'object') &&\n        (typeof obj.ownerDocument === 'object');\n    }\n  }*/\n}","export namespace Highlight {\n  let counter = 0;\n  \n  /**\n   * Highlight a node with a green rectangle. Uesd to indicate the target.\n   * @param target the node\n   * @param time delay after which to unhighlight\n   */\n  export function highlightNode(target: HTMLElement, time: number) {\n    const offset = $(target).offset();\n    const boundingBox = target.getBoundingClientRect();\n    const newDiv = $('<div/>');\n    const idName = 'ringer-highlight-' + counter;\n    newDiv.attr('id', idName);\n    newDiv.css('width', boundingBox.width);\n    newDiv.css('height', boundingBox.height);\n    if (offset) {\n      newDiv.css('top', offset.top);\n      newDiv.css('left', offset.left);\n    }\n    newDiv.css('position', 'absolute');\n    newDiv.css('z-index', 1000);\n    newDiv.css('background-color', '#00FF00');\n    newDiv.css('opacity', .4);\n    $(document.body).append(newDiv);\n  \n    if (time) {\n      setTimeout(function() {\n        dehighlightNode(idName);\n      }, time);\n    }\n  \n    return idName;\n  }\n  \n  export function dehighlightNode(id: string) {\n    $('#' + id).remove();\n  }\n}","import { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Highlight } from \"./highlight\";\nimport { Indexable } from \"../common/utils\";\nimport {\n  Snapshot,\n  Delta,\n  NodeSnapshot,\n  PropertyDifferentDelta,\n} from \"./snapshot\";\nimport { Target, TargetInfo, TargetStatus } from \"./target\";\nimport { DOMUtils } from \"./dom_utils\";\nimport {\n  RingerMessage,\n  PortInfo,\n  ReplayAckStatus,\n  RecordState,\n  GetIdMessage,\n} from \"../common/messages\";\nimport {\n  RingerEvent,\n  RecordedRingerEvent,\n  DOMRingerEvent,\n} from \"../common/event\";\nimport { Logs } from \"../common/logs\";\nimport {\n  CompensationAction,\n  IRingerParams,\n  RingerParams,\n} from \"../common/params\";\n\n/**\n * Handlers for other tools using record & replay to put data in event messages.\n * The only default handler is `___additionalData___`, for copying data from\n *   record event objects to replay event objects.\n */\ninterface RecordingHandlers {\n  [key: string]: Function;\n  ___additionalData___: Function;\n}\n\n/**\n * Toggle the handlers in {@link RecordingHandlers} on/off.\n */\ninterface RecordingHandlersToggle {\n  [key: string]: boolean;\n  ___additionalData___: boolean;\n}\n\n/**\n * Handlers for other tools using record and replay to process event even before\n *   most processing done.\n */\ninterface RecordingFilters {\n  [key: string]: Function;\n}\n\n/**\n * Toggle the filters in {@link RecordingFilters} on/off.\n */\ninterface RecordingFiltersToggle {\n  [key: string]: boolean;\n}\n\ninterface RingerSnapshot {\n  before?: NodeSnapshot;\n  after?: NodeSnapshot;\n  target: HTMLElement;\n}\n\nexport interface TimeoutInfo {\n  startTime: number;\n  startIndex: number;\n  events: RingerEvent[] | null;\n}\n\nexport class RingerContent {\n  public recording: RecordState;\n  public frameId?: number;\n  public port: chrome.runtime.Port;\n\n  /**\n   * Record variables\n   */\n  public pageEventId: number; // counter to give each event on page a unique id\n  public lastRecordEvent: DOMRingerEvent | null; // last event recorded\n\n  // snapshot (before and after) for last event\n  public lastRecordSnapshot?: RingerSnapshot;\n\n  // snapshot (before and after) the current event\n  public curRecordSnapshot?: RingerSnapshot;\n\n  public additional_recording_handlers: RecordingHandlers;\n  public additional_recording_handlers_on: RecordingHandlersToggle;\n\n  public additional_recording_filters: RecordingFilters;\n  public additional_recording_filters_on: RecordingFiltersToggle;\n\n  /**\n   * Replay variables\n   */\n  public lastReplayEvent: RingerEvent; // last event replayed\n  public lastReplayTarget: HTMLElement;\n\n  // snapshot taken before the event is replayed\n  public lastReplaySnapshot: RingerSnapshot;\n\n  // snapshot taken before the next event is replayed\n  public curReplaySnapshot: RingerSnapshot;\n\n  public dispatchingEvent: boolean; // if we currently dispatching an event\n  public retryTimeout: number | null; // ID to callback for retrying\n\n  // current events we need are trying to dispatch\n  public simulatedEvents: RingerEvent[] | null;\n\n  public simulatedEventsIdx: number;\n  public timeoutInfo: TimeoutInfo;\n\n  /**\n   * Addon hooks\n   */\n  public addonStartup: (() => void)[];\n  public addonStartRecording: (() => void)[];\n  public addonPreRecord: ((ev: Event) => boolean)[];\n  public addonPostRecord: ((ev: Event, msg: RingerEvent) => boolean)[];\n  public addonPreReplay: ((\n    target: Node,\n    ev: Event,\n    msg: RingerEvent,\n    events: RingerEvent[]\n  ) => boolean)[];\n  public addonPreTarget: ((ev: RingerEvent) => boolean)[];\n  public addonTarget: ((ev: RingerEvent) => Node)[];\n\n  /**\n   * Loggers\n   */\n  public log: Logs.Logger | Logs.NoopLogger;\n  public recordLog: Logs.Logger | Logs.NoopLogger;\n  public replayLog: Logs.Logger | Logs.NoopLogger;\n\n  /**\n   * Prompt\n   */\n  public promptCallback: ((text: string) => void) | null;\n\n  constructor() {\n    this.recording = RecordState.STOPPED;\n    this.pageEventId = 0;\n\n    this.additional_recording_filters = {};\n    this.additional_recording_filters_on = {};\n    this.additional_recording_handlers = {\n      ___additionalData___: () => {\n        return {};\n      },\n    };\n    this.additional_recording_handlers_on = {\n      ___additionalData___: true,\n    };\n\n    this.dispatchingEvent = false;\n    this.retryTimeout = null;\n    this.simulatedEvents = null;\n    this.simulatedEventsIdx = 0;\n    this.timeoutInfo = {\n      startTime: 0,\n      startIndex: 0,\n      events: null,\n    };\n\n    this.addonStartup = [];\n    this.addonStartRecording = [];\n    this.addonPreRecord = [];\n    this.addonPostRecord = [];\n    this.addonPreReplay = [];\n    this.addonPreTarget = [];\n    this.addonTarget = [];\n\n    this.log = Logs.getLog(\"content\");\n    this.recordLog = Logs.getLog(\"record\");\n    this.replayLog = Logs.getLog(\"replay\");\n\n    // We need to add all the events now before and other event listeners are\n    //   added to the page. We will remove the unwanted handlers once params is\n    //   updated.\n    this.addListenersForRecording();\n\n    // Need to check if we are in an iframe\n    const value: PortInfo = {\n      top: window === window.top,\n      URL: document.URL,\n    };\n\n    // Add all the other handlers\n    chrome.runtime.sendMessage(\n      { type: \"getId\", value: value },\n      (resp: GetIdMessage) => {\n        if (!resp) return;\n\n        this.log.log(resp);\n\n        this.frameId = parseInt(resp.value);\n        this.port = chrome.runtime.connect({ name: resp.value });\n        this.port.onMessage.addListener(this.handleMessage.bind(this));\n\n        // see if recording is going on\n        this.port.postMessage({\n          type: \"getParams\",\n          value: null,\n          state: this.recording,\n        });\n        this.port.postMessage({\n          type: \"getRecording\",\n          value: null,\n          state: this.recording,\n        });\n\n        // handle any startup the addons need\n        for (const addonHandler of this.addonStartup) {\n          addonHandler();\n        }\n      }\n    );\n\n    // TODO: cjbaik: should this polling ever stop? seems to check when the URL\n    //   on the document changes. Could we implement an event listener for this?\n    window.setInterval(function () {\n      if (value.URL !== document.URL) {\n        const url = document.URL;\n        value.URL = url;\n        this.port.postMessage({\n          type: \"url\",\n          value: url,\n          state: this.recording,\n        });\n        this.log.log(\"url change: \", url);\n      }\n    }, 1000);\n  }\n\n  /**\n   * Attach the event handlers to their respective events.\n   */\n  public addListenersForRecording() {\n    const events = RingerParams.params.events;\n    for (const eventType in events) {\n      const listOfEvents = events[eventType];\n      for (const e in listOfEvents) {\n        listOfEvents[e] = true;\n        document.addEventListener(e, this.recordEvent.bind(this), true);\n        HelenaConsole.namedLog(\"tooCommon\", \"adding listener content\", e);\n      }\n    }\n  }\n\n  /**\n   * Check if the current event has timed out.\n   *\n   * @param events The current list of events to replay.\n   * @param startIndex The index into {@link events} which is needs to be\n   *     replayed.\n   * @returns {boolean} True if timeout has occured\n   */\n  public checkTimeout(events: RingerEvent[], startIndex: number) {\n    let timeout = RingerParams.params.replay.targetTimeout;\n    if (events[startIndex] && events[startIndex].targetTimeout) {\n      timeout = <number>events[startIndex].targetTimeout;\n    }\n    console.log(\"Checking for timeout:\", timeout);\n    if (!(timeout === null || timeout === undefined) && timeout > 0) {\n      var curTime = new Date().getTime();\n\n      /* we havent changed event */\n      if (\n        this.timeoutInfo.events == events &&\n        this.timeoutInfo.startIndex == startIndex\n      ) {\n        if (curTime - this.timeoutInfo.startTime > timeout * 1000) {\n          return true;\n        }\n      } else {\n        this.timeoutInfo = {\n          startTime: curTime,\n          startIndex: startIndex,\n          events: events,\n        };\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Stop the next execution of {@link simulate}.\n   */\n  public clearRetry() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n      this.retryTimeout = null;\n    }\n  }\n\n  /**\n   * Update the last target, so that the record and replay deltas match.\n   * @param recordDeltas deltas from recording\n   * @param replayDeltas deltas from replay\n   * @param lastTarget last target\n   */\n  public fixDeltas(\n    recordDeltas: Delta[],\n    replayDeltas: Delta[],\n    lastTarget: HTMLElement & Indexable\n  ) {\n    this.replayLog.info(\"record deltas:\", recordDeltas);\n    this.replayLog.info(\"replay deltas:\", replayDeltas);\n\n    /* effects of events that were found in record but not replay */\n    const recordDeltasNotMatched = Snapshot.filterDeltas(\n      recordDeltas,\n      replayDeltas\n    );\n    /* effects of events that were found in replay but not record */\n    const replayDeltasNotMatched = Snapshot.filterDeltas(\n      replayDeltas,\n      recordDeltas\n    );\n\n    this.replayLog.info(\"record deltas not matched: \", recordDeltasNotMatched);\n    this.replayLog.info(\"replay deltas not matched: \", replayDeltasNotMatched);\n\n    const element = lastTarget;\n\n    for (const delta of replayDeltasNotMatched) {\n      this.replayLog.debug(\"unmatched replay delta\", delta);\n\n      if (delta.type === \"Property is different.\") {\n        const propDiffDelta = <PropertyDifferentDelta>delta;\n        const divProp = propDiffDelta.divergingProp;\n        if (\n          RingerParams.params.replay.compensation === CompensationAction.FORCED\n        ) {\n          try {\n            element[divProp] = propDiffDelta.orig.prop[divProp];\n            HelenaConsole.log(\n              \"updated prop\",\n              divProp,\n              \" to \",\n              propDiffDelta.orig.prop[divProp]\n            );\n          } catch (err) {\n            console.warn(\n              \"Attempted to update prop\",\n              divProp,\n              propDiffDelta.orig.prop[divProp]\n            );\n          }\n        }\n      }\n    }\n\n    /* the thing below is the stuff that's doing divergence synthesis */\n    for (const delta of recordDeltasNotMatched) {\n      this.replayLog.debug(\"unmatched record delta\", delta);\n\n      if (delta.type == \"Property is different.\") {\n        const diffPropDelta = <PropertyDifferentDelta>delta;\n        const divProp = diffPropDelta.divergingProp;\n        if (\n          RingerParams.params.replay.compensation == CompensationAction.FORCED\n        ) {\n          try {\n            element[divProp] = diffPropDelta.changed.prop[divProp];\n            HelenaConsole.log(\n              \"updated prop\",\n              divProp,\n              \" to \",\n              diffPropDelta.changed.prop[divProp]\n            );\n          } catch (err) {\n            console.warn(\n              \"Attempted to update prop\",\n              divProp,\n              diffPropDelta.orig.prop[divProp]\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the default event properties for an event.\n   * @param type The DOM event type\n   */\n  public getEventProps(type: string) {\n    const eventType = this.getEventType(type);\n    return RingerParams.params.defaultProps[eventType];\n  }\n\n  /**\n   * Get the class of an event, which is used to init and dispatch it\n   *\n   * @param type The DOM event type\n   * @returns The class type, such as MouseEvent, etc.\n   */\n  public getEventType(type: string) {\n    for (const eventType in RingerParams.params.events) {\n      const eventTypes = RingerParams.params.events[eventType];\n      for (const e in eventTypes) {\n        if (e === type) {\n          return eventType;\n        }\n      }\n    }\n    throw new ReferenceError(\"Invalid eventType.\");\n  }\n\n  /**\n   * Find matching event in simulatedEvents. Needed to ensure that an event is\n   *   not replayed twice, i.e. once by the browser and once by the tool.\n   */\n  public getMatchingEvent(eventData: Event) {\n    if (!this.dispatchingEvent) {\n      return null;\n    }\n\n    if (\n      this.simulatedEvents === null ||\n      this.simulatedEventsIdx >= this.simulatedEvents.length\n    ) {\n      return null;\n    }\n\n    const eventObject = this.simulatedEvents[this.simulatedEventsIdx];\n    if (eventObject.data.type === eventData.type) {\n      return eventObject;\n    }\n\n    return null;\n  }\n\n  /**\n   * Handle messages coming from the background page.\n   */\n  public handleMessage(request: RingerMessage) {\n    const type = request.type;\n\n    this.log.log(`[${this.frameId}] handle message:`, request, type);\n\n    if (type === \"recording\") {\n      this.recording = request.value;\n      if (this.recording === RecordState.RECORDING) {\n        /* handle any startup the addons need once a tab knows it's recording */\n        for (const addonHandler of this.addonStartRecording) {\n          addonHandler();\n        }\n      }\n    } else if (type === \"params\") {\n      this.updateParams(request.value);\n    } else if (type === \"dom\") {\n      this.simulate(request.value, 0);\n    } else if (type === \"stop\") {\n      this.updateDeltas();\n      this.resetRecord();\n    } else if (type === \"reset\") {\n      this.resetRecord();\n    } else if (type === \"pauseReplay\") {\n      this.clearRetry();\n    } else if (type === \"url\") {\n      this.port.postMessage({\n        type: \"url\",\n        value: document.URL,\n        state: this.recording,\n      });\n    } else if (type === \"promptResponse\") {\n      this.promptResponse(request.value);\n    } else {\n      this.log.error(\"cannot handle message:\", JSON.stringify(request));\n    }\n  }\n\n  /**\n   * Increment matched event counter.\n   */\n  public incrementMatchedEventIndex() {\n    this.simulatedEventsIdx++;\n  }\n\n  /**\n   * Does this send a prompt to the user?\n   * @param text\n   * @param callback\n   */\n  public promptUser(text: string, callback: (text: string) => void) {\n    if (!this.promptCallback) {\n      this.log.warn(\"overwriting old prompt callback\");\n    }\n\n    this.promptCallback = callback;\n    this.port.postMessage({\n      type: \"prompt\",\n      value: text,\n      state: this.recording,\n    });\n  }\n\n  /**\n   * Does this provide a response to a user prompt?\n   * @param text\n   */\n  public promptResponse(text: string) {\n    if (this.promptCallback) {\n      this.promptCallback(text);\n    }\n\n    this.promptCallback = null;\n  }\n\n  /**\n   * Create an event record given the data from the event handler.\n   */\n  public recordEvent(eventData: Event & Indexable) {\n    /* check if we are stopped, then just return */\n    if (this.recording == RecordState.STOPPED) {\n      return true;\n    }\n\n    for (const key in this.additional_recording_filters_on) {\n      // on may be false, or may lack a handler if user attached something silly\n      if (\n        !this.additional_recording_filters_on[key] ||\n        !this.additional_recording_filters[key]\n      ) {\n        continue;\n      }\n      const filterIt = this.additional_recording_filters[key](eventData);\n      if (filterIt) {\n        // the message including the eventMessage will never be sent, so this\n        //   event will never be recorded\n        return;\n      }\n    }\n\n    const type = eventData.type;\n    const dispatchType = this.getEventType(type);\n    let shouldRecord = RingerParams.params.events[dispatchType][type];\n    if (\n      RingerParams.params.ctrlOnlyEvents.includes(type) &&\n      !(<MouseEvent | KeyboardEvent>eventData).ctrlKey\n    ) {\n      //console.log(\"Ignoring \"+type+\" because CTRL key not down.\");\n      shouldRecord = false;\n    }\n\n    const matched = this.getMatchingEvent(eventData);\n\n    if (\n      !matched &&\n      type == \"change\" &&\n      this.recording == RecordState.REPLAYING\n    ) {\n      eventData.stopImmediatePropagation();\n      eventData.preventDefault();\n      return false;\n    }\n\n    /* cancel the affects of events which are not extension generated or are not\n     * picked up by the recorder */\n    if (\n      RingerParams.params.replay.cancelUnknownEvents &&\n      this.recording === RecordState.REPLAYING &&\n      !this.dispatchingEvent\n    ) {\n      this.recordLog.debug(\n        `[${this.frameId}] cancel unknown event during replay:`,\n        type,\n        dispatchType,\n        eventData\n      );\n      eventData.stopImmediatePropagation();\n      eventData.preventDefault();\n      return false;\n    }\n\n    if (\n      RingerParams.params.record.cancelUnrecordedEvents &&\n      this.recording === RecordState.RECORDING &&\n      !shouldRecord\n    ) {\n      this.recordLog.debug(\n        `[${this.frameId}] cancel unrecorded event:`,\n        type,\n        dispatchType,\n        eventData\n      );\n      eventData.stopImmediatePropagation();\n      eventData.preventDefault();\n      return false;\n    }\n\n    /* if we are not recording this type of event, we should exit */\n    if (!shouldRecord) {\n      return true;\n    }\n\n    /* handle any event recording the addons need */\n    for (const addonHandler of this.addonPreRecord) {\n      if (!addonHandler(eventData)) return false;\n    }\n\n    /* continue recording the event */\n    this.recordLog.debug(\n      `[${this.frameId}] process event:`,\n      type,\n      dispatchType,\n      eventData\n    );\n    this.sendAlert(\"Recorded event: \" + type);\n\n    const properties = this.getEventProps(type);\n    const target = <HTMLElement>eventData.target;\n    const nodeName = target.nodeName.toLowerCase();\n\n    const eventMessage: DOMRingerEvent = {\n      additional: {},\n      data: {\n        timeStamp: 0, // will be set below\n        type: \"\", // will be set below\n      },\n      frame: {\n        innerHeight: window.innerHeight,\n        innerWidth: window.innerWidth,\n        outerHeight: window.outerHeight,\n        outerWidth: window.outerWidth,\n        URL: document.URL,\n      },\n      meta: {\n        dispatchType: dispatchType,\n        nodeName: nodeName,\n        pageEventId: this.pageEventId++,\n        recordState: this.recording,\n      },\n\n      // TODO: cjbaik: moved this above `replayUpdateDeltas` and `updateDeltas`,\n      //   does it break?\n      target: Target.saveTargetInfo(target, this.recording),\n\n      timing: {},\n      type: \"dom\",\n    };\n\n    /* deal with all the replay mess that we can't do in simulate */\n    if (this.recording === RecordState.REPLAYING) {\n      this.replayUpdateDeltas(eventData, eventMessage);\n    }\n\n    /* deal with snapshotting the DOM, calculating the deltas, and sending\n     * updates */\n    this.updateDeltas(target);\n\n    const relatedTarget = eventData.relatedTarget;\n    if (relatedTarget) {\n      eventMessage.relatedTarget = Target.saveTargetInfo(\n        relatedTarget,\n        this.recording\n      );\n    }\n\n    /* record all properties of the event object */\n    if (RingerParams.params.record.allEventProps) {\n      for (const prop in eventData) {\n        try {\n          const value = eventData[prop];\n          const t = typeof value;\n          if (\n            t === \"number\" ||\n            t === \"boolean\" ||\n            t === \"string\" ||\n            t === \"undefined\"\n          ) {\n            eventMessage.data[prop] = value;\n          }\n        } catch (err) {\n          this.recordLog.error(\n            `[${this.frameId}] error recording property:`,\n            prop,\n            err\n          );\n        }\n      }\n    } else {\n      /* only record the default event properties */\n      for (const prop in properties) {\n        if (prop in eventData) {\n          eventMessage.data[prop] = eventData[prop];\n        }\n      }\n    }\n\n    // now we need to handle the timeStamp, which is milliseconds from epoch in\n    //   old Chrome, but milliseconds from start of current page load in new\n    //   Chrome\n    if (eventMessage.data.timeStamp < 307584000000) {\n      // if you've been waiting on this page for 10 years, you're out of luck\n      // we're assuming this is new Chrome's time since page loaeventMessage.d\n      eventMessage.data.timeStamp =\n        eventMessage.data.timeStamp + performance.timing.navigationStart;\n    }\n\n    /* handle any event recording the addons need */\n    for (const addonHandler of this.addonPostRecord) {\n      addonHandler(eventData, eventMessage);\n    }\n\n    for (const key in this.additional_recording_handlers_on) {\n      // on may be false, or may lack a handler if user attached something silly\n      if (\n        !this.additional_recording_handlers_on[key] ||\n        !this.additional_recording_handlers[key]\n      ) {\n        continue;\n      }\n      const handler = this.additional_recording_handlers[key];\n      const ret_val = handler(target, eventMessage);\n      if (ret_val === false) {\n        // additional recording handlers are allowed to throw out events by returning false\n        // this may not be a good design, so something to consider in future\n        // also, is false really the value that should do this?\n        return; // the message including the eventMessage will never be sent, so this event will never be recorded\n      }\n      if (ret_val !== null) {\n        eventMessage.additional[key] = ret_val;\n      }\n    }\n\n    /* save the event record */\n    this.recordLog.debug(\n      `[${this.frameId}] saving event message:`,\n      eventMessage\n    );\n    this.port.postMessage({\n      type: \"event\",\n      value: eventMessage,\n      state: this.recording,\n    });\n    this.lastRecordEvent = eventMessage;\n\n    /* check to see if this event is part of a cascade of events. we do this\n     * by setting a timeout, which will execute after the cascade of events */\n    setTimeout(() => {\n      if (!this.lastRecordEvent) {\n        throw new ReferenceError(\"lastRecordEvent is null.\");\n      }\n      const update = {\n        type: \"updateEvent\",\n        value: {\n          pageEventId: eventMessage.meta.pageEventId,\n          updates: [\n            {\n              field: \"meta.endEventId\",\n              value: this.lastRecordEvent.meta.pageEventId,\n            },\n          ],\n        },\n        state: this.lastRecordEvent.meta.recordState,\n      };\n      this.recordLog.debug(\"Update:\", update);\n      this.port.postMessage(update);\n    }, 0);\n\n    // TODO: special case with mouseover, need to return false\n    return true;\n  }\n\n  /**\n   * Fix deltas that did not occur during replay.\n   */\n  public replayUpdateDeltas(eventData: Event, eventMessage: DOMRingerEvent) {\n    const replayEvent = this.getMatchingEvent(eventData);\n    if (replayEvent) {\n      this.incrementMatchedEventIndex();\n\n      replayEvent.replayed = true;\n\n      eventMessage.meta.recordId = replayEvent.meta?.id;\n      const target = <HTMLElement>eventData.target;\n      this.snapshotReplay(target);\n\n      /* make sure the deltas from the last event actually happened */\n      if (RingerParams.params.compensation.enabled && this.lastReplayEvent) {\n        let recordDeltas = this.lastReplayEvent.meta?.deltas;\n        if (recordDeltas === undefined) {\n          this.recordLog.error(\n            \"no deltas found for last event:\",\n            this.lastReplayEvent\n          );\n          recordDeltas = [];\n        }\n\n        /* make sure replay matches recording */\n        if (this.lastReplaySnapshot) {\n          const replayDeltas = Snapshot.getDeltas(\n            this.lastReplaySnapshot.before,\n            this.lastReplaySnapshot.after\n          );\n          /* check if these deltas match the last simulated event\n           * and correct for unmatched deltas */\n          this.fixDeltas(recordDeltas, replayDeltas, this.lastReplayTarget);\n        }\n\n        /* Resnapshot to record the changes caused by fixing the deltas */\n        this.resnapshotBefore(target);\n      }\n      this.lastReplayEvent = replayEvent;\n      this.lastReplayTarget = target;\n    }\n  }\n\n  /**\n   * Reset all of the record-time variables.\n   */\n  public resetRecord() {\n    this.lastRecordEvent = null;\n    this.lastRecordSnapshot = undefined;\n    this.curRecordSnapshot = undefined;\n  }\n\n  /**\n   * Update the snapshot.\n   */\n  public resnapshotBefore(target: HTMLElement) {\n    this.curReplaySnapshot.before = Snapshot.snapshotNode(target);\n  }\n\n  /**\n   * Send an alert that will be displayed in the main panel.\n   */\n  public sendAlert(msg: string) {\n    this.port.postMessage({\n      type: \"alert\",\n      value: msg,\n      state: this.recording,\n    });\n  }\n\n  /**\n   * Set properties on events, even if they are read-only.\n   * @param e the event\n   * @param prop the property\n   * @param value the value\n   */\n  public setEventProp(e: Event & Indexable, prop: string, value: any) {\n    try {\n      if (e[prop] !== value) {\n        e[prop] = value;\n      }\n    } catch (err) {}\n\n    try {\n      if (e[prop] !== value) {\n        Object.defineProperty(e, prop, { value: value });\n      }\n    } catch (err) {}\n\n    try {\n      if (e[prop] !== value) {\n        let v = value;\n        Object.defineProperty(e, prop, {\n          get: () => v,\n          set: (arg) => {\n            v = arg;\n          },\n        });\n        Object.defineProperty(e, prop, { value: v });\n      }\n    } catch (err) {\n      this.replayLog.log(err);\n    }\n  }\n\n  /**\n   * Try simulating again in a bit of time.\n   * @param events events to simulate\n   * @param startIndex\n   * @param timeout time until retry\n   */\n  public setRetry(\n    events: RecordedRingerEvent[],\n    startIndex: number,\n    timeout: number\n  ) {\n    const self = this;\n    this.retryTimeout = setTimeout(() => {\n      self.simulate(events, startIndex);\n    }, timeout);\n    return;\n  }\n\n  /**\n   * Replays a set of events atomically.\n   * @param events The current list of events to replay.\n   * @param startIndex The index into {@link events} which needs to be\n   *     replayed.\n   */\n  public simulate(events: RecordedRingerEvent[], startIndex: number) {\n    /* since we are simulating new events, lets clear out any retries from\n     * the last request */\n    this.clearRetry();\n\n    this.simulatedEvents = events;\n    this.simulatedEventsIdx = 0;\n\n    for (let i = startIndex; i < events.length; ++i) {\n      /* Should not replay non-dom events here */\n      if (events[i].type !== \"dom\") {\n        this.replayLog.error(\"Simulating unknown event type\");\n        throw new ReferenceError(\"Unknown event type\");\n      }\n\n      const eventRecord = <DOMRingerEvent>events[i];\n\n      const eventData = eventRecord.data;\n      const eventName = eventData.type;\n\n      /* this event was detected by the recorder, so lets skip it */\n      if (RingerParams.params.replay.cascadeCheck && eventRecord.replayed) {\n        continue;\n      }\n\n      /* handle any event replaying the addons need */\n      for (const addonHandler of this.addonPreTarget) {\n        addonHandler(eventRecord);\n      }\n\n      this.replayLog.debug(\"simulating:\", eventName, eventData);\n\n      let target = null;\n      let targetInfo: TargetInfo | null = null;\n      if (this.addonTarget.length > 0) {\n        // use the addon's target\n        for (const addonHandler of this.addonTarget) {\n          target = addonHandler(eventRecord);\n          if (target) {\n            break;\n          }\n        }\n      } else {\n        targetInfo = <TargetInfo>eventRecord.target;\n        // const xpath = targetInfo.xpath;\n\n        /* find the target */\n        target = Target.getTarget(targetInfo);\n      }\n\n      // for debugging purposes it's sometimes helpful to fake node finding\n      //   failures\n      /*\n      if (Math.random() < 0.1){\n        this.port.postMessage({\n          type: 'findNodeWithoutRequiredFeatures',\n          value: null, state: recording});\n        setRetry(events, i, params.replay.defaultWait);\n        return;\n      }\n      */\n\n      // there are some cases where we're sure we have no node, in which case we\n      //   should just continue\n      if (\n        target === TargetStatus.REQUIRED_FEATURE_FAILED_CERTAIN ||\n        target === TargetStatus.TIMED_OUT_CERTAIN\n      ) {\n        i++;\n        this.setRetry(events, i, 0); // todo: is waiting 0 here ok?\n        return;\n      }\n\n      if (!target && eventRecord.data.type === \"blur\") {\n        // never wait to run blur event on node that doesn't currently exist.\n        //   doesn't make any sense to do that\n        this.replayLog.warn(\n          \"timeout finding target for blur event, skip event: \",\n          events,\n          i\n        );\n        // we timed out with this target, so lets skip the event\n        i++;\n      }\n\n      /* if no target exists, lets try to dispatch this event a little bit in\n       * the future, and hope the page changes */\n      if (!target || target === TargetStatus.REQUIRED_FEATURE_FAILED) {\n        if (this.checkTimeout(events, i)) {\n          if (\n            target === TargetStatus.REQUIRED_FEATURE_FAILED &&\n            eventRecord.additional.scrape\n          ) {\n            if (!targetInfo) {\n              throw new ReferenceError(\"TargetInfo is null.\");\n            }\n            // if we have a required feature failure, but it's just a scraping\n            //   event, go ahead and just don't scrape anything\n            const reqFeatures = <string[]>targetInfo.requiredFeatures;\n            const reqValues = reqFeatures.map(\n              (f) => (<TargetInfo>targetInfo).snapshot[f]\n            );\n            this.replayLog.warn(\n              \"REQUIREDFEATUREFAILURE finding scraping target, skip event: \",\n              events,\n              i,\n              reqFeatures,\n              reqValues\n            );\n            Target.markAsMissingFeatures(targetInfo);\n            // we timed out with this target, so lets skip the event\n            i++;\n          } else if (target === TargetStatus.REQUIRED_FEATURE_FAILED) {\n            // if we have a required feature failure and it's a node with which\n            //   we need to interact, should fail here or let top-level tool\n            //   decide\n            // todo: is this really where we shoudl be making these calls?\n            console.log(eventName, eventData, eventRecord);\n            // this is a special case, because the user has insisted on a few\n            //   special features, and we want\n            // the top-level tool to be allowed to decide what happens if node\n            //   addressing fails in this case\n            // so there will be a special error handler at the mainpanel for this\n            this.port.postMessage({\n              type: \"findNodeWithoutRequiredFeatures\",\n              value: null,\n              state: this.recording,\n            });\n          } else {\n            if (!targetInfo) {\n              throw new ReferenceError(\"TargetInfo is null.\");\n            }\n\n            // todo: is this really what we want?  perhaps we should let the\n            //   higher-level tool know what happened\n            // we can thus let it pick the strategy.  perhaps when it isn't\n            //   found, we should quit\n            this.replayLog.warn(\n              \"timeout finding target, skip event: \",\n              events,\n              i\n            );\n            Target.markTimedOut(targetInfo);\n            // we timed out with this target, so lets skip the event\n            i++;\n          }\n        }\n\n        this.setRetry(events, i, RingerParams.params.replay.defaultWait);\n        return;\n      }\n\n      if (RingerParams.params.replay.highlightTarget) {\n        if (![\"blur\", \"focus\"].includes(eventName)) {\n          Highlight.highlightNode(<HTMLElement>target, 100);\n        }\n      }\n\n      // additional handlers should run in replay only if ran in record\n      for (const key in this.additional_recording_handlers_on) {\n        this.additional_recording_handlers_on[key] = false;\n      }\n      for (const key in eventRecord.additional) {\n        this.additional_recording_handlers_on[key] = true;\n      }\n      // want to copy over any data in additionalData, so let's remember what's\n      //   in current event object's additionalData field\n      this.additional_recording_handlers_on.___additionalData___ = true;\n      this.additional_recording_handlers.___additionalData___ = () => {\n        if (\n          eventRecord.additional &&\n          eventRecord.additional.___additionalData___\n        ) {\n          return eventRecord.additional.___additionalData___;\n        }\n        return {};\n      };\n\n      /* Create an event object to mimick the recorded event */\n      const eventType = this.getEventType(eventName);\n      const defaultProperties = this.getEventProps(eventName);\n\n      if (!eventType) {\n        this.replayLog.error(\"can't find event type \", eventName);\n        return;\n      }\n\n      const options = jQuery.extend({}, defaultProperties, eventData);\n\n      // sometimes to adapt a script from mac to linux, want to switch from\n      //   metakey pressed to ctrl key pressed\n      if (\n        eventData.ctrlKeyOnLinux &&\n        window.navigator.platform.indexOf(\"Linux\") > -1\n      ) {\n        options.ctrlKey = true;\n      }\n      // sometimes to adapt a script from linux to mac, want to switch from ctrl\n      //   pressed to meta key pressed\n      if (\n        eventData.metaKeyOnMac &&\n        window.navigator.platform.indexOf(\"Mac\") > -1\n      ) {\n        options.metaKey = true;\n      }\n\n      let oEvent: Event & Indexable = document.createEvent(eventType);\n      if (eventType === \"Event\") {\n        oEvent = new Event(eventName, {\n          bubbles: options.bubbles,\n          cancelable: options.cancelable,\n        });\n      } else if (eventType === \"FocusEvent\") {\n        let relatedTarget = null;\n\n        if (eventRecord.relatedTarget) {\n          relatedTarget = Target.getTarget(eventData.relatedTarget);\n        }\n\n        oEvent = new UIEvent(eventName, {\n          bubbles: options.bubbles,\n          cancelable: options.cancelable,\n          detail: options.detail,\n          view: document.defaultView,\n        });\n        this.setEventProp(oEvent, \"relatedTarget\", relatedTarget);\n      } else if (eventType == \"MouseEvent\") {\n        let relatedTarget = null;\n\n        if (eventRecord.relatedTarget) {\n          let foundRelatedTarget = Target.getTarget(eventRecord.relatedTarget);\n          if (foundRelatedTarget instanceof Node) {\n            relatedTarget = foundRelatedTarget;\n          }\n        }\n\n        oEvent = new MouseEvent(eventName, {\n          altKey: options.altKey,\n          bubbles: options.bubbles,\n          button: options.button,\n          cancelable: options.cancelable,\n          clientX: options.clientX,\n          clientY: options.clientY,\n          ctrlKey: options.ctrlKey,\n          detail: options.detail,\n          metaKey: options.metaKey,\n          relatedTarget: relatedTarget,\n          screenX: options.screenX,\n          screenY: options.screenY,\n          shiftKey: options.shiftKey,\n          view: document.defaultView,\n        });\n      } else if (eventType == \"KeyboardEvent\") {\n        // TODO: nonstandard initKeyboardEvent\n        oEvent = new KeyboardEvent(eventName, {\n          altKey: options.altKey,\n          bubbles: options.bubbles,\n          cancelable: options.cancelable,\n          ctrlKey: options.ctrlKey,\n          key: options.keyIdentifier,\n          location: options.keyLocation,\n          metaKey: options.metaKey,\n          shiftKey: options.shiftKey,\n          view: document.defaultView,\n        });\n\n        const propsToSet = [\"charCode\", \"keyCode\"];\n\n        for (const prop of propsToSet) {\n          this.setEventProp(oEvent, prop, options[prop]);\n        }\n      } else if (eventType == \"TextEvent\") {\n        oEvent = new InputEvent(eventName, {\n          bubbles: options.bubbles,\n          cancelable: options.cancelable,\n          data: options.data,\n          inputType: options.inputMethod,\n          // locale: options.locale,\n          view: document.defaultView,\n        });\n      } else {\n        this.replayLog.error(\"unknown type of event\");\n      }\n\n      /* used to detect extension generated events */\n      oEvent.extensionGenerated = true;\n      if (eventData.cascading) {\n        oEvent.cascading = eventData.cascading;\n        oEvent.cascadingOrigin = eventData.cascadingOrigin;\n      }\n\n      this.replayLog.debug(\n        `[${this.frameId}] dispatchEvent`,\n        eventName,\n        options,\n        target,\n        oEvent\n      );\n\n      /* send the update to the injected script so that the event can be\n       * updated on the pages's context */\n      const detail: { [key: string]: any } = {};\n      for (const prop in oEvent) {\n        const data = oEvent[prop];\n        const type = typeof data;\n\n        if (\n          type === \"number\" ||\n          type === \"boolean\" ||\n          type === \"string\" ||\n          type === \"undefined\"\n        ) {\n          detail[prop] = data;\n        } else if (prop === \"relatedTarget\" && data instanceof HTMLElement) {\n          detail[prop] = DOMUtils.nodeToXPath(data);\n        }\n      }\n      document.dispatchEvent(new CustomEvent(\"webscript\", { detail: detail }));\n\n      /* update panel showing event was sent */\n      this.sendAlert(\"Dispatched event: \" + eventData.type);\n\n      /* handle any event replaying the addons need */\n      for (const preReplayHandler of this.addonPreReplay) {\n        preReplayHandler(target, oEvent, eventRecord, events);\n      }\n\n      // sometimes a tool will want to force us to set a target property before\n      //   dispatching event\n      if (eventRecord.meta.forceProp) {\n        for (const key in eventRecord.meta.forceProp) {\n          target = <Indexable & Node>target;\n          target[key] = eventRecord.meta.forceProp[key];\n        }\n      }\n\n      /* actually dispatch the event */\n\n      this.dispatchingEvent = true;\n      target.dispatchEvent(oEvent);\n      this.dispatchingEvent = false;\n    }\n    /* let the background page know that all the events were replayed (its\n     * possible some/all events were skipped) */\n    this.port.postMessage({\n      type: \"ack\",\n      value: { type: ReplayAckStatus.SUCCESS },\n      state: this.recording,\n    });\n    this.replayLog.debug(\"sent ack: \", this.frameId);\n  }\n\n  /**\n   * Create a snapshot of the target element.\n   */\n  public snapshotRecord(target: HTMLElement) {\n    this.lastRecordSnapshot = this.curRecordSnapshot;\n    if (this.lastRecordSnapshot)\n      this.lastRecordSnapshot.after = Snapshot.snapshotNode(\n        this.lastRecordSnapshot.target\n      );\n\n    this.curRecordSnapshot = {\n      before: Snapshot.snapshotNode(target),\n      target: target,\n    };\n  }\n\n  /**\n   * Take a snapshot of the target.\n   * @param target\n   */\n  public snapshotReplay(target: HTMLElement) {\n    this.replayLog.log(\"snapshot target:\", target);\n    this.lastReplaySnapshot = this.curReplaySnapshot;\n    if (this.lastReplaySnapshot) {\n      this.lastReplaySnapshot.after = Snapshot.snapshotNode(\n        this.lastReplaySnapshot.target\n      );\n    }\n\n    this.curReplaySnapshot = {\n      before: Snapshot.snapshotNode(target),\n      target: target,\n    };\n  }\n\n  /**\n   * Update the deltas for the previous event.\n   * @param target the event target\n   */\n  public updateDeltas(target?: HTMLElement) {\n    if (target) {\n      this.snapshotRecord(target);\n    }\n\n    if (this.lastRecordEvent && this.lastRecordSnapshot) {\n      const deltas = Snapshot.getDeltas(\n        this.lastRecordSnapshot.before,\n        this.lastRecordSnapshot.after\n      );\n      this.lastRecordEvent.deltas = deltas;\n      var update = {\n        type: \"updateEvent\",\n        value: {\n          pageEventId: this.lastRecordEvent.meta.pageEventId,\n          updates: [\n            {\n              field: \"meta.deltas\",\n              value: deltas,\n            },\n            {\n              field: \"meta.nodeSnapshot\",\n              value: Snapshot.snapshotNode(this.lastRecordSnapshot.target),\n            },\n          ],\n        },\n        state: this.recording,\n      };\n      this.port.postMessage(update);\n    }\n  }\n\n  /**\n   * Sends a message indicating an update to an existing event.\n   * @param eventMessage event to update\n   * @param field field of event to update\n   * @param value value of event to update\n   */\n  public updateExistingEvent(\n    eventMessage: DOMRingerEvent,\n    field: string,\n    value: string\n  ) {\n    const update = {\n      type: \"updateEvent\",\n      value: {\n        pageEventId: eventMessage.meta.pageEventId,\n        updates: [\n          {\n            field: field,\n            value: value,\n          },\n        ],\n      },\n      state: this.recording,\n    };\n    this.port.postMessage(update);\n  }\n\n  /**\n   * Update the parameters for this script's scope.\n   * @param newParams\n   */\n  public updateParams(newParams: IRingerParams) {\n    const oldParams = RingerParams.params;\n    RingerParams.params = newParams;\n\n    const oldEvents = oldParams.events;\n    const events = RingerParams.params.events;\n\n    // if we are listening to all events, then we don't need to do anything\n    //   since we should have already added listeners to all events at the very\n    //   beginning\n    if (RingerParams.params.record.listenToAllEvents) {\n      return;\n    }\n\n    for (const eventType in events) {\n      const listOfEvents = events[eventType];\n      const oldListOfEvents = oldEvents[eventType];\n      for (const e in listOfEvents) {\n        if (listOfEvents[e] && !oldListOfEvents[e]) {\n          this.log.log(`[${this.frameId}] extension listening for ${e}`);\n          document.addEventListener(e, this.recordEvent.bind(this), true);\n        } else if (!listOfEvents[e] && oldListOfEvents[e]) {\n          this.log.log(\n            `[${this.frameId}] extension stopped listening for ${e}`\n          );\n          document.removeEventListener(e, this.recordEvent.bind(this), true);\n        }\n      }\n    }\n  }\n}\n\n/*\nfunction injectScripts(paths) {\n  function injectScript(index) {\n    // inject code into the pages domain\n    var s = document.createElement('script');\n    s.src = chrome.extension.getURL(paths[index]);\n    s.onload = function() {\n      this.parentNode.removeChild(this);\n      if (index + 1 < paths.length)\n        injectScript(index + 1);\n    };\n    (document.head || document.documentElement).appendChild(s);\n  }\n  injectScript(0);\n}*/\n\n// TODO(sbarman): need to wrap these so variables don't escape into the\n// enclosing scope\n//injectScripts([\"scripts/lib/record-replay/common_params.js\",\n//               \"scripts/lib/record-replay/content_dom.js\",\n//               \"scripts/lib/record-replay/content_injected.js\"]);\n","import * as _ from \"underscore\";\n\nimport { Indexable, Utilities } from \"../common/utils\";\nimport { DOMUtils } from \"./dom_utils\";\nimport { RingerParams } from \"../common/params\";\n\n/**\n * Records effects of events (i.e. changes to a node).\n */\nexport interface Delta {\n  changed?: NodeSnapshot;\n  divergingProp?: string;\n  orig?: NodeSnapshot;\n  type: string;\n}\n\nexport interface PropertyDifferentDelta extends Delta {\n  changed: ElementSnapshot;\n  orig: ElementSnapshot;\n  divergingProp: string;\n}\n\nexport interface NodeAddedDelta extends Delta {\n  changed: NodeSnapshot;\n  divergingProp: undefined;\n  orig: undefined;\n}\n\nexport interface NodeMissingDelta extends Delta {\n  changed: undefined;\n  divergingProp: undefined;\n  orig: NodeSnapshot;\n}\n\nexport interface MiscDelta extends Delta {\n  changed: NodeSnapshot;\n  divergingProp: undefined;\n  orig: NodeSnapshot;\n}\n\n/**\n * An instance of a DOM node snapshot.\n */\nexport interface NodeSnapshot {\n  children?: NodeSnapshot[];\n  prop?: Indexable;\n  text?: string;\n  type: string;\n}\n\nexport interface ElementSnapshot extends NodeSnapshot {\n  children: NodeSnapshot[];\n  prop: Indexable;\n}\n\nexport interface TextNodeSnapshot extends NodeSnapshot {\n  text: string;\n}\n\n/**\n * Dealing with DOM node snapshots by saving their properties and children.\n * These can be very expensive operations, so use sparingly.\n */\nexport namespace Snapshot {\n  // Don't snapshot certain DOM nodes\n  let ignoreTags = { 'script': true, 'style': true };\n\n  /**\n   * Check if {@link delta1} changes all the props that {@link delta2} changes\n   *   or both leave property unchanged. Only checks for property differences.\n   * @param delta1\n   * @param delta2\n   */\n  function deltaEqual(delta1: Delta, delta2: Delta) {\n    const type = 'Property is different.';\n    if (delta1.type !== type || delta2.type !== type) {\n      this.log.error('deltaEqual called on unknown delta type.', delta1,\n        delta2);\n      return false;\n    }\n  \n    const prop1 = delta1.divergingProp;\n    const prop2 = delta2.divergingProp;\n  \n    return prop1 && prop2 && prop1 === prop2 &&\n           delta1.changed && delta2.changed &&\n           delta1.changed.prop && delta2.changed.prop &&\n           delta1.changed.prop[prop1] === delta2.changed.prop[prop2];\n  }\n\n  /**\n   * Find properties for which two objects have different values.\n   * @param obj1\n   * @param obj2\n   */\n  function divergingProps(obj1: Indexable, obj2: Indexable) {\n    if (!(obj1 && obj2)) {\n      throw new ReferenceError('divergingProps called with bad arguements');\n    }\n    obj1 = _.omit(obj1, RingerParams.params.compensation.omittedProps);\n    obj2 = _.omit(obj2, RingerParams.params.compensation.omittedProps);\n  \n    const divergingProps = [];\n    for (const prop in obj1) {\n      if (obj1[prop] != obj2[prop]) {\n        divergingProps.push(prop);\n      }\n    }\n    return divergingProps;\n  }\n\n  /**\n   * Return the list of deltas, taking out any deltas that appear in \n   *   {@link deltasToRemove}.\n   *\n   * @param delta\n   * @param deltasToRemove\n   *\n   * @returns Deltas contained in {@link delta} but not {@link deltasToRemove}\n   */\n  export function filterDeltas(deltas: Delta[], deltasToRemove: Delta[]) {\n    const finalDeltas = [];\n  \n    // for (var i = 0, ii = deltas.length; i < ii; ++i) {\n    for (const delta of deltas) {\n      // var delta = deltas[i];\n      let matched = false;\n      // for (var j = 0, jj = deltasToRemove.length; j < jj; ++j) {\n      for (const deltaToRemove of deltasToRemove) {\n        // var deltaToRemove = deltasToRemove[j];\n        /* check if every property changed by delta is also changed in the same\n         * way by deltaToRemove */\n        if (deltaEqual(delta, deltaToRemove)) {\n          matched = true;\n          continue;\n        }\n      }\n  \n      if (!matched) {\n        finalDeltas.push(delta);\n      }\n    }\n    return finalDeltas;\n  }\n\n  /**\n   * Calculates differences between two node snapshots.\n   *\n   * @param orig A snapshot of the original node\n   * @param changed A snapshot of the node after possible changes\n   *\n   * @returns a list of deltas, each delta indicating a property change\n   */\n  export function getDeltas(orig: NodeSnapshot | undefined,\n      changed: NodeSnapshot | undefined): Delta[] {\n    if (!orig && !changed) {\n      throw new ReferenceError(\"both nodes doesn't actually exist\");\n    }\n  \n    /* check if both nodes are DOM nodes and not just text nodes */\n    if (orig && changed &&\n        orig.type === 'DOM' && changed.type === 'DOM') {\n      const deltas = [];\n  \n      /* we've tried to match a node that turns out not to be the same\n       * we want to mark that this is a divergence, but there may be  more\n       * relevant deltas among its children, so let's just add this divergence\n       * and continue descending */\n      if (!nodeEquals(orig, changed)) {\n        let props1 = orig.prop || [];\n        let props2 = changed.prop || [];\n        const omittedProps = RingerParams.params.compensation.omittedProps;\n  \n        props1 = _.omit(props1, omittedProps);\n        props2 = _.omit(props2, omittedProps);\n  \n        const diffProps = divergingProps(props1, props2);\n        for (const diffProp of diffProps) {\n          deltas.push({\n            type: 'Property is different.',\n            orig: orig,\n            changed: changed,\n            divergingProp: diffProp\n          });\n        }\n      }\n      return deltas;\n    } else {\n      /* at least one node isn't a DOM node */\n      if (!orig) {\n        return [{\n          type: 'New node in changed DOM.',\n          orig: orig,\n          changed: changed\n        }];\n      } else if (!changed) {\n        return [{\n          type: 'Node missing in changed DOM.',\n          orig: orig,\n          changed: changed\n        }];\n      } else if (orig.type === 'DOM' || changed.type === 'DOM') {\n        return [{\n          type: 'Node types differ.',\n          orig: orig,\n          changed: changed\n        }];\n      } else if (orig.type === 'text' && orig.type === 'text') {\n        /* Both nodes should be text nodes */\n        if (nodeEquals(orig, changed)) {\n          return [];\n        }\n        /* sad, we descended all the way and the nodes aren't the same */\n        return [{\n          'type': 'Nodes not the same.',\n          'orig': orig,\n          'changed': changed\n        }];\n      } else {\n        throw new ReferenceError(\"Unable to create deltas.\");\n      }\n    }\n  }\n\n  /**\n   * Creates a snapshot of node properties. Only string, number, and boolean\n   * properties are copied.\n   *\n   * @param node The DOM node whose values should be copied.\n   * @param props An array of properties which should be copied. Alternatively\n   *     'all' can be specified which will copy all properties of the node.\n   *\n   * @returns mapping from property name to value.\n   */\n  function getProperties(node: Node & Indexable, props: 'all' | string[]) {\n    if (props === 'all') {\n      props = [];\n      for (const prop in node) {\n        props.push(prop);\n      }\n    } else if (!props) {\n      props = [];\n    }\n\n    const mapping: Indexable = {};\n    for (const prop of props) {\n      try {\n        const firstChar = prop.charCodeAt(0);\n        if (firstChar >= 65 && firstChar <= 90) {\n          continue;\n        }\n        const val = node[prop];\n        const type = typeof val;\n        if (type == 'string' || type == 'number' || type == 'boolean') {\n          mapping[prop] = val;\n        }\n      } catch (e) {\n        // do nothing\n      }\n    }\n    // let's add one special one that's useful for some purposes\n    mapping.source_url = window.location.href;\n\n    // for some pages, the strings for various text-y things get crazy long\n    // we're going to play around with truncating them to see if this helps with\n    //   some memory issues\n    // todo: is 300 a good limit?\n    Utilities.truncateDictionaryStrings(mapping, 300, [\"xpath\"]);\n\n    return mapping;\n  }\n\n  /**\n   * Checks if two node snapshots have all the same properties.\n   * @param node1\n   * @param node2\n   */\n  function nodeEquals(node1: NodeSnapshot, node2: NodeSnapshot) {\n    if (node1 && node2) {\n      if ('prop' in node1 && 'prop' in node2) {\n        const omittedProps = RingerParams.params.compensation.omittedProps;\n        const node1RelevantProps = _.omit(node1.prop, omittedProps);\n        const node2RelevantProps = _.omit(node2.prop, omittedProps);\n  \n        return _.isEqual(node1RelevantProps, node2RelevantProps);\n      } else if ('text' in node1 && 'text' in node2) {\n        return node1.text === node2.text;\n      }\n    }\n    return node1 === node2;\n  }\n\n  export function snapshot() {\n    const body = document.body;\n    const nodeName = body.nodeName.toLowerCase();\n    if (nodeName === 'body') {\n      return snapshotSubtree(body, 'html/body[1]');\n    }\n    throw new ReferenceError(\"Snapshot failed.\");\n  }\n\n  /**\n   * Create an array of snapshots from the node until the its highest parent\n   *   is reached.\n   *\n   * @param node\n   * @returns List of node snapshots, starting the highest ancestor.\n   */\n  export function snapshotBranch(node: Element | null) {\n    const path = [];\n    const props = ['className', 'id'];\n    while (node !== null) {\n      path.push(snapshotNodeHelper(node, DOMUtils.nodeToXPath(node),\n        true, props));\n      node = node.parentElement;\n    }\n    return path.reverse();\n  }\n\n  export function snapshotNode(node: Element | null) {\n    if (!node) { return undefined; }\n\n    return snapshotNodeHelper(node, DOMUtils.nodeToXPath(node), false, 'all');\n  }\n\n  /**\n   * Serializes a DOM node by saving properties of the node.\n   *\n   * @param node The DOM node to snapshot\n   * @param xpath The xpath of {@link node}\n   * @param childTags Whether the tags of {@link node}'s children\n   *     should also be snapshotted\n   * @param props The node's properties which should be saved\n   * \n   * @returns an object representing the {@link node}\n   */\n  function snapshotNodeHelper(node: Element, xpath: string, childTags: boolean,\n      props: 'all' | string[]) {\n    xpath = xpath.toLowerCase();\n\n    const nodeName = node.nodeName.toLowerCase();\n    const returnVal: NodeSnapshot = {\n      children: [],\n      prop: {},\n      type: 'DOM'\n    };\n\n    // possible failure due to cross-domain browser restrictions\n    if (nodeName !== 'iframe') {\n      returnVal.prop = getProperties(node, props);\n    }\n\n    const snapshotProps = <Indexable> returnVal.prop;\n    snapshotProps['nodeName'] = nodeName;\n    snapshotProps['xpath'] = xpath;\n\n    if (childTags) {\n      const childNodes = node.children;\n      const children = <NodeSnapshot[]> returnVal.children;\n      const childrenTags: { [key: string]: number } = {};\n\n      for (let i = 0; i < childNodes.length; ++i) {\n        const child = <Node> childNodes.item(i);\n        const nodeType = child.nodeType;\n\n        // let's track the number of tags of this kind we've seen in the\n        //   children so far, to build the xpath\n        const childNodeName = child.nodeName.toLowerCase();\n        if (!(childNodeName in childrenTags)) {\n          childrenTags[childNodeName] = 1;\n        } else {\n          childrenTags[childNodeName] += 1;\n        }\n\n        if (nodeType === Node.ELEMENT_NODE) {\n          if (!(childNodeName in ignoreTags)) {\n            const newPath = xpath + '/' + childNodeName + '[' +\n              childrenTags[childNodeName] + ']';\n            children.push(\n              snapshotNodeHelper(<Element> child, newPath, false, [])\n            );\n          }\n        }\n      }\n    }\n\n    return returnVal;\n  }\n\n  /**\n   * Create a tree of snapshots representing the subtree rooted at {@link node}.\n   *\n   * @returns a {@link NodeSnapshot} for the tree.\n   */\n  function snapshotSubtree(node: Element, xpath: string) {\n    const returnVal = snapshotNodeHelper(node, xpath, false, 'all');\n\n    const childNodes = node.childNodes;\n    const children: NodeSnapshot[] = [];\n    returnVal.children = children;\n\n    const childrenTags: Indexable = {};\n    for (let i = 0; i < childNodes.length; ++i) {\n      const child = <Node> childNodes.item(i);\n      const nodeType = child.nodeType;\n\n      // let's track the number of tags of this kind we've seen in the\n      //   children so far, to build the xpath\n      const childNodeName = child.nodeName.toLowerCase();\n      if (!(childNodeName in childrenTags)) {\n        childrenTags[childNodeName] = 1;\n      } else {\n        childrenTags[childNodeName] += 1;\n      }\n\n      if (nodeType === Node.TEXT_NODE) {\n        const value = child.nodeValue;\n        if (value) {\n          children.push({\n            text: value.trim(),\n            type: 'text'\n          });\n        }\n      } else if (nodeType === Node.ELEMENT_NODE) {\n        if (!(childNodeName in ignoreTags) &&\n            !(<Element> child).classList.contains('replayStatus')) {\n          const newPath = xpath + '/' + childNodeName + '[' +\n                        childrenTags[childNodeName] + ']';\n          children.push(snapshotSubtree(<Element> child, newPath));\n        }\n      }\n    }\n\n    return returnVal;\n  }\n}","import { Indexable, Utilities } from \"../common/utils\";\nimport { NodeSnapshot, Snapshot } from \"./snapshot\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { DOMUtils } from \"./dom_utils\";\nimport { RecordState } from \"../common/messages\";\n\ninterface ElementFeatures {\n  [key: string]: any;\n\n  xpath: string;\n}\n\ninterface DocumentFeatures extends ElementFeatures {\n  xpath: string;\n}\n\ninterface NonDocumentFeatures extends ElementFeatures {\n  source_url: string;\n\n  /** Text-related features */\n  // child0Text, child1Text, ...\n  // lastChild4Text, lastChild3Text, ...\n  firstThreeWords?: string;\n  firstTwoWords?: string;\n  firstWord?: string;\n  lastWord?: string;\n  possibleHeading?: string;\n  preColonText?: string;\n  previousElementSiblingText?: string;\n  textContent?: string;\n\n  /** Also includes CSS properties */\n  // there's a ton of these so won't list them here\n\n  /** Table-related features */\n  col_index?: number;\n  col_reverse_index?: number;\n  row_index?: number;\n  row_reverse_index?: number;\n}\n\nexport interface TargetInfo {\n  [key: string]: any;\n\n  branch?: NodeSnapshot[];\n  requiredFeatures?: string[];\n  snapshot: ElementFeatures;\n  // snapshot: NodeFeatures;\n  useXpathOnly?: boolean;\n  xpath: string;\n}\n\nexport enum TargetStatus {\n  REQUIRED_FEATURE_FAILED = 1,\n  REQUIRED_FEATURE_FAILED_CERTAIN,\n  TIMED_OUT_CERTAIN\n}\n\nexport namespace Target {\n  /** Caches nodes that have already been identified. */\n  let identifiedNodesCache: { [key: string]: Node } = {};\n\n  /** Stores whether targets are missing required features or not. */\n  let targetsMissingFeatures: { [key: string]: boolean } = {};\n\n  /** Stores target lookups that timed out. */\n  let timedOutNodes: { [key: string]: boolean } = {};\n\n  /**\n   * Find candidate elements given features.\n   * @param features \n   */\n  function getCandidateElements(features: ElementFeatures) {\n    HelenaConsole.log(\"running getAllSimilarityCandidates\");\n    let tagName = \"*\";\n    if (features.nodeName){\n      tagName = features.nodeName;\n    }\n    //return document.getElementsByTagName(tagName);\n    const visibleItems: Element[] = [];\n\n    document.querySelectorAll(tagName).forEach((el) => {\n      if ($(el).is(\":visible\")) {\n        visibleItems.push(el);\n      }\n    });\n\n    return visibleItems;\n  }\n\n  /**\n   * Featurize a DOM node.\n   * @param node \n   */\n  function getFeatures(node: Node) {\n    const info: ElementFeatures = {\n      xpath: DOMUtils.nodeToXPath(node)\n    };\n\n    // another special case for document, which doesn't have a lot of the\n    //   functions we'll call below\n    if (node === document) {\n      return <DocumentFeatures> info;\n    }\n\n    const el = <Element & Indexable> node;\n\n    let features: NonDocumentFeatures = {\n      ...info,\n      source_url: window.location.href\n    };\n\n    for (const prop in el) {\n      try {\n        let val = el[prop];\n\n        if (val !== null && typeof val === 'object') {\n          val = val.toString(); // sometimes get that toString not allowed\n        } else if (typeof val === 'function'){\n          continue;\n        }\n      \n        features[prop] = val;\n      } catch(err) {\n        continue;\n      }\n    }\n\n    const text = el.textContent;\n    if (text) {\n      features.textContent = text;\n      const trimmedText = text.trim();\n\n      const firstSpaceInd = trimmedText.indexOf(\" \");\n      if (firstSpaceInd > -1){\n          features.firstWord = trimmedText.slice(0,firstSpaceInd);\n          const secondSpaceInd = trimmedText.indexOf(\" \", firstSpaceInd + 1);\n          features.firstTwoWords = trimmedText.slice(0,secondSpaceInd);\n          const thirdSpaceInd = trimmedText.indexOf(\" \", secondSpaceInd + 1);\n          features.firstThreeWords = trimmedText.slice(0,thirdSpaceInd);\n          features.lastWord = trimmedText.slice(trimmedText.lastIndexOf(\" \"),\n            trimmedText.length);\n      }\n\n      const colonIndex = trimmedText.indexOf(\":\");\n      if (colonIndex > -1) {\n        features.preColonText = trimmedText.slice(0, colonIndex);\n      }\n    }\n    \n    const childNodes = el.childNodes;\n    const l = childNodes.length;\n    for (let i = 0; i < l; i++) {\n      const childText = childNodes[i].textContent;\n      features[`child${i}text`] = childText;\n      features[`lastChild${l-i}text`] = childText;\n    }\n\n    // keep ascending the parent links as long as the inner text is the same.\n    //   as soon as it's not the same, add the first text of the new thing as a\n    //   possible heading\n    let currentNode = $(el);\n    while (\n      $(currentNode).parent().text().trim() ===\n        $(currentNode).text().trim() ||\n      $(currentNode).parent().text().trim().startsWith(\n        $(currentNode).text().trim())) {\n      currentNode = $(currentNode).parent();\n    }\n  \n    // ok, let's go one more up to get to that parent node that has different\n    //   text.\n    currentNode = $(currentNode).parent();\n    const children = currentNode[0].children;\n    let possibleHeading = undefined;\n    for (let i = 0; i < children.length; i++) {\n      const child = children.item(i);\n      if (child?.textContent) {\n        possibleHeading = child.textContent.trim();\n        break;\n      }\n    }\n    features.possibleHeading = possibleHeading;\n\n    const prev = el.previousElementSibling;\n    if (prev && prev.textContent) {\n      features.previousElementSiblingText = prev.textContent;\n    }\n\n    // TODO: cjbaik: checked, and I don't think boundingBox has ANY properties\n    //   fulfilling hasOwnProperty so this is essentially doing nothing\n    const boundingBox = el.getBoundingClientRect();\n    for (const prop in boundingBox) {\n      if (boundingBox.hasOwnProperty(prop)) {\n        features[prop] = (<Indexable> boundingBox)[prop];\n      }\n    }\n  \n    const style = window.getComputedStyle(el, null);\n    for (let i = 0; i < style.length; i++) {\n      const prop = style[i];\n      features[prop] = style.getPropertyValue(prop);\n    }\n\n    // this may be a table cell, in which case we'll add a couple extra features\n    const $element = $(el);\n    const $table = $element.closest('table');\n    if ($table.length > 0) {\n      // cool, it is in a table\n      // want index and reverse index for rows and columns\n\n      // might not be good for nested tables, although at least we'll have\n      //   chosen the deepest table that contains the $element. todo: be better\n      const $rows = $table.find(\"tr\");\n      for (let i = 0; i < $rows.length; i++){\n        const $row = $rows[i];\n        if ($row.contains(el)) {\n          features.row_index = i;\n          features.row_reverse_index = $rows.length - i;\n          break;\n        }\n      }\n      const $tr = $element.closest('tr');\n\n      // same issue as comment above potentially.  todo: try again\n      const $cells = $tr.find(features.nodeName);\n      for (let i = 0; i < $cells.length; i++){\n        const $cell = $cells[i];\n        if ($cell.contains(el)) {\n          features.col_index = i;\n          features.col_reverse_index = $cells.length - i;\n          break;\n        }\n      }\n    }\n\n    // for some pages, the strings for various text-y things get crazy long\n    // we're going to play around with truncating them to see if this helps with\n    //   some memory issues\n    Utilities.truncateDictionaryStrings(info, 300, [\"value\",\n      \"xpath\"]);\n\n    return features;\n  }\n\n  export function getTarget(targetInfo: TargetInfo) {\n    // console.log(\"identifiedNodesCache\", identifiedNodesCache.length,\n    //   identifiedNodesCache);\n    if (!targetInfo) {\n      return null;\n    }\n\n    if (targetInfo.xpath in timedOutNodes) {\n      HelenaConsole.namedLog(\"nodeTimeout\", \"nope, this node timed out\");\n      return TargetStatus.TIMED_OUT_CERTAIN;\n    }\n    if (missingRequiredFeatures(targetInfo)) {\n      HelenaConsole.namedLog(\"nodeTimeout\",\n        \"nope, already know we don't have those features\");\n      return TargetStatus.REQUIRED_FEATURE_FAILED_CERTAIN;\n      // return \"REQUIREDFEATUREFAILURECERTAIN\";\n    }\n\n    const xpath = targetInfo.xpath;\n    if (xpath in identifiedNodesCache) {\n      // we've already had to find this node on this page. use the cached node.\n      const cachedNode = identifiedNodesCache[xpath];\n      // unless the page has changed and that node's not around anymore!\n      if (document.body.contains(cachedNode) && $(cachedNode).is(':visible')){\n        return cachedNode;\n      }\n    }\n\n    // we have a useXpathOnly flag set to true when the top level has\n    //   parameterized on xpath, and normal node addressing approach should be\n    //   ignored\n    if (targetInfo.useXpathOnly) {\n      const nodes = DOMUtils.xPathToNodes(xpath);\n      if (nodes.length > 0) {\n        const xpathNode = nodes[0];\n        HelenaConsole.namedLog(\"nodeTimeout\", \"xpathNode\", xpathNode);\n        return xpathNode;\n      }\n    }\n    // the top-level tool may specify that some subset of features remain stable\n    //   (text, id, so on, if they have special knowledge of page design)\n    // in this case, we should grab these requiredFeatures to use as a filter\n    let filterFeatures: string[] = [];\n    if (targetInfo.requiredFeatures) {\n      filterFeatures = targetInfo.requiredFeatures;\n    }\n\n    // ok, now let's use similarity-based node finding\n    const features = targetInfo.snapshot;\n    const winningNode = findBestElement(features, filterFeatures);\n    \n    // don't cache the TargetStatus return values we sometimes use\n    if (winningNode && typeof winningNode !== 'number') {\n      identifiedNodesCache[xpath] = winningNode;\n    }\n    return winningNode;\n  }\n\n  /**\n   * Returns true if the targetInfo is known to be missing required features.\n   * @param targetInfo \n   */\n  function missingRequiredFeatures(targetInfo: TargetInfo) {\n    if (!targetInfo.requiredFeatures){ return false; }\n    return targetsMissingFeatures[toString(targetInfo)];\n  }\n\n  /**\n   * Find the best element matching the features.\n   * @param features \n   * @param filterFeatures\n   */\n  function findBestElement(features: ElementFeatures,\n      filterFeatures: string[] = []) {\n    HelenaConsole.log(\"getTargetForSimilarityFiltered\", features,\n      filterFeatures);\n\n    let unfilteredCandidates = [];\n    if (window.helenaContent.ringerUseXpathFastMode ||\n        filterFeatures.includes(\"xpath\")) {\n      // this is a special case, where we can just speed it up by using the\n      //   xpath they want, since it's a required feature\n      const nodes = DOMUtils.xPathToNodes(features.xpath);\n      unfilteredCandidates = nodes;\n    } else {\n      // recall that this could be just the body node if nothing's loaded yet\n      unfilteredCandidates = getCandidateElements(features);\n    }\n\n    // soon we'll filter by text, since we're doing\n    //   getTargetForSimilarityFilteredByText\n    // but we need to filter based on the user-provided filterFeatures (the ones\n    //   required to be stable) first\n    let userFilteredCandidates = null;\n    if (filterFeatures.length === 0) {\n      userFilteredCandidates = unfilteredCandidates;\n    } else {\n      // have to convert to feature view to do our filtering!\n      const unfilteredCandidatesFeatures = unfilteredCandidates.map(\n        (c: Element) => getFeatures(c));\n      userFilteredCandidates = [];\n      for (let i = 0; i < unfilteredCandidates.length; i++){\n        const matchedAllFeatures = filterFeatures.every((feature) =>\n          unfilteredCandidatesFeatures[i][feature] === features[feature]\n        );\n        if (matchedAllFeatures){\n          userFilteredCandidates.push(unfilteredCandidates[i]);\n        }\n      }\n\n      HelenaConsole.log(\"userFilteredCandidates\", userFilteredCandidates.length,\n        userFilteredCandidates);\n      // 1 because we should always at least see the body node, which just means\n      //   we're not ready, right?\n      if (unfilteredCandidates.length > 1 &&\n          userFilteredCandidates.length === 0) {\n        // this is a case where, because user can require features that no\n        //   longer appear, we can get zero matches!\n        return TargetStatus.REQUIRED_FEATURE_FAILED;\n        // return \"REQUIREDFEATUREFAILURE\";\n      }\n    }\n\n    if (userFilteredCandidates.length === 0) {\n      // console.log(\"After filtering on user-selected features, no candidates\n      //   qualify.\");\n      return null;\n    }\n\n    // ok, now filter by text\n    const targetText = features.textContent;\n    const candidates = [];\n    for (const cand of userFilteredCandidates) {\n      if (cand.textContent === targetText){\n        candidates.push(cand);\n      }\n    }\n    if (candidates.length === 0) {\n      //fall back to the normal one that considers all nodes\n      return selectBestCandidate(features, userFilteredCandidates);\n    }\n    \n    //otherwise, let's just run similarity on the nodes that have the same text\n    return selectBestCandidate(features, candidates);\n  }\n\n  /**\n   * Mark a target as missing necessary features.\n   * @param targetInfo \n   */\n  export function markAsMissingFeatures(targetInfo: TargetInfo) {\n    HelenaConsole.namedLog(\"nodeTimeout\", \"marked as missing features\");\n    targetsMissingFeatures[toString(targetInfo)] = true;\n  }\n\n  /**\n   * Mark a target timed out, when it doesn't appear to exist on current page.\n   * @param targetInfo target info\n   */\n  export function markTimedOut(targetInfo: TargetInfo) {\n    HelenaConsole.namedLog(\"nodeTimeout\", \"marked timed out\");\n    timedOutNodes[targetInfo.xpath] = true;\n  }\n\n  /**\n   * Store information about the DOM node.\n   * @param target DOM node\n   * @param recording recording status\n   */\n  export function saveTargetInfo(target: Element, recording: string) {\n    const targetInfo: TargetInfo = {\n      //change this line to change node addressing approach\n      // snapshot: Snapshot.snapshotNode(target),\n      snapshot: getFeatures(target),\n      xpath: DOMUtils.nodeToXPath(target)\n    };\n    if (recording === RecordState.RECORDING) {\n      targetInfo.branch = Snapshot.snapshotBranch(target);\n    }\n    return targetInfo;\n  }\n\n  /**\n   * Select the best candidate element matching the features.\n   * @param features \n   * @param candidates \n   */\n  export function selectBestCandidate(features: ElementFeatures,\n      candidates: Node[]) {\n    let bestScore = -1;\n    let bestNode = null;\n    for (const cand of candidates) {\n      const info = getFeatures(cand);\n      let similarityCount = 0;\n      for (const prop in features) {\n        if (features.hasOwnProperty(prop)) {\n          if (features[prop] === info[prop]) {\n            similarityCount += 1;\n          }\n        }\n      }\n      if (similarityCount > bestScore){\n        bestScore = similarityCount;\n        bestNode = cand;\n      }\n    }\n    return bestNode;\n  }\n\n  /**\n   * Convert a {@link TargetInfo} to string.\n   * @param targetInfo \n   */\n  function toString(targetInfo: TargetInfo) {\n    if (!targetInfo.requiredFeatures) {\n      throw new ReferenceError(\"Expected requiredFeatures.\");\n    }\n    const featureNames = targetInfo.requiredFeatures.sort();\n    const values = featureNames.map((f) => targetInfo.snapshot[f]);\n    return `${featureNames.join(\"_\")}____${values.join(\"_\")}`;\n  }\n}\n\n/*\nfunction getFeature(element, feature){\n  if (feature === \"xpath\"){\n    return DOMUtils.nodeToXPath(element);\n  }\n  else if (feature === \"id\"){\n    return element.id;\n  }\n  else if (feature === \"preceding-text\"){\n    return $(element).prev().text();\n  }\n  else if (_.contains([\"tag\",\"class\"],feature)){\n    return element[feature+\"Name\"];\n  }\n  else if (_.contains([\"top\", \"right\", \"bottom\", \"left\", \"width\", \"height\"], feature)){\n    var rect = element.getBoundingClientRect();\n    return rect[feature];\n  }\n  else{\n    var style = window.getComputedStyle(element, null);\n    return style.getPropertyValue(feature);\n  }\n}*/\n  /* The following functions are different implementations to take a target\n   * info object, and convert it to a list of possible DOM nodes */ \n\n   /*\n  function getTargetSimple(targetInfo) {\n    return DOMUtils.xPathToNodes(targetInfo.xpath);\n  }\n\n  function getTargetSuffix(targetInfo) {\n\n    function helper(xpath) {\n      var index = 0;\n      while (xpath[index] == '/')\n        index++;\n\n      if (index > 0)\n        xpath = xpath.slice(index);\n\n      var targets = DOMUtils.xPathToNodes('//' + xpath);\n\n      if (targets.length > 0) {\n        return targets;\n      }\n\n      /* If we're here, we failed to find the child. Try dropping\n       * steadily larger prefixes of the xpath until some portion works.\n       * Gives up if only three levels left in xpath.\n      if (xpath.split('/').length < 4) {\n        /* No more prefixes to reasonably remove, so give up\n        return [];\n      }\n\n      var index = xpath.indexOf('/');\n      xpathSuffix = xpath.slice(index + 1);\n      return helper(xpathSuffix);\n    }\n\n    return helper(targetInfo.xpath);\n  }\n\n  function getTargetText(targetInfo) {\n    var text = targetInfo.snapshot.prop.innerText;\n    if (text) {\n      return DOMUtils.xPathToNodes('//*[text()=\"' + text + '\"]');\n    }\n    return [];\n  }\n\n  function getTargetSearch(targetInfo) {\n    /* search over changes to the ancesters (replacing each ancestor with a\n     * star plus changes such as adding or removing ancestors)\n\n    function helper(xpathSplit, index) {\n      if (index == 0)\n        return [];\n\n      var targets;\n\n      if (index < xpathSplit.length - 1) {\n        var clone = xpathSplit.slice(0);\n        var xpathPart = clone[index];\n\n        clone[index] = '*';\n        targets = DOMUtils.xPathToNodes(clone.join('/'));\n        if (targets.length > 0)\n          return targets;\n\n        clone.splice(index, 0, xpathPart);\n        targets = DOMUtils.xPathToNodes(clone.join('/'));\n        if (targets.length > 0)\n          return targets;\n      }\n\n      targets = DOMUtils.xPathToNodes(xpathSplit.join('/'));\n      if (targets.length > 0)\n        return targets;\n\n      return helper(xpathSplit, index - 1);\n    }\n\n    var split = targetInfo.xpath.split('/');\n    return helper(split, split.length - 1);\n  }\n\n  function getTargetClass(targetInfo) {\n    var className = targetInfo.snapshot.prop.className;\n    if (className) {\n      //DOMUtils.xPathToNodes(\"//*[@class='\" + className + \"']\");\n\n      var classes = className.trim().replace(':', '\\\\:').split(' ');\n      var selector = '';\n      for (var i = 0, ii = classes.length; i < ii; ++i) {\n        var className = classes[i];\n        if (className)\n          selector += '.' + classes[i];\n      }\n\n      return $.makeArray($(selector));\n    }\n    return [];\n  }\n\n  function getTargetId(targetInfo) {\n    var id = targetInfo.snapshot.prop.id;\n    if (id) {\n      var selector = '#' + id.trim().replace(':', '\\\\:');\n      return $.makeArray($(selector));\n    }\n    return [];\n  }\n\n  /*\n  function getTargetComposite(targetInfo) {\n    var targets = [];\n    var metaInfo = [];\n\n    for (var strategy in targetFunctions) {\n      try {\n        var strategyTargets = targetFunctions[strategy](targetInfo);\n        for (var i = 0, ii = strategyTargets.length; i < ii; ++i) {\n          var t = strategyTargets[i];\n          var targetIndex = targets.indexOf(t);\n          if (targetIndex == -1) {\n            targets.push(t);\n            metaInfo.push([strategy]);\n          } else {\n            metaInfo[targetIndex].push(strategy);\n          }\n        }\n      } catch (e) {}\n    }\n\n    var maxStrategies = 0;\n    var maxTargets = [];\n    for (var i = 0, ii = targets.length; i < ii; ++i) {\n      var numStrategies = metaInfo[i].length;\n      if (numStrategies == maxStrategies) {\n        maxTargets.push(targets[i]);\n      } else if (numStrategies > maxStrategies) {\n        maxTargets = [targets[i]];\n        maxStrategies = numStrategies;\n      }\n    }\n\n    return maxTargets;\n  }*/\n\n  /* Set the target function */\n  // getTargetFunction = getTargetComposite;\n\n  /* Given the target info, produce a single target DOM node. May get several\n   * possible candidates, and would just return the first candidate. */\n   /*\n  getTarget = function(targetInfo) {\n\tconsole.log(\"targetInfo\", targetInfo);\n    var targets = getTargetFunction(targetInfo);\n    if (!targets) {\n      console.log(\"No target found.\");\n      log.debug('No target found');\n      return null;\n    } else if (targets.length > 1) {\n      log.debug('Multiple targets found:', targets);\n      return null;\n    } else {\n      return targets[0];\n    }\n  };\n  */\n\n  /*\n  var getTargetForSimilarity = function(targetInfo) {\n    var candidates = getAllSimilarityCandidates(targetInfo);\n    return getTargetForSimilarityHelper(targetInfo, candidates);\n  };*/\n\n/* List of all target functions. Used for benchmarking */\n/*\ntargetFunctions = {\n  simple: getTargetSimple,\n  suffix: getTargetSuffix,\n  text: getTargetText,\n  class: getTargetClass,\n  id: getTargetId,\n  search: getTargetSearch\n};\n\n  // now let's not go crazy with recording when we've seen a timeout. if the\n  //   page changes, let's clear out all our timedOutNodes\n  // todo: should we also clear out the identifiedNodesCache\n  var observer = new window.MutationObserver(function(mutations, observer) {\n      // fired when a mutation occurs\n      HelenaConsole.namedLog(\"nodeTimeout\",\n        \"observed dom change, clearing timeout cache\");\n      timedOutNodes = {};\n      targetsMissingFeatures = {};\n  });\n  */","import { RingerMessage, PortInfo } from \"../common/messages\";\nimport { Logs } from \"../common/logs\";\n\nexport interface TabInfo {\n  top: PortInfo[];\n  frames: PortInfo[];\n}\n\ninterface SingleTopTabInfo {\n  top?: PortInfo;\n  frames: PortInfo[];\n}\n\n/**\n * Manages mappings between ports, tabs, iframes, etc.\n */\nexport class PortManager {\n  private log = Logs.getLog(\"ports\");\n  public numPorts: number;\n  public portIdToPort: { [key: string]: chrome.runtime.Port };\n  public portIdToPortInfo: { [key: string]: PortInfo };\n  public portIdToTabId: { [key: string]: number };\n  public portIdToWindowId: { [key: string]: number };\n  public tabIdToPortIds: { [key: number]: string[] };\n  public tabIdToTab: { [key: number]: chrome.tabs.Tab };\n  public tabIdToTabInfo: { [key: number]: TabInfo };\n  public tabIdToWindowId: { [key: number]: number };\n\n  constructor() {\n    this.numPorts = 0;\n    this.portIdToPort = {};\n    this.portIdToTabId = {};\n    this.portIdToPortInfo = {};\n    this.portIdToWindowId = {};\n    this.tabIdToPortIds = {};\n    this.tabIdToTabInfo = {};\n    this.tabIdToTab = {};\n    this.tabIdToWindowId = {};\n  }\n\n  /**\n   * When a port connects, store its metadata.\n   * @param port\n   */\n  public connectPort(port: chrome.runtime.Port) {\n    const self = this;\n\n    const portId = port.name;\n    const ports = this.portIdToPort;\n\n    this.portIdToPort[portId] = port;\n\n    port.onMessage.addListener((msg) => {\n      window.ringerMainpanel.handleMessage(port, msg);\n    });\n\n    port.onDisconnect.addListener((evt) => {\n      self.log.log(\"Disconnect port:\", port);\n\n      if (portId in ports) {\n        delete ports[portId];\n      } else {\n        throw new ReferenceError(\"Can't find port\");\n      }\n\n      const portInfo = self.portIdToPortInfo[portId];\n      const tabId = self.portIdToTabId[portId];\n      const tabInfo = self.tabIdToTabInfo[tabId];\n\n      let frames: PortInfo[];\n      if (tabInfo) {\n        if (portInfo.top) {\n          frames = tabInfo.top;\n        } else {\n          frames = tabInfo.frames;\n        }\n\n        for (let i = 0; i < frames.length; ++i) {\n          if (frames[i].portId === portId) {\n            frames.splice(i, 1);\n            break;\n          }\n        }\n      } else {\n        self.log.log(\"Cannot find information about tab:\", tabId, tabInfo);\n      }\n    });\n  }\n\n  /**\n   * Gets a new id from the content script.\n   * @param value\n   * @param sender\n   */\n  public getNewId(value: PortInfo, sender: chrome.runtime.MessageSender) {\n    const self = this;\n\n    // for some reason, the start page loads the content script but doesn't\n    //   have a tab id. in this case, don't assign an id\n    //console.log(\"getNewId\", value, sender);\n    if (!sender.tab) {\n      this.log.warn(\"request for new id without a tab id\");\n      return;\n    }\n\n    const windowId = sender.tab.windowId;\n\n    // bug with listening to removed tabs, so lets actually check which\n    //   tabs are open and then update our list appropriately\n    chrome.tabs.query({}, (openTabs) => {\n      self.updateRemovedTabs(openTabs);\n    });\n\n    this.numPorts++;\n    const portId = this.numPorts.toString();\n\n    this.log.log(\"adding new id: \", portId, value);\n\n    /* Update various mappings */\n    const tabId = sender.tab.id;\n    if (!tabId) {\n      throw new ReferenceError(\"No tab id was sent.\");\n    }\n\n    this.tabIdToTab[tabId] = sender.tab;\n    this.tabIdToWindowId[tabId] = windowId;\n    this.log.log(\"adding tab:\", tabId, sender.tab);\n\n    this.portIdToTabId[portId] = tabId;\n    this.portIdToPortInfo[portId] = value;\n    value.portId = portId;\n    this.portIdToWindowId[portId] = windowId;\n\n    let portIds = this.tabIdToPortIds[tabId];\n    if (!portIds) {\n      portIds = [];\n      this.tabIdToPortIds[tabId] = portIds;\n    }\n    portIds.push(portId);\n\n    let tabInfo: TabInfo = this.tabIdToTabInfo[tabId];\n    if (!tabInfo) {\n      tabInfo = {\n        top: [],\n        frames: [],\n      };\n      this.tabIdToTabInfo[tabId] = tabInfo;\n    }\n\n    if (value.top) {\n      tabInfo.top.push(value);\n      // console.log(\"this.tabIdToTabInfo, added top frame: \",\n      //   this.tabIdToTabInfo);\n    } else {\n      // console.log(\"this.tabIdToTabInfo, added non-top frame: \",\n      //   this.tabIdToTabInfo);\n      tabInfo.frames.push(value);\n    }\n    return portId;\n  }\n\n  /**\n   * Get a {@link chrome.runtime.Port} given a port id.\n   * @param portId\n   */\n  public getPort(portId: string) {\n    return this.portIdToPort[portId];\n  }\n\n  /**\n   * Get a {@link chrome.tabs.Tab} from the tab id.\n   * @param tabId\n   */\n  public getTabFromTabId(tabId: number) {\n    return this.tabIdToTab[tabId];\n  }\n\n  /**\n   * Get tab id given a port id.\n   * @param portId\n   */\n  public getTabId(portId: string) {\n    return this.portIdToTabId[portId];\n  }\n\n  /**\n   * Get tab info.\n   * @param tabId\n   */\n  public getTabInfo(tabId: number) {\n    const tabInfo = this.tabIdToTabInfo[tabId];\n    if (!tabInfo) {\n      return null;\n    }\n\n    const ret: SingleTopTabInfo = {\n      frames: tabInfo.frames,\n    };\n\n    // we store all the top frames, so just return the last frame\n    const topFrames = tabInfo.top;\n    if (topFrames.length > 0) {\n      ret.top = topFrames[topFrames.length - 1];\n    }\n\n    return ret;\n  }\n\n  /**\n   * Get window id given a port id.\n   * @param portId\n   */\n  public getWindowId(portId: string) {\n    return this.portIdToWindowId[portId];\n  }\n\n  /**\n   * Delete information about the port.\n   * @param portId\n   */\n  public removePort(portId: string) {\n    delete this.portIdToPort[portId];\n    delete this.portIdToPortInfo[portId];\n    delete this.portIdToTabId[portId];\n    delete this.portIdToWindowId[portId];\n  }\n\n  /**\n   * Delete information about the tab.\n   * @param tabId\n   */\n  public removeTab(tabId: number) {\n    const portIds = this.tabIdToPortIds[tabId];\n    if (portIds) {\n      for (const portId of portIds) {\n        this.removePort(portId);\n      }\n    }\n    delete this.tabIdToPortIds[tabId];\n    delete this.tabIdToTab[tabId];\n    delete this.tabIdToTabInfo[tabId];\n  }\n\n  /**\n   * Delete all information about the tab.\n   * @param tabId\n   */\n  public removeTabInfo(tabId: number) {\n    delete this.tabIdToTabInfo[tabId];\n    delete this.tabIdToWindowId[tabId];\n    delete this.tabIdToTab[tabId];\n    const ports = this.tabIdToPortIds[tabId];\n    delete this.tabIdToPortIds[tabId];\n    if (ports) {\n      for (const port of ports) {\n        delete this.portIdToPort[port];\n        delete this.portIdToTabId[port];\n        delete this.portIdToPortInfo[port];\n        delete this.portIdToWindowId[port];\n      }\n    }\n  }\n\n  /**\n   * Send message to all content scripts.\n   * @param message\n   */\n  public sendToAll(message: RingerMessage) {\n    this.log.log(\"sending to all:\", message);\n    const ports = this.portIdToPort;\n    for (const portId in ports) {\n      ports[portId].postMessage(message);\n    }\n  }\n\n  /**\n   * Remove tabs that are not currently open.\n   * @param openTabs list of currently open tabs.\n   */\n  public updateRemovedTabs(openTabs: chrome.tabs.Tab[]) {\n    const possiblyOpenTabs: { [key: number]: boolean } = {};\n    for (const tabId in this.tabIdToTab) {\n      possiblyOpenTabs[parseInt(tabId)] = false;\n    }\n    for (const openTab of openTabs) {\n      possiblyOpenTabs[<number>openTab.id] = true;\n    }\n\n    for (const tabId in possiblyOpenTabs) {\n      if (!possiblyOpenTabs[tabId]) {\n        this.removeTab(parseInt(tabId));\n      }\n    }\n  }\n\n  /**\n   * Update the URL associated with the port.\n   * @param port\n   * @param url\n   */\n  public updateUrl(port: chrome.runtime.Port, url: string) {\n    this.portIdToPortInfo[port.name].URL = url;\n  }\n}\n","import { PortManager } from \"./port_manager\";\nimport { RingerMessage, UpdateEventMessage, RecordState } from \"../common/messages\";\nimport { RingerEvent, RecordedRingerEvent } from \"../common/event\";\nimport { Indexable } from \"../common/utils\";\nimport { Logs } from \"../common/logs\";\n\n/**\n * Handles recording of events from the content scripts.\n */\nexport class Record {\n  public events: RecordedRingerEvent[];\n  public lastTime: number;\n  public listeners: ((msg: RingerMessage) => void)[];\n  public log = Logs.getLog('record');\n  public ports: PortManager;\n  public recordState: RecordState;\n  public scriptId?: number;\n\n  constructor(ports: PortManager) {\n    this.ports = ports;\n    this.listeners = [];\n\n    this.reset();\n  }\n\n  /**\n   * Add the event to be recorded.\n   *\n   * @param e Details of about the saved event\n   * @param portId Optional name of the port for the event\n   * @param index Index where put the event. Defaults to the end of the event\n   *   array if undefined\n   *\n   * @returns id assigned to the event\n   */\n  public addEvent(e: RingerEvent, portId?: string, index?: number) {\n    this.log.log('added event:', e, portId);\n\n    const recordedEv = <RecordedRingerEvent> e;\n\n    // Check if the event is coming from a content script\n    if (portId) {\n      const ports = this.ports;\n      const tab = ports.getTabId(portId);\n      const win = ports.getWindowId(portId);\n      const tabInfo = ports.getTabInfo(tab);\n      \n      const topURL = tabInfo?.top?.URL;\n      if (!topURL) {\n        throw new ReferenceError(\"Tab had no topURL.\");\n      }\n\n      let iframeIndex = -1;\n      let topFrame = (tabInfo?.top?.portId === portId);\n\n      if (topFrame) {\n        topFrame = true;\n      } else {\n        topFrame = false;\n        const frames = tabInfo?.frames;\n        if (frames) {\n          for (let i = 0; i < frames.length; ++i) {\n            if (frames[i].portId == portId) {\n              iframeIndex = i;\n              break;\n            }\n          }\n        }\n      }\n\n      recordedEv.frame.port = portId;\n      recordedEv.frame.topURL = topURL;\n      recordedEv.frame.topFrame = topFrame;\n      recordedEv.frame.iframeIndex = iframeIndex;\n      recordedEv.frame.tab = tab;\n      recordedEv.frame.windowId = win;\n    }\n\n    // Save timing info\n    const time = recordedEv.data.timeStamp;\n    const lastTime = this.lastTime;\n    let waitTime;\n    if (lastTime === 0) {\n      waitTime = 0;\n    } else {\n      // the time to wait between running the last event and running this one.\n      waitTime = time - lastTime;\n    }\n\n    if (!e.timing) {\n      recordedEv.timing = {\n        waitTime: waitTime\n      };\n    } else {\n      recordedEv.timing.waitTime = waitTime;\n    }\n    this.lastTime = time;\n\n    // Give this event an unique id\n    const events = this.events;\n    if (!e.meta) {\n      recordedEv.meta = {\n        id: 'event' + events.length\n      };\n    } else {\n      recordedEv.meta.id = 'event' + events.length;\n    }\n\n    if (index === undefined) {\n      this.events.push(recordedEv);\n      this.updateListeners({\n        type: 'event',\n        value: { event: recordedEv }\n      });\n    } else {\n      this.events.splice(index, 0, recordedEv);\n      this.updateListeners({\n        type: 'event', \n        value: {\n          event: recordedEv,\n          index: index\n        }\n      });\n    }\n    return recordedEv.meta.id;\n  }\n\n  /**\n   * Add a listener.\n   * @param listener \n   */\n  public addListener(listener: (msg: RingerMessage) => void) {\n    this.listeners.push(listener);\n  }\n\n  /**\n   * Get event, given an event id.\n   * @param eventId\n   */\n  public getEvent(eventId: string) {\n    if (!this.events) {\n      return null;\n    }\n\n    for (const e of this.events) {\n      if (e.meta?.id === eventId) \n        return e;\n    }\n    return null;\n  }\n\n  /**\n   * Create a copy of the events recorded.\n   */\n  public getEvents(): RecordedRingerEvent[] {\n    return jQuery.extend(true, [], this.events);\n  }\n\n  /**\n   * Get the script id.\n   */\n  public getScriptId() {\n    return this.scriptId;\n  }\n\n  /**\n   * Get current record state.\n   */\n  public getStatus() {\n    return this.recordState;\n  }\n\n  /**\n   * Reset recording state.\n   */\n  public reset() {\n    this.updateStatus(RecordState.STOPPED);\n    this.scriptId = undefined;\n    this.events = [];\n    // the time the last event was recorded\n    this.lastTime = 0;\n\n    this.updateListeners({\n      type: 'reset',\n      value: null\n    });\n    this.ports.sendToAll({\n      type: 'reset', \n      value: null\n    });\n  }\n\n  /**\n   * Set the recorded events.\n   */\n  public setEvents(events: RecordedRingerEvent[]) {\n    this.reset();\n    this.events = events;\n    for (const event of events) {\n      this.updateListeners({\n        type: 'event',\n        value: { event: event }\n      });\n    }\n  }\n\n  /**\n   * Set the script id.\n   * @param id\n   */\n  public setScriptId(id?: number) {\n    this.scriptId = id;\n  }\n\n  /**\n   * Begin recording events.\n   *\n   * @param replaying Whether we are recording a user's interactions or the\n   *   events raised by the replayer. \n   */\n  public startRecording(replaying: boolean) {\n    this.log.log('starting record');\n    const s = replaying ? RecordState.REPLAYING : RecordState.RECORDING;\n    this.updateStatus(s);\n\n    // Tell the content scripts to begin recording\n    this.ports.sendToAll({\n      type: 'recording',\n      value: this.getStatus()\n    });\n  }\n\n\n  /**\n   * Stop recording.\n   */\n  public stopRecording() {\n    this.log.log('stopping record');\n    this.updateStatus(RecordState.STOPPED);\n\n    // Tell the content scripts to stop recording\n    this.ports.sendToAll({\n      type: 'stop',\n      value: null\n    });\n    this.ports.sendToAll({\n      type: 'recording',\n      value: this.getStatus()\n    });\n  }\n\n\n  /**\n   * Update the properties of an event. {@link request} should contain the\n   * pageEventId so that the event can be matched.\n   *\n   * @param request Updates to be made and meta data used to identify event\n   * @param portId id of port which requests came through\n   */\n  public updateEvent(request: UpdateEventMessage, portId: string) {\n    const pageEventId = request.pageEventId;\n    const updates = request.updates;\n\n    this.log.log('updating event:', updates, pageEventId);\n\n    const events = this.events;\n\n    for (let i = events.length - 1; i >= 0; --i) {\n      const value = events[i];\n      // Check if its the right event\n      if (value.frame && value.frame.port === portId &&\n          value.meta && value.meta.pageEventId === pageEventId) {\n        const id = value.meta.id;\n        for (const u of updates) {\n          this.userUpdate(id, u.field, u.value); \n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Update all listeners with message.\n   * @param msg \n   */\n  public updateListeners(msg: RingerMessage) {\n    for (const listener of this.listeners) {\n      listener(msg);\n    }\n  }\n\n  /**\n   * Update recording state.\n   * @param newStatus \n   */\n  public updateStatus(newStatus: RecordState) {\n    this.recordState = newStatus;\n    this.updateListeners({\n      type: 'status',\n      value: 'record:' + newStatus\n    });\n    this.ports.sendToAll({\n      type: 'recording',\n      value: newStatus\n    });\n  }\n\n\n  /**\n   * Finds the event based upon the eventId and updates the event's\n   *   {@link field} to {@link newVal}.\n   * @param eventId\n   * @param field\n   * @param newVal\n   */\n  public userUpdate(eventId: string, field: string, newVal: any) {\n    const updateProp = (obj: Indexable, path: string[], i: number) => {\n      if (i === path.length - 1) {\n        obj[path[i]] = newVal;\n      } else {\n        updateProp(obj[path[i]], path, i + 1);\n      }\n    }\n\n    for (const event of this.events) {\n      if (event.meta?.id === eventId) {\n        updateProp(event, field.split('.'), 0);\n      }\n    }\n  }\n}","import { PortManager } from \"./port_manager\";\nimport { User } from \"./user\";\nimport { Record } from \"./record\";\nimport { RingerMessage, ReplayAckStatus } from \"../common/messages\";\nimport {\n  RingerEvents,\n  RecordedRingerEvent,\n  RecordedRingerFrameInfo,\n} from \"../common/event\";\nimport { Utilities } from \"../common/utils\";\nimport { HelenaConsole } from \"../../common/utils/helena_console\";\nimport { Logs } from \"../common/logs\";\nimport {\n  BrokenPortStrategy,\n  TimingStrategy,\n  RingerParams,\n} from \"../common/params\";\n\nenum ReplayState {\n  STOPPED = \"stopped\",\n  REPLAYING = \"replaying\", // replaying the next command\n  ACK = \"ack\", // waiting for an ack from the content script\n}\n\ninterface ReplayTimeoutInfo {\n  startTime: number;\n  index: number;\n}\n\nexport interface ReplayConfig {\n  frameMapping?: { [key: string]: string };\n  scriptId?: number;\n  tabMapping?: { [key: string]: number };\n  targetWindowId?: number;\n}\n\nexport type ErrorContinuations = {\n  [key: string]: (replay: Replay, ringerCont: Function | null) => void;\n};\n\nexport interface ScriptServer {\n  saveScript: (\n    id: string,\n    replayEvents: RecordedRingerEvent[],\n    scriptId: number,\n    whatsthis: string\n  ) => void;\n}\n\ninterface ReplayAck {\n  setTimeout?: boolean;\n  type: ReplayAckStatus;\n}\n\n/**\n * Handles replaying scripts.\n */\nexport class Replay {\n  public static replayableEvents = [\n    \"dom\",\n    \"completed\",\n    \"manualload\",\n    \"webnavigation\",\n  ];\n\n  public ack: ReplayAck | null; // stores responses from the content script\n  public ackPort: string;\n  public addonReset: ((replay: Replay) => void)[];\n  public addonTiming: ((replay: Replay) => number)[];\n  public callbackHandle: number | null;\n\n  // callback executed after replay has finished\n  public cont: ((replay: Replay) => void) | null;\n\n  private currentCompletedObservationFailures: number;\n\n  // stores # of failures to find port for given event\n  private currentPortMappingFailures: number;\n\n  public errorConts: ErrorContinuations;\n  public events: RecordedRingerEvent[];\n  public firstEventReplayed: boolean;\n  public index: number; // current event index\n  public listeners: ((msg: RingerMessage) => void)[];\n  private log = Logs.getLog(\"replay\");\n\n  // whether a completed event has happened\n  public matchedCompletedEvents: number[];\n\n  // mapping record ports and replay ports\n  public portMapping: { [key: string]: chrome.runtime.Port };\n\n  public ports: PortManager;\n  public record: Record;\n  public replayState: ReplayState;\n\n  // links replayed events with the original recording\n  public scriptId: number | null;\n\n  public scriptServer: ScriptServer | null;\n  public startTime: number;\n\n  // mapping record tabs and replay tabs\n  public tabMapping: { [key: string]: number };\n\n  public targetWindowId?: number;\n  public time?: number;\n  public timeoutInfo: ReplayTimeoutInfo;\n  public user: User;\n\n  constructor(ports: PortManager, scriptServer: null, user: User) {\n    this.addonReset = [];\n    this.addonTiming = [];\n    this.currentCompletedObservationFailures = 0;\n    this.currentPortMappingFailures = 0;\n    this.ports = ports;\n    this.scriptServer = scriptServer;\n    /* The user interface to interact with the replayer */\n    this.user = user;\n    this.record = new Record(ports);\n    this.listeners = [];\n\n    this.reset();\n  }\n\n  /**\n   * Add a listener.\n   * @param listener\n   */\n  public addListener(listener: (msg: RingerMessage) => void) {\n    this.listeners.push(listener);\n  }\n\n  /**\n   * Check if an event has already been replayed.\n   * @param ev\n   */\n  private checkReplayed(ev: RecordedRingerEvent) {\n    for (const recordedEvent of this.record.events) {\n      if (recordedEvent.meta.recordId === ev.meta.id) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if executing an event has timed out.\n   */\n  private checkTimeout() {\n    const eventTimeout = RingerParams.params.replay.eventTimeout;\n    if (eventTimeout !== null && eventTimeout > 0) {\n      const timeoutInfo = this.timeoutInfo;\n      const curTime = new Date().getTime();\n\n      // we havent changed events\n      const index = this.index;\n      if (timeoutInfo.index === index) {\n        if (curTime - timeoutInfo.startTime > eventTimeout * 1000) {\n          return true;\n        }\n      } else {\n        this.timeoutInfo = { startTime: curTime, index: index };\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Dispatches events to the content script.\n   */\n  private dispatchToContentScript() {\n    if (this.checkTimeout()) {\n      // lets call the end of this script\n      const msg = `event ${this.index} has timed out`;\n      this.log.log(msg);\n      this.finish();\n      return;\n    }\n\n    if (this.getStatus() === ReplayState.ACK) {\n      const ack = this.ack;\n      if (!ack) {\n        // usually this means we want to keep waiting, but sometimes the port\n        //   has disappeared, in which case a navigation probably happened\n        //   before the replay ack could be sent, so then we should assume\n        //   that's what the port's disappearance means\n        if (!this.ports.portIdToPort[this.ackPort]) {\n          this.log.log(\n            \"ack port is actually gone; assume port disappearance \" +\n              \"means success\"\n          );\n          this.incrementIndex();\n          this.setNextTimeout();\n          this.updateStatus(ReplayState.REPLAYING);\n        }\n        this.setNextTimeout(RingerParams.params.replay.defaultWait);\n        this.log.log(\"continue waiting for replay ack\");\n        return;\n      }\n\n      const type = ack.type;\n      if (type === ReplayAckStatus.SUCCESS) {\n        this.log.log(\"found replay ack\");\n        this.incrementIndex();\n        this.setNextTimeout();\n\n        this.updateStatus(ReplayState.REPLAYING);\n      } else if (type === ReplayAckStatus.PARTIAL) {\n        throw new ReferenceError(\"partially executed commands\");\n      }\n      return;\n    }\n\n    const events = this.events;\n    const index = this.index;\n\n    /* check if the script finished */\n    // console.log(\"index\", index, events.length);\n    // console.log(events[index]);\n    if (index >= events.length) {\n      //no more events to actively replay, but may need to wait for some\n      //console.log(index, \"done with script\");\n      this.finish();\n      return;\n    }\n\n    const e = events[index];\n    const type = e.type;\n    // console.log(\"event running\", e);\n\n    // Find the replay function associated with the event type\n    if (Replay.replayableEvents.includes(type)) {\n      if (type === \"dom\") {\n        this.simulateDomEvent(e);\n      } else if (type === \"completed\") {\n        this.simulateCompletedEvent(e);\n      } else if (type === \"manualload\") {\n        this.simulateManualLoadEvent(e);\n      } else if (type === \"webnavigation\") {\n        this.simulateWebNavigationEvent(e);\n      } else {\n        throw new ReferenceError(\"Replayable event with unspecified behavior\");\n      }\n    } else {\n      this.log.log(\"skipping event:\", e);\n      this.incrementIndex();\n      this.setNextTimeout(0);\n    }\n  }\n\n  /**\n   * Looks for a node when required features failed.\n   */\n  public findNodeWithoutRequiredFeatures() {\n    // todo: eventually this should actually provide a continuation as an\n    //   argument!  null is wrong!\n    if (this.errorConts && this.errorConts.findNodeWithoutRequiredFeatures) {\n      this.stopReplay();\n      this.errorConts.findNodeWithoutRequiredFeatures(this, null);\n    }\n  }\n\n  /**\n   * Given the frame information from the recorded trace, find a\n   * corresponding port.\n   * @param newTabId\n   */\n\n  private findPortInTab(newTabId: number, frame: RecordedRingerFrameInfo) {\n    const ports = this.ports;\n    const portInfo = ports.getTabInfo(newTabId);\n    this.log.log(\"trying to find port in tab:\", portInfo);\n\n    if (!portInfo) {\n      return null;\n    }\n\n    // if it's the top frame, use that\n    if (frame.topFrame) {\n      this.log.log(\"assume port is top level page\");\n      const topFrame = portInfo.top;\n      if (topFrame && topFrame.portId) {\n        return ports.getPort(topFrame.portId);\n      }\n    } else {\n      // if it's an iframe, find all frames with matching urls\n      this.log.log(\"try to find port in one of the iframes\");\n      var frames = portInfo.frames;\n\n      let bestFrameSoFar = null;\n      let bestFrameDistanceSoFar = 99999;\n      for (let i = 0; i < frames.length; i++) {\n        const distance = Utilities.levenshteinDistance(\n          frames[i].URL,\n          frame.URL\n        );\n        if (distance < bestFrameDistanceSoFar) {\n          bestFrameSoFar = frames[i];\n          bestFrameDistanceSoFar = distance;\n        }\n        if (distance === bestFrameDistanceSoFar) {\n          this.log.warn(\n            \"have multiple iframes with same distance, might be \" +\n              \"the best distance:\",\n            bestFrameSoFar,\n            frames[i]\n          );\n        }\n      }\n\n      // no matching frames\n      if (!(bestFrameSoFar && bestFrameSoFar.portId)) {\n        return null;\n      } else {\n        return ports.getPort(bestFrameSoFar.portId);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Replay has finished, and now we need to call the continuation.\n   */\n  private finish() {\n    const self = this;\n\n    this.log.log(\"finishing replay\");\n\n    if (this.getStatus() === ReplayState.STOPPED) {\n      return;\n    }\n\n    this.updateStatus(ReplayState.STOPPED);\n\n    this.pause();\n\n    this.time = new Date().getTime() - this.startTime;\n    this.record.stopRecording();\n\n    // save the recorded replay execution\n    setTimeout(() => {\n      const replayEvents = self.record.getEvents();\n      const scriptId = self.scriptId;\n\n      if (\n        RingerParams.params.replay.saveReplay &&\n        scriptId &&\n        replayEvents.length > 0\n      ) {\n        self.scriptServer?.saveScript(\n          \"replay \" + scriptId,\n          replayEvents,\n          scriptId,\n          \"\"\n        );\n        self.log.log(\"saving replay:\", replayEvents);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (self.cont) {\n        self.cont(self);\n      }\n    }, 0);\n  }\n\n  /**\n   * Get event, given an event id.\n   * @param eventId\n   */\n  public getEvent(eventId?: string) {\n    if (!this.events || !eventId) {\n      return null;\n    }\n\n    for (const e of this.events) {\n      if (e.meta?.id === eventId) {\n        return e;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Given an event, find the corresponding port\n   * @param\n   */\n  private getMatchingPort(ev: RecordedRingerEvent) {\n    const self = this;\n    const portMapping = this.portMapping;\n    const tabMapping = this.tabMapping;\n\n    const frame = ev.frame;\n    const port = frame.port;\n    const tab = frame.tab;\n\n    // lets find the corresponding port\n    let replayPort = null;\n    // we have already seen this port, reuse existing mapping\n    if (port in portMapping) {\n      replayPort = portMapping[port];\n      //if (gpmdebug) {console.log(\"gpm: port in portMapping\", portMapping);}\n      this.log.log(\"port already seen\", replayPort);\n    } else if (tab in tabMapping) {\n      // we have already seen this tab, find equivalent port for tab\n      //   for now we will just choose the last port added from this tab\n      // todo: woah, just grabbing the last port from the tab doesn't seem ok\n      replayPort = this.findPortInTab(tabMapping[tab], frame);\n\n      if (replayPort) {\n        // tab already seen, found port\n        portMapping[port] = replayPort;\n      } else {\n        // tab already seen, no port found\n        this.setNextTimeout(RingerParams.params.replay.defaultWait);\n\n        // we can get into a loop here if (for example) we use a next button to\n        //   try to get to the next page of a list\n        // so we actually know the right tab because it's the same page where we\n        //   had the list in the past\n        // but if the network has gone down for a moment or something else went\n        //   wrong during loading the next page\n        // there would be no ports associated with the tab?\n\n        // todo: should probably actually have our own counter for this, in case\n        //   the tab just loaded at this particular iteration or something\n        if (\n          this.currentPortMappingFailures > 0 &&\n          this.currentPortMappingFailures % 50 === 0\n        ) {\n          // let's see if there are no ports associated with the tab we should\n          //   be using, and let's reload\n          const portInfo = this.ports.getTabInfo(tabMapping[tab]);\n          if (!portInfo || !portInfo.top) {\n            // why don't we have port info for the tab that we think is the\n            //   right tab?  try reloading\n            chrome.tabs.reload(tabMapping[tab], {}, () => {\n              // it's reloaded. not actually anything to do here I don't think\n            });\n          }\n        }\n\n        // todo: this may be a place to do some kind of recovery by actually\n        //   reloading the tab\n      }\n    } else {\n      // nothing matched, so we need to open new tab\n      const allTabs = Object.keys(this.ports.tabIdToTab).map((tabId) =>\n        parseInt(tabId)\n      );\n\n      // create list of all current tabs that are mapped to\n      const revMapping: { [key: number]: boolean } = {};\n      for (const t in tabMapping) {\n        revMapping[tabMapping[t]] = true;\n      }\n\n      // find all tabs that are in the target window, but are not mapped to\n      const unusedTabs = [];\n      for (const tabId of allTabs) {\n        if (!revMapping[tabId]) {\n          // now make sure it's actually in the target window, if there is one\n          if (\n            !this.targetWindowId ||\n            this.targetWindowId === this.ports.tabIdToWindowId[tabId]\n          ) {\n            unusedTabs.push(tabId);\n          }\n        }\n      }\n\n      // if this is not the first event, and there is exactly one unmapped\n      //   tab, then lets assume this new tab should match\n\n      // if 2, one is our initial tab that explains the recording process, and\n      //   the other must be the tab we want\n      if (unusedTabs.length === 1) {\n        // go ahead and make a mapping and then try going through the whole\n        //   process again\n        tabMapping[frame.tab] = unusedTabs[0];\n        this.setNextTimeout(0);\n        return;\n      }\n\n      // todo: ensure commenting out the below is acceptable. for now relying on\n      //   completed events marked forceReplay to make sure we load everything\n      //   that doesn't get loaded by dom events\n\n      /* create a new tab, and update the mapping */\n      /*\n      var replay = this;\n      var openNewTab = function() {\n        replayLog.log('need to open new tab');\n        chrome.tabs.create({url: frame.topURL, active: true},\n          function(newTab) {\n            replayLog.log('new tab opened:', newTab);\n            var newTabId = newTab.id;\n            replay.tabMapping[frame.tab] = newTabId;\n            replay.ports.tabIdToTab[newTabId] = newTab;\n            replay.setNextTimeout(params.replay.defaultWaitNewTab);\n          }\n        );\n      };\n      */\n\n      /* automatically open up a new tab for the first event */\n      /*\n      if (!this.firstEventReplayed && params.replay.openNewTab) {\n        openNewTab();\n      }\n      */\n\n      // High level goal here:\n      // Check this.events against this.record.events for a load in the same\n      //   position in the trace\n      // We want to look back through this.events (the events to replay) for an\n      //   event of type 'completed' that has the same frame as the one we're\n      //   trying to replay to now then look through this.record.events (the\n      //   events we've actually seen) for a corresponding 'completed' event.\n      //   Whatever port that one had, use it.  And update the port mapping.\n      //   Basically we're using when tabs appear as a way to line them up,\n      //   build the mapping.\n\n      const recordTimeEvents = this.events;\n      const replayTimeEventsSoFar = this.record.events;\n      const currEventURL = ev.frame.URL;\n      const currEventTabID = ev.frame.tab;\n      const currEventIndex = this.index;\n\n      // todo: sometimes it seems like doing this loading time thing gives us\n      //   the wrong answer.  when that happens, may want to revisit it after a\n      //   while, clear the tabMapping mappings that were made with this, if we\n      //   keep looking for a port and failing...\n\n      for (let i = currEventIndex - 1; i >= 0; i--) {\n        const e = recordTimeEvents[i];\n        let completedCounter = 0;\n\n        if (RingerEvents.isComplete(e)) {\n          completedCounter++;\n          if (e.data.url === currEventURL && e.data.tabId === currEventTabID) {\n            // there's a record-time load event with the same url and tab id as\n            //   the event whose frame we're currently trying to find.\n            //   we can try lining up this load event with a load event in the\n            //   current run\n            let completedCounterReplay = 0;\n            for (let j = replayTimeEventsSoFar.length - 1; j >= 0; j--) {\n              const e2 = replayTimeEventsSoFar[j];\n              if (RingerEvents.isComplete(e2)) {\n                completedCounterReplay++;\n                if (completedCounter === completedCounterReplay) {\n                  //this is the replay-time completed event that lines up with e\n                  //  use the frame in which this completed event happened\n                  //fix up ports\n                  //var e2Frame = ??;\n                  //var ports = this.ports;\n                  //var replayPort = ports.getPort(e2Frame);\n                  //portMapping[port] = replayPort;\n                  //return replayPort;\n\n                  // update tabMapping for completed event alignments\n                  tabMapping[currEventTabID] = e2.data.tabId;\n\n                  this.setNextTimeout(0);\n\n                  // not returning real port (refreshed tab mapping) so that\n                  //   simulateDom event will be called again, and we'll get\n                  ///  back here now with good mappings\n                  return;\n                }\n              }\n            }\n          }\n        }\n      }\n    } // end the kind of top-level else\n\n    if (!replayPort) {\n      // Freak out.  We don't know what port to use to replay this event.\n      // it may be the tab just isn't ready yet, not added to our mappings yet.\n      //   try again in a few.\n      this.setNextTimeout(1000);\n      // unless...we've been seeing this a lot, in which case this looks like a\n      //   real failure\n      this.currentPortMappingFailures += 1;\n      // below is commented out because now we give up after 120\n      /*\n      if (this.currentPortMappingFailures >= 10){\n        // ok, this is getting ridiculous. seems like the right port isn't arriving...\n        this.setNextTimeout(60000);\n        console.log(\"We're going to slow the port checking waaaaaaay down, since this doesn't seem to be working.\");\n      }\n      */\n      // === rather than > because we don't want to call handler a bunch of\n      //   times, only once\n      if (this.currentPortMappingFailures === 120) {\n        if (this.errorConts && this.errorConts.portFailure) {\n          // now keep in mind that this continuation may never be called if the\n          //   top-level tool doesn't want to continue where we left off\n          // so any cleanup must happen now\n          // for instance, must put the currentPortMappingFailures back to 0\n          // by the time this code gets used again, the top level tool should\n          //   have fixed it so we can find the port\n          this.currentPortMappingFailures = 0;\n          // or alternatively it should have decided not to carry on trying to\n          //   find the port anymore\n          var continuation = () => {\n            self.setNextTimeout(0);\n          };\n          this.stopReplay();\n          this.errorConts.portFailure(this, continuation);\n        }\n      }\n\n      // not returning real port\n      return null;\n    }\n    //if (gpmdebug) {console.log(replayPort);}\n    this.currentPortMappingFailures = 0;\n    //if (gpmdebug) {console.log(\"gpm: returning real port\");}\n    return replayPort;\n  }\n\n  /**\n   * Return the index of the next event that should be replayed.\n   */\n\n  private getNextReplayableEventIndex() {\n    for (let i = this.index; i < this.events.length; ++i) {\n      if (this.events[i].type in Replay.replayableEvents) {\n        return i;\n      }\n    }\n    return this.events.length;\n  }\n\n  /**\n   * Return the time in the future the next replayable event should be\n   *   executed based upon the current timing strategy.\n   */\n  private getNextTime() {\n    let time;\n\n    for (const timingHandler of this.addonTiming) {\n      time = timingHandler.call(this);\n      if (typeof time === \"number\") {\n        return time;\n      }\n    }\n\n    const timing = RingerParams.params.replay.timingStrategy;\n\n    const curIndex = this.index;\n    const nextIndex = this.getNextReplayableEventIndex();\n    const events = this.events;\n    let waitTime = 0;\n\n    // Check if there are any events to replay\n    if (nextIndex >= events.length) {\n      return 0;\n    }\n    if (curIndex === 0) {\n      // note: this used to be 1,000, not sure why\n      // may need to look into this at some point.\n      return 0;\n    }\n\n    let defaultTime = 0;\n    for (let i = curIndex; i <= nextIndex; ++i) {\n      let timeToAdd = events[i].timing.waitTime;\n      if (events[i].timing.ignoreWait && timeToAdd > 5) {\n        timeToAdd = timeToAdd / 5;\n      }\n      defaultTime += timeToAdd;\n    }\n\n    if (defaultTime > 10000) {\n      defaultTime = 10000;\n    }\n\n    if (timing === TimingStrategy.MIMIC) {\n      waitTime = defaultTime;\n    } else if (timing === TimingStrategy.SPEED) {\n      waitTime = 0;\n    } else if (timing === TimingStrategy.SLOWER) {\n      waitTime = defaultTime * 2;\n    } else if (timing === TimingStrategy.SLOWEST) {\n      waitTime = defaultTime * 4;\n    } else if (timing === TimingStrategy.FIXED_1) {\n      waitTime = 1000;\n    } else if (timing === TimingStrategy.RANDOM_0_3) {\n      waitTime = Math.round(Math.random() * 3000);\n    } else if (timing === TimingStrategy.PERTURB_0_3) {\n      waitTime = defaultTime + Math.round(Math.random() * 3000);\n    } else if (timing === TimingStrategy.PERTURB) {\n      var scale = 0.7 + Math.random() * 0.6;\n      waitTime = Math.round(defaultTime * scale);\n    } else {\n      throw new ReferenceError(\"unknown timing strategy\");\n    }\n\n    this.log.log(\"wait time:\", waitTime);\n    return waitTime;\n  }\n\n  /**\n   * Get current replay state.\n   */\n  public getStatus() {\n    return this.replayState;\n  }\n\n  /**\n   * Increase the index and update the listeners.\n   */\n  private incrementIndex() {\n    this.index += 1;\n\n    if (this.index < this.events.length) {\n      const e = this.events[this.index];\n      if (e.meta) {\n        this.updateListeners({ type: \"simulate\", value: e.meta.id });\n      }\n    }\n  }\n\n  /*\n  private openTabSequenceFromTrace(trace){\n    var completed_events = _.filter(trace, function(event){return RingerEvents.isComplete(event);});\n    //console.log(completed_events);\n    var eventIds = _.map(completed_events, function(event){return event.meta.id});\n    return eventIds;\n  }*/\n\n  /* Pause the execution by clearing out the callback */\n  public pause() {\n    var handle = this.callbackHandle;\n    if (handle) {\n      clearTimeout(handle);\n      this.callbackHandle = null;\n    }\n\n    /* tell whatever page was trying to execute the last event to pause */\n    this.ports.sendToAll({ type: \"pauseReplay\", value: null });\n  }\n\n  /**\n   * Receive a replay acknowledgement from the content script.\n   * @param ack\n   */\n  public receiveAck(ack: ReplayAck) {\n    this.ack = ack;\n    if (ack.setTimeout) {\n      this.setNextTimeout(0);\n    }\n  }\n\n  /**\n   * TODO\n   */\n  private reloadLastTabIfFailed() {\n    const self = this;\n    if (this.targetWindowId) {\n      // for now this is only going to check for failed tabs in the target\n      //   window (the window created for replay), and only if there even is a\n      //   target window\n      chrome.tabs.query({ windowId: this.targetWindowId }, (tabs) => {\n        HelenaConsole.log(\n          \"We think we might have had a tab fail to load, so \" +\n            \"we're going to try reloading.\"\n        );\n        HelenaConsole.log(tabs);\n        // we really prefer to only reload the very last tab, but since there's the possibility it might be earlier, we could be willing to go back further\n\n        for (let i = tabs.length - 1; i >= 0; i--) {\n          const tab = tabs[i];\n          if (isTabLoadFailed(tab)) {\n            // let's make sure once it's reloaded we're ready to try again\n            /*\n            var checkUntilComplete = function _checkUntilComplete(){\n              chrome.tabs.get(tab.id, function (tab) {\n                if (tab.status === 'complete') {\n                  that.setNextTimeout(0);\n                }\n                else{\n                  checkUntilComplete();\n                }\n              });\n            }\n            */\n            // let's go tell it to reload\n            if (tab.id) {\n              chrome.tabs.reload(tab.id, {}, () => {\n                // ok, good, it's reloaded.  start checking for completion\n                // checkUntilComplete();\n                // for now, since even without network connection we'll get the\n                //  'complete' status, we don't want to do the loop above\n                // because it just ends up looping really really quickly, and I\n                //   don't want to crash the extension.  so just wait the whole\n                //   5000 (above)\n              });\n            }\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Begin replaying a list of events.\n   *\n   * @param events List of events\n   * @param config\n   * @param cont Callback thats executed after replay is finished\n   * @param errorConts map from errors to callbacks that should be executed for\n   *   those errors\n   */\n  public replay(\n    events: RecordedRingerEvent[],\n    config: ReplayConfig,\n    cont: (replay: Replay) => void,\n    errorConts: ErrorContinuations = {}\n  ) {\n    this.log.log(\"starting replay\");\n\n    /* Pause and reset and previous executions */\n    this.pause();\n    this.reset();\n\n    // Record start time for debugging\n    this.startTime = new Date().getTime();\n\n    // If these events were already replayed, we may need to reset them\n    this.events = events;\n    for (const event of events) {\n      this.resetEvent(event);\n    }\n\n    if (config) {\n      if (config.scriptId) {\n        this.scriptId = config.scriptId;\n      }\n\n      if (config.frameMapping) {\n        const frameMapping = config.frameMapping;\n        for (const k in frameMapping) {\n          this.portMapping[k] = this.ports.getPort(frameMapping[k]);\n        }\n      }\n      if (config.tabMapping) {\n        var tabMapping = config.tabMapping;\n        for (var k in tabMapping) {\n          this.tabMapping[k] = tabMapping[k];\n        }\n      }\n      if (config.targetWindowId) {\n        this.targetWindowId = config.targetWindowId;\n      }\n    }\n\n    this.cont = cont;\n    this.errorConts = errorConts;\n    this.updateStatus(ReplayState.REPLAYING);\n\n    this.record.startRecording(true);\n    this.setNextTimeout(0);\n  }\n\n  /**\n   * Resets Replay to initial state.\n   */\n  public reset() {\n    // execution proceeds as callbacks so that the page's JS can execute, this\n    //   is the handle to the current callback\n    this.callbackHandle = null;\n    this.updateStatus(ReplayState.STOPPED);\n\n    // record the first execution attempt of the first event\n    this.timeoutInfo = {\n      startTime: 0,\n      index: -1,\n    };\n\n    this.ack = null;\n\n    this.events = [];\n\n    this.index = 0;\n    this.portMapping = {};\n    this.tabMapping = {};\n    this.scriptId = null;\n    this.cont = null;\n    this.firstEventReplayed = false;\n    this.startTime = 0;\n    this.matchedCompletedEvents = [];\n\n    for (const resetHandler of this.addonReset) {\n      resetHandler.call(this);\n    }\n\n    this.record.reset();\n  }\n\n  /**\n   * Remove any information added to an event during replay.\n   * @param ev\n   */\n  private resetEvent(ev: RecordedRingerEvent) {\n    if (ev.reset) {\n      ev.reset = {};\n    }\n  }\n\n  /**\n   * Set the callback to replay the next event\n   *\n   * @param time Optional delay when callback should be executed. The\n   *     default will use whatever strategy is set in the parameters.\n   */\n  private setNextTimeout(time?: number) {\n    const self = this;\n    if (this.callbackHandle) {\n      // we'll always choose the next time to run based on the most recent\n      //   setNextTimeout, so clear out whatever might already be there\n      clearTimeout(this.callbackHandle);\n    }\n    if (time === undefined) {\n      time = this.getNextTime();\n    }\n\n    this.callbackHandle = setTimeout(() => {\n      self.dispatchToContentScript();\n    }, time);\n  }\n\n  /* Replay a different set of events as a subexecution. This requires\n   * saving the context of the current execution and resetting it once\n   * the execution is finished.\n   *\n   * @param {array} events List of events to replay\n   * @param {string} scriptId Id of script\n   * @param {object} tabMapping Initial tab mapping\n   * @param {object} portMapping Initial port mapping\n   * @param {function} check Callback after subreplay is finished. The replay\n   *     is passed in as an argument.\n   * @param {function} cont Callback after subreplay is finished and\n   *     replayer's state is reset to original.\n   * @param {number} timeout Optional argument specifying a timeout for the\n   *     subreplay.\n   */\n  /*\n    public subReplay(events, scriptId, tabMapping, portMapping,\n          check, cont, timeout) {\n    // copy the properties of the replayer (so they can be later reset)\n    var props = Object.keys(this);\n    var copy = {};\n    for (var i = 0, ii = props.length; i < ii; ++i) {\n    var prop = props[i];\n    copy[prop] = this[prop];\n    }\n\n    // replay the events\n    var replay = this;\n    this.replay(events, {scriptId: scriptId}, function(r) {\n    if (timeout) {\n    clearTimeout(timeoutId);\n    }\n    check(r);\n\n    this.reset();\n    for (var key in copy) {\n    replay[key] = copy[key];\n    }\n\n    this.updateStatus(ReplayState.REPLAYING);\n    this.record.startRecording(true);\n\n    cont(r);\n    });\n\n    // set the mappings\n    this.tabMapping = tabMapping;\n    this.portMapping = portMapping;\n\n    if (timeout) {\n    var timeoutId = setTimeout(function() {\n    replay.finish();\n    }, timeout);\n    }\n  }*/\n\n  /*\n  public replayOne() {\n    //      this.updateStatus(ReplayState.REPLAYING);\n    //      this.restart();\n  }*/\n\n  /**\n   * TODO\n   */\n  public resend() {\n    if (this.getStatus() === ReplayState.ACK) {\n      this.updateStatus(ReplayState.REPLAYING);\n    }\n  }\n\n  /**\n   * Restart by setting the next callback immediately.\n   */\n  public restart() {\n    if (this.callbackHandle === null) {\n      if (this.getStatus() === ReplayState.ACK) {\n        this.updateStatus(ReplayState.REPLAYING);\n      }\n\n      this.setNextTimeout(0);\n    }\n  }\n\n  /**\n   * Replays an event of type \"completed\".\n   * @param ev\n   */\n  private simulateCompletedEvent(ev: RecordedRingerEvent) {\n    const self = this;\n    if (ev.forceReplay && (!ev.reset || !ev.reset.alreadyForced)) {\n      //console.log(\"forcing replay\");\n      if (!ev.reset) {\n        ev.reset = {};\n      }\n      // enforce that we don't do the forceReplay a second time, but instead\n      //   wait to see the completed event?\n      ev.reset.alreadyForced = true;\n      const options: chrome.tabs.CreateProperties = {\n        active: true,\n        url: ev.data.url,\n      };\n      if (this.targetWindowId) {\n        options.windowId = this.targetWindowId;\n      }\n      //console.log(\"options\", options);\n      //console.log(\"event\", e);\n      chrome.tabs.create(options, () => {\n        // not sufficient to treat tab creation as getting an ack. must wait for\n        //   it to appear in the replay-time trace\n        // that.index ++; // advance to next event\n        self.setNextTimeout(0);\n      });\n    } else {\n      // don't need to do anything\n      // this.index ++;\n      // this.setNextTimeout(0);\n\n      if (!RingerEvents.isComplete(ev)) {\n        // not a top-level load, so assume we can ignore it\n        this.index++;\n        this.currentCompletedObservationFailures = 0;\n        this.setNextTimeout(0);\n        return;\n      }\n\n      // ok, used to think we don't need to do anything, but really we should\n      //   actually wait for the completed event, at least if it's a top-level\n      //   one.  let's make sure *something* has appeared in the last 5 or so\n      //   events\n      // todo: is it really sufficient to just check the last 5 events? if our\n      //   assumption about the last dom even causing the completed event is\n      //   true, we should expect that it appears after the most recent dom\n      //   event\n      // can't assume it's the last event, because a top-level load often causes\n      //   some script loads, that kind of thing, as well.  and those might have\n      //   snuck in.\n\n      // ok, so this may not be quite right, but let's go back to the most\n      //   recent DOM event and make sure there's a top-level completed event\n      //   somewhere near it\n      const replayTimeEvents = this.record.events;\n      let completedAfterLastDom = false;\n      let bestBetMatchedIndex = null;\n      let domIndex = null;\n      let completedWithinWindowBeforeDom = false;\n      const completedBeforePriorMatchedCompletedEvent = false;\n      const win = 5;\n      const lastMatchedCompletedEventIndex = this.matchedCompletedEvents[\n        this.matchedCompletedEvents.length - 1\n      ];\n      for (let i = replayTimeEvents.length - 1; i >= 0; i--) {\n        // debug todo: remove next two lines\n        const ev = replayTimeEvents[i];\n        // console.log(i, domIndex, ev.type, ev.data);\n\n        // for now, commenting out the below, deciding to be willing to go all\n        //   the way back to the last top-level completed event that we've\n        //   already matched\n        /*\n        if (domIndex !== null && i < (domIndex - win)){\n          // ok, we've gone too far, we've passed the window around the domIndex\n          break;\n        }\n        */\n\n        if (i <= lastMatchedCompletedEventIndex) {\n          // ok, we've gone too far.  we've now reached a completed event that\n          //   we already matched in the past, so can't use this one again\n          break;\n        }\n\n        if (domIndex === null && ev.type === \"dom\") {\n          // we've found the last dom event\n          domIndex = i;\n        } else if (domIndex === null && RingerEvents.isComplete(ev)) {\n          // we've found a completed top-level after the last dom event\n          completedAfterLastDom = true;\n          // don't add this index to matchedCompletedEvents yet, because we\n          //   might find something even earlier\n          // (some pages do weird things where it looks like the page loads\n          //   twice)\n          // but if we reach the end of the loop and this is the last one we\n          //   found, then we'll use it\n          // this.matchedCompletedEvents.push(i);\n          bestBetMatchedIndex = i;\n        } else if (domIndex !== null && RingerEvents.isComplete(ev)) {\n          // since we're still going, but we've found the domIndex already, this\n          //   is a completed event before the last dom event\n          completedWithinWindowBeforeDom = true;\n          this.matchedCompletedEvents.push(i);\n          break;\n        }\n      }\n      if (completedAfterLastDom && bestBetMatchedIndex) {\n        this.matchedCompletedEvents.push(bestBetMatchedIndex);\n      }\n\n      if (completedWithinWindowBeforeDom || completedAfterLastDom) {\n        // we've seen a corresponding completed event, don't need to do anything\n        this.index++;\n        this.currentCompletedObservationFailures = 0;\n        this.setNextTimeout(0);\n      } else {\n        // one thing that might have happened - some versions of chrome produce\n        //   'completed' events while others produce webnavigation onCompletion\n        // and some produce both.  but if we try to wait for both on a version\n        //   that will only have one, we'll wait forever\n        // so here let's check if the url for the event we're waiting for is the\n        //   same as the url for the last completion-related event we were\n        //   waiting for\n        if (this.currentCompletedObservationFailures > 3 && ev.mayBeSkippable) {\n          // we think maybe we don't need to see a corresponding completed event\n          // so let's not do anything\n          this.index++;\n          this.currentCompletedObservationFailures = 0;\n          this.setNextTimeout(0);\n        }\n\n        // let's give it a while longer\n        // todo: as above in waitforobserved events, question of whether it's ok\n        //   to keep waiting and waiting for the exact same number of top-level\n        //   completed events.  should we give it 10 tries, then just continue?\n        // todo: eventually we really do need to surface this to the top-level\n        //   tool.  can't just keep looping here forever\n        this.currentCompletedObservationFailures += 1;\n        if (this.currentCompletedObservationFailures <= 30) {\n          // todo: consider raising this or adding backoff.  wonder if this is\n          //   the cause of occasional possibly wifi-outage related crashes\n          this.setNextTimeout(500);\n        } else {\n          // ok, this is getting a little ridiculous.  we've tried for 15\n          //   seconds and still haven't found anything?\n          // it's possible that the network connection went out momentarily and\n          //   that we need to go and reload a page.  let's check for something\n          //   that looks like it might suggest that, then fix it\n          this.reloadLastTabIfFailed();\n\n          // let's also slow down our checks so we don't crash the extension\n          this.setNextTimeout(5000);\n        }\n      }\n    }\n  }\n\n  /**\n   * Replays a DOM event.\n   * @param ev\n   */\n  private simulateDomEvent(ev: RecordedRingerEvent) {\n    try {\n      // check if event has been replayed, if so skip it\n      if (RingerParams.params.replay.cascadeCheck && this.checkReplayed(ev)) {\n        this.log.debug(\"skipping event: \" + ev.type);\n        this.incrementIndex();\n        this.setNextTimeout();\n\n        this.updateStatus(ReplayState.REPLAYING);\n        return;\n      }\n\n      const meta = ev.meta;\n      this.log.log(\"background replay:\", meta.id, ev);\n\n      const replayPort = this.getMatchingPort(ev);\n      if (!replayPort) {\n        // it may be that the target tab just isn't ready yet, hasn't been added\n        //   to our mappings yet.  may need to try again in a moment.\n        // if no matching port, getMatchingPort wiill try again later\n        return;\n      }\n\n      // we have a replay port, which also means we know which tab it's going to\n      // let's make the tab be the active/visible tab so we can see what's\n      //   happening\n      if (replayPort.sender?.tab?.id) {\n        chrome.tabs.update(replayPort.sender.tab.id, { selected: true });\n      }\n\n      // sometimes we use special no-op events to make sure that a page has gone\n      //   through our alignment process without actually executing a dom event\n      if (ev.data.type === \"noop\") {\n        this.incrementIndex();\n        this.setNextTimeout(0);\n      }\n\n      // if there is a trigger, then check if trigger was observed\n      const triggerEvent = this.getEvent(ev.timing.triggerEvent);\n      if (triggerEvent) {\n        const recordEvents = this.record.events;\n\n        let matchedEvent = null;\n        for (var i = recordEvents.length - 1; i >= 0; --i) {\n          const otherEvent = recordEvents[i];\n          if (\n            otherEvent.type == triggerEvent.type &&\n            otherEvent.data.type == triggerEvent.data.type &&\n            Utilities.matchUrls(otherEvent.data.url, triggerEvent.data.url, 0.9)\n          ) {\n            matchedEvent = otherEvent;\n            break;\n          }\n        }\n\n        if (!matchedEvent) {\n          this.setNextTimeout(RingerParams.params.replay.defaultWait);\n          return;\n        }\n      }\n\n      // we hopefully found a matching port, lets dispatch to that port\n      const type = ev.data.type;\n\n      // console.log(\"this.getStatus()\", this.getStatus());\n\n      try {\n        if (this.getStatus() === ReplayState.REPLAYING) {\n          // clear ack\n          this.ack = null;\n          this.ackPort = replayPort.name;\n\n          // group atomic events\n          let eventGroup = [];\n          const endEvent = meta.endEventId;\n          if (RingerParams.params.replay.atomic && endEvent) {\n            let t = this.index;\n            const events = this.events;\n            let curEvent = events[t];\n            while (\n              t < events.length &&\n              curEvent.meta.pageEventId &&\n              endEvent >= curEvent.meta.pageEventId &&\n              ev.frame.port == curEvent.frame.port\n            ) {\n              eventGroup.push(curEvent);\n              t++;\n              curEvent = events[t];\n            }\n          } else {\n            eventGroup = [ev];\n          }\n\n          replayPort.postMessage({ type: \"dom\", value: eventGroup });\n          this.updateStatus(ReplayState.ACK);\n\n          this.firstEventReplayed = true;\n\n          this.log.log(\"sent message\", eventGroup);\n          this.log.log(\"start waiting for replay ack\");\n          this.setNextTimeout(0);\n        } else {\n          throw \"unknown replay state\";\n        }\n      } catch (err) {\n        this.log.error(\"error:\", err.message, err);\n        // a disconnected port generally means that the page has been\n        //   navigated away from\n        if (err.message === \"Attempting to use a disconnected port object\") {\n          const strategy = RingerParams.params.replay.brokenPortStrategy;\n          //console.log(\"using broken port strategy: \", strategy);\n          if (strategy === BrokenPortStrategy.RETRY) {\n            if (ev.data.cascading) {\n              // skip the rest of the events\n              this.incrementIndex();\n              this.setNextTimeout(0);\n            } else {\n              // remove the mapping and try again\n              delete this.portMapping[ev.frame.port];\n              this.setNextTimeout(0);\n            }\n          } else {\n            throw \"unknown broken port strategy\";\n          }\n        } else {\n          err.printStackTrace();\n          throw err;\n        }\n      }\n    } catch (err) {\n      this.log.error(\"error:\", err.message, err);\n      this.finish();\n    }\n  }\n\n  /**\n   * Replay event where user manually loaded page.\n   * @param e\n   */\n  private simulateManualLoadEvent(ev: RecordedRingerEvent) {\n    this.index++; // advance to next event\n    this.setNextTimeout(0);\n    /*\n    console.log(\"simulating manual load\", e);\n    var that = this;\n    var options = {url: e.data.url, active: true};\n    if (this.targetWindowId){\n      options.windowId = this.targetWindowId;\n    }\n    chrome.tabs.create(options, function(){\n      that.index ++; // advance to next event\n      that.setNextTimeout(0); \n    });\n    */\n    // commented out the above because for now we just do it via forced\n    //   completed events (with forceReplay); may want to change this in future\n  }\n\n  /**\n   * Replays a Chrome web navigation event.\n   * @param e\n   */\n  private simulateWebNavigationEvent(ev: RecordedRingerEvent) {\n    if (RingerEvents.isComplete(ev)) {\n      // unfortunately chrome has changed so that sometimes these webnavigation\n      //   oncompleted events\n      // are the only way we know a page load completion has happened\n      // (no completed event gets raised), so we need to treat this is a\n      //   completed event\n      this.simulateCompletedEvent(ev);\n    } else {\n      this.index++; // advance to next event\n      this.setNextTimeout(0);\n    }\n  }\n\n  /**\n   * TODO\n   */\n  public skip() {\n    this.incrementIndex();\n    this.updateStatus(ReplayState.REPLAYING);\n  }\n\n  /**\n   * Stop the replay.\n   */\n  public stopReplay() {\n    if (this.getStatus() == ReplayState.STOPPED) {\n      return;\n    }\n\n    this.updateStatus(ReplayState.STOPPED);\n\n    this.pause();\n  }\n\n  /**\n   * Update all listeners with message.\n   * @param msg\n   */\n  public updateListeners(msg: RingerMessage) {\n    for (const listener of this.listeners) {\n      listener(msg);\n    }\n  }\n\n  /**\n   * Update replay state.\n   * @param newStatus\n   */\n  public updateStatus(newStatus: ReplayState) {\n    this.replayState = newStatus;\n    this.updateListeners({\n      type: \"status\",\n      value: \"replay:\" + newStatus,\n    });\n  }\n}\n\n/**\n * Return whether it seems a tab load failed. Criteria are if there's no favicon\n *   URL and if the page title is just a segment of the URL.\n * @param tab\n */\nfunction isTabLoadFailed(tab: chrome.tabs.Tab) {\n  if (!tab.favIconUrl && tab.title && tab.url?.includes(tab.title)) {\n    return true;\n  }\n  return false;\n}\n","import { PortManager } from \"./port_manager\";\nimport { Record } from \"./record\";\nimport { Replay, ErrorContinuations, ReplayConfig } from \"./replay\";\nimport { User } from \"./user\";\nimport { RingerMessage, RecordState, GetIdMessage } from \"../common/messages\";\nimport { Indexable } from \"../common/utils\";\nimport { RingerEvent, RecordedRingerEvent } from \"../common/event\";\nimport { Logs } from \"../common/logs\";\nimport { RingerParams } from \"../common/params\";\n\ninterface WebRequestDetails\n  extends chrome.webNavigation.WebNavigationCallbackDetails {\n  reqTimeStamp: number;\n  type: string;\n  windowId: number;\n}\n\nexport class RingerMainpanel {\n  // public controller: Controller;\n  private log = Logs.getLog(\"background\");\n  public ports: PortManager;\n  public record: Record;\n  public replay: Replay;\n  public scriptServer: null;\n  public user: User;\n\n  constructor() {\n    const self = this;\n\n    this.ports = new PortManager();\n    this.scriptServer = null;\n\n    this.user = new User();\n    this.record = new Record(this.ports);\n    this.replay = new Replay(this.ports, this.scriptServer, this.user);\n    // this.controller = new Controller(this.record, this.replay,\n    // this.scriptServer, this.ports);\n\n    // Attach the event handlers to their respective events\n    chrome.runtime.onMessage.addListener(this.handleIdMessage.bind(this));\n\n    chrome.runtime.onConnect.addListener((port) => {\n      self.ports.connectPort(port);\n    });\n\n    chrome.tabs.getCurrent((curTab) => {\n      const tabId = curTab?.id;\n      chrome.tabs.onActivated.addListener((activeInfo) => {\n        if (activeInfo.tabId !== tabId) {\n          self.user.activatedTab(activeInfo);\n        }\n      });\n    });\n\n    chrome.tabs.onRemoved.addListener((tabId, removeInfo) => {\n      self.ports.removeTab(tabId);\n    });\n\n    const filter: chrome.webRequest.RequestFilter = {\n      urls: [\"http://*/*\", \"https://*/*\"],\n      types: [\"main_frame\", \"sub_frame\", \"script\", \"object\", \"xmlhttprequest\"],\n    };\n\n    chrome.webRequest.onBeforeRequest.addListener(\n      (details) => {\n        self.log.log(\"request start\", details);\n        self.addWebRequestEvent(details, \"start\");\n      },\n      filter,\n      [\"blocking\"]\n    );\n\n    chrome.webRequest.onCompleted.addListener((details) => {\n      self.log.log(\"completed\", details);\n      self.addWebRequestEvent(details, \"completed\");\n    }, filter);\n\n    chrome.webNavigation.onCommitted.addListener((details) => {\n      self.log.log(\"onCommitted\", details);\n      const manuallyLoadedPageTypes = [\"auto_bookmark\", \"reload\", \"typed\"];\n      if (manuallyLoadedPageTypes.includes(details.transitionType)) {\n        // ok, this one indicates a manual load, so add it\n\n        // as a special case, let's throw away manual loads that happen\n        //   automatically when we just open a new tab (loading the new tab\n        //   contents)\n        console.log(details);\n        self.addWebRequestEvent(details, \"manualload\");\n      }\n      if (details.transitionQualifiers.includes(\"from_address_bar\")) {\n        // same deal.  this is a manual one\n        console.log(details);\n        self.addWebRequestEvent(details, \"manualload\");\n      }\n    });\n\n    const eventList = [\n      \"onBeforeNavigate\",\n      \"onCreatedNavigationTarget\",\n      \"onCommitted\",\n      \"onCompleted\",\n      \"onDOMContentLoaded\",\n      \"onErrorOccurred\",\n      \"onReferenceFragmentUpdated\",\n      \"onTabReplaced\",\n      \"onHistoryStateUpdated\",\n    ];\n    for (const e of eventList) {\n      (<Indexable>chrome.webNavigation)[e].addListener(\n        (data: WebRequestDetails) => {\n          if (typeof data) {\n            data.type = e;\n            self.addWebRequestEvent(data, \"webnavigation\");\n            //console.log(e, data);\n          } else {\n            console.error(chrome.i18n.getMessage(\"inHandlerError\"), e);\n          }\n        }\n      );\n    }\n\n    this.ports.sendToAll({\n      type: \"params\",\n      value: RingerParams.params,\n    });\n    this.stop();\n  }\n\n  /**\n   * Listen to web requests. TODO: describe this.\n   * @param e\n   */\n  public addBackgroundEvent(e: RingerEvent) {\n    if (this.record.recordState === RecordState.RECORDING) {\n      this.record.addEvent(e);\n    } else if (this.replay.record.recordState === RecordState.REPLAYING) {\n      this.replay.record.addEvent(e);\n    }\n  }\n\n  /**\n   * TODO: describe this.\n   */\n  public addWebRequestEvent(\n    details: chrome.webNavigation.WebNavigationCallbackDetails,\n    type: string\n  ) {\n    const data = <WebRequestDetails>details; // all copied in by default now\n    /*\n    data.requestId = details.requestId;\n    data.method = details.method;\n    data.parentFrameId = details.parentFrameId;\n    data.tabId = details.tabId;\n    data.type = details.type;\n    data.url = details.url;\n    */ data.reqTimeStamp =\n      details.timeStamp;\n    data.timeStamp = new Date().getTime();\n\n    const v = {\n      data: data,\n      type: type,\n    };\n\n    this.addBackgroundEvent(v);\n\n    // let's also figure out the window that should be associated with this web\n    //   request, add that info once we get it\n    // -1 means the request is not associated with a particular tab\n    if (details.tabId > -1) {\n      chrome.tabs.get(details.tabId, (tab) => {\n        if (!tab && type !== \"manualload\") {\n          console.warn(\"No tab.windowId!\");\n          return;\n        }\n        v.data.windowId = tab.windowId;\n      });\n    }\n  }\n\n  /**\n   * Handle the getId message that the content script sends.\n   * @param msg\n   * @param sender\n   * @param sendResponse\n   */\n  private handleIdMessage(\n    msg: RingerMessage,\n    sender: chrome.runtime.MessageSender,\n    sendResponse: (resp: RingerMessage) => void\n  ) {\n    this.log.log(\"background receiving:\", msg, \"from\", sender);\n    if (msg.type == \"getId\") {\n      const portId = this.ports.getNewId(msg.value, sender);\n      if (portId) {\n        const getIdMsg: GetIdMessage = {\n          type: \"id\",\n          value: portId,\n        };\n        sendResponse(getIdMsg);\n      }\n    }\n  }\n\n  /**\n   * Handle messages coming from the content scripts.\n   * @param port\n   * @param request\n   */\n  public handleMessage(port: chrome.runtime.Port, request: RingerMessage) {\n    const type = request.type;\n    const state = request.state;\n\n    this.log.log(\"handle message:\", request, type, state);\n\n    if (\n      state === RecordState.RECORDING &&\n      [\"event\", \"updateEvent\"].includes(type)\n    ) {\n      if (type === \"event\") {\n        this.record.addEvent(request.value, port.name);\n      } else if (type === \"updateEvent\") {\n        this.record.updateEvent(request.value, port.name);\n      } else {\n        this.log.error(\"cannot handle message:\", JSON.stringify(request));\n      }\n    } else if (\n      (state === RecordState.REPLAYING &&\n        [\n          \"event\",\n          \"updateEvent\",\n          \"ack\",\n          \"prompt\",\n          \"findNodeWithoutRequiredFeatures\",\n        ].includes(type)) ||\n      // todo: is this ok?  the stopped acks are breaking everything...\n      (state === RecordState.STOPPED && [\"ack\", \"updateEvent\"].includes(type))\n    ) {\n      if (type === \"event\") {\n        this.replay.record.addEvent(request.value, port.name);\n      } else if (type === \"updateEvent\") {\n        this.replay.record.updateEvent(request.value, port.name);\n      } else if (type === \"ack\") {\n        this.replay.receiveAck(request.value);\n      } else if (type === \"prompt\") {\n        this.user.contentScriptQuestion(request.value, port);\n      } else if (type === \"findNodeWithoutRequiredFeatures\") {\n        this.replay.findNodeWithoutRequiredFeatures();\n      } else {\n        this.log.error(\"cannot handle message:\", JSON.stringify(request));\n      }\n    } else if ([\"alert\", \"getRecording\", \"getParams\", \"url\"].includes(type)) {\n      if (type === \"alert\") {\n        //panel.addMessage('[' + port.name + '] ' + request.value);\n      } else if (type === \"getRecording\") {\n        const recStatus = this.record.getStatus();\n        const repStatus = this.replay.record.getStatus();\n\n        if (recStatus === RecordState.RECORDING) {\n          port.postMessage({ type: \"recording\", value: recStatus });\n        } else if (repStatus === RecordState.REPLAYING) {\n          port.postMessage({ type: \"recording\", value: repStatus });\n        } else {\n          port.postMessage({ type: \"recording\", value: RecordState.STOPPED });\n        }\n      } else if (type === \"getParams\") {\n        port.postMessage({ type: \"params\", value: RingerParams.params });\n      } else if (type === \"url\") {\n        this.ports.updateUrl(port, request.value);\n      } else {\n        this.log.error(\"cannot handle message:\", JSON.stringify(request));\n      }\n    } else {\n      this.log.error(\"cannot handle message:\", JSON.stringify(request));\n    }\n  }\n\n  /**\n   * TODO\n   * @param config\n   * @param cont\n   * @param errorConts\n   */\n  public replayRecording(\n    config: ReplayConfig | null,\n    cont: (replay: Replay) => void,\n    errorConts: ErrorContinuations = {}\n  ) {\n    this.log.log(\"replay\");\n    this.stop();\n\n    if (!config) {\n      config = {};\n    }\n\n    if (!config.scriptId) {\n      config.scriptId = this.record.getScriptId();\n    }\n\n    this.replay.replay(this.record.getEvents(), config, cont, errorConts);\n    return this.replay;\n  }\n\n  /**\n   * TODO\n   */\n  public replayScript(\n    events: RecordedRingerEvent[],\n    config: ReplayConfig | null,\n    cont: (replay: Replay) => void,\n    errorConts: ErrorContinuations = {}\n  ) {\n    this.setEvents(undefined, events);\n    return this.replayRecording(config, cont, errorConts);\n  }\n\n  /**\n   * Reset recording status.\n   */\n  public reset() {\n    this.log.log(\"reset\");\n    this.record.reset();\n  }\n\n  /**\n   * Sets the recorded events.\n   * @param scriptId\n   * @param events\n   */\n  public setEvents(\n    scriptId: number | undefined,\n    events: RecordedRingerEvent[]\n  ) {\n    this.record.setEvents(events);\n    this.record.setScriptId(scriptId);\n  }\n\n  /**\n   * Start recording.\n   */\n  public start() {\n    this.log.log(\"start\");\n    this.record.startRecording(false);\n\n    /* Update the UI */\n    chrome.browserAction.setBadgeBackgroundColor({ color: [255, 0, 0, 64] });\n    // chrome.browserAction.setBadgeText({text: 'ON'});\n  }\n\n  /**\n   * Stop recording.\n   */\n  public stop() {\n    this.log.log(\"stop\");\n    this.record.stopRecording();\n\n    /* Update the UI */\n    chrome.browserAction.setBadgeBackgroundColor({ color: [0, 0, 0, 0] });\n    // chrome.browserAction.setBadgeText({text: 'OFF'});\n  }\n\n  /**\n   * Stop replay.\n   */\n  public stopReplay() {\n    this.replay.stopReplay();\n  }\n}\n\n/*\nfunction printEvents() {\n  var events = record.events;\n  var text = JSON.stringify(events, null, 2);\n  bgLog.log(text);\n}\n\nfunction printReplayEvents() {\n  var events = replay.record.events;\n  var text = JSON.stringify(events, null, 2);\n  bgLog.log(text);\n}\n*/\n","import { Logs } from \"../common/logs\";\nimport { RingerParams } from \"../common/params\";\n\n/**\n * The interface for the user to interact with the replayer. Can be used to\n *   directly query the user.\n */\nexport class User {\n  public activeTab: chrome.tabs.TabActiveInfo | null;\n  private log = Logs.getLog('user');\n  public panel: null;\n\n  constructor() {\n    this.panel = null;\n    this.activeTab = null;\n  }\n\n  /**\n   * Set which tab the user has selected.\n   * @param tabInfo chrome TabActiveInfo\n   */\n  public activatedTab(tabInfo: chrome.tabs.TabActiveInfo) {\n    this.activeTab = tabInfo;\n  }\n\n\n  /**\n   * Question posed from the content script\n   * @param prompt\n   * @param port\n   */\n  public contentScriptQuestion(prompt: string, port: chrome.runtime.Port) {\n    this.question(prompt, () => true, '', (answer: string) => {\n      port.postMessage({ type: 'promptResponse', value: answer });\n    });\n  }\n\n  /**\n   * Get activated tab.\n   */\n  /*\n  public getActivatedTab() {\n    return this.activeTab;\n  }*/\n\n  /**\n   * Query the user.\n   * @param prompt Text to show the user\n   * @param validation Check whether the answer is as exepcted\n   * @param defaultAnswer Answer to use during automated periods\n   * @param callback Continuation to pass answer into\n   */\n  private question(prompt: string, validation: (ans: string) => boolean,\n      defaultAnswer: string, callback: (ans: string) => void) {\n    if (RingerParams.params.replay.defaultUser) {\n      callback(defaultAnswer);\n    } else {\n      /*\n      this.panel.question(prompt, (answer: string) => {\n        const sanitize = validation(answer);\n        if (sanitize) {\n          callback(sanitize);\n        } else {\n          this.question(prompt, validation, defaultAnswer, callback);\n        }\n      });*/\n    }\n  }\n\n  /**\n   * Set the panel.\n   * @param panel \n   */\n  /*\n  public setPanel(panel) {\n    this.panel = panel;\n  }*/\n}","import { helenaIsReady, HelenaBackground } from \"helena-lang\";\n\nhelenaIsReady.then(() => {\n  new HelenaBackground();\n});\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,QAKA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACx3CA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACxLA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrCA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnCA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzBA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACpHA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AAMA;AACA;AACA;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/GA;AACA;;AAGA;;;;;;;AAQA;;;;;AAMA;;;;;;;AAQA;;AAGA;;AAEA;AAEA;;AAEA;;;;;AAKA;AACA;;;;;;;;;;;;;AAaA;;;;;AAMA;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAQA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAQA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAAA;AACA;AC9KA;AACA;ACDA;AAOA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;;AAGA;AAEA;AAEA;AACA;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAGA;AAEA;AACA;AAEA;AACA;;AAGA;AAEA;AAEA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AAEA;AAEA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAEA;AACA;AA0BA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAsBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AC1nBA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;ACrwBA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;ACvLA;AACA;AAAA;AACA;ACDA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AChDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACRA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAMA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAMA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AClMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;ACrBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AC7JA;AAOA;AAAA;AACA;AACA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAnEA;AAoEA;AArEA;AACA;ACHA;AAAA;AA0DA;AApDA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAxDA;AAEA;AACA;AAsDA;AA1DA;AAmEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AAEA;;;;;;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAAA;;;AAGA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AAnBA;;;;AAoBA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;ACvFA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAkCA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACdA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AChBA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AClHA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;ACvBA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;ACjBA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/KA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;ACXA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;ACbA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AC3BA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;ACKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACiBA;AA+DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AC5RA;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;ACxBA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;ACrFA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;ACjCA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;;AACA;AACA;AAAA;AACA;ACdA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;;AACA;AACA;AAAA;AACA;ACXA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAAA;AACA;ACjBA;AAAA;AAGA;AAAA;AAEA;;AACA;AACA;AAAA;AACA;ACRA;AAAA;AAIA;AAAA;AAEA;AACA;;AACA;AACA;AAAA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAKA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAAA;AACA;AC5EA;AAAA;AAEA;AAAA;AAEA;AACA;;AACA;AACA;AAAA;AACA;ACRA;AAAA;AAEA;AAAA;AAEA;;AACA;AACA;AAAA;AACA;ACHA;AAEA;AAAA;AAOA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA;AAAA;AACA;ACjCA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAOA;AAEA;AAEA;AACA;AAAA;AAEA;AAEA;AAEA;AAAA;AACA;AACA;AAQA;AAEA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAQA;AACA;AAQA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvkBA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;AAMA;;;;;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACriBA;AAAA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;ACdA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;ACzCA;AAcA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAOA;AAIA;AACA;AACA;AAOA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAOA;AAIA;AACA;AACA;AAOA;AAIA;AACA;AACA;AAOA;AAIA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAMA;AACA;AAMA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/NA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;ACtCA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvLA;AACA;AACA;AACA;AAMA;AACA;AAMA;AACA;AAMA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AC9DA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;ACnBA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAKA;AAKA;AAMA;AAEA;AAMA;AAQA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;;;AAKA;AACA;AACA;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAIA;AACA;AACA;AACA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;;;;;AAOA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AACA;AACA;AACA;ACnSA;AACA;ACKA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;ACXA;AAEA;AAOA;AAHA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;;AAAA;;;;;;AAEA;AAEA;;;;;AACA;AACA;;AAAA;AACA;;AAAA;;;;;;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAIA;;;;AAEA;;AAAA;AACA;;;;AAEA;;;AAIA;AACA;AACA;AAEA;;;;AAEA;;AAAA;AACA;;;;AAEA;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AACA;AAWA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;;AAAA;AACA;;;;AAEA;;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;;;;;;AAEA;AAEA;;;;;;;;AAGA;;;;AAAA;AAEA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;;AAIA;;;AAAA;AAEA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAOA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAIA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAGA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAaA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;AAKA;;;AAAA;AAAA;AACA;;AAAA;;;AADA;;;;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AACA;AACA;;;;;AACA;AACA;AACA;;;;AAEA;;AAAA;;;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AACA;;;;;;AAjFA;;;AAAA;AAAA;AAAA;;;;;AAAA;;;;;;AAmFA;AAEA;;;AACA;AACA;AACA;;;;AACA;AAEA;;;;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;;;AAAA;AAAA;AACA;AACA;;AAAA;;;AAEA;;;AAJA;;;;;;AAMA;AAEA;;;;;;AACA;AACA;AACA;AAMA;AAEA;AAEA;;AAAA;AACA;AACA;;;;AACA;AACA;AAAA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzvBA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;;;;;;AACA;AAQA;;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AARA;AACA;ACpDA;AAmBA;AAEA;AAAA;AACA;AACA;AAEA;AAIA;;;;;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;AAAA;;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;;AAAA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AACA;;;;;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrFA;AACA;AACA;AACA;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7gDA;AAAA;AACA;;;;;;;;;;;ACDA;AAAA;AACA;;;;;;;;;;;ACDA;AAAA;AACA;;;;;;;;;;;ACDA;AAAA;AACA;;;;;;;;;;;ACDA;AAAA;AACA;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AC5pDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAEA;AACA;AAEA;AACA;AAGA;AAMA;AALA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AA/LA;AAiMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9MA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAEA;AAAA;AAeA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAiCA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAGA;AAJA;AAKA;AACA;AACA;;;;;;;;;;;;;ACjKA;AAkIA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AA6BA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;AAYA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA1DA;AA4DA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;AACA;AACA;AAJA;AAMA;;;;;;;;;AASA;AAEA;AACA;;;;;;;;;;;;AAYA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAvDA;AAuDA;AAEA;AACA;;;;;;;;;;AAUA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAxBA;AAyBA;AACA;AACA;;;;;;;;;;;;;ACvaA;AAEA;AAEA;AAAA;AACA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;AA2DA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlBA;AAoBA;;;;;;;;;AASA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAIA;AACA;AACA;AACA;AA/BA;AAiCA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1LA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAPA;AAQA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AACA;AACA;;;;;;;;;;;;;AC9CA;AACA;AAKA;AAoBA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAFA;AAIA;;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAPA;AASA;AAIA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAIA;AACA;AACA;AACA;AACA;AARA;AAUA;AAIA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAFA;AAIA;AAIA;AACA;AALA;AAOA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAFA;AAIA;AAIA;AACA;AALA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5CA;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvVA;;AAEA;AACA;AAAA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAsBA;AACA;AACA;;;;;;;;;;;;;ACxCA;;;AAGA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAJA;AAIA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AAjBA;AAmBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAdA;AAgBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAdA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAIA;AAEA;;;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAjDA;AAkDA;AACA;AACA;;;;;;;;;;;;;AC5MA;AACA;AAEA;AAGA;;;AAGA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AASA;AAEA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAVA;AAYA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AACA;AACA;;;;;;;;;;;;;ACvEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAiGA;AAzDA;;AAEA;AACA;AAuDA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AApEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAoBA;;;AAGA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;;;;;;AAMA;AACA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AAIA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AA7VA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAGA;AAGA;;;AAGA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAiBA;AACA;AACA;;;;;;;;;;;;;AC3DA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAPA;AASA;;;;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA5BA;AA8BA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA3FA;AA6FA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAPA;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;;;;;;;;;;;;;AC7NA;AAEA;AAGA;AAEA;AAGA;AAMA;AACA;AACA;AACA;AACA;AACA;AAMA;AAAA;AAEA;;AAEA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAxLA;AA0LA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AATA;AAWA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAvEA;AAyEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAjBA;AAmBA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AAEA;AAGA;AACA;AACA;AAGA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAVA;AAYA;;;;;;AAMA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AA7EA;AA+EA;AACA;AAEA;AACA;AAEA;AACA;AAPA;AASA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA1NA;AA0NA;AACA;AACA;AACA;;;;;;;;;;;;;ACrjCA;AAEA;AAKA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA8BA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtWA;AAwWA;;AAEA;AACA;AAMA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAjHA;AAmHA;;AAEA;AACA;AAGA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAlHA;AAoHA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AA9FA;AAgGA;;AAEA;AACA;AAOA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnEA;AACA;AACA;;;;;;;;;;;;;ACt2BA;AAMA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvCA;AAyCA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAEA;AACA;AACA;AAYA;;AAEA;AACA;AAKA;AAJA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AArKA;AACA;AACA;;;;;;;;;;;;;ACrBA;AASA;;AAEA;AACA;AAKA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AA1DA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAQA;;AAEA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AA2CA;;;;AAIA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAnBA;AAqBA;;;;;;AAMA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAdA;AAiBA;;;;;;;;;AASA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAqBA;;;;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAhBA;AAmBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AACA;AACA;;;;;;;;;;;;;ACxNA;AAQA;;AAEA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1DA;AA0DA;AACA;AACA;AACA;;;;;;;;;;;;;ACvKA;AAAA;AASA;AAGA;AAHA;AAKA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAzBA;AA2BA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AALA;AAOA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AAqCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA3CA;AA6CA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAaA;AACA;AACA;;;;;;;;;;;;;ACzWA;AAqDA;AApDA;AAqDA;AApDA;AAqDA;AApDA;AAqDA;AApDA;AAsDA;AArDA;AAoDA;AAvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAEA;AACA;AAGA;AAEA;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA/NA;AAiOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChPA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5CA;AA8CA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAiDA;AApBA;AAMA;AAEA;AACA;AACA;AACA;AAMA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/TA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwSA;;;;;;;;AAQA;AACA;AACA;;;;;;;;;;;;;ACnWA;AAWA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AA5GA;AACA;AACA;;;;;;;;;;;;;AChBA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAQA;AAAA;AACA;AACA;AACA;AAiCA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAmCA;AACA;AAzBA;AAGA;AAGA;AAGA;AAGA;AAeA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AArxDA;AACA;AAuxDA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFA;AACA;AACA;;;;;;;;;;;;;AC1uGA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvEA;AACA;AACA;;;;;;;;;;;;;ACPA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/DA;AACA;AACA;;;;;;;;;;;;;ACXA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AA/RA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAEA;;AAEA;AACA;AAGA;;AACA;AAGA;AAEA;;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AACA;AACA;;;;;;;;;;;;;ACPA;AACA;AAEA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;;AAEA;AACA;AAUA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAlVA;AACA;AAoVA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AC3YA;AACA;AAEA;AASA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4BA;AAkBA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA7eA;AACA;AACA;AA8eA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAKA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;;;;;;;;;;;;;ACpoBA;AAEA;AAKA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AA/DA;AACA;AA+DA;AACA;AACA;;;;;;;;;;;;;AC/EA;AACA;AAEA;AAEA;AACA;AAGA;AAKA;AAGA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;;;;AAIA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAhNA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAEA;AACA;AAEA;AAEA;AACA;AAOA;AAEA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAhRA;AACA;AACA;AAiRA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;;;;;;;;;;;;;ACjUA;AACA;AACA;AAMA;AACA;AASA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnMA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzQA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAEA;AAEA;AAMA;AAEA;AAEA;AACA;AAEA;AAEA;AAYA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA1aA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAQA;AACA;AACA;AAEA;;AAEA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA3bA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;ACVA;AAGA;AAMA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAlIA;AACA;AACA;;;;;;;;;;;;;ACdA;AAIA;AAEA;AAMA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzLA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAIA;AAKA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvDA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAIA;AAKA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA7EA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAIA;AAGA;AACA;AACA;AACA;AANA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AAwBA;AAOA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;;;;;;AAMA;AAEA;;;;AAIA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;;;;;;;;;;;AAWA;AAEA;;;;AAIA;AACA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjfA;AAmfA;;;;;;;;AAQA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnrBA;AAUA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AAEA;AACA;AACA;AA5FA;AACA;AACA;;;;;;;;;;;;;ACZA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAOA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAsCA;AAQA;AA6wBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtyBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAzzBA;AACA;AAy1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/6BA;AACA;AACA;AAGA;AAIA;AACA;AAIA;AACA;AAkFA;AACA;AACA;AACA;AApFA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA9IA;AACA;AACA;;;;;;;;;;;;;ACZA;AAEA;AAEA;;;;;;;;AAQA;AACA;AAAA;AAUA;AAIA;AAEA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA6CA;AACA;AACA;AACA;;;;;;;;;;;;;ACvFA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;;AAIA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AARA;AAUA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAlEA;AAmEA;AACA;AACA;;;;;;;;;;;;;ACnIA;AAEA;AACA;AAGA;AAYA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlNA;AACA;AACA;;;;;;;;;;;;;ACRA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAIA;AAGA;AACA;AACA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAqCA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAMA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AA3vDA;AACA;AA6vDA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACrzDA;AACA;AAuEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AAEA;AAEA;;;;;;;AAOA;AACA;AAEA;AAEA;AAGA;AAAA;AACA;AAEA;AAEA;AAJA;AAMA;AAGA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AARA;AAUA;AAEA;AAEA;AAJA;AAMA;AAEA;AAEA;AAJA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAEA;AAHA;AAKA;AAEA;AAEA;AAJA;AAMA;AAEA;AAEA;AAJA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAEA;AARA;AASA;AACA;AACA;;;;;;;;;;;;;ACxPA;AAEA;AAGA;AAKA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAaA;AAIA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAEA;;AACA;AACA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;;AApOA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA;;AAEA;AAEA;AAgDA;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;AASA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AApIA;AACA;AACA;;;;;;;;;;;;;ACuFA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;;;;;;;;;;;;;ACpJA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAbA;AAaA;AAEA;AAIA;AAHA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAOA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAoDA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;;;;;;;;;;;;;AChQA;AAMA;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AAFA;AAIA;;;;AAIA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA9BA;AAgCA;;;;;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAnBA;AAqBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAUA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAEA;AAAA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AAkCA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;AACA;AACA;;;;;;;;;;;;;AC9JA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAzBA;AA2BA;AACA;AACA;AAFA;AAGA;AACA;AACA;;;;;;;;;;;;;ACxCA;AACA;AAEA;AAMA;AACA;AACA;AAYA;AACA;AAmDA;AAwEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AAEA;AACA;AAIA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAMA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAMA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAQA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAOA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAlyCA;AAoyCA;;;;;;;;;;;;;;AAcA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACr4CA;AAEA;AACA;AACA;AAuDA;;;AAGA;AACA;AAAA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AArEA;AAuEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AAAA;AAEA;AACA;AAJA;AAMA;;;;;;;;;;AAUA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrbA;AACA;AACA;AACA;AACA;AAgDA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAxDA;AA0DA;;;AAGA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;AAGA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8IA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AAEA;;;;AAIA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;;;;;;;;;;;;;AChrBA;AAYA;;AAEA;AACA;AAYA;AAXA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AA/RA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAGA;AAEA;;AAEA;AACA;AASA;AALA;AAMA;AACA;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;AAMA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjUA;AACA;AACA;;;;;;;;;;;;;ACTA;AACA;AACA;AAKA;AACA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AAgCA;;AAEA;AACA;AAqDA;AA1BA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;AAcA;AAEA;AACA;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AAEA;;;;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/zCA;AACA;AACA;AACA;AACA;AACA;AACA;AA4zCA;;;;AAIA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACv4CA;AACA;AACA;AACA;AACA;AAGA;AACA;AASA;AASA;AARA;AACA;AAQA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAMA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAIA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AA9VA;AAgWA;;;;;;;;;;;;AAYA;AACA;AACA;;;;;;;;;;;;;AC/XA;AACA;AAEA;;;AAGA;AACA;AAKA;AAHA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;;AAGA;AAEA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AAAA;AACA;;;;;;;;AAQA;AACA;AACA;AAUA;AAtEA;AACA;AACA;;;;;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}